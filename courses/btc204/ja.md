---
name: ビットコインにおけるプライバシー
goal: ビットコインを使用する際のプライバシー保護の原則を理解し、習得する。
objectives: 

  - プライバシー保護の利害関係を理解するために必要な理論的概念を定義する。
  - ビットコインにおけるユーザーのプライバシーの損失に関連するリスクを特定し、軽減する方法を知る。
  - ビットコインでプライバシーを保護する方法とツールを使う
  - チェーン分析の手法を理解し、防衛戦略を立てる

---
# ビットコインでプライバシーを守る

金融取引のプライバシーが徐々に贅沢になりつつある世界では、ビットコインの使用におけるプライバシー保護の原則を理解し、習得することが不可欠です。このトレーニングでは、この目標を自分で達成するための、理論と実践の両方の鍵をすべて提供します。

今日、ビットコインには連鎖分析を専門とする企業が存在する。彼らの本業はまさに、取引の機密性を危うくするために、あなたのプライバシーに侵入することである。実際、ビットコインには「プライバシーの権利」は存在しない。したがって、自分の自然権を主張し、自分の取引の機密性を守るのは、ユーザーであるあなた次第である。

このトレーニングは、包括的なジェネラリストコースとして提供されます。すべての技術的な概念は詳細に説明され、説明図によってサポートされています。その目的は、誰もが知識を利用できるようにすることです。そのため、BTC204は初心者や中級者にもわかりやすくなっています。また、このトレーニングは経験豊富なビットコイナーにも付加価値を提供します。

私たちと一緒にビットコインの使い方を変え、機密保持をめぐる問題を理解し、プライバシーを保護できる情報通のユーザーになりましょう。

+++
# はじめに

<partId>e17474a8-8899-4bdb-a7f8-bc52ddb01440</partId>

## トレーニング入門

<chapterId>08ba1933-f393-4fb5-8279-777d874caedb</chapterId>

金融取引のプライバシーが徐々に贅沢になりつつある世界では、ビットコインの使用におけるプライバシー保護の原則を理解し、習得することが不可欠です。このトレーニングでは、この目標を自分で達成するための、理論と実践の両方の鍵をすべて提供します。

今日、ビットコインのエコシステムには、ブロックチェーン分析を専門とする企業が存在する。彼らのコアビジネスは、まさにあなたのプライバシーに侵入し、取引の機密性を損なうことだ。実際、ビットコインには「プライバシーの権利」は存在しない。したがって、自分の自然権を主張し、取引の機密性を守るのはユーザーであるあなた次第である。

ビットコインは、「ナンバー・ゴー・アップ」や貯蓄価値の保全のためだけにあるわけではない。そのユニークな特徴と歴史から、主にオルタナティブ経済のツールとなっている。この驚くべき発明のおかげで、誰にも止められることなく、自由にお金を管理し、使い、蓄えることができる。

ビットコインは、国家のくびきから平和的に逃れ、既成の法律では対抗できない自然権を完全に享受することを可能にする。サトシ・ナカモトの発明のおかげで、あなたは私有財産権を行使し、契約の自由を取り戻す力を手に入れた。

しかし、ビットコインはデフォルトでは匿名ではないため、オルタナティブ経済に従事する個人、特に専制的な体制下にある地域にとってはリスクとなる可能性がある。しかし、危険はこれだけではない。ビットコインは貴重で検閲のない資産であるため、泥棒の目を引く可能性がある。したがって、プライバシーの保護はセキュリティの問題にもなる。サイバー攻撃や物理的な攻撃を防ぐことができる。

これから説明するように、プロトコルは特定の固有のプライバシー保護を提供しますが、このプライバシーを最適化し、守るために追加のツールを使用することが非常に重要です。このコースは、ビットコインのプライバシー問題を理解するための包括的で一般的なパスとして設計されています。各技術的な概念は詳細に議論され、説明図によってサポートされます。目標は、初心者や中級者を含むすべての人が知識を利用できるようにすることです。経験豊富なビットコイナーには、各トピックの理解を深めるために、このコースで非常に技術的で、時にはあまり知られていない概念も取り上げます。

このコースのゴールは、ビットコインの使用において完全に匿名にすることではなく、個人的な目標に応じてプライバシーを保護する方法を知るために不可欠なツールを提供することです。あなたは、提示されたコンセプトやツールから自由に選択し、特定の目標やニーズに合わせた独自の戦略を開発することができます。

### セクション1：定義と主要概念

はじめに、ビットコインがどのように機能するかを支配する基本的な事項を一緒に見て、その後、プライバシー関連の概念に冷静にアプローチする。UTXOや受信アドレス、スクリプトなどの基本的な概念をマスターしておくことは、以降のセクションで取り上げる概念を完全に把握する前に不可欠である。また、サトシ・ナカモトが思い描いたビットコインの一般的なプライバシーモデルを紹介し、問題点や関連するリスクを把握できるようにする。

![BTC204](assets/it/11/1.webp)

### 第2節 チェーン分析の理解と自己防衛の方法

第2章では、ブロックチェーン分析会社がビットコイン上でのあなたの行動を追跡するために使用する技術を研究します。これらの手法を理解することは、あなたのプライバシーの保護を向上させる上で非常に重要です。このパートでは、リスクをよりよく理解し、以降のセクションで研究するテクニックの基礎を築くために、攻撃者の戦略を検証することを目的としています。トランザクションのパターン、内部および外部のヒューリスティック、そしてこれらのパターンのもっともらしい解釈を分析します。理論的な要素に加え、実践的な例と演習を通して、チェーン分析を行うためのブロック・エクスプローラーの使用方法を学びます。

![BTC204](assets/fr/002.webp)

### セクション3：プライバシー保護のためのベストプラクティスの習得

コースの第3章では、問題の核心に迫ります！ゴールは、ビットコインユーザーにとって自然な反射神経となるべき本質的なベストプラクティスをすべてマスターすることです。新鮮なアドレスの使用、ラベリング、統合、フルノードの使用、さらにKYCと取得方法についても取り上げます。その目的は、プライバシー保護の探求において堅固な基盤を確立するために避けるべき落とし穴の包括的な概要を提供することです。いくつかの実践方法については、具体的なチュートリアルをご覧ください。

![BTC204](assets/it/11/3.webp)

### 第4節 Coinjoinトランザクションを理解する

coinjoinについて語らずして、ビットコインのプライバシーについて語ることはできないだろう。セクション4では、このミキシング方法について知っておく必要があることをすべて説明します。コインジョイントとは何か、その歴史と目的、そして存在するコインジョイントの種類について学びます。最後に、経験豊富なユーザーのために、アノンセットとエントロピーとは何か、そしてこれらの指標の計算方法について説明します。

![BTC204](assets/it/11/4.webp)

### 第5節 その他の高度なプライバシー技術の問題点を理解する

第 5 章では、coinjoin 以外にビットコイン上でプライバシーを保護するための既存のテクニックの概要を説明します。長年にわたり、開発者はプライバシーに特化したツールの設計においてかなりの創造性を発揮してきました。payjoin、協調取引、コインスワップ、アトミックスワップなど、これらの手法をすべて検証し、その仕組み、目的、潜在的な弱点について詳しく説明します。

また、ノードネットワークレベルのプライバシーとトランザクションの拡散についても取り上げる。また、静的アドレスプロトコルを含め、ビットコイン上のユーザープライバシーを改善するために長年提案されてきた様々なプロトコルについても議論する。

![BTC204](assets/fr/005.webp)

# 定義と主要概念

<partId>b9bbbde3-34c0-4851-83e8-e2ffb029cf31</partId>

## ビットコインのUTXOモデル

<chapterId>8d6b50c5-bf74-44f4-922b-25204991cb75</chapterId>

ビットコインは主に通貨ですが、BTCがプロトコルでどのように表現されているか具体的に知っていますか？

### ビットコインのUTXOとは？

ビットコインのプロトコルでは、通貨単位の管理は、"_Unspent Transaction Output_"の略であるUTXOモデルに基づいている。

このモデルは、金融の流れを追跡するために口座と残高のメカニズムに依存する従来の銀行システムとは大きく異なる。実際、銀行システムでは、個々の残高はIDにリンクされた口座で管理される。たとえば、あなたがパン屋からバゲットを買うと、銀行はあなたの口座から購入金額を引き落とすだけで、あなたの残高は減り、パン屋の口座には同じ金額が入金され、残高は増える。このシステムでは、あなたの口座に入ってくるお金と出ていくお金の間には、取引記録以外のリンクという概念はない。

ビットコインでは、仕組みが異なる。口座という概念は存在せず、通貨単位は残高ではなくUTXOを通じて管理される。UTXOは、まだ使用されていない特定の量のビットコインを表し、「ビットコインの一部」を形成する。例えば、UTXOは500BTCの価値もあれば、700SATSの価値もある。

**> サトシは、しばしばサットと略され、ビットコインの最小単位であり、不換紙幣の1ペニーに匹敵する。

```plaintext
1 BTC = 100,000,000 SATS
```

理論的には、UTXOはビットコインのあらゆる価値を表すことができ、その価値は1BTCから理論上の最大値である約2100万BTCまである。しかし、2,100万ビットコインすべてを所有することは論理的に不可能であり、「ダスト」と呼ばれる経済的閾値が存在し、それ以下ではUTXOは経済的に不経済であるとみなされる。

**>ビットコインで作成された史上最大のUTXOは、50万BTCの価値があった。これは、2011年11月にMtGoxプラットフォームによって統合作業中に作成されました：[29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf](https://mempool.space/fr/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)

### UTXOと支出状況

UTXOはビットコインにおける交換手段である。各取引では、インプットとしてUTXOが消費され、アウトプットとして新しいUTXOが生成されます。トランザクションが行われると、インプットとして使用されたUTXOは「使用された」とみなされ、新しいUTXOが生成され、トランザクションのアウトプットで示された受取人に割り当てられます。したがって、UTXOは単に未使用のトランザクションのアウトプットを表し、その結果、ある時点でユーザーに属するビットコインの量を表す。

![BTC204](assets/it/21/2.webp)

すべてのUTXOは、使用可能な条件を定義するスクリプトによって保護されている。UTXOを消費するには、ユーザーは、そのUTXOを保護するスクリプトによって設定された条件を満たしていることをネットワークに示さなければならない。一般に、UTXOは公開鍵（またはこの公開鍵を表す受信アドレス）によって保護されている。この公開鍵に関連付けられたUTXOを使用するには、ユーザーは、この鍵で作成されたデジタル署名を提供することによって、対応する秘密鍵を保持していることを証明しなければならない。このため、ビットコイン・ウォレットには実際にビットコインが入っているのではなく、秘密鍵が保管されていると言われている。

![BTC204](assets/it/21/3.webp)

ビットコインにはアカウントという概念がないため、ウォレットの残高は単純に、そのウォレットが使用できるすべてのUTXOの値の合計となります。例えば、あなたのビットコインウォレットが以下の4つのUTXOを使えるとします：

```plaintext
- 2 BTC
- 8 BTC
- 5 BTC
- 2 BTC
```

あなたのウォレットの総残高は17BTCになる。

![BTC204](assets/it/21/4.webp)

## ビットコイン取引の仕組み

<chapterId>29d3aaab-de2e-4746-ab40-c9748898850c</chapterId>

### トランザクションのインプットとアウトプット

ビットコイン取引とは、ある人から別の人へビットコインの所有権を移転することを可能にする、ブロックチェーン上に記録された取引のことである。より具体的には、我々はUTXOモデルであり、アカウントは存在しないため、トランザクションは1つまたは複数のUTXOを保護した支出条件を満たし、それらを消費し、等価的に、新しい支出条件を備えた新しいUTXOを作成します。要するに、トランザクションはビットコインを、それを保護するためのスクリプトから新しいスクリプトに移動させる。

![BTC204](assets/it/22/1.webp)

このように、各ビットコイン取引は1つ以上の入力と1つ以上の出力から構成される。入力は、出力を生成するためにトランザクションによって消費されるUTXOである。出力は、将来のトランザクションの入力として使用可能な新しい UTXO である。

![BTC204](assets/it/22/2.webp)

**> 理論的には、ビットコイン取引は無限の入力と出力を持つことができます。最大ブロックサイズのみがこの数を制限します。ビットコイン取引における各入力は、以前の未使用の UTXO（Unspent Transaction Output）を参照します。UTXOをインプットとして使用するには、その保有者は、それに関連付けられたスクリプトを検証することによって、つまり課された支出条件を満たすことによって、正当な所有者であることを証明しなければならない。一般的に、これには、そのUTXOを最初にセキュリ ティ保護した公開鍵に対応する秘密鍵で生成されたデジタル署名を提供するこ とが含まれる。次にスクリプトは、その署名が資金を受け取るときに使用された公開鍵と一致することを検証する。

一方、各出力は、送金されるビットコインの量と受取人を指定する。後者は通常、新しく作成されたUTXOを受信アドレスまたは新しい公開鍵でロックする新しいスクリプトによって定義される。

コンセンサスルールに従ってトランザクションが有効とみなされるためには、アウトプットの合計がインプットの合計以下でなければならない。言い換えれば、トランザクションによって生成された新しいUTXOの合計は、インプットとして消費されたUTXOの合計を超えてはならない。この原則は論理的である。もしあなたが50万SATS`しか持っていなければ、70万SATS`を購入することはできない。

### ビットコイン取引における交換と統合

したがって、UTXOに対するビットコイン取引の作用は、金貨の溶解に例えることができる。実際、UTXOは分割可能ではなく、統一されているだけである。つまり、ある一定量のビットコインを表すUTXOを、単純にいくつかの小さなUTXOに分割することはできない。ユーザーは取引でUTXOを完全に消費し、初期値以下の任意の値のUTXOを1つ以上新たに生成しなければならない。

この仕組みは金貨と似ている。2オンスのコインを所有していて、1オンスの支払いをしたいとします。コインを溶かして、1オンスずつ2枚のコインを新たに鋳造しなければならない。

ビットコインでも操作は似ている。アリスが10,000 SATSのUTXOを持っていて、4,000 SATSのバゲットを買いたいとする。アリスは10,000 SATS`のUTXO1枚をインプットとして取引を行い、そのUTXOをすべて消費し、アウトプットとして4,000 SATS`と6,000 SATS`の2枚のUTXOを作る。4,000SATS`のUTXOはバゲットの代金としてパン屋に送られ、6,000SATS`のUTXOはお釣りとしてアリスに戻る。トランザクションの最初の送信者に戻るこのUTXOは、ビットコインの専門用語で「おつり」と呼ばれるものである。

ここで、アリスが10,000 SATSのUTXOを1つ持っているのではなく、3,000 SATSのUTXOを2つ持っているとする。この状況では、それぞれのUTXOはバゲットの4,000 SATSをカバーするのに十分ではない。したがって、アリスは3,000 SATSのUTXOを同時にインプットとして使わなければならない。こうすることで、インプットの合計は6,000SATS`に達し、パン屋への4,000SATS`の支払いをカバーすることができる。複数のUTXOを1つの取引のインプットにまとめるこの方法は、しばしば「コンソリデーション」と呼ばれる。

### 取引手数料

直感的には、取引手数料も取引のアウトプットであると考えるかもしれない。しかし、実際にはそうではない。取引手数料は、総インプットと総アウトプットの差額を表している。つまり、ある取引において、インプットの価値の一部を使って所望のアウトプットを賄った後、インプットの一定額が未使用のまま残るということである。この残額が取引手数料となる。

```plaintext
Commissioni = input totali - output totali
```

10,000SATS`のUTXOを持っていて、4,000SATS`のバゲットを買いたいアリスの例 に戻ろう。アリスは10,000 SATS`のUTXOを入力としてトランザクションを作成する。その後、アリスはパン屋がバゲットの代金を支払うための`4,000 SATS`のアウトプットを生成する。自分の取引をブロックに含めるようマイナーに奨励するため、アリスは`200 SATS`を手数料として割り当てる。そうすることで、アリスは2つ目のアウトプットを生成し、その残りは5,800 SATS`となり、アリスに返却される。

手数料の計算式に当てはめると、鉱夫には200SATSが残っていることになる：

```plaintext
Commissioni = input totali - output totali
Spese = 10.000 - (4.000 + 5.800)
Spese = 10.000 - 9.800
Spese = 200
```

マイナーがブロックの検証に成功すると、「コインベース」と呼ばれる取引を通じて、そのブロックに含まれるすべての取引に対してこれらの手数料を徴収する権利が与えられる。

### ビットコインにおけるUTXOの誕生

これまでの段落を注意深く見てきたなら、UTXOは他の既存のUTXOを消費することでしか作成できないことがお分かりいただけただろう。このように、ビットコイン上のコインは連続したチェーンを形成している。しかし、この連鎖の中で最初のUTXOがどのように出現したのか不思議に思うかもしれない。これはニワトリと卵の問題に似ている。

その答えは**コインベース取引**にある。

Coinbaseは特定のタイプのビットコイン取引であり、各ブロックに固有で、常にその中で最初に行われる。有効なプルーフ・オブ・ワークを見つけた採掘者は、ブロック報酬を受け取ることができます。この報酬は2つの要素で構成されています： *前編で説明した**ブロックグラント**と**取引手数料**である。

coinbase取引の特徴は、出力を生成するために入力を消費する必要がなく、無からビットコインを生成できる唯一の取引であることです。これらの新しく作られたビットコインは、"オリジナルのUTXO "と呼ばれるものである。

ブロックグラントのビットコインは、コンセンサスルールで事前に定義された発行スケジュールに従って、何もないところから新たに生み出されるBTCである。ブロック補助金は21万ブロックごと、約4年ごとに "半減 "と呼ばれるプロセスで半減される。当初は1ブロックあたり50ビットコインが発行されていたが、徐々に減少し、現在は1ブロックあたり3,125ビットコインとなっている。

取引手数料の部分については、新たに創出されたBTCを表しているとはいえ、ブロック内の全取引のインプットとアウトプットの合計の差を超えてはならない。これらの手数料は、トランザクションのアウトプットに使用されなかったインプットの一部を表していることは前述した。この部分は技術的には取引中に「失われる」ものであり、マイナーはこの価値を1つまたは複数の新しいUTXOの形で再作成する権利を有する。したがって、これはトランザクションの送信者からブロックチェーンに追加するマイナーへの価値の移転である。

**> コインベースの取引から生成されたビットコインは、100ブロックの成熟期間が設けられ、その間はマイナーによって使用されることはありません。このルールは、後に廃止される可能性のあるチェーン上で新しく作成されたビットコインの使用に関連する複雑さを回避することを目的としています。

### UTXOモデルの意味

まず、UTXOモデルはビットコインの取引手数料に直接影響する。各ブロックの容量には限りがあるため、マイナーはブロック内で占めるスペースに比して最高の手数料を提供するトランザクションを選好する。実際、トランザクションが入力と出力として含むUTXOが多ければ多いほど、そのトランザクションは重くなり、したがって高い手数料が必要となる。これが、ポートフォリオ内のUTXOの数を減らす努力がしばしば行われる理由の1つであり、プライバシーにも影響する可能性がある。

次に、前の部分で述べたように、ビットコインのコインは基本的にUTXOの連鎖である。したがって、各取引は、過去のUTXOと将来のUTXOの間のリンクを作成します。従って、UTXOはビットコインの作成から現在の支出までの経路を明確に追跡することを可能にする。このような透明性は、各ユーザーが受け取ったビットコインの真正性を保証できるため、肯定的に捉えることができる。しかし、このトレーサビリティと監査可能性という原則の上に連鎖分析が成り立っており、プライバシーを侵害するように設計されています。トレーニングの第2部では、この慣行について詳しく学びます。

## ビットコインのプライバシー・モデル

<chapterId>769d8963-3ed5-4094-b21d-9203c7d9e465</chapterId>

### 通貨真正性、完全性、二重支出

通貨の機能の一つは、欲求の二重一致の問題を解決することである。物々交換に基づくシステムでは、交換を行うには、私の欲求を満たす財を提供する個人を見つけるだけでなく、彼らの欲求を満たす同等の価値の財を提供する必要がある。このバランスを見つけるのは複雑である。

そのため、空間と時間の両方で価値の移転を可能にする通貨が使われるのである。

通貨がこの問題を解決するためには、財やサービスを提供する側が、その金額を後で使うことができると確信することが不可欠である。したがって、デジタル通貨であれ現物通貨であれ、ある通貨を受け入れようとする合理的な個人は、その通貨が2つの基本的な基準を満たしていることを確認する：


- コインは無傷で本物でなければならない。

現物の通貨を使用する場合、最初の特徴は最も複雑な主張である。さまざまな歴史的時代を通じて、金属コインの完全性は、切断や打ち抜きなどの行為によってしばしば損なわれてきた。例えば、古代ローマでは、市民が金貨の端を削って貴金属の一部を集め、将来の取引のために保存することが一般的であった。こうしてコインの本質的な価値は下がったが、額面は変わらなかった。これが、後に硬貨の縁に縞模様が造られるようになった理由である。

また、真正性を物理的な金銭的手段で確認することも困難である。今日、偽造に対抗する技術はますます複雑化しており、加盟店は高価な検証システムに投資せざるを得ない。

一方、現物通貨はその性質上、二重払いは問題にならない。私が10ユーロ札をあなたに渡せば、その10ユーロ札は私の手元からあなたの手元に戻る。もちろん、同じ通貨単位を何度も使う可能性は排除される。つまり、私はその10ユーロ札を二度と使うことはできない。

デジタル通貨の場合、その難しさは異なる。コインの真正性と完全性を保証することは、多くの場合容易である。前のセクションで見たように、ビットコインのUTXOモデルでは、コインをその起源までさかのぼることができるため、コインが本当にマイナーによってコンセンサスルールに従って作成されたものであることを検証することができる。

しかし、デジタル財は本質的に情報であるため、二重払いがないことを保証するのはより複雑である。物理的な財とは異なり、情報は交換中に分割されるのではなく、増殖することによって伝播する。例えば、私があなたに文書を電子メールで送ると、それは複製される。あなたの側では、私が元の文書を削除したかどうかを確実に確認することはできない。

### ビットコイン二重払いの防止

デジタル資産の重複を避ける唯一の方法は、システム内のすべてのやり取りを把握しておくことだ。そうすれば、誰が何を所有しているかを把握し、行われた取引に基づいて全員の所有権を更新することができる。これは、例えば銀行システムにおける経典貨幣で行われていることだ。クレジットカードで加盟店に10ユーロを支払うと、銀行はこのやり取りを記録し、台帳を更新する。

ビットコインでは、二重支払いの防止は同じ方法で達成される。その目的は、問題のコインをすでに使った取引がないことを確認することである。これらのコインが一度も使用されていなければ、二重支払いが発生しないことを確信できる。この原則は、サトシ・ナカモトが白書の中でこの有名な文章で説明している：

**取引がないことを確認する唯一の方法は、すべての取引を把握しておくことだ。

しかし、銀行モデルとは異なり、ビットコインでは中央組織を信頼する必要はない。すべてのユーザーが、第三者に依存することなく、この二重支払いの不在を確認できることが必要である。そのため、すべてのビットコイン取引を誰もが把握する必要がある。このため、ビットコインの取引はネットワークのすべてのノードで公にブロードキャストされ、ブロックチェーン上にプレーンテキストで記録される。

ビットコインにおけるプライバシー保護を複雑にしているのは、まさにこの情報の公開である。伝統的な銀行システムでは、理論上、金融機関だけが取引を知ることができる。一方、ビットコインでは、すべてのユーザーがそれぞれのノードを介して、すべての取引を知らされる。

### プライバシーモデル：銀行システム対ビットコイン

従来のシステムでは、銀行口座は個人のIDとリンクしている。銀行員は、どの顧客がどの銀行口座に属し、どのような取引がそれに関連しているかを知ることができる。しかし、この情報の流れは銀行と一般領域との間で遮断されている。つまり、他人の銀行口座の残高や取引を知ることはできない。この情報にアクセスできるのは銀行だけなのだ。

例えば、銀行員はあなたが毎朝近所のパン屋でバゲットを買っていることを知っているが、隣人はこの取引を知らない。このように、情報の流れは、銀行を中心とする利害関係者にはアクセスできるが、外部の人間にはアクセスできないままである。

前編で見たトランザクションの公開という制約のため、ビットコインのプライバシーモデルは銀行システムのモデルには従えない。ビットコインの場合、取引と公開領域との間で情報の流れを遮断することができないため、**プライバシーモデルは、ユーザーのアイデンティティと取引**そのものとの分離に基づいている。

例えば、あなたがBTCで支払うパン屋からバゲットを買った場合、自分のフルノードを所有する隣人は、システム内の他のすべての取引を見ることができるのと同じように、あなたの取引が行われるのを見ることができる。しかし、プライバシーの原則が尊重されるのであれば、この特定の取引とあなたの身元を結びつけることはできないはずだ。

しかし、ビットコインの取引は公開されているため、関係者の情報を推測するために取引間のリンクを確立することは可能である。この活動は、"連鎖分析 "と呼ばれる専門分野にまで発展しています。コースの次のパートでは、あなたのビットコインがどのように追跡されているかを理解し、より良い自己防衛の方法を知るために、連鎖分析の基本を探求してください。

# チェーン分析の理解と自己防衛の方法

<partId>4739371e-9fef-45b0-bcaa-b7a4df6b4470</partId>

## ビットコインのチェーン分析とは？

<chapterId>7d198ba6-4af2-4f24-86cb-3c79cb25627e</chapterId>

### 定義と運用

連鎖分析は、ブロックチェーン上のビットコインの流れを追跡するために使用されるすべての方法を包含する実践である。一般的に、連鎖分析は過去の取引のサンプルの特徴を観察することに基づいている。そして、分析したい取引においてこれらと同じ特徴を特定し、もっともらしい解釈を推測することになる。このように、実用的なアプローチから十分な解決策を見出す問題解決方法は、"ヒューリスティクス "と呼ばれるものである。

単純化するために、チェーン分析は3つの主要ステップで行われる：

1. **ブロックチェーンを観察する。

2. **既知の特徴を特定する。

3. **仮定の教育

ブロックチェーンの分析は誰にでもできる。ブロックチェーンの公開情報にフルノードを通じてアクセスし、取引の動きを観察し、仮説を立てることができれば十分である。この分析を容易にする無料のツールもあり、例えばウェブサイト[OXT.me](https://oxt.me/)がある。本編の最後の2つの章で詳しく説明する。しかし、主なプライバシー・リスクは、連鎖分析を専門とする企業からもたらされる。これらの企業は連鎖分析を工業的規模にまで高め、そのサービスを金融機関や政府に販売している。このような企業の中では、おそらくChainalysis社が最もよく知られているだろう。

### チェーン分析の目標

チェーン分析の目的の1つは、ビットコイン上のさまざまなアクティビティをグループ化し、それらを実行したユーザーの一意性を判断することである。次に、この一連の活動を実際のアイデンティティに結びつけることを試みることが可能になる。

前章を思い出してほしい。ビットコインのプライバシーモデルが、もともとユーザーのアイデンティティとそのトランザクションを分離することに基づいていた理由を説明した。したがって、オンチェーンのアクティビティをグループ化できたとしても、実際のアイデンティティと関連付けることはできないため、オンチェーン分析は役に立たないと考えたくなるだろう。

理論的には、この記述は正確である。このトレーニングの最初の部分では、暗号鍵ペアがUTXOの条件を確立するために使用されることを見た。本質的に、これらの鍵ペアは、その保持者の身元に関する情報を一切明らかにしない。したがって、異なる鍵ペアに関連する活動をグループ化できたとしても、これらの活動の背後にある実体については何もわからない。

しかし、現実はもっと複雑だ。本物のIDとオンチェーン・アクティビティを結びつけるリスクのある行動は多数存在する。分析では、これをエントリー・ポイントと呼び、数多く存在する。

もちろん、最も一般的なのはKYC（_Know Your Customer）である。規制されたプラットフォームから個人の受け取りアドレスの一つにビットコインを引き出すと、このアドレスにあなたの身元を結びつけることができる人がいます。より一般的には、エントリーポイントは、あなたの実生活とビットコイン取引との間のあらゆる形式の相互作用であり得ます。例えば、ソーシャルネットワークに受取アドレスを投稿する場合、これは分析のためのエントリーポイントになり得る。あなたがパン屋にビットコインで支払いをすれば、パン屋はあなたの顔（あなたのアイデンティティの一部）とビットコインアドレスを関連付けることができる。

ビットコインを使う上で、こうしたエントリーポイントはほぼ避けられない。その範囲を制限しようとしても、存在し続ける。だからこそ、プライバシーの保護を目的とした方法を組み合わせることが極めて重要なのです。実際のアイデンティティとトランザクションの分離を維持することは魅力的なアプローチではあるが、現在ではまだ不十分である。実際、あなたのオンチェーン・アクティビティがすべてグループ化されている場合、わずかな侵入によって、あなたが確立したプライバシーの1つのレイヤーが損なわれる可能性が高い。

### チェーン分析に対するディフェンス

したがって、ビットコインの使用においてブロックチェーン分析に対応できるようにすることも必要である。このように進めることで、私たちの活動の集約を最小限に抑え、プライバシーへのエントリーポイントの影響を抑えることができる。

実際、ブロックチェーン分析によりよく対抗するためには、ブロックチェーン分析で使用される手法に精通すること以上のアプローチがあるだろうか？ビットコインでプライバシーを向上させる方法を知りたければ、これらの方法を理解する必要がある。そうすることで、coinjoinやpayjoinのようなテクニック（トレーニングの後半で学ぶテクニック）をよりよく理解できるようになり、あなたが犯すかもしれないミスを減らすことができます。

この文脈では、暗号と暗号解読を類推することができる。優れた暗号解読者は、何よりもまず優れた暗号解読者である。新しい暗号アルゴリズムを考案するためには、それがどのような攻撃に直面するかを知り、また過去のアルゴリズムがなぜハッキングされたかを研究する必要がある。同じ原理がビットコインのプライバシーにも当てはまる。ブロックチェーンを分析する方法を理解することが、ブロックチェーンから身を守る鍵となる。このトレーニングでブロックチェーン分析のセクション全体を提案するのはそのためだ。

https://planb.network/tutorials/privacy/on-chain/coinjoin-samourai-wallet-e566803d-ab3f-4d98-9136-5462009262ef
https://planb.network/fr/tutorials/privacy/on-chain/payjoin-848b6a23-deb2-4c5f-a27e-93e2f842140f
### ブロックチェーンの分析手法

ブロックチェーン分析は厳密な科学ではないことを理解することが重要である。過去の観察結果や論理的解釈から導き出されたヒューリスティックに依存している。これらのルールにより、かなり信頼性の高い結果を得ることができますが、絶対的な精度を持つことはありません。言い換えれば、**ブロックチェーン分析では、出される結論に常に確率の次元が含まれる**。例えば、2つのアドレスが同じエンティティに属することを多かれ少なかれ確実に推定することはできますが、完全な確実性は常に手の届かないところにあります。

ブロックチェーン分析の主な目的は、まさにエラーのリスクを最小化するための様々なヒューリスティックの集約にある。それはある意味、現実に近づくための証拠の集積である。

これらの有名なヒューリスティクスは、いくつかのカテゴリーに分類することができる：


- トランザクション・モデル（またはトランザクション・モデル）;**。
- トランザクションの内部ヒューリスティック。
- トランザクションの外部にあるヒューリスティック。

### サトシ・ナカモトとブロックチェーン分析

なお、チェーン分析のための最初の2つのヒューリスティックは、サトシ・ナカモト自身が発見したものである。彼はビットコイン白書の第10部でそれらについて述べている。これらは


- 共通入力特性ヒューリスティックス（CIOH）；
- そしてアドレスの再利用。

![BTC204](assets/fr/031.webp)

出典S. Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System", https://bitcoin.org/bitcoin.pdf, 2009.

次の章では、これがいったいどういうことなのかを探っていくが、この2つのヒューリスティックが今日でも連鎖分析において重要な位置を占めていることは、すでに興味深いことである。

## 取引テンプレート

<chapterId>d365a101-2d37-46a5-bfb9-3c51e37bf96b</chapterId>

トランザクションモデルとは、ブロックチェーン上で見られる典型的なトランザクションの一般的なパターンや構造のことであり、その解釈はおそらく既知である。パターンを研究する際には、一つの取引に焦点を当て、それを高いレベルで分析する。

言い換えれば、トランザクションのより具体的な詳細や環境にはこだわらず、インプットのUTXOの数とアウトプットのUTXOの数だけを見る。観察されたパターンから、トランザクションの性質を解釈することができる。次にその構造の特徴を探し、解釈を推測する。

![BTC204](assets/it/32/01.webp)

このパートでは、チェーン分析で遭遇する可能性のある主な取引パターンを一緒に発見し、それぞれのパターンについて、具体的な例とともに、この構造の解釈の可能性をお伝えします。

### 簡単な送信（または簡単な支払い）

ほとんどのビットコイン決済で使用されている、非常にポピュラーなモデルから始めましょう。単純な支払いモデルは、入力で1つ以上のUTXOを消費し、出力で2つのUTXOを生成することを特徴とする。したがって、このモデルは次のようになる：

![BTC204](assets/it/32/02.webp)

ブロックチェーン上でこのトランザクション構造を特定すると、すでに解釈を導き出すことができる。その名前が示すように、このパターンはセンドまたはペイのトランザクションを扱っていることを示している。ユーザーはインプットでUTXOを消費し、アウトプットで支払いのUTXOと釣銭のUTXO（同じユーザーに返されるお金）を満たす。

したがって、観察されたユーザーは、おそらく2つの出力UTXOのうちの1つ（支払いUTXO）はもはや所有していないが、もう1つのUTXO（変更UTXO）はまだ所有していることがわかる。

現時点では、どの出力がどのUTXOを表しているかを特定することは不可能である。この目標は、以下のパートで研究するヒューリスティックスに頼ることで達成する。この段階では、我々の目標は問題のトランザクションの性質を特定することに限定される。

例えば、単純な送信モデルを採用したビットコイン取引である：

```plaintext
b6cc79f45fd2d7669ff94db5cb14c45f1f879ea0ba4c6e3d16ad53a18c34b769
```

![BTC204](assets/it/32/03.webp)

Fonte: [Mempool.space](https://mempool.space/fr/tx/b6cc79f45fd2d7669ff94db5cb14c45f1f879ea0ba4c6e3d16ad53a18c34b769)

この最初の例を見れば、"トランザクションモデル "を研究することの意味がよく理解できるはずである。トランザクションの環境やトランザクション固有の詳細を考慮することなく、トランザクショ ンの構造のみに焦点を当てて、トランザクションを調査する。この最初のステップでは、トランザクションをグローバルに見るだけである。

モデルとは何かを理解したところで、他の既存のモデルについて説明しよう。

### 掃除

この第2のモデルは、入力として単一のUTXOを消費し、出力として単一のUTXOを生成することを特徴とする。

![BTC204](assets/it/32/04.webp)

このモデルの解釈では、自動転送を扱っていることになる。ユーザーは自分のビットコインを自分の所有する別のアドレスに送金した。この取引には残りがないため、支払いを行っている可能性は非常に低い。実際、支払いが行われた場合、支払者が売り手から要求された金額と取引手数料を加えた金額と完全に一致するUTXOを持つことはほとんど不可能である。そのため、一般的に、支払人は残額を出力することを余儀なくされる。

したがって、観察されたユーザーはおそらくまだこのUTXOを所持していることがわかる。連鎖分析の文脈では、トランザクションで入力として使用されたUTXOがアリスのものであるこ とが分かれば、出力のUTXOもアリスのものであると仮定できる。後で面白くなるのは、この仮定を強化するかもしれないトランザクショ ン内部のヒューリスティックスを見つけることである（これらのヒューリスティックスについてはセクション 3.3で研究する）。

例えば、スイープモデルを採用したビットコイン取引である：

```plaintext
35f1072a0fda5ae106efb4fda871ab40e1f8023c6c47f396441ad4b995ea693d
```

![BTC204](assets/it/32/05.webp)

出典：[Mempool.space](https://mempool.space/fr/tx/35f1072a0fda5ae106efb4fda871ab40e1f8023c6c47f396441ad4b995ea693d) しかし、このようなパターンから、暗号通貨取引所のプラットフォーム口座への自己送金が判明することもある。それが自己保管ウォレットへの統合なのか、プラットフォームへの出金なのかを知ることができるのは、既知のアドレスとトランザクションのコンテキストを研究することだろう。実際、取引所プラットフォームのアドレスは簡単に特定できることが多い。

アリスの例に戻ろう。連結が（例えばBinanceのような）プラットフォームの既知のアドレスにつながる場合、これはビットコインがアリスの直接の所有から移されたことを意味するかもしれない。一方、送金先アドレスが不明な場合は、単にアリスが所有する別のウォレットであると考えるのが妥当である。しかし、この種の研究は、パターンの研究ではなく、ヒューリスティックの範疇に入る。

### 統合

このモデルの特徴は、入力として複数のUTXOを消費し、出力として単一のUTXOを生成することである。

![BTC204](assets/it/32/06.webp)

このパターンの解釈は、統合が進んでいるということだ。これはビットコインユーザーの間で一般的に行われていることで、取引手数料が上昇する可能性を見越して複数のUTXOを統合することである。手数料が低い期間にこの操作を行うことで、将来の手数料を節約することができる。この慣行については4.3章で詳しく説明する。

このトランザクションモデルの背後にいるユーザーは、おそらくすべての入力UTXOを所有しており、出力UTXOもまだ所有していると推測できる。これは間違いなく自動転送である。

統合と同様に、この種のパターンも取引所プラットフォーム口座への自己送金を明らかにする可能性がある。それが自己保管ウォレットへの統合なのか、プラットフォームへの引き出しなのかを知ることができるのは、既知のアドレスとトランザクションのコンテキストを調査することである。

例えば、コンソリデーション方式を採用したビットコイン取引である：

```plaintext
77c16914211e237a9bd51a7ce0b1a7368631caed515fe51b081d220590589e94
```

![BTC204](assets/it/32/07.webp)

Fonte: [Mempool.space](https://mempool.space/fr/tx/77c16914211e237a9bd51a7ce0b1a7368631caed515fe51b081d220590589e94)

連鎖分析の文脈では、このモデルは多くの情報を明らかにすることができる。例えば、入力の1つがアリスのものであることが分かれば、このトランザク ションの他のすべての入力と出力がアリスのものであると仮定できる。この仮定により、過去の取引チェーンをさかのぼり、アリスに関連しそうな他の取引を発見し分析することができる。

![BTC204](assets/it/32/08.webp)

### グループ支出

このモデルの特徴は、インプットとして数個のUTXOを消費し（多くの場合1個のみ）、アウトプットとして多数のUTXOを生産することである。

![BTC204](assets/it/32/09.webp)

このパターンの解釈は、バンドル支出を扱っているということだ。これは、取引所のプラットフォームのような重要な経済活動を明らかにする可能性が高い慣行である。グループ化された支出により、これらの事業体は費用を単一の取引に統合することで手数料を節約することができる。

このモデルから推測できるのは、UTXOのインプットは重要な経済活 動を行う企業からもたらされ、UTXOのアウトプットは分散する。その多くは、プラットフォームからビットコインを引き出した企業の顧客に帰属する。その他はパートナー企業に行くかもしれない。最後に、発行会社に戻る1つ以上の取引所が確実に存在する。

例えば、グループ化された支出モデルを採用したビットコイン取引である（おそらくBybitプラットフォームが発行した取引である）：

```plaintext
8a7288758b6e5d550897beedd13c70bcbaba8709af01a7dbcc1f574b89176b43
```

![BTC204](assets/it/32/10.webp)

Fonte: [Mempool.space](https://mempool.space/fr/tx/8a7288758b6e5d550897beedd13c70bcbaba8709af01a7dbcc1f574b89176b43)

### プロトコル固有のトランザクション

取引パターンの中で、特定のプロトコルの使用を明らかにするパターンを特定することもできる。例えば、Whirlpoolのコイン結合（第5回で説明する）には、他の伝統的な取引と区別できるような識別しやすい構造がある。

![BTC204](assets/it/32/11.webp)

このパターンを分析すると、おそらく協調的な取引を扱っていることが示唆される。コインジョインを観察することも可能である。もし後者の仮説が正しいと証明されれば、アウトプットの数からコインジョインの参加者数を大まかに推定することができる。

例えば、coinjoin協調取引タイプモデルを採用したビットコイン取引である：

```plaintext
00601af905bede31086d9b1b79ee8399bd60c97e9c5bba197bdebeee028b9bea
```

![BTC204](assets/it/32/12.webp)

Fonte: [Mempool.space](https://mempool.space/fr/tx/00601af905bede31086d9b1b79ee8399bd60c97e9c5bba197bdebeee028b9bea)

この他にも、独自の構造を持つプロトコルは数多くある。例えば、ワビサビ、スタンプ、ルーンなどのトランザクションを区別することができる。

このようなトランザクションモデルのおかげで、私たちは与えられたトランザクショ ンに関するある程度の情報をすでに解釈することができる。しかし、分析のための情報源は取引の構造だけではない。トランザクションの詳細を調べることもできる。このような詳細はトランザクションの内部的なものであり、私が「内部ヒューリスティックス」と呼びたいものである。

## 内部ヒューリスティック

<chapterId>c54b5abe-872f-40f4-a0d0-c59faff228ba</chapterId>

内部ヒューリスティックとは、環境を調査する必要なく、トランザクション自体の中で特定された特定の特徴であり、これによって推論を行うことができる。高いレベルでトランザクションの全体的な構造に注目するモデルとは異なり、内部ヒューリスティックは抽出可能なデータの集合に基づいている。これには以下が含まれる：


- さまざまなUTXOの出入りの量；
- アドレスの受信、バージョン管理、ロック時間など、スクリプトに関するあらゆること。

一般に、この種のヒューリスティックは、特定の取引における残りを特定することを可能にする。そうすることで、複数のトランザクショ ンにわたってエンティティを追跡し続けることができる。実際、追跡したいユーザーが所有するUTXOを特定する場合、そのユーザーがトランザクショ ンを行う際に、どの出力が他のユーザーに譲渡され、どの出力が残りを表し、そのためそのユーザーが所有し ているかを判断することは極めて重要である。

![BTC204](assets/it/33/01.webp)

繰り返しになるが、これらのヒューリスティックは決して正確ではない。個々に見れば、もっともらしいシナリオを特定できるに過ぎない。不確実性を完全に排除することはできなくても、不確実性を減らすのに役立つのは、さまざまなヒューリスティックの積み重ねなのである。

### 内部の類似性

この発見的手法は、同じ取引の入力と出力の類似性を調査するものである。トランザクションの入力と出力の1つだけに同じ特徴が見られる場合、この出力が残りの部分を構成している可能性が高い。

最も明白な特徴は、同一トランザクションにおける受信アドレスの再利用である。

![BTC204](assets/it/33/02.webp)

このヒューリスティックは、疑いの余地をほとんど残さない。秘密鍵がハッキングされない限り、同じ受信アドレスは必然的に1人のユーザーの活動を明らかにする。次の解釈は、トランザクションの残りは入力と同じアドレスの出力であるというものだ。これにより、この残りに基づいて個人を継続的に追跡することができる。

例えば、このヒューリスティックが合理的に適用できる取引を紹介しよう：

```plaintext
54364146665bfc453a55eae4bfb8fdf7c721d02cb96aadc480c8b16bdeb8d6d0
```

![BTC204](assets/fr/046.webp)

Fonte: [Mempool.space](https://mempool.space/tx/54364146665bfc453a55eae4bfb8fdf7c721d02cb96aadc480c8b16bdeb8d6d0)

このような入力と出力の類似性は、アドレスの再利用にとどまらない。スクリプトの使用に類似点があれば、ヒューリスティックを適用することができる。例えば、入力とトランザクション出力の間で同じバージョニングが観察されることがある。

![BTC204](assets/it/33/04.webp)

この図では、入力番号0がP2WPKHスクリプト（`bc1q`で始まるSegWit V0）をアンロックしていることがわかる。出力番号0も同じタイプのスクリプトを使用する。しかし、出力番号1はP2TRスクリプト（`bc1p`で始まるSegWit V1）を使用している。この特徴の解釈は、入力と同じバージョニングを持つアドレスが残りのアドレスである可能性が高いということである。従って、同じユーザーのものであることに変わりはない。

このヒューリスティックが合理的に適用できる取引のひとつを紹介しよう：

```plaintext
db07516288771ce5d0a06b275962ec4af1b74500739f168e5800cbcb0e9dd578
```

![BTC204](assets/fr/048.webp)

Fonte: [Mempool.space](https://mempool.space/tx/db07516288771ce5d0a06b275962ec4af1b74500739f168e5800cbcb0e9dd578)

この場合、入力No.0と出力No.1はP2WPKHスクリプト（SegWit V0）を使用し、出力No.0はP2PKH（Legacy）という異なるタイプのスクリプトを使用していることがわかる。2010年代初期には、使用可能なスクリプトの種類が限られていたため、スクリプトのバージョンに基づくこのヒューリスティックは比較的役に立ちませんでした。しかし、時間の経過とその後のビットコインのアップデートにより、スクリプトタイプの多様性が増している。スクリプトの種類が増えたことで、ユーザーはより小さなグループに分けられ、この内部バージョン再利用ヒューリスティックが適用される可能性が高まったため、このヒューリスティックはますます適切になってきています。このため、プライバシーの観点からだけでも、最も一般的なスクリプトタイプを選ぶことが望ましい。たとえば、この行を書いている時点では、Taprootスクリプト (`bc1p`) はSegWit V0スクリプト (`bc1q`) よりも使用頻度が低い。Taprootスクリプトは、特定の文脈では経済的な利点とプライバシー上の利点を提供するが、より伝統的な単一署名の用途では、新しい標準がより広く採用されるまで、プライバシー上の理由から古い標準に固執するのが賢明かもしれない。

### 四捨五入された数字での支払い

余りを識別するのに役立つもう一つの内部ヒューリスティックは、四捨五入された数である。一般的に、単純な支払いスキーム（1入力2出力）に直面したとき、出力の1つが丸められた金額を使うなら、それが支払いを表す。

![BTC204](assets/it/33/06.webp)

消去法により、一方の出力が支払いを表す場合、他方は釣銭を表す。従って、トランザクションを入力したユーザーは、釣銭として識別された出力をまだ所有している可能性が高いと推論できる。

ほとんどの支払いはまだ不換紙幣単位で行われているため、このヒューリスティックが常に適用されるわけではないことに注意すべきである。実際、フランスの商人がビットコインを受け入れる場合、一般的に安定した価格をサッツで表示することはない。むしろ、ユーロでの価格とビットコインでの支払額との間の換算を選ぶだろう。したがって、取引出力に丸められた数字があってはならない。

しかし、アナリストは、取引がネットワークを介して送信された時点で有効な為替レートを考慮することで、この換算を試みるかもしれない。97,552sats`の入力と、31,085sats`と64,152sats`の2つの出力がある取引を例にとってみよう。一見したところ、この取引には丸めた金額は含まれていないように見える。しかし、取引時の為替レート64.339ドルを適用すると、ユーロに換算すると次のようになる：


- 投入額は62.76ユーロ；
- 生産高は20ユーロ；
- 出力は41.27ユーロ。

一旦不換紙幣に変換されると、この取引は金額を丸めた支払いのヒューリスティックスを適用することができる。20ユーロの出力は、おそらく商人向けであったか、そうでなければ所有者が変わったのであろう。推論によれば、41.27ユーロの出力は、おそらく元の使用者が所有したままである。

![BTC204](assets/it/33/07.webp)

いつの日か、ビットコインが私たちの取引で好まれる勘定単位になれば、このヒューリスティックは分析にさらに役立つだろう。

例えば、このヒューリスティックがおそらく適用できるであろう取引がある：

```plaintext
2bcb42fab7fba17ac1b176060e7d7d7730a7b807d470815f5034d52e96d2828a
```

![BTC204](assets/fr/051.webp)

Fonte: [Mempool.space](https://mempool.space/tx/2bcb42fab7fba17ac1b176060e7d7d7730a7b807d470815f5034d52e96d2828a)

### 最高のアウトプット

単純な支払いモデルにおいて、取引の2つのアウトプットの間に著しく大きな差がある場合、大きい方のアウトプットが残余である可能性が高いと推定できる。

![BTC204](assets/it/33/09.webp)

この最大出力のヒューリスティックは、おそらく最も不正確なものだろう。単独で識別される場合は、かなり弱い。しかし、この特徴を他のヒューリスティックと組み合わせることで、解釈の不確実性を減らすことができる。

例えば、ある取引で、1つのアウトプットが丸い金額であり、もう1つのアウトプットが大きい金額である場合、丸い支払いのヒューリスティックと大きいアウトプットに関連するヒューリスティックを共同で適用することで、不確実性のレベルを下げることができる。

例えば、このヒューリスティックがおそらく適用できるであろう取引がある：

```plaintext
b79d8f8e4756d34bbb26c659ab88314c220834c7a8b781c047a3916b56d14dcf
```

![BTC204](assets/fr/053.webp)

Fonte: [Mempool.space](https://mempool.space/tx/b79d8f8e4756d34bbb26c659ab88314c220834c7a8b781c047a3916b56d14dcf)

## 外部ヒューリスティック

<chapterId>4a170e3b-200d-431a-8285-18a23ff617ba</chapterId>

外部ヒューリスティックの研究では、取引そのものに内在しない特定の要素の類似性、パターン、特徴を分析する。言い換えれば、以前は内部ヒューリスティックによって取引に内在する要素を利用することに限定されていたとすれば、現在は外部ヒューリスティックによって取引の環境へと分析のフィールドを広げているのである。

### アドレスの再利用

これはビットコイン愛好家の間で最もよく知られたヒューリスティックスの一つである。アドレスの再利用は、異なるトランザクションと異なるUTXOの間で接続を確立することを可能にする。これは、ビットコインの受信アドレスが複数回使用される場合に観察される。

従って、（前章で見たように）残りを識別する内部ヒューリスティックとして、同一トランザク ション内でのアドレス再利用を利用することが可能である。しかし、アドレスの再利用は、複数のトランザクションの背後にあるエンティティの一意性を認識する ための外部ヒューリスティックとしても機能する。

アドレス再利用の解釈は、このアドレスにロックされたUTXOはすべて同じエンティティに属している（または属していた）ということである。このヒューリスティックは不確実性の余地をほとんど残さない。識別が可能であれば、それに続く解釈は現実に対応する可能性が高い。そのため、異なるオンチェーン・アクティビティをクラスタリングすることができる。

![BTC204](assets/it/34/01.webp)

このパート3の冒頭で説明したように、このヒューリスティックはサトシ・ナカモト自身が発見したものである。白書の中で彼は、ユーザーがこれを避けるための解決策に特に言及している：

"追加の保護として、共通の所有者にリンクされるのを防ぐために、各取引に新しいキー・ペアを使用することができる。"

![BTC204](assets/fr/055.webp)

出典S. Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System", https://bitcoin.org/bitcoin.pdf, 2009.

例えば、複数のトランザクションで再利用されるアドレスがある：

```plaintext
bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0
```

出典：[Mempool.space](https://mempool.space/address/bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0)

### スクリプトと財布の指紋の類似性

アドレスの再利用に加え、同じポートフォリオやアドレスのクラスターにシェアをリンクするためのヒューリスティックな方法が他にもいくつかある。

まず第一に、分析者はスクリプトの使用法の類似性を利用できる。例えば、multisigのような特定の少数派スクリプトは、SegWit V0スクリプトよりも簡単に特定できる。隠れているグループが大きければ大きいほど、私たちを特定するのは難しくなります。このため、優れたCoinjoinプロトコルでは、すべての参加者がまったく同じ種類のスクリプトを使用します。

より一般的には、分析者はポートフォリオのフィンガープリント特性に注目することもできます。これらは、追跡ヒューリスティックとして利用することを目標に特定しようとする、利用 に関連する特定のプロセスである。言い換えれば、追跡対象エンティティに帰属する取引において、同じ内部特性の蓄積が観察される場合、他の取引においてこれらと同じ特性を特定しようと試みることができる。

例えば、追跡されたユーザーは、P2TRアドレス(`bc1p...`)に残りを組織的に送信していることが確認できる。このプロセスが繰り返されるなら、それは分析の継続のためのヒューリスティックとして使うことができる。他のフィンガープリント、例えば UTXO の順番、出力における余りの配置、RBF (Replace-by-Fee) シグナリング、あるいはバージョン番号、`nSequence` フィールド、`nLockTime` フィールドを使うことができる。

Space Kek #19](https://podcasters.spotify.com/pod/show/decouvrebitcoin/episodes/SpaceKek-19---Analyse-de-chane--anonsets-et-entropie-e1vfuji)(フランス語圏のポッドキャスト)で[@LaurentMT](https://twitter.com/LaurentMT)が明言しているように、チェーン分析におけるウォレットフィンガープリントの有用性は時間とともに著しく増加します。実際、スクリプトタイプの増加とウォレットソフトウェアによるこれらの新機能のますます緩やかな展開はその違いを際立たせています。追跡されているエンティティによって使用されているソフトウェアを正確に特定できる場合さえあります。したがって、ウォレットのデジタルフットプリントの研究は、2010年代初頭に開始された取引よりも、最近の取引に特に関連性があることを理解することが重要である。

要約すると、フィンガープリントはウォレットによって自動的に、あるいはユーザーによって手動で実行される、分析に役立つ他のトランザクション上で見つけることができる、あらゆる特定の実践である。

### インプットの共通所有権（CIOH）のヒューリスティクス

CIOHとは英語で "Common Input Ownership Heuristic"（共通入力所有ヒューリスティック）の略で、ある取引に複数の入力が含まれる場合、それらの入力は単一の事業体からもたらされる可能性が高いというヒューリスティックな考え方である。その結果、それらの所有権は共通である。

CIOH（Common Ownership Heuristics of Inputs）を適用するには、まず複数のインプットを持つ取引を観察する。これは最小 2 インプットから最大 30 インプットまで可能である。この特徴が特定されたら、その取引が既知の取引モデルに当てはまらないかどうかをチェックする。例えば、5 つの入力がほぼ同額で、5 つの出力が全く同額であれば、コインジョインの構造であることがわかる。したがって、IOCH を適用することはできない。

しかし、そのトランザクションが既知の協調トランザクションのどのモデルにも当てはまらない場合、すべての入力はおそらく同じエンティティからのものであると推測できる。これは既知のクラスターを拡大したり、追跡を継続したりするのに非常に有用である。

CIOHはサトシ・ナカモトによって発見された。彼は白書のパート10でこれについて述べている：

「連鎖は複数入力トランザクションでは避けられず、必然的にその入力が同じ所有者によって所有されていたことが明らかになる。リスクは、キーの所有者が明らかになった場合、連結によって同じ所有者に属する他の取引が明らかになる可能性があることである。

特に興味深いのは、サトシ・ナカモトがビットコインの正式ローンチ以前から、IOCHとアドレスの再利用という2つの主要なプライバシーの脆弱性を特定していたことだ。この2つのヒューリスティックは、今日に至るまでブロックチェーン分析において最も有用であるため、このような予測は非常に注目に値する。

例を挙げると、IOCHを適用できる可能性のある取引がある：

```plaintext
20618e63b6eed056263fa52a2282c8897ab2ee71604c7faccfe748e1a202d712
```

Fonte: [Mempool.space](https://mempool.space/tx/20618e63b6eed056263fa52a2282c8897ab2ee71604c7faccfe748e1a202d712)

### オフチェーンデータ

もちろん、オンチェーン分析はオンチェーンデータだけに限定されるものではない。過去に分析されたデータやインターネット上で入手可能なデータも、分析を改良するために使用できる。

例えば、追跡された取引が同じビットコインノードから組織的に送信されていることが観察され、そのIPアドレスが特定できれば、同じエンティティからの他の取引を特定し、送信者のアイデンティティの一部を決定することができるかもしれない。この実践は多くのノードを必要とするため簡単には実現できないが、連鎖分析を専門とする企業がこれを採用する可能性はある。

分析者はまた、以前にオープンソースで行われた分析に頼る、あるいは自分自身の以前の分析に頼るという選択肢もある。おそらく、すでに特定されているアドレス・クラスターを指し示す出力が見つかるかもしれない。また、交換プラットフォームを指す出力に依存することも可能で、これらの企業のアドレスは一般的に知られている。

同様に、消去法による分析も可能である。例えば、2つの出力を持つトランザクションの分析中に、そのうちの1つが既に知られているが追跡対象のエンティティとは異なるアドレスクラスタに接続されている場合、もう1つの出力はおそらく残りを表していると解釈することができる。

チェーン分析には、インターネット検索をもう少し一般化したOSINT（_オープンソースインテリジェンス）の一部も含まれる。偽名であろうとなかろうと、ソーシャルメディアやウェブサイトに直接受信アドレスを掲載することが推奨されないのはこのためだ。

![BTC204](assets/fr/063.webp)

### 時間的パターン

あまり意識されることはないが、ある種の人間の行動はオンチェーンで認識できる。最も分析に役立つのは、あなたの睡眠パターンかもしれない！そう、寝ているときはおそらくビットコイントランザクションを送信していない。あなたは一般的に同じ時間に眠るので、オンチェーン分析では時間分析を使用するのが一般的です。これは単に、特定のエンティティのトランザクションがビットコインネットワークに送信される時間をカタログ化することです。これらの時間的パターンを分析することで、多くの情報を推測することができる。

まず第一に、時間的分析によって、追跡対象の事業体の性質が明らかになることがある。トランザクションが24時間にわたって一貫して送信されていることが確認されれば、強力な経済活動が明らかになる。このような取引の背後にある企業は、国際的な企業である可能性が高く、おそらく内部で自動化された手順を持つ企業であろう。

例えば、[手数料に19ビットコインを誤って割り当てた取引](https://mempool.space/tx/d5392d474b4c436e1c9d1f4ff4be5f5f9bb0eb2e26b61d2781751474b7e870fd)を分析することで、[数ヶ月前にこのパターンに気づいた](https://twitter.com/Loic_Pandul/status/1701127409712452072)。単純な時間的分析によって、私たちは自動化されたサービスを扱っており、したがっておそらく取引所のプラットフォームのような大規模な組織であると仮定することができた。

実際、その数日後、その資金はパクソスの取引所プラットフォームを通じてペイパルのものであることが判明した。

逆に、時間パターンが非常に特定の16時間にわたって広がっている場合は、個人ユーザー、あるいは取引量によってはローカルビジネスが相手と推定できる。

観察されたエンティティの性質に加え、時間モデルはタイムゾーンを通じてユーザーのおおよその位置も知ることができる。次に、他のトランザクションをリンクさせ、これらのタイムスタンプを分析に追加できる追加ヒューリスティックとして使用することができる。

たとえば、先ほどの再利用アドレスでは、トランザクションが発着ともに13時間間隔に集中していることが観察できる。

```plaintext
bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0
```

![BTC204](assets/fr/064.webp)

ソースOXT.me

この範囲はおそらくヨーロッパ、アフリカ、中東に相当する。したがって、これらの取引の背後にいるユーザーはそこに住んでいると推測できる。

別の登録では、サトシ・ナカモトが日本からではなく、実はアメリカから活動していたという仮説を可能にしたのも、このような時間分析である：[The Time Zones of Satoshi Nakamoto_](https://medium.com/@insearchofsatoshi/the-time-zones-of-satoshi-nakamoto-aa40f035178f)

## ブロック・エクスプローラーによる実践

<chapterId>6493cf2f-225c-405f-9375-c4304f1087ed</chapterId>

最終章では、これまで学んできた概念を具体的に応用していく。実際のビットコイン取引の例を紹介するので、私が求める情報を抽出してほしい。

理想的には、このような演習では、プロのチェーン分析ツールを使用することが望ましいでしょう。しかし、Samourai Walletのクリエイターがシャットダウンした後、唯一の無料分析ツールOXT.meは利用できなくなりました。そのため、この演習では古典的なブロックエクスプローラーを使用することにします。Mempool.space](https://mempool.space/)を使用することをお勧めしますが、[Bitcoin Explorer](https://bitcoinexplorer.org/)のような他のエクスプローラーを選択することもできます。はじめに、練習問題を紹介します。ブロックエクスプローラーを使って問題を解き、解答を紙に書いてください。そして、この章の最後に解答を示しますので、結果を確認し、修正してください。

これらの演習のために選択された取引は、その特徴のみからやや無作為に選択された。本章は教育および情報提供のみを目的としている。これらのツールを悪意のある目的で使用することを推奨したり、奨励したりするものでは ないことを明確にしておきたい。目的は連鎖分析から身を守る方法を教えることであり、他人の個人情報を暴露するために分析を行うことではありません_。

### エクササイズ1

分析するトランザクションのID：

```plaintext
3769d3b124e47ef4ffb5b52d11df64b0a3f0b82bb10fd6b98c0fd5111789bef7
```

このトランザクションのモデル名は何であり、そのモデル、すなわちトランザクションの構造だけを調べることによって、どのようなもっともらしい解釈が引き出せるだろうか？

### エクササイズ2

分析するトランザクションのID：

```plaintext
baa228f6859ca63e6b8eea24ffad7e871713749d693ebd85343859173b8d5c20
```

このトランザクションのモデル名は何であり、そのモデル、すなわちトランザクションの構造だけを調べることによって、どのようなもっともらしい解釈が引き出せるだろうか？

### エクササイズ3

分析するトランザクションのID：

```plaintext
3a9eb9ccc3517cc25d1860924c66109262a4b68f4ed2d847f079b084da0cd32b
```

この取引のパターンは？

トランザクションの内部ヒューリスティックを使ってモデルを特定した後、どのような出力が残りを表すと考えられるか？

### 練習4

分析するトランザクションのID：

```plaintext
35f0b31c05503ebfdf7311df47f68a048e992e5cf4c97ec34aa2833cc0122a12
```

この取引のパターンは？

トランザクションの内部ヒューリスティックを使ってモデルを特定した後、どのような出力が残りを表すと考えられるか？

### エクササイズ5

ロイックがソーシャルネットワークのツイッターに、支払いを受けるためのビットコインアドレスを投稿したとしよう：

![BTC204](assets/fr/065.webp)

```plaintext
bc1qja0hycrv7g9ww00jcqanhfpqmzx7luqalum3vu
```

アドレス再利用のヒューリスティック**だけを使用して、どのようなビットコイン取引をロイックのアイデンティティにリンクできますか？

明らかに、私はこの受信アドレスの本当の所有者ではないし、ソーシャルメディアに投稿したわけでもない。ブロックチェーンから無作為に選んだアドレスなのだ。

### エクササイズ6

演習 5 の後、アドレス再利用ヒューリスティックを使用して、ロイックが関与していると思われるビットコイン取引をいくつか特定できました。通常、特定されたトランザクションの中で、あなたはこのトランザクションを特定したはずである：

この取引はLoïcのアドレスに資金を送った最初の取引です。この取引でLoïcが受け取ったビットコインはどこから来たと思いますか？

### エクササイズ7

演習 5 の後、アドレス再利用ヒューリスティックを使用して、Loïc が関与していると思われるビットコイン取引をいくつか特定できました。あなたは今、Loïcがどこから来たのかを調べたいと考えています。見つかったトランザクションに基づいて時間分析を行い、Loïcが使用している可能性の高いタイムゾーンを見つけます。このタイムゾーンから、Loïc が住んでいると思われる場所（国、州/地域、都市...）を特定する。

### エクササイズ8

ここで、ビットコインの取引を研究してみよう：

```plaintext
bb346dae645d09d32ed6eca1391d2ee97c57e11b4c31ae4325bcffdec40afd4f
```

この取引だけを見て、どのような解釈ができるだろうか？

### 練習問題の解答

*エクササイズ1:_***

この取引のモデルは単純な支払いである。その構造だけを研究すれば、1つの出力は変化を表し、もう1つの出力は実際の支払いを表すと解釈できる。そして、観察されたユーザーは、おそらく出力に含まれる2つのUTXOのうちの1つ（支払いのためのもの）はもはや所有していないが、もう1つのUTXO（変化のためのもの）はまだ所有していることがわかる。

**エクササイズ2

この取引のパターンは、バッチ支出である。このパターンはおそらく、取引所プラットフォームのような重要な経済活動を示している。入力されたUTXOは重要な経済活動を行う企業から提供されたものであり、出力されたUTXOは分散すると推測できる。あるものはビットコインをセルフストレージウォレットに引き出した会社の顧客のものでしょう。その他はパートナー企業に行くかもしれない。最後に、発行会社に戻る残りがあることは間違いない。

*エクササイズ3:_***

この取引のモデルは単純な支払いである。したがって、この取引に内部ヒューリスティックを適用して、残りを特定しようとすることができる。

個人的には、同じ仮説を裏付ける内部ヒューリスティックが少なくとも2つある：


- 同じタイプのスクリプトの再利用；
- 最大出力。

最も明白なヒューリスティックは、同じタイプのスクリプトの再利用である。実際、出力`0`は`P2SH`であり、受信アドレスが`3`で始まることで認識できる：

```plaintext
3Lcdauq6eqCWwQ3UzgNb4cu9bs88sz3mKD
```

出力`1`は`P2WPKH`で、`bc1q`で始まるアドレスで識別できる：

```plaintext
bc1qya6sw6sta0mfr698n9jpd3j3nrkltdtwvelywa
```

このトランザクションの入力として使用されるUTXOも `P2WPKH`スクリプトを使用している：

```plaintext
bc1qyfuytw8pcvg5vx37kkgwjspg73rpt56l5mx89k
```

したがって、出力`0`は支払いに対応し、出力`1`は残りのトランザクショ ンであると仮定することができる。

この仮説を支持または反証するために、私たちは自分の考えを確認したり、仮説が正しい確率を下げるような他のヒューリスティクスを探すことができる。

私は少なくとももう1つのヒューリスティックを特定した。それは最大の出力である。0`出力は123,689sats`を計測し、`1`出力は505,839sats`を計測する。したがって、これら2つの出力には大きな差がある。より大きな出力のヒューリスティックは、よりボリュームのある出力がおそらく残りであることを示唆している。従って、このヒューリスティックは我々の初期仮説をさらに強化するものである。

入力のUTXOを提供したユーザーは、残りのトランザクションを表すと思われる出力`1`をまだ保持しているようだ。

*エクササイズ4:_***

この取引のモデルは単純な支払いである。したがって、この取引に内部ヒューリスティックを適用して、残りを特定しようとすることができる。

私は個人的に、同じ仮説を支持する少なくとも2つの内部ヒューリスティックを特定した：


- 同じタイプのスクリプトの再利用；
- ラウンド量の出力。

最も明白なヒューリスティックは、同じタイプのスクリプトの再利用である。実際、出力`0`は`P2SH`であり、受信アドレスが`3`で始まることで認識できる：

```plaintext
3FSH5Mnq6S5FyQoKR9Yjakk3X4KCGxeaD4
```

出力`1`は`P2WPKH`で、`bc1q`で始まるアドレスで識別できる：

```plaintext
bc1qvdywdcfsyavt4v8uxmmrdt6meu4vgeg439n7sg
```

このトランザクションの入力として使用されるUTXOも `P2WPKH`スクリプトを使用している：

```plaintext
bc1qku3f2y294h3ks5eusv63dslcua2xnlzxx0k6kp
```

したがって、出力`0`は支払いに対応し、出力`1`は残りの取引であると仮定することができる。

この仮説を支持または反証するために、私たちは自分の考えを確認したり、仮説が正しい確率を下げるような他のヒューリスティクスを探すことができる。

私は少なくとももう1つのヒューリスティックを特定した。それはラウンド量の出力である。出力`0`は`70,000 sats`を計測し、出力`1`は`22,962 sats`を計測する。したがって、BTC単位で完全に丸い出力を扱っていることになる。ラウンド出力のヒューリスティックは、1つのラウンド金額を持つUTXOがおそらく支払いであり、消去によって、もう1つは残りを表していることを示唆している。したがって、このヒューリスティックは最初の仮説をさらに強化する。

しかし、この例では、別のヒューリスティックが最初の仮定を覆すかもしれない。実際、出力 `0` は出力 `1` よりも大きい。もし、最も大きい出力が一般的に余りであるというヒューリスティックに基づいて推論するならば、出力`0`が余りであると推論するかもしれない。しかし、他の2つのヒューリスティックは最大出力ヒューリスティックよりもかなり説得力があるように見えるので、この逆仮説はありえないように思われる。したがって、この明らかな矛盾にもかかわらず、最初の仮説を維持することは妥当であると思われる。

したがって、入力としてUTXOを提供したユーザーは、トランザクションの残りの部分を表すと思われる`1`出力をまだ保持している可能性が高いと思われる。

*エクササイズ5:_***

8つのトランザクションがLoïcのIDに関連付けられることがわかる。このうち、4件はビットコインの受領に関係している：

```plaintext
2d9575553c99578268ffba49a1b2adc3b85a29926728bd0280703a04d051eace
8b70bd322e6118b8a002dbdb731d16b59c4a729c2379af376ae230cf8cdde0dd
d5864ea93e7a8db9d3fb113651d2131567e284e868021e114a67c3f5fb616ac4
bc4dcf2200c88ac1f976b8c9018ce70f9007e949435841fc5681fd33308dd762
```

残りの4つはビットコインの送金についてだ：

```plaintext
8b52fe3c2cf8bef60828399d1c776c0e9e99e7aaeeff721fff70f4b68145d540
c12499e9a865b9e920012e39b4b9867ea821e44c047d022ebb5c9113f2910ed6
a6dbebebca119af3d05c0196b76f80fdbf78f20368ebef1b7fd3476d0814517d
3aeb7ce02c35eaecccc0a97a771d92c3e65e86bedff42a8185edd12ce89d89cc
```

*エクササイズ6:_***

この取引のパターンを調べると、グループ化された支出であることがわかる。実際、この取引には1つのインプットと51のアウトプットがあり、重要な経済活動を示している。したがって、ロイックが取引所プラットフォームからビットコインを引き出したと考えることができる。

この仮説を補強する要素がいくつかある。第一に、入力UTXOを保護するために使用されるスクリプトのタイプは、P2SHマルチシグ2/3スクリプトであり、取引所プラットフォームに典型的な高度なセキュリティレベルを示している：

```plaintext
OP_PUSHNUM_2
OP_PUSHBYTES_33 03eae02975918af86577e1d8a257773118fd6ceaf43f1a543a4a04a410e9af4a59
OP_PUSHBYTES_33 03ba37b6c04aaf7099edc389e22eeb5eae643ce0ab89ac5afa4fb934f575f24b4e
OP_PUSHBYTES_33 03d95ef2dc0749859929f3ed4aa5668c7a95baa47133d3abec25896411321d2d2d
OP_PUSHNUM_3
OP_CHECKMULTISIG
```

さらに、分析されたアドレス`3PUv9tQMSDCEPSMsYSopA5wDW86pwRFbNF`は220,000以上の異なる取引で再利用されており、これは一般的にプライバシーを気にしない取引所プラットフォームの特徴であることが多い。このアドレスに適用された時間的ヒューリスティックも、3ヶ月間にわたってほぼ毎日トランザクションが定期的に広がっていることを示しており、24時間を超える時間帯が延長されていることから、取引所プラットフォームの継続的な活動が示唆される。

最後に、このエンティティによって処理された量は膨大である。実際、このアドレスは2022年12月から2023年3月までの間に222,262件の取引で44BTCを送受信している。これらの膨大な量は、取引所プラットフォームの活動の可能性が高いことをさらに裏付けている。

*エクササイズ7:_***

トランザクションの確認時間を分析すると、以下のUTC時間が確認できる：

```plaintext
05:43
20:51
18:12
17:16
04:28
23:38
07:45
21:55
```

これらの時間を分析すると、UTC-7とUTC-8の時間帯は、ほとんどの時間帯において、一般的な人間の活動範囲（午前8時から午後11時の間）と一致していることがわかる：

```plaintext
05:43 UTC > 22:43 UTC-7
20:51 UTC > 13:51 UTC-7
18:12 UTC > 11:12 UTC-7
17:16 UTC > 10:16 UTC-7
04:28 UTC > 21:28 UTC-7
23:38 UTC > 16:38 UTC-7
07:45 UTC > 00:45 UTC-7
21:55 UTC > 14:55 UTC-7
05:43 UTC > 21:43 UTC-8
20:51 UTC > 12:51 UTC-8
18:12 UTC > 10:12 UTC-8
17:16 UTC > 09:16 UTC-8
04:28 UTC > 20:28 UTC-8
23:38 UTC > 15:38 UTC-8
07:45 UTC > 23:45 UTC-8
21:55 UTC > 13:55 UTC-8
```

UTC-7タイムゾーンは、以下のような州や地域が含まれるため、夏には特に関係が深い：


- カリフォルニア州（ロサンゼルス、サンフランシスコ、サンディエゴなどの都市がある）；
- ネバダ州（ラスベガスと一緒）；
- オレゴン州（ポートランドと一緒）；
- ワシントン州（シアトルと一緒）；
- カナダのブリティッシュ・コロンビア州（バンクーバーやビクトリアなどの都市がある）。

この情報によれば、ロイックはアメリカ西海岸かカナダに住んでいる可能性がある。

*エクササイズ8:_***

この取引を分析すると、5つのインプットと1つのアウトプットがあり、これは連結を示唆しているようである。CIOHヒューリスティックを適用すると、インプットのUTXOはすべて1つのエンティティが保有しており、アウトプットのUTXOもこのエンティティに属することが示唆される。このユーザーは、自分が所有する複数のUTXOを、自分のコインを統合する目的で、アウトプットの単一のUTXOに統合することを選択したようである。このアプローチは、おそらく将来の手数料を削減するために、現時点での低い取引手数料を利用したいという願望が動機となっている。

---
この連鎖分析に関するパート3の執筆にあたり、私は以下の資料を参考にした。


- 2021年にSamourai Walletが制作した[Understanding Bitcoin Privacy with OXT](https://medium.com/oxt-research/understanding-bitcoin-privacy-with-oxt-part-1-4-8177a40a5923)と題された4つの記事シリーズ。
- OXTリサーチ](https://medium.com/oxt-research)の様々なレポート、および無料のチェーン分析ツール（Samourai Walletの創設者が逮捕されたため、現在は利用できない）。
- もっと一般的に言えば、私の知識は[@LaurentMT](https://twitter.com/LaurentMT)と[@ErgoBTC](https://twitter.com/ErgoBTC)の様々なツイートや内容から得たものだ。
- \(https://twitter.com/louneskmt)、[@TheoPantamis](https://twitter.com/TheoPantamis)、[@Sosthene_ai](https://twitter.com/Sosthene___)、[@LaurentMT](https://twitter.com/LaurentMT)と共に参加した[Space Kek #19](https://podcasters.spotify.com/pod/show/decouvrebitcoin/episodes/SpaceKek-19---Analyse-de-chane--anonsets-et-entropie-e1vfuji)。

その著者、開発者、プロデューサーに感謝したい。また、このパート3のベースとなった記事を丹念に添削し、専門的なアドバイスで私に栄誉を与えてくれた査読者にも感謝する。


- _[ジル・カディニャン](https://twitter.com/gillesCadignan);_。
- _[ルドヴィク・ラース](https://viresinnumeris.fr/)._。

# プライバシー保護のベストプラクティスをマスターする

<partId>9bd04b63-f1af-4e50-9061-6bc90009df68</partId>

## アドレスの再利用

<chapterId>f3e97645-3df3-41bc-a4ed-d2c740113d96</chapterId>

Bitcoin上でプライバシーを侵害する可能性のあるテクニックを研究した後、この第3部では、あなた自身を保護するために採用できるベストプラクティスを検討します。このパートは、プライバシーを改善する方法を探ることが目的ではなく、このトピックは後で取り上げるが、むしろ、追加のテクニックに頼ることなく、ビットコインが自然に提供するプライバシーを維持するために、ビットコインと適切にやり取りする方法を理解することが目的である。

もちろん、この第3部を始めるにあたり、アドレスの再利用について話をする。この現象は、ユーザーのプライバシーに対する主な脅威である。従って、この章は全講座の中で最も重要であろう。

### 受信アドレスとは何ですか？

ビットコイン受け取りアドレスは、ウォレットにビットコインを受け取るために使用される文字列または識別子です。

厳密には、ビットコインの受け取りアドレスは、文字通りの意味でビットコインを「受け取る」のではなく、ビットコインを使用できる条件を定義します。具体的には、支払いがあなたに送信されると、送信者のトランザクションは、入力で消費したUTXOから出力であなた宛の新しいUTXOを作成する。この出力には、このUTXOを後でどのように使用するかを定義するスクリプトが適用される。このスクリプトは"_ScriptPubKey_"または"_Locking Script_"として知られています。あなたの受信アドレス、より正確にはそのペイロードは、このスクリプトに埋め込まれている。簡単に説明すると、このスクリプトは基本的に次のように記述する：

> "_この新しいUTXOを使用するには、この受信アドレスに関連付けられた秘密鍵を使用してデジタル署名を提供する必要があります。"
![BTC204](assets/fr/067.webp)

ビットコインアドレスは、使用されるスクリプトモデルによって異なるタイプがあります。最初のモデルは「_Legacy_」として知られ、`P2PKH`（_Pay-to-PubKey-Hash_）と`P2SH`（_Pay-to-Script-Hash_）アドレスが含まれる。P2PKHアドレスは常に `1` で始まり、P2SHアドレスは `3` で始まる。P2PKHアドレスは常に `1` から始まり、P2SHアドレスは `3` から始まる。まだ安全ではあるが、これらの形式は新しい標準よりも取引手数料が高く、プライバシーも低いため、現在では廃止されている。

SegWit V0（`P2WPKH`と`P2WSH`）とTaproot / SegWit V1（`P2TR`）アドレスは最新のフォーマットを表している。SegWitアドレスは`bc1q`で始まり、2021年に導入されたTaprootアドレスは`bc1p`で始まる。

例えば、これはタップルートの受信アドレスである：

```text
bc1ps5gd2ys8kllz9alpmcwxqegn7kl3elrpnnlegwkm3xpq2h8da07spxwtf5
```

ScriptPubKeyの作成方法は、使用する規格によって異なります：

| スクリプトテンプレート | ScriptPubKey | | ----------------------------------------------------------- | --------------------------------------------------------------------------- |

| P2PKH｜OP_DUP OP_HASH160 `<pubKeyHash>` OP_EQUALVERIFY OP_CHECKSIG｜OP_EQUALVERIFY OP_CHECKSIG

| P2SH｜OP_HASH160 `<scriptHash>` OP_EQUAL｜P2SH｜OP_HASH160 `<scriptHash>` OP_EQUAL｜OP_EQUAL

| P2WPKH｜0 `<pubKeyHash>`｜｜P2WPKH｜0 `<pubKeyHash>`｜｜P2WPKH

| P2WSH | 0 `<witnessScriptHash>` |

| P2SH - P2WPKH｜OP_HASH160 `<RedeemScriptHash>` OP_EQUAL｜P2SH - P2WPKH｜OP_HASH160 `<RedeemScriptHash>` OP_EQUAL｜OP_EQUAL

| P2SH - P2WSH｜OP_HASH160 `<RedeemScriptHash>` OP_EQUAL｜P2SH - P2WSH｜OP_HASH160 `<RedeemScriptHash>` OP_EQUAL｜OP_EQUAL

| P2TR | 1 `<pubKey>`

受信アドレスの作成に関しても、選択したスクリプトのテンプレートに依存する：


- P2PKH`アドレスと`P2WPKH`アドレスでは、ペイロード(アドレスのコア)は公開鍵 のハッシュを表す；
- P2SH` アドレスと `P2WSH` アドレスの場合、ペイロードはスクリプトのハッシュを表す；
- P2TRアドレスの場合、ペイロードは変更された公開鍵である。P2TR`の出力は、_Pay-to-PubKey_と_Pay-to-Script_を組み合わせたものである。修正された公開鍵は、ビットコインの使用にも使用できるスクリプトのセットのMerkleルートから派生した「修正」を伴う古典的な支出公開鍵を追加した結果である。

![BTC204](assets/it/67/01.webp)

ウォレットソフトウェアに表示されるアドレスには、HRP（_Human-Readable Part_）、通常ポストSegWitアドレスの場合は`bc`、セパレータ`1`、SegWit V0の場合はバージョン番号`q`、Taproot/SegWit V1の場合は`p`も含まれます。また、送信中のアドレスの完全性と有効性を保証するためにチェックサムも追加される。

最後に、住所は標準的なフォーマットにまとめられる：


- 古いレガシーアドレスのベース58チェック；
- SegWitアドレス用のBech32；
- Taprootアドレス用Bech32m。

以下はbech32とbech32mフォーマット（SegWitとTaproot）のベース10からの加算行列である：

| + | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |

| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

| 0｜q｜p｜z｜r｜y｜9｜x｜8｜8



| 16｜S｜3｜J｜N｜5｜4｜K｜H｜24｜C｜E｜6｜M｜U｜A｜7｜L｜L

### アドレスの再利用とは？

アドレスの再利用とは、複数の異なるUTXOをブロックするために同じ受信アドレスを使用することを指す。

前のセクションで見たように、各UTXOにはそれをロックする独自のScriptPubKeyがあり、UTXOが新しいトランザクションの入力として消費されるためには、それを満たす必要がある。受信アドレス(ペイロード)はこのScriptPubKeyに埋め込まれる。

複数のScriptPubKeyに同じ受信アドレスが含まれている場合、これはアドレスの再利用として知られています。実際には、これはユーザーが複数の支払いでビットコインを受け取るために、送信者に同じアドレスを複数回提供したことを意味します。そして実際、この行為はあなたのプライバシーにとって破滅的です。

### なぜアドレスの再利用が問題なのか？

ブロックチェーンは公開されているため、どのアドレスがどのUTXOをブロックし、どれだけのビットコインをブロックしているかを簡単に確認することができる。同じアドレスが複数の取引に使用されている場合、そのアドレスに関連するすべてのビットコインが同一人物のものであると推測することが可能になる。この慣行は、異なる取引間に決定論的なリンクを確立し、ブロックチェーン上でビットコインを追跡することを可能にすることで、ユーザーのプライバシーを損なうものである。サトシ・ナカモト自身、ビットコイン白書でこの問題を強調している：

> 追加のファイアウォールとして、各トランザクションに新しいキー・ペアを使用し、共通の所有者にリンクされるのを防ぐことができる。
![BTC204](assets/fr/055.webp)

出典S. Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System", https://bitcoin.org/bitcoin.pdf, 2009.

この声明でサトシが求めたゴールは、ユーザーのアイデンティティとビットコイン上のキー・ペアが関連づけられた場合に追加のファイアウォールを作り、すべてのアクティビティが公に自分のアイデンティティにリンクされることを避けることだった。今日、ブロックチェーン分析会社やKYC規制の普及により、固有アドレスの使用はもはや「追加のファイアウォール」ではなく、プライバシーを最低限守りたい人にとって必要な慣行となっている。

アドレスを再利用すると、そのアドレスに関連するすべての取引の間に、ほとんど議論の余地のないリンクが作成されます。楕円曲線による暗号化は秘密鍵の安全性を保証するため、これが直接あなたの資金を危険にさらすことはないが、あなたの活動を監視することは容易になる。実際、ノードを持つ誰もがあなたの取引とアドレスの残高を観察することができ、あなたの匿名性は完全に損なわれる。

![BTC204](assets/it/34/01.webp)

この点を説明するために、ドルコスト平均法（DCA）で定期的に少額のビットコインを購入し、いつも同じアドレスに送金しているユーザー、ボブを例にとってみよう。2年後、このアドレスにはかなりの量のビットコインが入っている。ボブがこのアドレスを使って地元の商人に支払いを行うと、商人は関連するすべての資金を見ることができ、ボブの財産を差し引くことができる。これは、窃盗や恐喝の試みなど、個人のセキュリティリスクにつながる可能性がある。もしボブが定期的な購入のたびに新しいアドレスを使っていたなら、商人に公開する情報は限りなく少なくて済んだだろう。

チェーン分析では、2種類のアドレス再利用を区別する：


- 外部再利用；
- トランザクション内での内部再利用。

1つ目は、あるアドレスが複数の異なるビットコイン取引で再利用される場合に観察される。このヒューリスティックにより、このアドレスを通過するすべてのUTXOは単一のエンティティに属すると推測できる。

内部アドレスの再利用が観察されるのは、再利用が複数のトランザクションにまたがって発生する場合ではなく、同一トランザク ション内で発生する場合である。実際、入力をロックするために使用された同じアドレスがトランザクションの出力として使用された場合、 この出力はまだ同じユーザー（残金）に属しており、2番目の出力は実際の支払いを表していると推測できる。この別の発見的手法により、複数のトランザクションにまたがって資金を追跡することができる。

![BTC204](assets/it/33/02.webp)

アドレスの再利用は、ビットコインの本当の惨劇である。ウェブサイトOXT.me（現在はアクセスできない）によると、ビットコインにおけるアドレス再利用の全体的な割合は、2022年には約52％だった：

![BTC204](assets/fr/069.webp)

この割合は非常に大きいが、個人ユーザーよりもむしろ取引所プラットフォームからのものが圧倒的に多い。

### アドレスの再利用を避けるには？

アドレスの再利用を避けるのはとても簡単です： **ウォレットに新しく入金されるたびに新しいアドレスを使用するだけです。

BIP32のおかげで、最新のポートフォリオは決定論的かつ階層的になった。つまり、ユーザーはシードという一つの初期情報から多数のアドレスを生成することができる。この単一の情報を保存することで、ウォレット内のすべての秘密鍵を復元することができ、対応するアドレスによって保護された資金にアクセスすることができます。

![BTC204](assets/fr/070.webp)

そのため、ウォレットソフトウェアで「_receive_」ボタンを押すと、毎回未使用の受信アドレスが提示されます。このアドレスでビットコインを受け取った後、ソフトウェアは自動的に新しいアドレスを提案します。

> 追記：最近、一部のウォレットソフトウェアが、当局によるマネーロンダリングの一種と受け取られることを恐れ、空白アドレスの生成を停止する意向を表明しました。もしあなたのソフトウェアがそのようなものであれば、直ちに交換することを強くお勧めします。
例えば寄付を受け取るなど、支払いを受け取るために静的な識別子が必要な場合、古典的なビットコインアドレスを使用することは再利用のリスクがあるため推奨されません。ライトニングアドレスを使用するか、静的なオンチェーン決済識別子を使用する場合は、BIP47 または Silent Payments を選択することをお勧めします。これらのプロトコルがどのように機能するかは、このトレーニングのパート6で詳しく説明します。

## コインのラベリングと管理

<chapterId>fbdb07cd-c025-48f2-97b0-bd1bc21c68a8</chapterId>

チェーン分析のセクションで発見したように、トランザクションに関する情報を推測するために使用できるヒューリスティックとパターンが多数存在する。ユーザーとして、よりよく自分自身を守るために、これらのテクニックを知っておくことは重要である。

これには、UTXOの出所を把握することや、支払いの際に消費されるUTXOを慎重に選択することなどが含まれる。この効果的なウォレット管理は、優れたビットコインウォレットの2つの重要な特徴であるラベリングとコイン管理に依存しています。

この章では、これらの機能を研究し、ビットコインでのプライバシーを大幅に最適化するために、作業負荷をあまり増やすことなく、どのようにインテリジェントに使用できるかを見ていきます。

### ラベリングとは何か？

タグ付けは、ビットコインウォレットの特定のUTXOに注釈またはラベルを割り当てることを含むプラクティスです。これらの注釈はウォレットソフトウェアによってローカルに保存され、ビットコインネットワーク上で送信されることはありません。したがって、タグ付けは個人管理のためのツールである。

例えば、私がBisqでCharlesとP2Pで購入したUTXOを所有している場合、私はそれに「`Non-KYC Bisq Charles`」というラベルを付けるかもしれない。

タグ付けは、UTXOの起源または意図された宛先を記憶するのに役立ち、それによって資金管理を容易にし、プライバシーを最適化する良い習慣です。実際、あなたのビットコインウォレットには複数の UTXO が含まれている可能性があります。これらの UTXO のソースが異なる場合、将来的にこれらの UTXO をマージしたくない場合があります。すべてのコインに適切なラベルを付けることで、たとえそれが数年後であったとしても、必要なときにそのコインの出所を思い出すことができます。

### コイン・コントロールとは？

ウォレットソフトウェアのコインコントロールオプションと組み合わせれば、タグ付けの積極的な利用がさらに魅力的になる。

コインコントロールは、優れたビットコインウォレットソフトウェアに見られる機能であり、トランザクションを実行するための入力として使用する特定のUTXOを手動で選択する機能を提供します。実際、送信する支払いを満たすには、その見返りとして受信 UTXO を消費する必要があります。後述するいくつかの理由から、ある支払いを満たすために入力として消費するコインを正確に選択したい場合があります。これこそ、コイン・コントロールが可能にすることである。例えて言うなら、この機能はバゲットの支払いをするときに財布の中の特定のコインを選ぶ動作に似ています。

コインを管理するウォレットソフトウェアとUTXOのラベリングを組み合わせることで、ユーザーは取引に使用するUTXOを正確に見分け、選択することができる。

### UTXOに正しいラベルを付けるには？

UTXOのラベリングには、誰にでも合う普遍的な方法はない。ポートフォリオを簡単にナビゲートできるようなラベリング・システムを定義するのはあなた次第である。いずれにせよ、優れたラベリングは、必要なときに理解できるものであることを心に留めておいてください。あなたのビットコインウォレットが主に貯蓄用である場合、数十年後までラベルが役に立たないかもしれません。そのため、明確で正確、かつ包括的であることを確認してください。

あなたの大切な人が、いつかあなたのポートフォリオにアクセスする必要が生じたときに、資金の出所を簡単に特定できるようにしておくことは重要です。これは、プライバシー上の理由だけでなく、当局の前で資金の出所を正当化する必要がある場合、法的な必要性にも役立ちます。

ラベリングの最も重要な点は、UTXOの出所を記すことです。このコインがどのようにしてあなたのウォレットに到着したかを簡単に示す必要があります。取引所のプラットフォームで購入したものですか？顧客からの支払いですか？ピアツーピア取引所？それとも購入の残りですか？つまり、次のように指定することができます：


- ピックアップ・エクスチェンジ・ドット・コム
- 支払依頼人デイビッド`；
- P2Pシャルルを買う`；
- ソファー購入からの撤退

UTXOの管理を洗練させ、ポートフォリオ内でファンドを分離する戦略を遵守するために、これらの分離を反映する追加マーカーでラベルを充実させることができる。ポートフォリオにUTXOの2つのカテゴリーがあり、混在させたくない場合、これらのグループを明確に区別するためのマーカーをラベルに組み込むことができる。このような分離マーカーは、KYCを含む買収プロセスからのUTXOを区別したり、プロフェッショナルのファンドと個人のファンドを区別するなど、基準によって異なる。前述したラベルの例で説明すると、次のようになる：


- KYC - Exchange.com出金`；
- KYC - Customer Payment David`；
- NO KYC - P2Pシャルルの購入；
- KYC なし - ソファー購入の残金

また、取引中にコインのラベリングを永続させることが望ましい。例えば、KYCなしでUTXOを統合する場合、コインの出所の明確な痕跡を維持するために、結果のUTXOに「統合」だけでなく、特に「KYCなし統合」とマークするようにしてください。

最後に、ラベルに日付を記入することは必須ではありません。ほとんどのウォレットソフトウェアはすでに取引の日付を表示しているし、ブロックエクスプローラーでTXIDを使ってこの情報を取り出すことはいつでも可能だ。

### コインを正しく選ぶには？

トランザクションを行う際、コインコントロールにより、どのUTXOをインプットとして消費し、アウトプットを満たすかを具体的に選択することができる。この選択には2つの側面を考慮する必要がある：


- 支払の受領者が、入力として使用されたUTXOにあなたのアイデンティティの一部をリンクする機能；
- 外部のオブザーバーが、インプットとして消費されたすべてのUTXOのつながりを作る能力。

最初の点を説明するために、具体的な例を挙げてみよう。あなたが近所のパン屋からビットコインでバゲットを買ったとする。あなたは自分のUTXOを1つ以上インプットとして使用し、少なくともバゲットの価格と取引手数料をアウトプットとして賄う。パン屋は、あなたの顔や、彼が知っているあなたのアイデンティティの他の部分を、入力として使用されたコインと関連付けることができる可能性がある。このリンクの存在を知っていれば、支払いの際に他のUTXOよりも特定のUTXOを選ぶことを好むかもしれない。

例えば、あなたのUTXOの1つが取引所プラットフォームから来たもので、あなたがパン屋にこのプラットフォームのあなたのアカウントを知られたくない場合、あなたは支払いにこのUTXOを使用することを避けるでしょう。また、多額のビットコインを明らかにする高価値のUTXOを持っている場合、パン屋にあなたのBTC財産が知られるのを防ぐために、それを使用しないことを選択するかもしれません。

したがって、この最初のポイントに使用するUTXOの選択は、個人的な判断に基づくものであり、あなたが何を開示するかしないかに影響される。受け取り時にUTXOに割り当てたラベルは、使用時に、あなたが相手に開示しても構わない情報のみを表示するUTXOを選択するのに役立ちます。

受信者に開示される可能性のある情報に加えて、入力の選択もすべてのブロックチェーン監視者に開示する内容に影響します。実際、トランザクションの入力として複数のUTXOを使用することで、入力の共通所有ヒューリスティックス（CIOH）に従って、それらが同じエンティティによって所有されていることが明らかになる。

そのため、コインを選択する際には、送信しようとしている取引によって、使用されているすべてのUTXO間にリンクが作成されることに注意する必要があります。このリンクは、特にUTXOが異なるソースから来た場合、個人のプライバシーにとって問題となる可能性があります。

BisqからKYCなしでUTXOを購入した例に戻ると、私のIDを知っている規制取引所プラットフォームのUTXOと組み合わせることは避けたい。実際、これらの2つのUTXOを同じ取引でインプットとして使用した場合、規制プラットフォームは私のアイデンティティとBisqで購入したUTXOをリンクすることができますが、以前は私のアイデンティティとリンクされていませんでした。

最後に、トランザクションの入力として消費するUTXOを適切に選択するために最も重要なことは、複数のUTXOを使用しないことです。可能な限り、支払いをカバーするのに十分な大きさのコインを1枚選んでください。そうすることで、COINJOINに関連するリスクを完全に回避することができます。しかし、個々のUTXOが支払いに十分でなく、複数のUTXOを消費する必要がある場合は、不要な接続のリスクを最小限に抑えるために、同様のソースからのUTXOであることを確認してください。また、受取人はあなたに関する情報を、入力として使用されたコインの履歴と関連付ける可能性があることに留意してください。

### コインの自動選択を理解する

前のセクションでは、トランザクションのためにUTXOを手動で選択することについて説明した。しかし、ウォレットソフトウェアがこの選択を自動的に行うとどうなるでしょうか？消費するコインを決定する方法はいくつかあり、UTXO の選択はビットコインにおける実際の研究分野である。この自動プロセスの主な目的は、ユーザーの取引手数料を最小限に抑えることであることが多い。

FIFO（先入れ先出し）やLIFO（後入れ先出し）のようなUTXOの選択方法は、最も単純なものの一つであるが、最も効率が悪いものでもある。FIFOでは、ポートフォリオの中で最も古いコインが最初に使用される。このアプローチは、相対タイムロックが使用され、定期的に更新されなければならない場合を除き、取引手数料の最小化とプライバシーの保護の両方において、一般的に非効率的である。対照的に、LIFOは最新のUTXOの使用を優先する。単純ではあるが、これら2つの方法はしばしば非効率である。

より高度な方法として_Knapsack Solver_がある。これはバージョン 0.17 までの Bitcoin Core ウォレットで使用されていた方法です。これは、ウォレットからUTXOを反復的かつランダムに選択し、それらをサブグループに合計し、ユーザー手数料を削減するために、トランザクションの重みをできるだけ減らす解を保持することを含む。

ブランチアンドバウンド_（BNB）は、その発明者にちなんでしばしば「マーチのアルゴリズム」という愛称で呼ばれ、バージョン0.17からビットコイン・コアの_ナップザック・ソルバ_に取って代わった。このより高度な方法は、トランザクションの出力を満たすために必要な量に正確に一致するUTXOのセットを見つけることを目的としています。BNB の目標は、残りにかかる即時のコストと予想される将来のコストの両方を考慮した無駄の基準と呼ばれるものを削減することで、手数料と同様に残りの量を最小化することです。この方法は、1960年にAilsa LandとAlison Harcourtによって考案されたオリジナルの_Branch-and-Bound_コンセプトから派生したもので、_Knapsack Solver_よりも正確な手数料最適化を提供します。

これらの自動的なUTXO選択方法はすべて、トランザクション手数料の削減には効果的であるが、 ユーザーのプライバシーの保護においては非効率的であることが多い。実際、これらのアルゴリズムは複数のUTXOを入力にマージする可能性があるため、COHによりこれらのUTXOの共通所有権が明らかになる。明らかに、これらの方法はUTXOに付けられたラベルを考慮することができない。これは、どのコインを取引の受取人に公開するかを意識的に選択するために極めて重要である。現在のところ、コイン選択におけるプライバシーを最適化する唯一の解決策は、手作業で行うことである。

### UTXOラベリングチュートリアル

UTXOにタグを付ける方法を知りたい場合は、既存の主なビットコインウォレットソフトウェアで包括的なチュートリアルをまとめました：

https://planb.network/tutorials/privacy/on-chain/utxo-labelling-d997f80f-8a96-45b5-8a4e-a3e1b7788c52
## KYCと鍵の識別

<chapterId>cec6b9d9-0eed-4f85-bc4e-1e9aa59ca605</chapterId>

KYCは「Know Your Customer」の略で、ビットコイン業界で事業を展開する一部の企業が実施する規制手続きである。この手続きは、マネーロンダリングとテロ資金調達に対抗するという明確な目標を掲げ、顧客の身元を確認し、記録することを目的としている。

具体的には、KYCは顧客から様々な個人情報を収集することを含み、法域によって異なるかもしれないが、一般的にはID、写真、居住証明などが含まれる。これらの情報は検証され、将来の使用のために保管される。

この手続きは、ほとんどの欧米諸国で規制されているすべての交換プラットフォームで必須となっている。つまり、これらのプラットフォームを通じてフィアット通貨とビットコインの交換を希望する人は、KYC要件を遵守しなければなりません。

この手続きは、ユーザーのプライバシーとセキュリティに対するリスクがないわけではない。本章では、これらのリスクを詳細に検証し、KYCと本人確認プロセスがビットコインユーザーのプライバシーに与える具体的な影響を分析する。

### オンチェーントラッキングの促進

KYCに関連する第1のリスクは、ブロックチェーン分析の優先的な入口となることである。前節で見たように、アナリストは取引パターンとヒューリスティックを使ってブロックチェーン上の活動をグループ化して追跡することができる。一旦ユーザーのオンチェーン・アクティビティをクラスター化することに成功すれば、全取引と鍵の中からたった1つのエントリー・ポイントを見つけるだけで、プライバシーを完全に侵害することができる。

![BTC204](assets/fr/078.webp)

取引所プラットフォームからビットコインを引き出す際に使用される受取アドレスを、検証済みのあなたの完全な身元とリンクさせるため、KYCに提出すると、チェーン分析のための非常に質の高いエントリーポイントを提供することになります。理屈の上では、この情報はあなたが情報を提供した会社にしか知られませんが、後で述べるように、データ損失のリスクは現実的です。さらに、たとえ企業がこの情報を共有していなくても、企業がこの情報を保持しているという事実だけでも問題になる可能性があります。

したがって、ブロックチェーン上の自分の活動のプーリングを制限する他の措置が取られない限り、KYCというエントリーポイントを知っている人なら誰でも、ビットコイン上のすべての活動を自分のアイデンティティに結びつけることができる可能性がある。したがって、この企業から見れば、ビットコインの使用はすべての機密性を失うことになる。

![BTC204](assets/fr/079.webp)

このことを比較で説明すると、X銀行の銀行員がX銀行とのすべての取引にアクセスできるだけでなく、Y銀行との取引や自分の現金取引もすべて見ることができるようなものである。

このトレーニングの最初の部分を思い出してほしい。サトシ・ナカモトによって設計されたビットコインのプライバシー・モデルは、ユーザーのアイデンティティとキー・ペアの分離に基づいている。このプライバシーの層は今日ではもはや十分ではないが、それでも可能な限りその劣化を抑えることが賢明である。

### 国の監視にさらされる

KYCの2つ目の大きな問題は、ある時点でビットコインを保有していたことが国家に明らかになることである。規制された行為者を通じてビットコインを購入すると、国家がその保有を知ることが可能になる。現在のところ、これは些細なことのように思えるかもしれないが、自国の政治的・経済的未来が自分の手中にあるわけではないことを忘れてはならない。

まず第一に、国家はすぐに権威主義的な姿勢をとることができる。歴史には、政策が突然変更された例がたくさんある。今日、ヨーロッパでは、ビットコイン愛好家がビットコインに関する記事を書いたり、カンファレンスに参加したり、自分専用のウォレットを管理したりすることができる。しかし、明日がどうなるかは誰にもわからない。ビットコインが突然パブリック・エネミー・ナンバーワンになれば、国の登録簿でビットコインと関連付けられることが問題になるかもしれない。

その後、深刻な経済危機に直面した場合、国家は市民が保有するビットコインの差し押さえを検討するかもしれない。おそらく明日は、ビットコイナーは危機に乗じているとみなされ、不換紙幣の切り下げに直面したキャピタルゲインのために超過課税されるだろう。

ビットコインはシャッフルされるため、追跡できないから問題ないと思うかもしれない。しかし、トレーサビリティは問題ではない。本当の問題は、あなたがビットコインを持っていることを国家が知っていることだ。この単純な情報だけで、あなたを有罪にしたり、口座を要求したりすることができる。ビットコインを使い込んだと主張することもできるが、それは確定申告に反映させなければならず、バレてしまう。ボート事故で鍵をなくしたと言うこともできるが、ツイッターのジョークを越えて、本当にそれで冤罪が晴れると思うか？

従って、今はそのリスクが遠くに感じられるかもしれないが、BTCを所有していることが国家に知られるかもしれないという単純な事実に関連するリスクを考慮することが重要である。

国の監督という観点からKYCがもたらすもう一つの問題は、規制対象プラットフォームによる報告義務である。他の国の規制についてはよく知らないが、フランスでは、_Digital Asset Service Providers_（PSANs）は、疑わしいと思われる資金の動きを金融監督機関に報告することが義務付けられている。

こうして、2023年のフランスでは、1,449件の不審な行為がPSANによって報告された。今のところ、これらの行為のほとんどは犯罪関連である。しかし、当局は規制対象のプラットフォームに対しても、その構造のみに基づく疑わしいビットコイン取引を報告するよう求めている。もしあなたが共同取引を行ったり、多少非典型的なパターンを持つ取引を行ったりした場合、そしてその取引がこれらのプラットフォームからのビットコインの引き出しの近くで発生した場合、当局に報告される可能性があります。不正行為がなく、正当な権利の行使であったとしても、この報告により、監視の目が厳しくなり、KYCがなければ避けられたであろう不都合が生じる可能性があります。

### 個人情報紛失のリスク

KYCのもうひとつの問題は、個人データをすべて民間企業のサーバーに保管しなければならないという事実にある。最近の出来事は、金融であれIT関連であれ、誰も失敗を免れないことを思い起こさせた。2022年、セルシオの顧客は被害を被った。同社が破産した結果、債権者の名前と資産額が行政手続き中の米国司法制度によって公開されたのだ。

ちょうど2年前、暗号通貨分野の大手サイバーセキュリティ企業が、顧客の個人情報の盗難に遭った。この事件はビットコインの購入とは直接関係なかったが、このリスクは取引所プラットフォームにも残っている。したがって、この個人データに関連するリスクは確実に存在する。

すでに私たちは個人情報の多くを民間企業に預けているのは事実だ。しかし、このデータは個人を特定できるだけでなく、ビットコインでの活動ともリンクしているため、リスクは二重になっている。実際、ハッカーが取引所プラットフォームの顧客データにアクセスできた場合、その顧客はビットコインを所有していると合理的に推測できる。このように、ビットコインは他の貴重な資産と同様、窃盗犯の興味を引くという事実が、このリスクを悪化させている。

データ漏洩が発生した場合、最悪の場合、標的型フィッシングの標的になる可能性がある。最悪の場合、自宅が物理的な脅威にさらされる可能性もある。

ビットコインに関連する特定のリスクに加えて、身分証明書の送信に関連する危険性も考慮する必要がある。実際、データが流出した場合、なりすましの被害に遭う可能性がある。したがって、問題となっているのは取引の機密保護にとどまらず、各個人の個人的なセキュリティにも影響を及ぼす。

### KYCに関するよくある誤解

ツイッターやビットコイナー同士の議論でよく見かけるKYCに関する誤解を払拭することは重要である。

まず第一に、KYC（Know Your Customer）を通じて取得したビットコインのプライバシー保護が無駄だと考えるのは間違いである。ビットコインにおけるプライバシーのためのツールや方法は多様であり、目的も異なる。例えば、KYCからビットコインのcoinjoinトランザクションを使用することは悪いアイデアではない。もちろん、アカウントを凍結されたり禁止されたりしないよう、規制された取引所プラットフォームでは慎重になる必要があるが、厳密な技術的見地から言えば、これらのやり方は相容れないものではない。Coinjoinはコインの履歴を中断させる効果があり、KYCに関連する連鎖分析リスクのいくつかに対抗するのに役立ちます。すべてのリスクを排除するものではありませんが、すでに大きなメリットとなっています。

ビットコインにおけるプライバシーは、「匿名」ビットコインとそうでないものを区別するような二元的な見方をすべきではない。KYCによって取得したビットコインを所有したからといって、すべてが失われるわけではなく、それどころか、プライバシーツールの使用はさらに有益であることが証明されるかもしれない。

逆に、KYC以外の方法でビットコインを取得しても、完全なプライバシーが保証されるわけではなく、他の保護措置を講じる必要性が免除されるわけではありません。非KYCのビットコインを保有していても、受信アドレスを何度も再利用している場合、あなたの取引は追跡され、グループ化される可能性があります。ビットコインの外の世界とのわずかなつながりが、あなたが持っていた1つのプライバシーの層を損なう可能性があります。したがって、ビットコインのプライバシーを向上させるツールや手法はすべて補完的なものと考えることが重要です。それぞれの技術は特定のリスクに対処し、追加の保護層を追加することができます。したがって、非KYCビットコインを所有しているからといって、他の予防措置を講じることが絶対に免除されるわけではありません。

### KYCはキャンセルできますか？

KYCを完了した後に「後戻り」することは可能なのかと聞かれることがあるが、先の段落から想像できるように、その答えは微妙である。KYCに関連するリスクを避けるために、最も単純な方法は、ビットコインを取得する際にKYCを使用しないことです。このトピックについては次の章で詳しく説明する。しかし、KYCがすでに実行され、ビットコインが購入されている場合、発生するリスクを軽減する方法はあるのでしょうか？

取引追跡のリスクに関しては、coinjoinの使用が一つの解決策となります。この方法については研修の後半で詳しく説明しますが、coinjoinはコインの履歴を破壊し、過去-現在、現在-過去のトレーサビリティを妨げる可能性があることを知っておいてください。たとえ規制されたプラットフォームを通じて入手したBTCであっても、この手法によってトレーサビリティが妨げられる可能性があります。

しかし、coinjoinはKYCに関連する2つ目のリスク、つまりビットコインを保有していることを国に知られるというリスクを排除することはできません。実際、たとえあなたのコインが追跡不可能になったとしても、司法管轄権によっては、国があなたの暗号化された有効な外国人登録明細書にアクセスできる可能性がある。このリスクは技術的なものではなく管理的なものであるため、KYCにさらされることを避ける以外に、このリスクを排除するビットコイン特有の解決策はありません。このリスクを軽減する唯一の合法的な方法は、規制されたプラットフォームで規制されたプラットフォームを通じて取得したビットコインを売却し、KYCのない手段で買い戻すことです。売却し、廃棄を宣言することで、管理者はあなたがもはやそれらを所有していないことに注意する必要があります。

個人データや身分証明書が公開される危険性については、ビットコインの外部にある危険性であり、それを回避する技術的な解決策はない。いったんデータが開示されると、これを元に戻すことは難しい。プラットフォーム上で口座を閉鎖することは可能ですが、特に本人確認が外部委託されている場合、KYCデータの消去を保証するものではありません。特に本人確認が外部に委託されている場合はなおさらです。したがって、このリスクを完全に防止し、もはや存在しないようにする解決策はありません。

### KYCとキー・アイデンティフィケーションの違い

ビットコイナーの中には、「KYC」という言葉を、送金やクレジットカードによる支払いを伴うBTC交換にまで拡大解釈する傾向がある。しかし、KYCと鍵識別を混同しないことが重要である。個人的には、このトピックに対する私の認識は時間の経過とともに変化してきたと認めざるを得ない。

KYCとは特に、一部の企業が顧客の身元を確認し記録するために実施する規制手続きのことを指す。ビットコインを取得する際、KYCに応じるか応じないかの二者択一の問題である。しかし、ユーザーのアイデンティティの一面をオンチェーン・アクティビティにリンクさせる鍵識別は、それほど二元的ではなく、むしろ連続性を表している。実際、ビットコインの売買という文脈では、この識別は程度の差こそあれ常に可能である。

例えば、スイスの規制されたプラットフォームでビットコインを購入する場合、KYC（Know Your Customer）は必要ありません。しかし、購入が銀行口座を通じて行われたため、キーの特定が行われる可能性がある。ここでKYCに関連する最初の2つのリスク-オンチェーン追跡の容易化と政府の監視への暴露-が生じるが、これはKYCのない取引所でも顕在化する可能性がある。スイスの事業体があなたの国の当局に疑わしい取引を報告した場合、当局は購入に使われた銀行口座を調べるだけで、あなたの身元を突き止めることができる。このように、規制されたプラットフォームでKYCを行わずに購入することは、重要な身元確認のリスクとしてはかなり高い。

しかし、規制されたプラットフォームを避け、P2P（Peer-to-Peer）の取得方法を選んでも、鍵識別のリスクが完全になくなるわけではなく、単にリスクが軽減されるだけである。Bisqや他のP2Pプラットフォームで購入する例を考えてみよう。取引相手との決済には、おそらく銀行口座を使うでしょう。もし当局が取引相手に質問し、あなたの名前を尋ねれば、前述のリスク1と2に遭遇することになる。これらのリスクは、確かにプラットフォームで非KYCで購入するよりははるかに低く、KYCで購入するよりはさらに低いですが、それでも少なからず存在します。

最後に、物理的な現金取引所でビットコインを購入したとしても、完全に匿名というわけではない。取引相手はあなたの顔を見ており、それはあなたのアイデンティティの一部である。この例では最小限だが、識別キーが存在する可能性はまだある。

結論として、ビットコインと他の資産との交換の際には、それが不換紙幣の購入であろうと実物資産との売却であろうと、必ず鍵の識別が行われる。選択された交換方法によって、この識別は強度が異なります。この識別を、明確に定義された規制プロセスであるKYCと混同しないことが重要である。なぜなら、KYCはこのスペクトルの上位に位置し、当局によるユーザー鍵の識別を体系的に促進するからである。

## 販売・獲得方法

<chapterId>756598af-95aa-4c77-ac48-243c7ad89530</chapterId>

前章を読んだ後、KYCに関連するリスクを避けるために、本人確認プロセスを受けることなくビットコインを売買する方法を疑問に思うかもしれない。交換にはいくつかの方法があります。

### 現金でのP2P取引

これまで見てきたように、プライバシーの面で最も優れた方法は、現金決済によるP2P（ピアツーピア）交換であることに変わりはない。この方法では、買い手であれ売り手であれ、残された痕跡を最小限に抑えることができ、鍵を特定される可能性を大幅に減らすことができます。

しかし、このやり方には個人的なセキュリティリスクが伴う。主な危険は、取引中に、あなたが現金またはビットコインでかなりの額を保有していることが取引相手に知られることにある。この情報は悪意のある人物の注意を引く可能性がある。実際、一般的にビットコインの保有については慎重を期すことが勧められている。このアドバイスは現金にも適用できる。しかし、対面でのやり取りでは、ビットコインを所有していることを公表することは避けられず、欲をかき立てられる可能性がある。

このリスクを抑えるためには、家族や親しい友人など、信頼できる人との現金取引を優先することをお勧めします。また、[ローカルビットコインミーティング](https://btcmap.org/communities/map) に何度か参加した後、交換を行うことも検討してみてください。そうすることで、他の参加者とよりよく知り合うことができ、物理的な交換の間に一人になることもない。しかし、P2P現金交換には、規制されたプラットフォームや銀行口座を通じて購入する場合には存在しない、個人的なセキュリティに対するリスクが内在していることを認識することが重要です。

また、住んでいる場所によっては、ビットコインであれ現金であれ、大金の輸送や保管にはリスクが伴う。

また、現金の両替は、警察などのチェックの際に法的なリスクをもたらす可能性もある。ほとんどの国では現金の所持量に制限はありませんが、あまりに多額の現金は疑われる可能性があります。そのため、特に長距離を移動する必要がある場合は慎重になり、一度に多額の取引を避け、多額の所持を正当化する必要がないようにしましょう。

最後に、P2P購入のもう一つの欠点は、価格が規制されたプラットフォームで観察されるよりもしばしば高いことである。売り手はしばしば、1％から時には10％以上のサーチャージを課す。この価格差にはいくつかの理由がある。第一に、これはP2P販売者の間で一般的な慣行であり、長い時間をかけて確立されたものである。さらに、売り手は買い手に資金を送る際に取引手数料がかかる。また、P2P販売では、プラットフォーム取引よりも盗難リスクが高いため、リスクに対する手数料が正当化される。最後に、プレミアムは需要とプライバシーの観点からの取引所の質に相対的である可能性がある。買い手としては、プライバシーの利得は売り手によって請求される追加料金に織り込まれている。また、一部のビットコイナーは、P2Pで購入されたBTCの価格の上昇は、その真の価値を反映していると考えており、規制されたプラットフォームでの低価格は、個人情報のプライバシーに関するトレードオフの結果であると主張している。

### マッチング・プラットフォームによるP2P交換

個人的なセキュリティという点で、よりリスクの低い選択肢は、PayPal、銀行振込、Revolutなどの電子決済手段を使って、オンラインのみでP2P交換を行うことである。

この方法は、現金取引に伴う多くのリスクを回避するのに役立つ。しかし、オンライン取引中に取引相手が約束を守らないリスクは大きくなります。実際、物理的な取引所では、ビットコインの見返りを送らない売り手にお金を渡しても、相手は目の前に立っているので、すぐにそのことを訴えることができます。一方、オンラインでは、あなたから盗んだ人を見つけることができないことがよくあります。

このリスクを軽減するために、P2P交換に特化したマッチング・プラットフォームを利用することができる。このようなプラットフォームでは、紛争解決メカニズムを使用して、不満を持つユーザーを保護する。一般的に、これらのプラットフォームはエスクローシステムを提供し、売り手によって不換紙幣での支払いが確認されるまでビットコインが保管される。

個人のセキュリティという点では、この購入方法は物理的な現金交換よりもかなり安全である。しかし、前述したように、オンラインP2P取引所は、物理的な取引所よりも多くの痕跡を残し、ビットコイン上のプライバシーを損なう可能性がある。銀行のようなオンラインのフィアット決済方法を使用することで、鍵の特定を容易にする可能性のある、より多くの情報を公開することになります。

繰り返しになるが、これらのプラットフォームでは、1回の取引で多額の取引を行わないことをお勧めする。取引を分割することで、取引相手による盗難の可能性に伴うリスクを分散することができる。

P2P購入のもう一つの欠点は、価格が規制されたプラットフォームで観察されるよりもしばしば高いことである。売り手はしばしば、1％から時には10％以上のサーチャージを課す。この価格差にはいくつかの理由がある。第一に、これはP2P販売者の間で一般的な慣行であり、長い時間をかけて確立されたものである。さらに、売り手は買い手に資金を送る際に取引手数料がかかる。また、P2P販売では、プラットフォーム取引よりも盗難リスクが高いため、リスクに対する手数料が正当化される。最後に、プレミアムは需要とプライバシーの観点からの取引所の質に相対的である可能性がある。買い手としては、プライバシーの利得は売り手によって請求される追加料金に織り込まれている。また、一部のビットコイナーは、P2Pで購入されたBTCの高い価格は、その真の価値を反映していると考えており、規制されたプラットフォームでの低い価格は、個人情報のプライバシーに関するトレードオフの結果であると主張している。

ソリューションに関しては、個人的にはいつも[Bisq](https://bisq.network/)を使っており、非常に満足している。Bisqのシステムは確立されており、信頼できる。しかし、BisqはPC上でのみ利用可能で、そのインターフェースは初心者には複雑すぎるかもしれない。もう一つの欠点は、Bisqがオンチェーン取引のみで運用されていることで、ビットコインの取引手数料が高い時期には高額になる可能性がある。

-> Bisqのチュートリアルについてはこちらをご覧ください。

https://planb.network/tutorials/exchange/peer-to-peer/bisq-fe244bfa-dcc4-4522-8ec7-92223373ed04
より簡単なオプションとして、[Peach](https://peachbitcoin.com/)を試してみることができる。[Peach](https://peachbitcoin.com/)は、統合された紛争解決システムで買い手と売り手のつながりを促進するモバイルアプリである。Bisqよりも直感的に利用できる。

-> Peachのチュートリアルについてはこちらをご覧ください。

もう一つのオンライン・オプションは[HodlHodl](https://hodlhodl.com/)で、個人的にはテストしていないが、良い流動性を提供する定評のあるプラットフォームである。

-> HodlHodlのチュートリアルについてはこちらをご覧ください。

https://planb.network/tutorials/exchange/peer-to-peer/peach-wallet-db64fe42-17ca-4b24-abb8-e7d4c03b2028
https://planb.network/tutorials/exchange/peer-to-peer/hodlhodl-d7344cd5-6b18-40f5-8e78-2574a93a3879
ライトニング・ネットワーク・ベースのソリューションとしては、[RoboSats](https://learn.robosats.com/)と[LNP2PBot](https://lnp2pbot.com/)がある。RoboSatsはウェブサイトからアクセスでき、使い方も比較的簡単だ。LNP2PBotは、メッセージングアプリのTelegram上の交換システムを通じて動作するという点で、より非典型的である。

-> ロボサットに関するチュートリアルをご覧ください。

-> LNP2PBotのチュートリアルをご覧ください。

https://planb.network/tutorials/exchange/peer-to-peer/robosats-b60e4f7c-533a-4295-9f6d-5368152e8c06
https://planb.network/tutorials/exchange/peer-to-peer/lnp2pbot-v2-e6bcb210-610b-487d-970c-7cce85273e3c
### KYCなしの規制プラットフォーム

お住まいの国によっては、ビットコインの売買に KYC 手続きを必要としない規制されたプラットフォームを利用できる場合があります。例えばスイスでは、[Relai](https://relai.app/)や[MtPelerin](https://www.mtpelerin.com/)などのプラットフォームを利用することができます。

-> チュートリアルはこちら。

前章で見たように、この種のプラットフォームはKYC手続きに関連するリスクは免れるが、鍵識別のリスクは高くなる。ビットコインのプライバシーの観点から、これらのプラットフォームはKYC購入方法よりも優れた保護を提供しますが、P2P取引所よりも魅力的ではありません。

しかし、個人のセキュリティという点では、これらのプラットフォームを使用することは、P2P取引所よりもはるかにリスクが低い。また、P2P交換を促進するプラットフォームよりも使いやすいことが多い。

https://planb.network/tutorials/exchange/centralized/relai-v2-30a9671d-e407-459d-9203-4c3eae15b30e
### ATM

KYCなしでビットコインを売買するもう一つの選択肢は、暗号通貨ATM（現金自動預け払い機）である。個人的には、私の国にはないので、このソリューションをテストする機会がなかった。しかし、この方法は住んでいる場所によっては非常に興味深いものになるだろう。

ATM の問題は、ATM が禁止されている国や厳しく規制されている国があることである。ATM が本人確認プロセスを必要とする場合、規制された KYC プラットフォームに内在するリスクと同じリスクに直面する。しかし、ATMが少額であれば本人確認なしで取引できるのであれば、その利用は現金ベースのP2P取引に匹敵するレベルのプライバシーを提供することができ、この種の取引に関連するリスクのほとんどを回避することができる。

ATMの主な欠点は、両替手数料がしばしば高額になることである。

### ギフトカード

最後に、ビットコインを売って不換紙幣に換えるのではなく、日々の買い物にビットコインを使いたい人にも有効なソリューションを紹介したい。

BTCを使用する最良の方法は、ビットコインを直接使用するか、ライトニングネットワークを使用して商品やサービスを購入することである。しかし、多くの国では、ビットコインを受け入れる加盟店の数は依然として限られている。そのため、ギフトカードを利用するのが現実的な選択肢となる。

KYC手続きを必要としないいくつかのプラットフォームは、主要店舗で使用できるギフトカードとビットコインを交換する機能を提供している。これらのプラットフォームには、[CoinsBee](https://www.coinsbee.com/)、[The Bitcoin Company](https://thebitcoincompany.com/)、[Bitrefill](https://www.bitrefill.com/)が含まれます。これらのプラットフォームは、不換紙幣に交換することなく、幅広い製品やサービスにアクセスできるようにすることで、ビットコインの日常的な使用を大幅に容易にします。

https://planb.network/tutorials/exchange/centralized/bitrefill-8c588412-1bfc-465b-9bca-e647a647fbc1
### その他の取得方法

プライバシーを守りながらビットコインを入手する他の方法の中には、もちろんマイニングがあります。satsのマイニングを開始するには、身元を明らかにする必要はありません。有効な雇用証明を見つけてネットワークに提出するだけです。プールマイニングを選択した場合、KYCなどの身分証明書が必要なプールもあれば、不要なプールもあります。

もう一つの方法は、ビットコインと引き換えに働くことである。この入手方法は魅力的だが、必要な本人確認の程度は状況によって大きく異なる。

\この章を書くために、Plan ȏ Networkで[@pivi__en](https://x.com/pivi___)が作成したBTC205コースを使用した（当分の間、フランス語でのみ利用可能）。

## 統合、UTXO、CIOH管理

<chapterId>d0486c8f-332d-402b-ae2e-949416752b9c</chapterId>

セルフストレージのポートフォリオを持っている場合、管理が最も複雑な側面の一つは間違いなく統合である。統合すべきか？目的は何か？どの規模のUTXOを目指すべきか？プライバシーのトレードオフは何か？このセクションではそれを探っていこうと思う。

### 統合とは何か？

ビットコインの運用はオークション市場に似ており、最高の手数料を提供するトランザクションがマイナーによって優遇される。しかし、各ブロックには最大ウェイトがあり、含めることができるトランザクションの数が制限される。ブロックは平均10分ごとに生成されるため、各ブロックで利用可能なスペースは希少な資源である。

電気代、資本金、メンテナンスに多大なコストを要する採掘業者は、当然ながら収益性を最大化しようとする。彼らは、その重量に比して最も高い手数料を提供する取引を好む傾向がある。

実際、ビットコインの取引はすべて同じ重さではない。インプットとアウトプットが多いものは、より重くなります。例えば、2つのトランザクションを考えてみましょう：


- 取引Aは1つの入力と1つの出力を含む。手数料は1,994サツであり、そのウェイトは141vBである；
- より複雑なトランザクションBは、2つのインプットと2つのアウトプットを持ち、2,640サットの手数料を220VBのウェイトに割り当てている。

この例では、トランザクションBの方が高い手数料総額を提示しているが、マイナーはトランザクショ ンAを支持する。以下は各トランザクションの計算で、仮想バイト当たりのサット数（sat/vB）で表したものである：

```text
TXA: 1994 / 141 = 14 sat/vB
TXB: 2640 / 220 = 12 sat / vB
```

これは、重さの単位ごとに、取引Aは取引Bよりも手数料を多く提供することを意味する。

そのため、利用者にとっては、取引において可能な限り最小限のインプットを消費することがますます魅力的になっている。しかし、アウトプットの支払いを満足させるためには、十分な量を消費する必要がある。したがって、ポートフォリオを管理する際には、十分に大きなUTXOを持つ必要がある。

統合の原則は、ビットコインの手数料が低い期間を利用して、自分の小さなUTXOを1つの大きなUTXOに統合することである。したがって、ビットコインの手数料が上昇すると、最小限の入力で取引できるため、絶対的な手数料を少なくすることができる。目標は、手数料が高い期間に強制的な取引を計画することである。

取引手数料の節約に加え、UTXOを統合することで "ダスト "の発生を避けることができる。ダストとは、サットでの価値が非常に低く、それを使うために必要な取引手数料をカバーするのに十分でないUTXOを指す。このため、取引手数料が高いままである限り、これらのUTXOを使用することは経済的に不合理となります。UTXOを積極的にグループ化することで、UTXOがダストになるのを防ぎ、すべての資金を使用可能な状態に保つことができます。

### UTXOの最小サイズは？

UTXOの最低推奨値はいくらかという質問を受けることがある。残念ながら、あなたの好みや手数料の市況に左右されるため、普遍的な答えはありません。しかし、あなたのニーズに合った基準値を決定するのに役立つ公式をご紹介します：

$$
\frac {P \times F}T = M
$$

どこでだ：


- P$は取引の重さである；
- F$は、1バイトあたりのサトシ（sats/vB）単位で、あなたがカバーしてもよいと考える最大レートを表す；
- T$は、UTXOの総価値に対する取引手数料の割合である；
- M$は、各UTXOのサトシでの最低額である。

標準的なSegWit取引の手数料を1インプット、2アウトプット、141vBでカバーしたいと仮定します。最大800 sat/vBをカバーし、最大でもUTXOの価値の12%までの手数料を費やすことを厭わないのであれば、計算は次のようになる：

$$
\frac{141 \times 800}{0.12} = 940\ 000
$$

この例では、ポートフォリオのUTXOの最低値を94万サットに維持するのが賢明だろう。

### 統合とCOIH

ブロックチェーン分析で最も広く使用されているヒューリスティックの1つは、COIH（_Common Input Ownership Heuristic_）で、ビットコイン取引へのすべての入力が同じエンティティに属していると仮定することができます。正確には、コンソリデーションの原理は、入力として複数のUTXOを消費し、出力として単一のUTXOを作成することです。したがって、コンソリデーションは COIH の適用を可能にする。

![BTC204](assets/fr/097.webp)

実際には、これは外部のオブザーバーが、連結されたUTXOはすべておそらく同じ人物のものであり、生成された唯一の出力も同様にその人物のものであると推測できることを意味する。このような状況は、異なる取引履歴をリンクすることによって、あなたのプライバシーを損なう可能性がある。例えば、私がP2Pで取得した3つのUTXOと、KYCを必要とするプラットフォームを通じて取得した1つのUTXOを統合したとします：

![BTC204](assets/fr/098.webp)

そうすることで、政府機関を含む可能性のある取引所プラットフォームのデータにアクセスできるあらゆる組織が、私が他の金額のBTCを保有していることを特定できる。以前は、これらのUTXOは私のIDに直接リンクされていませんでしたが、今ではリンクされています。さらに、これにより、私が一定量のビットコインを所有していることがあらゆる情報源に明らかになる。

UTXOを管理する上で、手数料を減らすために統合を推し進める経済的配慮は、UTXOを決して統合しないことを推奨する優れたプライバシー慣行と対立する。したがって、経済性とプライバシーのどちらを選択するかは、各ユーザーの優先順位によります。

UTXOの規模を大幅に維持したまま統合を回避できるのであれば、それが理想的だ。そのためには、取得方法を最適化しましょう。DCAでビットコインを購入する場合、1回限りの購入の間隔をできるだけ広くして、価値をより少ないUTXOにまとめるようにします。毎週120ユーロ購入するよりも、2ヶ月に1回1,000ユーロ購入する方が管理しやすいでしょう。こうすることで、UTXOの発生数を最小限に抑え、プライバシーを守りながらポートフォリオの管理を簡素化することができます。

ビットコインを統合する必要がある場合は、同じソースからのUTXOの統合を優先してください。例えば、プラットフォームAからの5つのUTXOとプラットフォームBからの5つのUTXOを混ぜるよりも、単一のプラットフォームからの10つのUTXOを統合する方がプライバシーへの影響は少なくなります。例えば、KYCで取得したUTXOは1つのトランザクションにまとめ、P2Pで取得したUTXOは別のトランザクションにまとめる。

いずれにせよ、統合は必然的にプライバシーの喪失につながることを忘れてはならない。したがって、リスクを考慮した上で、その必要性とプライバシーへの潜在的な影響を慎重に見極めましょう。

## その他のグッド・プラクティス

<chapterId>b5216965-7d13-4ea1-9b7c-e292966a487b</chapterId>

ビットコインでのプライバシーを最適化するのに役立つ、その他のベストプラクティスを一緒に探ってみましょう。

### コンプリート・ノット

自分のビットコインを個人的に保管することは良いことですが、自分の完全なノードを使用することはより良いことです！これが、ビットコインを完全に主権的に使用するためには、自分自身のノードを持つことが重要である理由です：


- 検閲への抵抗**：あなたの取引は誰にもブロックされません；
- 第三者からの独立性**：ブロックチェーンデータの検証を外部サービスに依存する必要がなくなります；
- 積極的な参加**：あなた自身の検証ルールを設定し、コンセンサスに直接参加することができます；
- ネットワークへの貢献**：ノードを運営することで、ビットコインネットワークの強化と分散に貢献できます；
- 技術教育**：フルノードを実行することは、ビットコインに関する技術的な知識を深めるのに最適な方法です。

これらの利点に加え、フルノードを使用することで、取引を送信する際のプライバシーも向上します。あなたがトランザクションを発行するとき、それはまずあなたの財布を通して作成され、署名されます。それをビットコインネットワーク上で送信するには、少なくとも1つのノードに知られている必要があります。自分のノードを使用することで、この送信を直接制御し、プライバシーを向上させ、データ損失のリスクを抑えることができます。

![BTC204](assets/fr/099.webp)

自分のビットコインノードを持っていない場合、ウォレットソフトウェアプロバイダーが提供するような第三者のノードを使用せざるを得なくなります。トランザクションの送信に加えて、ウォレットは保留中のトランザクション、アドレスに関連付けられた残高、またはトランザクションの確認数などの様々な情報にアクセスする必要があります。これらのデータにアクセスするには、ノードに問い合わせる必要があります。

![BTC204](assets/fr/100.webp)

自分のビットコインノードを使用しない場合の主なリスクは、サードパーティのノードオペレータがブロックチェーン上のあなたの活動を観察したり、この情報を他のエンティティと共有したりする可能性があることです。このリスクを制限するための中間的な解決策は、Tor経由で接続をマスクできるウォレットソフトウェアを使用することです。これにより、あなたのデータの露出を減らすことができる。しかし、最適な解決策は、自分自身のビットコインノードを持ち、それを使ってトランザクションを送信することに変わりはない。もちろん、自分のノードから情報が漏れないようにする必要もあるが、それは次のセクションで検討する別のトピックである。

自分の完全なノードを持つことは、プライバシーに対する明らかな利点に加え、ブロックチェーン上のデータの信頼性を保証し、検閲から保護し、ビットコインの統治に積極的に参加することを可能にします。自分のノードを使用することで、選択したブロックチェーンに経済的な重みを貢献することができ、これは、例えば2015年から2017年にかけてのブロックサイズ戦争のようなコミュニティ内の紛争の際に重要です。フォークが発生した場合、第三者のノードを使用すると、ノード運営者があなたの代わりに選択を行うため、あなたが支持したくないチェーンを支持することになりかねません。プライバシーの観点からも、より一般的な個人主権の観点からも、自分自身のノードをフル稼働させ、使用することが不可欠であることはご理解いただけるだろう！

### 欺く分析ヒューリスティック

より一般的に言えば、前節で述べたヒューリスティックを理解することは、ヒューリスティックを上手に避けたり欺いたりするために重要である。多くのベストプラクティスを採用することは、たとえそれが必須でないとしても、有益であることがわかります。これらのベストプラクティスは、ビットコインを使用する際にプライバシーを適切に維持するために重要な、追加の保護レイヤーを提供します。

最初のアドバイスは、最も密集した群衆の中に溶け込むことだ。ビットコインでは、これは最も広く採用されているスクリプトテンプレートを使用することを意味する。例えば、マルチシグSegWit V0構成によく使用されるP2WSHスクリプトは非常にまれです。これらのスクリプトでは、匿名性の高い大規模なセットに隠れることはできません。P2PKHやP2SHのような古いモデルも同様です。これらはUTXOセットには広く存在しますが、新しい取引ではあまり使われなくなっています。

一般的に、十分に採用されている限り、最新のスクリプト標準に移行する方が安全である。したがって、2022年には、P2TR（Taproot）の採用率が低いため、P2TRの使用は控えた方がよいとアドバイスしたはずですが、2024年には、P2TRを使用するトランザクションの数が非常に大きな割合を占め始めているため、このタイプのスクリプトを選択するか、それができなければ、SegWit V0スクリプトを選択することをお勧めします。

出典：[txstats.com](https://txstats.com/d/000000054/utxo-set-repartition-by-output-type)

プライバシーを守るためのもう一つのヒントは、内部トランザクションのヒューリスティックスを回避しようとすることである。例えば、あなたが支払いをするとき、丸い金額で出力を作成するのを避けようとするかもしれません。100kサトシを友人に送る必要がある場合、このヒューリスティックから逃れるために、少し高い金額を送金することを検討する。同様に、支払いに比べて不釣り合いなほど高額な残余のアウトプットを作成しないようにしましょう。

最後に、ビットコインの取引を定期的に行う場合は、常に同じ時間に送信しないようにしてください。トランザクションの送信を一日中、一週間を通して分散させることで、外部のオブザーバーにタイムゾーンに基づく時間パターンを検出する能力を与えず、分析を向上させることができます。

日常的に採用すべきこれらのベストプラクティスに加え、ビットコインのトレーサビリティを完全に破壊するさらに効果的な方法があります。これにはもちろんコインジョイント取引も含まれます。

# Coinjoinトランザクションを理解する

<partId>6d0bbf16-3714-4db1-9897-2d45019f6bdc</partId>

## Coinjoin取引とは何ですか？

<chapterId>0862bc6b-1c48-4aa4-b76d-4f547b469008</chapterId>

プライバシー保護の基本を学んだので、次はあなたのプライバシーを積極的に守ること、特にビットコインの履歴を関連付けないことを目的とした、より洗練されたテクニックについて説明します。次のパートでは、多くの小さなテクニックを探りますが、まずcoinjoinについてお話したいと思います。

Coinjoinは、ビットコインユーザーのプライバシーを保護する最も効果的な方法と考えられています。しかし、コインジョイント取引とは一体何なのでしょうか？一緒に調べてみましょう。

### Coinjoinの基本原則

coinjoinはブロックチェーン上のビットコインの追跡を破壊する技術である。これは、coinjoin取引という同名の特定の構造を持つ共同取引に基づいている。

このトレーニングの最初の部分で見たように、ビットコイン上の取引は、そのノードを介してすべてのユーザーに知られている。したがって、各コインの電子署名チェーンを検証し、その履歴を観察することは容易である。これは、すべてのユーザーが他のユーザーの取引を分析しようと試みることができることを意味する。その結果、取引レベルでの匿名性は不可能となる。しかし、個人の識別レベルでは匿名性が保たれる。各口座が個人のIDにリンクされている従来のバンキングとは異なり、ビットコインでは、資金は暗号キーペア（またはスクリプト）と関連付けられているため、暗号識別子の背後にある仮名性の一形態をユーザーに提供する。

![BTC204](assets/it/51/01.webp)

したがって、外部の監視者が特定のUTXOを特定ユーザーと関連付けることができるようになると、ビットコインの機密性が損なわれる。この関連付けが確立されると、そのユーザーの取引を追跡し、ビットコインの履歴を分析することが可能になる。Coinjoinはまさに、取引レベルでビットコインユーザーにある程度の機密性を提供するために、UTXOの追跡を妨害するために開発された技術である。

コイン結合は、外部のオブザーバーによるチェーン分析を複雑にすることで、ビットコインユーザーの機密性を向上させる。その構造は、異なるユーザーからの複数のコインを単一のトランザクションにマージすることを可能にするため、トレースを難読化し、入力アドレスと出力アドレスの間のリンクを決定することを困難にする。

コインジョイント取引の目的は、コインの履歴を破壊することであることを理解することが重要である。このテクニックは、永久的な匿名性を付与したり、ビットコインのトレーサビリティを永久的に停止したりするものではありません。Coinjoinの目的は、Coinjoin取引が実行された時点で履歴を中断させることだけである。しかし、この取引の前も後も、コインは同じプライバシーリスクにさらされたままである。

![BTC204](assets/fr/104.webp)

### コインジョイントはどのように機能するのか？

coinjoinの原理は協調的なアプローチに基づいている：自分のビットコインを混ぜたい複数のユーザーが、同じトランザクションのインプットに同じ金額を入金する。その後、これらの金額は各ユーザーに等しい価値の出力で再分配される。

![BTC204](assets/fr/105.webp)

トランザクションが終了すると、特定の出力と既知のユーザー入力を関連付けることは不可能になる。インプットとアウトプットの間に直接的なリンクがないため、ユーザーとそのUTXOの関連付けが崩れ、各コインの履歴も崩れる。

![BTC204](assets/fr/106.webp)

アリスの例を見てみよう。彼女は妹のイヴの誕生日に約10万サトシ（sats）を送りたい。しかし、アリスはイヴに自分の取引履歴を追跡されたくない。なぜなら、自分が何枚のビットコインを所有しているか、どうやって入手したかを明かしたくないからだ。そのため、アリスはコインジョイン取引でUTXOの履歴を破壊することにした。彼女はBob、Charles、David、Frankと共同取引を行うように手配する：Alice、Bob、Charles、David、Frankはそれぞれ105,000 satsのUTXO（マイニング手数料として5,000 satsを含む）を取引のインプットとして誓約する：

![BTC204](assets/fr/107.webp)


- これらの入力を使用する見返りとして、それぞれが新しいアドレスを生成し、それぞれ10万サットの5つの同一の出力を作成する。各参加者は1つの出力を取り出す：

![BTC204](assets/fr/108.webp)


- アリスは結局、履歴が混在している100,000 satのUTXOを手に入れた。彼女はこのUTXOを新たな取引に使用し、Eveの誕生日にその金額を送る：

![BTC204](assets/fr/109.webp)


- Eveがこの取引を分析して情報を引き出そうとすると、Alice、Bob、Charles、David、Frankが関与するcoinjoin取引に行き当たる。金額が一様であるため、イヴはそれぞれの入力が誰のものかを区別することができず、アリスのUTXOの履歴をたどることも、妹が何ビットコインを所有しているか、どのように入手したかを特定することもできない：

![BTC204](assets/fr/110.webp)

このシナリオでは、アリスはコイン結合技術を使い、後方分析に対するプライバシーを高めた。実際、AliceはEveがUTXOの履歴を遡るために特定のトランザクションから始める可能性のある分析から自分自身を守っている。現在から過去への分析に対するこの保護は、我々がretrospective anonsetと呼ぶものである。この概念については、このパートの最後の章で詳しく説明する。

しかし、コイン結合は過去から現在への分析、いわゆるプロスペクティブ・アノンセットに対するプライバシーを改善する可能性も提供する。アリスがイヴの誕生日に98,000サットを送った例に戻ろう。ここで、プライバシーを心配しているのはイヴだと想像してみよう。実際、アリスはイブに送ったコインをたどって情報を集めたいと思うかもしれない。イヴはこの新しく受け取ったUTXOを他の全てのUTXOと統合することができ、それによってアリスが自分のウォレットに保有しているビットコインの量がバレてしまうかもしれない。これを避けるために、Eveは新しく受け取ったコインの履歴を破壊することもできます。


- イブ、グレース、マロリー、オスカー、ビクターはそれぞれ98,000サットのUTXOをビットコイン取引に投入した：

![BTC204](assets/fr/111.webp)


- これらの入力を使用する代わりに、それぞれが新しいアドレスを提供し、完全に等しい97,500サットずつの5つの出力を作成する。各ユーザーは1つの出力を取得する：

![BTC204](assets/fr/112.webp)


- イヴは現在、97,500サットのUTXOを保持している。彼女は将来の取引に心配することなくそれを使うことができる。実際、アリスがイヴに送ったビットコインを追跡しようとすると、コインジョイン取引に出くわすだろう。アリスはイヴがどのUTXOアウトプットに属するか判断できない。分析が不可能になる：

![BTC204](assets/fr/113.webp)

最初の例では、coinjoin がコインのプライバシーをそのコインの過去との関係でどのように保護できるか、そして、2 番目の例では、coinjoin がコインの歴史をそのコインの未来との関係でどのように保護できるかを見ました。これが、coinjoinをコインの履歴を双方向に分割する一度限りのイベントと見なすべきだと述べた理由です：

![BTC204](assets/fr/104.webp)

### ミキシング、コインジョイント、ミキサー...。その違いとは？

ミキシング（mixing）」という用語がコインジョイントを表現するのに使われることがあるが、この用語を拒否するビットコイナーがいるのは、カストディアル・ミキサーとの混同を恐れているからである。しかし、数学的な文脈では、コインジョイントはまさにミキシングの概念を体現しているので、この懸念は根拠のないものだと私は思う。

一般的な数学の分野では、混合とは、ある時間後に、初期空間のすべての部分が理論的に他の部分と混合されうる力学系の性質を指す。混合とは、粒子の位置や系の状態が、将来の分布が初期分布に依存しないように進化し、初期状態の特性が系の空間内に一様に分布する状態になることを意味する。これはまさに、ビットコインによるコインジョイントで起こることである。つまり、私の考えでは、コインジョイントとは、まさにコインの混合方法なのである。

![BTC204](assets/fr/114.webp)

しかし、コインジョイントとミキサーを区別することは重要である。ミキサーとは、ユーザーがビットコインを送信して混合するサービスである。これらのサービスは2010年代には人気があったが、coinjoinと比較して2つの大きな欠点があるため、その利用は減少している：


- これらの銀行では、利用者がミキシングの過程で資金の保管を放棄する必要があり、盗難のリスクにさらされている；
- ミキサーが取引の詳細を記録しないという保証はないし、この情報をブロックチェーン分析会社に売ることもない。

![BTC204](assets/fr/115.webp)

そのため今日、ユーザーはコインジョイントを好んで利用している。coinjoinの参加者は、他の関係者にビットコインを盗まれるリスクを負うことはない。次の章では、これがどのようにして可能なのかを一緒に探ってみよう。

## ゼロリンクとチャウミアンのコインジョイント

<chapterId>326c9654-b359-4906-b23d-d6518dd5dc3e</chapterId>

コインジョインによって提供されるプライバシーは、我々のピースが隠されているグループのサイズに基づいている。したがって、できるだけ多くの参加者を見つける必要がある。独立に見つけたユーザーを使って、手動でコインジョインを実行することは十分可能だが、この方法は複雑で、大規模なアノセットを使用することはできない。

このため、ビットコインではコインジョイン・コーディネーターが発達した。彼らの役割は、異なるユーザーをつなぎ、共同取引を成功させるために必要な情報を送信することである。

![BTC204](assets/fr/116.webp)

しかし、コーディネータが利用者のビットコインを管理することがないようにするにはどうすればよいでしょうか。また、コーディネータはcoinjoinトランザクションを構築する人ですが、利用者のインプットとアウトプットを結びつけることができず、プライバシーが損なわれる可能性があることをどう保証すればよいでしょうか。

### チャウムのブラインドサイン

最近のコイン結合の実装では、情報漏洩を防ぐためにDavid Chaumのブラインド署名が使われている。このブラインド署名がどのように機能するのか、早速一緒に勉強してみよう。

Chaumブラインド署名は、署名発行者が署名するメッセージの内容を知らないデジタル署名の一形態である。しかし、署名は後で元のメッセージで検証することができる。この技法は1983年に暗号技術者のDavid Chaumによって開発された。

契約書などの機密文書を、その内容を明らかにすることなく認証したいと考える企業を例にとってみよう。この企業は、元の文書を可逆的な方法で暗号的に変換するマスキング・プロセスを適用する。この変更された文書は認証局に送られ、認証局は基本的な内容を知ることなくブラインド署名を適用する。署名された文書を受け取った後、企業は署名からマスキングを取り除く。その結果、認証局は元のコンテンツを見ることなく、認証局の署名によって認証された元の文書ができあがる。

Chaumのブラインド署名は、このように、文書の内容を知らなくても文書の真正性を証明することができ、ユーザーのデータの機密性と署名された文書の完全性の両方を保証する。

### チャウミアン・コインジョイン

Chaumian CoinJoins "では、TorとDavid Chaumのブラインド署名を組み合わせることで、コーディネータが各アウトプットがどのユーザのものかを知ることができないようにしている。コインジョイントトランザクションの構築プロセスは、入力登録、出力登録、トランザクション署名の3つの主要なステップから構成される。コインジョイン参加者の一人であるアリスの例でこのプロセスを検証してみよう。他の参加者はアリスと同じステップを各自で踏む。

**ステップ1：入力の登録**。


- アリスはトランザクションの入力として使いたいUTXOと、ビットコインを受け取るために出力として使いたいマスクされた受信アドレスをコーディネータに送る。したがって、コーディネータはアリスのアドレスを知ることができない。コーディネータが見るのは彼女のマスクされたバージョンだけである。
- コーディネータは入力の正当性を検証し、アリスの秘密鍵でアリスの マスクされたアドレスに署名する。そしてアリスにブラインド署名を送る。

**ステップ2: 録音出力.**.


- アリスはコーディネーターの秘密鍵で署名されたアドレスから仮装を外すことができる。彼女は別のTor IDで新しい接続を確立する。コーディネーターはこの新しいIDで接続しているのがアリスであることを識別できない。
- アリスは偽装されていないアドレスと署名をコーディネーターに送る（コーディネーターはまだそれがアリスであることを知らない）。

**ステップ3：取引に署名する。


- コーディネータも同様に、すべての参加者からマスクされていない出力を取得する。関連する署名により、コーディネータは匿名で送信された各アウトプットが実際に自分の秘密鍵で署名されたものであることを確認し、その正当性を保証することができる。その後、コインジョイントトランザクションを作成し、参加者に送信して署名してもらう。
- アリスは他の参加者と同じように、自分の入力と出力がコーディネー ターが構築したトランザクションに正しく含まれていることを検証する。すべてが満足のいくものであれば、Aliceは自分の入力のスクリプトをアンロックする署名をコーディネータに送る。
- coinjoinの参加者全員から署名を集めた後、コーディネーターはトランザクションをビットコインネットワーク上に送信し、ブロックに追加できるようにする。

このシステムでは、コーディネーターは入力を特定の出力に結びつけることができない。さらに、参加者のUTXOのロックを解除するために必要な秘密鍵にアクセスすることもできないため、参加者の資金を所有することもできない。プロセス全体を通して、そしてステップ3の終わりまで、彼は署名に アクセスすることすらできない。アリスと他の参加者がグローバルトランザクションに署名し、すべてが正しいことを確認した後、コーディネータはこのトランザクションを無効にすることなく、出力を含め、このトランザクションを変更することができなくなる。こうしてコーディネーターによるビットコインの盗難を防ぐことができる。

最終的に、コインジョイン・ユーザーは、自分のアウトプットを取引に登録する際、選挙で投票する市民のような保証を望む。こうした行動には、公的な側面と私的な側面の二面性がある。一方では、非公開にしたいことがある。有権者にとっては、自分の投票用紙と自分のIDがリンクされることを避けたいし、coinjoinユーザーにとっては、自分の出力と自分の入力が関連付けられることを避けたい。実際、コーディネータやその他の関係者が入力と出力のリンクを確立することに成功すれば、coinjoinはその目的をすべて失うことになる。先に説明したように、コインジョイントはコインの履歴の切れ目として機能しなければならない。この休止は、コインジョイントの取引において、特定のインプットと特定のアウトプットを関連付けること（プロスペクティブ・アノンセット）、およびその逆（レトロスペクティブ・アノンセット）ができないために正確に発生する。

同様に、コインジョインのユーザーは、コインジョイン取引に自分のアウトプットが含まれていることを確認したい。実際、coinjoinの参加者は、取引に署名する前に自分のアウトプットの存在を確認できることが絶対に必要である。

デビッド・チャウムのブラインド署名を使用することで、まさにこの2つのパブリックとプライベートの側面が可能になり、チャウムのコインジョイン参加者は、ビットコインが盗まれることはなく、資金を追跡されることもないと確信できる。

### コインジョイントのコンセプトを考案したのは誰ですか？

誰が最初にビットコインにcoinjoinのアイデアを導入したのか、そして誰がこの文脈でDavid Chaumのブラインド署名を使用するアイデアを思いついたのかを確実に判断することは難しい。2013年のBitcoinTalkへの投稿](https://bitcointalk.org/index.php?topic=279249.0)で最初に言及したのはグレゴリー・マクスウェルだと考えられることが多い：

Chaumのブラインド署名を使用：サーバーはトークンに署名してユーザーに返す。サーバーはトークンに署名し、ユーザーに返却する。ユーザーは匿名で再接続し、出力アドレスを公開し、サーバーに送り返す。サーバーは、すべての出力がサーバーによって署名され、その結果、すべての出力が有効な参加者からのものであることを確認できる。その後、人々は再接続し、署名する。

Maxwell, G. (2013, 8月 22)._CoinJoin：Bitcoin's privacy for the real world_.ビットコイン・トーク・フォーラム https://bitcointalk.org/index.php?topic=279249.0

しかし、ミキシングとコインジョイントの文脈における Chaum signature の両方についての言及は以前にもあった。[2011年6月、Duncan TownsendはBitcoinTalk](https://bitcointalk.org/index.php?topic=12751.0)で、現代のChaumiansのコインジョイントとよく似た方法でChaum署名を使用するミキサーを発表しました。

同じスレッドに、彼のミキサーを改良するための[ダンカン・タウンゼントに対するハッシュコインメッセージ](https://bitcointalk.org/index.php?topic=12751.msg315793#msg315793)がある。このメッセージで説明されているプロセスは、まさにコインジョイントに最も近いものを表している。同様のシステムは、[2012年のAlex Mizrahiからのメッセージ](https://gist.github.com/killerstorm/6f843e1d3ffc38191aebca67d483bd88#file-laundry)でも言及されている。彼はTenebrixのクリエイターにアドバイスしており、このTenebrixは後にLitecoinを生み出す基礎となった最初のアルトコインの1つである。コインジョイント」という言葉自体も、グレッグ・マクスウェルが発明したものではなく、ピーター・トッドのアイデアから生まれたものだ。

![BTC204](assets/fr/125.webp)

### ゼロリンク

Zerolinkは、Chaumianiコイン結合と、様々な形態のチェーン分析からユーザーの匿名性を保護する様々な戦略を統合し、ウォレット管理に関連するエラーを大幅に削減する包括的な混合プロトコルです。このプロトコルは[2017年にnopara73とTDevDによって導入された](https://github.com/nopara73/ZeroLink/blob/master/README.md)。

![BTC204](assets/fr/126.webp)

その名が示すように、ゼロリンクの原理は、インプットとアウトプットの間のリンクをたどることができないようにコインジョイン取引を行うことである。この機能は、すべてのアウトプットが完全に同一金額であることを保証することによって達成される。

![BTC204](assets/fr/127.webp)

Zerolinkによる重要な予防措置は、別々の暗号鍵セット、あるいは別々のウォレットを使用して、未混合のUTXOと混合のUTXOを完全に分離することである。この方法で、混合前のコイン用の "混合前 "ウォレットは、混合後のコイン用の "混合後 "ウォレットと区別されます。

![BTC204](assets/fr/128.webp)

このUTXOの厳格な分離は、主に混合UTXOと非混合UTXOの偶発的な関連付けを防ぐために機能する。実際、このようなリンクが発生すると、混合UTXOのcoinjoinの有効性がユーザーの知らないうちに無効になり、履歴が破壊されたと思われたUTXOの機密性が損なわれる。このようなリンクは、ミックスされたUTXOをミックスされていないUTXOでセキュアにするためのアドレス再利用、またはユーザーがミックスされたUTXOとミックスされていないUTXOを同じトランザクションの入力として消費する場合、共通入力所有ヒューリスティック（CIOH）を適用することで発生する可能性がある。混合前のポートフォリオと混合後のポートフォリオを分離することで、このような偶発的な関連付けが回避され、ユーザーは意図しないエラーから保護される。

![BTC204](assets/fr/129.webp)

この分離は、ポートフォリオソフトのレベルで、プレミキシングポートフォリオとポストミキシングポート フォリオの間で異なるルールを適用する可能性も提供する。例えば、ポストミキシングポートフォリオでは、ユーザーアノンセットを損なうようなCIOHの適用を防ぐために、ソフトウェアは入力UTXOのマージを禁止することができる。また、ウォレットフィンガープリントによる識別を防止するために、スクリプトやトランザクショ ンオプション（例えば RBF シグナリングなど）の使用を標準化することも可能である。

現在、WhirlpoolはZerolinkプロトコルを厳密に実行する唯一のcoinjoin実装です。次の章では、様々な既存のコインジョイント実装と、それぞれの利点と欠点を探ります。

## コイン結合の実装

<chapterId>e37ed073-9498-4e4f-820b-30951e829596</chapterId>

2024年、ビットコインでコインジョイントを実行したいユーザーが利用できるツールに大きな変化が見られます。現在、私たちは重要な時期にあり、コインジョイント市場は大規模な再編が行われています。したがって、この章は時間の経過とともに更新される可能性が高い。

今のところ、ビットコインには主に3つの異なるcoinjoinの実装がある：


- ワールプール
- ワビサビ；
- ジョインマーケット

これらの実装はいずれも、コインジョイントランザクションを通じてUTXOの歴史を断ち切ることを目的としている。しかし、その仕組みは大きく異なる。したがって、自分のニーズに最も適したオプションを選択するためには、それぞれの仕組みを理解することが不可欠である。

### ジョインマーケット

2015年にアダム・ギブソンとクリス・ベルチャーによって創設されたJoinMarketが他のコインジョイントの実装と異なるのは、そのユニークなユーザー・マッチング・モデルである。このシステムはP2P交換マーケットプレイスに基づいており、「メイカー」と呼ばれる一部のユーザーは自分のビットコインをミキシングに利用できるようにし、「テイカー」と呼ばれる他のユーザーは手数料と引き換えにこれらの資金を使ってコインジョイントを実行する。

![BTC204](assets/fr/130.webp)

このモデルでは、「メーカー」は自分のビットコインを「テイカー」に提供し、その対価として手数料を受け取る。一方、「テイカー」は、「メイカー」のビットコインを使用してコインジョイン取引を行うために手数料を支払う。サービス料は役割によって異なり、「メイカー」は流動性の提供に対して手数料を積み立て、「テイカー」は手数料を支払う。この市場は利用条件なしに自由に運営されている。

JoinMarketの主な欠点はその複雑な使用方法であり、効果的に利用するには端末にある程度精通している必要がある。この複雑さは経験豊富なユーザーにとっては障害にはならないが、一般ユーザーのアクセスを制限する可能性がある。しかし、最近JAMと呼ばれるウェブ・インターフェースが導入されたことで、利用がいくらか容易になった。

![BTC204](assets/fr/131.webp)

ソース[JAM](https://github.com/joinmarket-webui/jam/blob/devel/docs/assets/screenshot-dark.webp)

しかし、技術的な障壁は依然として大きな障害となっている。参加者の数によって機密性が高まるコインジョイン・エコシステムでは、アクセシビリティを低下させる制限は利用可能な流動性に直接影響する。金融取引においてすでにニッチな存在であるビットコインは、コインジョイントの利用をサブニッチとみなしており、JoinMarketはさらに特化した一部であるため、ユーザーのアノンセットを増やす可能性が制限されている。

JoinMarketはコインジョインのための革新的なP2Pマッチングモデルであるにもかかわらず、特にトランザクション構造の面で大きな欠点がある。Whirlpoolのような他の実装とは異なり、JoinMarketはアウトプット間の完全な平等性を保証しておらず、インプットとアウトプットの間に決定論的なリンクが引かれる可能性がある。また、すでに混合されたコインが再び混合されるのを防ぐツールも欠けており、ユーザーが求める機密性を損なう可能性がある。最後に、JoinMarketのコンセプトは、特にダイナミックな流動性市場に興味がある人にとっては魅力的ですが、その構造的な弱点と技術的な複雑さによって、コインジョイントの実装を求める初心者にも専門家にも魅力的でないと私は思います。

### ワビサビ

Wabisabiはcoinjoinの別の実装であり、トランザクションの調整を一元化するアプローチである。このモデルは2021年にÁdám Ficsór（nopara73）、Yuval Kogman、Lucas Ontivero、István András Seresによって設計され、翌年にWasabi 2.0ソフトウェアに統合された。ワビサビはまさに、2018年に発売されたワサビ・ソフトウェアのコインジョイン・モデルを進化させたものである。

2010年代後半、WasabiはWhirlpoolとは根本的に異なるトランザクション構造をコインジョイントに採用した。参加者の匿名性を高めるため、Wasabiは数十人の参加者をグループ化した非常に大規模なコインジョイント取引を採用した。これとは対照的に、Whirlpoolは複数の小さなトランザクションを選択し、サイクルごとに指数関数的にアノンを増やすことを可能にした。

余りの処理方法も2つの実装を区別した。Whirlpoolでは、余りはTX0によってコインジョインサイクルの前にUTXOから除外され分離された。一方、Wasabiでは、余りはコインジョイントランザクションの出力の1つを形成し、いくつかの入力と出力の間の決定論的なリンクを維持した。

Wabisabiにより、Wasabiのバージョン2.0はWhirlpoolのコイン結合のアプローチに近づいた。コインジョイントランザクションは依然として非常に大きいが、Whirlpoolのモデルを踏襲し、複数のラウンドを連鎖させることが可能になった。ワビサビ1.0では、お釣りはユーザーの入力に直接リンクされていたが、ワビサビでは、お釣りをいくつかの少額に分割し、すべての参加者に等しい額面で分配するようにした。

2人のユーザーだけの単純化した例で説明しよう：アリスは115,000サットを、ボブは210,000サットを混合したい。手数料を無視すると、Wasabi 1.0では、コインジョイン取引は100,000サットの3つの出力に加え、Aliceには15,000サットの残りを1つ、Bobには10,000サットの残りを1つ生成することになる。余りの出力は常に入力にリンクされている：

ワビサビでは、同じ取引で10万サットのアウトプットが3回、5000サットのアウトプットが5回発生する：

個人的には、ワビサビにおけるチェンジ・マネジメントには、プライバシーの面でその有効性を損ないかねないいくつかのリスクがあると考えている：


- あるユーザーが他の参加者よりもかなり大きなUTXOを提供した場合、必然的にそのユーザーは自分の入力にリンクされた量の変化を持つことになる。これは、識別可能な変化をなくすことを目的としたプロトコルの最初の目標に反する；
- 残りの部分を細分化するために呼称を増殖させることは、逆説的にミキシング効率を損なう可能性がある。このプロセスは、特定のアウトプットが識別しやすくなるため、アノンセットの減少につながる可能性がある；
- この方法はまた、ユーザーにとって管理上の問題となる価値の低いUTXOを生成する。このような小さなUTXOは、その価値に比して使用するコストが高くなりすぎると、"塵 "となる可能性がある。この現象により、ユーザーは将来の取引で複数の投入UTXOを統合するか、あるいはそれらを統合するよう促される。いずれの場合も、COHによって、得られるアノンセットが減少したり、最初のコイン結合で得られたプライバシーの利点が完全に打ち消されたりする可能性がある。

UTXOのプレミックスとポストミックスの厳格な分離を保証することでZeroLinkプロトコルを実装しているワールプールとは異なり、ワビサビはこの厳格な分離を維持していない。また、ワサビの一部の顧客によるアドレスの再利用が問題になっているが、これは明らかにユーザーにとって非常に有害である。

Wasabiのバージョン2.0では、新しいコインジョイント価格ポリシーが導入されました。0.01ビットコイン以上のUTXOの場合、調整手数料は0.3%に設定され、それ以下のUTXOの場合、これらの手数料は完全にゼロになります。さらに、これらの小さなUTXOのリミックスは無料ですが、リミックスを含むすべてのトランザクションのマイニング手数料は残っています。

このポリシーは、取得したアノンセットのサイズに関係なく手数料が固定されたままであるWhirlpoolのポリシーとは対照的である。Wasabi 2.0では、小さなUTXOの場合、コーディネーターの手数料はゼロにリセットされるが、ユーザーはリミックスを含むすべての取引でマイニング手数料を支払う必要がある。

本稿執筆時点で、最近の出来事の結果、ワビサビの利用はかなり複雑になっている。実際、Samourai Walletの創設者が逮捕された後、Wasabiの開発に資金を提供し管理しているzkSNACKs社は、2024年6月1日にcoinjoinのコーディネートサービスを終了すると発表した。このコーディネータはデフォルトでWasabiに設定されており、流動性の大部分を持っていた。

このメイン・コーディネーターの閉鎖に伴い、ユーザーは新しい独立したコーディネーターに接続しなければならなくなった。この変更には懸念がある。一方では、新しいコーディネーターの流動性が十分でない可能性があり、プライバシーの面でコイン結合の有効性が低下する。一方では、悪意のあるコーディネーターに遭遇するリスクもある。このような状況は、ワビサビを利用しようとする人々にとって重大な新たなリスクを追加することになる。

技術的な問題に加え、Wasabiを運営するzkSNACKs社がブロックチェーン分析会社のサービスを利用してコインジョイントへの参加者をフィルタリングするという決定は、倫理的かつ戦略的に重大な問題を提起している。当初のアイデアは、犯罪者によるWasabiでのコインジョイントの利用を防ぐことであり、合法的に見えるかもしれない。しかし、これはパラドックスを引き起こす。ユーザーのプライバシーを高めることを主な使命とするコーディネーターに手数料を支払い、同じプライバシーを侵害することを目的とする企業に資金を提供するだけなのだ。

さらに厄介なのはフィルタリングの原則で、オープンで検閲のない金融システムを提供するというビットコインの理念とは大きく対照的だ。犯罪行為を排除したいと考えるのは正当化されるように思えるかもしれないが、このフィルタリングは、文脈によっては違法行為に分類されるものの、道徳的に正当化されたり、社会的に有益であったりする可能性のある個人を標的にする可能性もある。エドワード・スノーデンの例は、この二律背反を見事に示している。彼の暴露により、一部の政府からは犯罪者とみなされ、他の政府からは公益のために行動した内部告発者とみなされている。この複雑さは、フィルタリングの潜在的な危険性を浮き彫りにしている。フィルタリングは善意で始まったものの、最終的には合法的なユーザーの権利とセキュリティを害する可能性があるのだ。ある種の権威主義体制下で迫害されている活動家やジャーナリストについても言及することができた。お察しの通り、私の好みは間違いなくビットコインでコインジョイントを行うためのワールプールモデルである。このシステムはその厳格さで際立っており、プライバシーの面で優れた保証を提供している。また、数学的な文脈で完璧とみなされる混合を提案する唯一のものでもある。私の意見では、このモデルはビットコインにおけるコインジョイントの未来を象徴しています。したがって、次の章でこのモデルをより深く探求していただきたい。

## ワールプールの運営

<chapterId>bdbd7109-e36d-4b4f-a3c6-928df4e9bfda</chapterId>

Whirlpoolは「_ZeroLink_」トランザクションを使用することで、他のコインジョイント方式とは異なり、すべてのインプットとすべてのアウトプットの間に技術的に可能な限りのつながりがないことを保証します。この完全な混合は、各参加者が（マイニング手数料を除いて）同量のインプットを提供する構造によって達成され、その結果、完全に同量のアウトプットが生成されます。

インプットに関するこのような制限的なアプローチにより、Whirlpoolのコインジョイン取引には、インプットとアウトプットの間に決定論的なリンクが全くないというユニークな特徴が与えられている。すなわち、インプットとアウトプットの間に決定論的なリンクがまったくないということである。言い換えれば、各アウトプットは、取引における他のすべてのアウトプットと相対的に、どの参加者にも帰属する確率が等しいということである。

![BTC204](assets/fr/136.webp)

### ワールプールの一般的な操作

当初、各Whirlpoolコインジョイントの参加者数は5人に制限され、新規参入者が2人、リミキサーが3人だった（これらの概念については後で説明する）。しかし、2023年に観察されたオンチェーン取引の手数料の増加により、Samourai氏のチームはコストを削減しながらプライバシーを向上させるためにモデルを見直すことになった。そこで、手数料市場の状況と参加者数を考慮し、コーディネーターは6人、7人、8人の参加者を含むコインジョインを開催できるようになった。これらの強化されたセッションは、"_Surge Cycles_"という名前で指定されている。重要なのは、どのような構成であっても、Whirlpoolのコインジョイントでは常に2人しか新規参加者がいないということである。

したがって、ワールプールの取引は、同一の数の入力と出力によって特徴付けられる：


- 5入力5出力；

![BTC204](assets/fr/137.webp)


- 6入力6出力；

![BTC204](assets/fr/138.webp)


- 7入力7出力；

![BTC204](assets/fr/139.webp)


- 8入力8出力。

![BTC204](assets/fr/140.webp)

このように、Whirlpoolの提案するモデルは、小規模なコインジョイン取引に基づいている。WabisabiやJoinMarketでは、アノンセットの堅牢性は1サイクル（または数サイクル）の参加者の量に基づいているが、Whirlpoolは複数の小さなサイクルの連結に依存している。このモデルでは、ユーザーはプールへの最初の参加時にのみコストを負担し、追加コストなしで多数のリミックスに参加することができる。リミキサーの採掘コストをカバーするのは新規参入者である。

コインが参加するコインジョイントが増えるたびに、そのコインが過去に出会った仲間とともに、アノネットは指数関数的に増えていきます。つまり、このような無料のリミックスを利用することが目標であり、リミックスが発生するたびに、各コインミックスに関連するアノネットの密度が強化されます。

ワールプールは、2つの重要な要件を念頭に置いて設計された：


- Samourai Walletは主にスマートフォンのアプリケーションであるため、モバイル機器への実装が容易である；
- リミックスサイクルのスピードは、アノセットの大幅な増加を促す。

サムライ・ウォレットの開発者は、このような要請を指針としてWhirlpoolを設計し、サイクルごとの参加者数を制限した。参加者が少なすぎればcoinjoinの有効性が損なわれ、各サイクルで生成されるアノンセットが激減し、参加者が多すぎればモバイルアプリケーションの管理に問題が生じ、サイクルの流れが阻害されることになる。

結局のところ、Whirlpoolでコインジョインするために参加者の数が多い必要はない。なぜなら、アノネットはいくつかのコインジョインサイクルの積み重ねで実現されるからである。ここで最も重要な原則は、すべての参加者のUTXOが均質であることである。これにより、完璧なミックスが可能になり、ミキシングとリミキシングサイクルの恩恵を十分に受けることができるからである。

### コインジョイン・プールと料金

このような複数のサイクルで混合コインのアノンセットを効果的に増加させるためには、UTXOの使用量を制限する何らかの枠組みを確立しなければならない。そのため、Whirlpoolはいくつかのプールを定義している。

プールは、コインの完全な均質性を維持しながらコイン結合プロセスを最適化するために使用するUTXOの量に合意した、一緒に混合することを望むユーザーのグループを表します。各プールはUTXOの固定量を指定し、ユーザーが参加するためにはそれを満たす必要があります。したがって、Whirlpoolでコインジョイントを行うには、プールを選択する必要があります。現在利用可能なプールは以下の通り：


- 0.5ビットコイン；
- 0.05ビットコイン
- 0.01ビットコイン
- 0.001ビットコイン（＝100,000サット）。

あなたのビットコインでプールに参加することで、プールの他の参加者のビットコインと完全に同質のUTXOが生成されます。各プールには上限があるため、この上限を超える金額については、同じプールに2回に分けてエントリーするか、より大きな金額の別のプールに変更する必要があります：

| プール（ビットコイン）｜1エントリーあたりの上限額（ビットコイン

|----------------|----------------------------------------|



| 0,05 | 3,5 |

| 0,01 | 0,7 |



UTXOは、コインジョイントに組み込む準備ができた時点でプールに属するとみなされる。しかし、これはユーザーがその所有権を失うことを意味するものではありません。このパートの最初の章で見たように、さまざまな混合サイクルを通じて、ユーザーは自分の鍵、ひいてはビットコインを完全に管理し続けることができる。これがcoinjoin技術と他の中央集権的な混合技術との違いである。

coinjoinプールに参加するには、採掘料と同様にサービス料を支払う必要があります。サービス料は各プールごとに固定されており、Whirlpoolの開発とメンテナンスを担当するチームへの補償を目的としています。

Whirlpoolを利用するためのサービス料は、プールに入る際に一度だけ支払う必要があります。この手続きが完了すれば、追加料金なしで無制限にリミックスに参加することができます。各プールの現在の固定料金は以下の通りです：

| プール(ビットコイン)｜投入手数料(ビットコイン)

| -------------- | --------------------------------- |

| 0.5 | 0.0175 |

| 0.05 | 0.00175 |

| 0.01｜0.0005（5万サット

| 0.001｜0.00005（5,000サット

これらの手数料は、coinjoinに入力する金額に関係なく、基本的に選択したプールへの入場券として機能します。つまり、0.01 BTCのプールに0.01 BTCで入ろうが、0.5 BTCで入ろうが、手数料の絶対値は変わりません。

Whirlpoolのコインジョイントを行う前に、ユーザーは2つの戦略から選択することができる：


- サービス料を最小限に抑えるため、小規模のプールを選ぶ；
- あるいは、より大きなプールを好み、より価値の高いUTXOを少数獲得するために高い手数料を支払うことに同意する。

一般的に、コイン結合サイクルの後に、複数の混合UTXOをマージすることは推奨されない。これは、特に共通入力所有ヒューリスティック（CIOH: _Common-Input-Ownership-Heuristic_）のため、得られるプライバシーを損なう可能性があるからである。したがって、出力として小さな値のUTXOが多すぎることを避けるために、より大きなプールを選択することが賢明かもしれない。ユーザーは、これらのトレードオフを評価して、好みのプールを選択しなければならない。

サービス料金に加えて、ビットコイン取引に固有のマイニング料金も考慮する必要があります。Whirlpoolのユーザーとして、あなたは準備トランザクション（`Tx0`）と最初のコイン結合のためのものと同様にマイニング手数料を支払う必要があります。Whirlpoolの新規参入者に支払うモデルのため、それ以降のリミックスはすべて無料となります。

実際、それぞれのWhirlpool coinjoinでは、入力のうち2人のユーザーが新規参加者である。他のインプットはリミキサーからのものです。その結果、トランザクションの全参加者のマイニング手数料は、この2人の新規参加者によって賄われ、彼らもまた無料のリミックスから利益を得ることになります：

![BTC204](assets/it/54/07.webp)

この料金システムにより、Whirlpoolは他のコインジョイントの実装とは真に異なります。なぜなら、UTXOの匿名性はユーザーが支払った料金に比例しないからです。したがって、プールへの参加料と2つのトランザクション（Tx0とイニシャルミックス）の採掘手数料を支払うだけで、かなり高いレベルの匿名性を達成することができます。

ただし、`mix to`オプションを選択した場合は、追加トランザクションなしで、コインジョイントの出力として資金を直接受け取る外部アドレスを提供することができます。

### HDウォレットアカウント

Whirlpoolを通してコインジョイントを行うには、ウォレットは複数の別々のアカウントを生成する必要があります。これがZeroLinkプロトコルの原理です。HD (_Hierarchical Deterministic_)ウォレットのコンテキストでは、アカウントは他から完全に分離されたセクションを構成し、この分離はウォレット階層の3番目の深さ、すなわち`xpub`レベルで発生します。

![BTC204](assets/it/54/08.webp)

HDウォレットは理論上、最大`2^(32/2)`の異なるアカウントを導き出すことができる。初期アカウントはすべてのビットコインウォレットでデフォルトで使用され、`0'`インデックスに対応する。

ワールプールに適合したポートフォリオの場合、ゼロリンク・プロセスの要件を満たすために4つの口座が使用される：


- 0'`というインデックスで識別される**預金口座**；
- 2 147 483 644'`のインデックスで識別される**悪い銀行口座**（または「有害な取引所」）；
- 2 147 483 645'`というインデックスで識別される**プレミックスアカウント**；
- 2 147 483 646'`で識別される**ポストミックスアカウント**。

これらのアカウントはそれぞれ、コインジョイン・プロセスにおいて特定の機能を果たす。

これらのアカウントはすべて1つのシードにリンクされており、ユーザーはリカバリフレーズと必要に応じてパスフレーズを使用して、すべてのビットコインへのアクセスを回復することができます。ただし、この回復操作の間に、使用されたアカウントの異なるインデックスをソフトウェアに指定する必要がある。

では、これらのアカウントにおけるワールプールのコインジョイントのさまざまな段階を検証してみよう。

### TX0

Whirlpool coinjoinのスタート地点は**預金口座**です。この口座は新しいビットコインウォレットを作成する際に自動的に使用されます。この口座には、ミックスしたいビットコインが入金されている必要があります。

Tx0`はワールプールミキシングプロセスの最初のステップである。これはコインジョインのためのUTXOを準備し、均等化することを目的とし、選択されたプールの量に対応する単位に分割し、ミキシングの均質性を確保する。均等化されたUTXOは、**プレミックスアカウント**に送られます。プールに入ることができない差額については、**バッドバンク**（または「有毒な取引所」）という特定の口座に分けられます。

この最初のトランザクション`Tx0`は、coinjoinコーディネータに支払うサービス料の決済も兼ねている。後続のステップとは異なり、このトランザクションは共同作業ではないため、ユーザーはマイニング料金の全コストを負担しなければならない：

![BTC204](assets/it/54/09.webp)

この`Tx0`トランザクションの例では、私たちの**預金口座**からの`372 000 sats`の入力は、出力のいくつかのUTXOに分割され、それらは以下のように分配される：


- 100,000サッツのプールに入るためのサービス料として5,000サッツがコーディネーターに割り当てられる；
- 3つのUTXOがミキシングのために準備され、私たちの**premixアカウント**にリダイレクトされ、コーディネーターに登録されます。これらのUTXOはそれぞれ`108 000 sats`で均等化され、将来の初期ミックスの採掘料をカバーする；
- プールに入ることができない余剰金は、少なすぎるため、有毒交換とみなされる。これは特定の口座に送られる。ここでは、この交換は40,000サッツに相当する；
- 最後に、「Tx0」を確認するために必要な採掘料である「3,000サット」があるが、これはアウトプットを構成しない。

例えば、これは本物のTx0ワールプールです（私のものではありません）：[edef60744f539483d868caff49d4848e5cc6e805d6cdc8d0f9bdbbaedcb5fc46](https://mempool.space/fr/tx/edef60744f539483d868caff49d4848e5cc6e805d6cdc8d0f9bdbbaedcb5fc46)

![BTC204](assets/fr/145.webp)

### 有害な変化

プールに組み入れることができなかった余剰分（ここでは4万サッツに相当）は、ポートフォリオ内の他のUTXOから厳密に分離するために、「有害な交換」とも呼ばれる**バッドバンク**口座に振り向けられる。

このUTXOはユーザーのプライバシーにとって危険である。なぜなら、このUTXOはユーザーの過去にリンクされたままであり、その結果、所有者のアイデンティティにリンクされる可能性があるだけでなく、コインジョイントに参加したユーザーのものであるとマークされるからである。

![BTC204](assets/fr/146.webp)

このUTXOがシャッフルされた出力とマージされた場合、CIOH(_Common-Input-Ownership-Heuristic_)により、コイン結合サイクルで得られたすべてのプライバシーを失うことになります。もしそれが他の有毒な変更とマージされた場合、コインジョインサイクルの異なる入力がリンクされるため、ユーザーはプライバシーを失う危険性があります。そのため、注意して取り扱う必要があります。これらの有毒なUTXOの管理については、この章の最後のセクションで詳しく説明します。

### イニシャル・ミックス

Tx0`が完了すると、均等化されたUTXOはポートフォリオの**premix**アカウントに送られ、最初のコイン結合サイクル（"イニシャルミックス "とも呼ばれる）に導入される準備が整います。この例のように、`Tx0`がミキシングを目的とした複数のUTXOを生成した場合、それぞれのUTXOは別々のイニシャルミックスに統合されます。

これらの最初のミックスが終わると、**premix**アカウントは空になり、私たちのコインは、この最初のコイン結合のための採掘手数料を支払った後、選択したプールによって定義された金額で決済されます。この例では、最初のUTXOである`108,000 sats`はちょうど`100,000 sats`に減少します。

![BTC204](assets/fr/147.webp)

### リミックス

最初のミックスの後、UTXOは**postmix**アカウントに転送されます。このアカウントには、ミックス済みのUTXOとリミックス待ちのUTXOの両方が集められます。Whirlpoolクライアントがアクティブになると、**postmix**アカウントのUTXOは自動的にリミックス可能になり、これらの新しいラウンドに参加するためにランダムに選ばれます。

注意点として、リミックスは完全に無料です：追加のサービス料や採掘料は必要ありません。従って、UTXOを**postmix**アカウントに保管することで、UTXOの価値が維持され、同時にアノンセットが向上します。これが、これらのコインが複数のコインジョインサイクルに参加できるようにすることが重要な理由です。これには全くコストがかからず、アノンセットレベルが向上します。

ミックスされたUTXOを使用する場合は、この**postmix**アカウントから直接使用することができます。ミックスUTXOは、無料リミックスの恩恵を受けるため、またWhirlpoolサーキットからの流出を防ぐため、このアカウントに保管しておくことをお勧めします。

### ポストミックスのアカウントを適切に管理するには？

コインジョインサイクルを実行した後、最良の戦略は、UTXOを**postmix**アカウントに保管し、将来の使用を待つことです。使う必要があるまで、無期限にリミックスしておくことをお勧めします。

ユーザーによっては、混合したビットコインを保護されたハードウェアウォレットに移すことを考えるかもしれません。これは可能ですが、得られる機密性を損なわないよう、Samourai Walletの推奨事項に細心の注意を払うことが重要です。

UTXOの組み合わせは最もよく犯す間違いである。CIOH（コモン・インプット・オーナーシップ）ヒューリスティックスを避けるため、同じトランザクショ ンで、ミックスされたUTXOとミックスされていないUTXOを組み合わせることは避ける必要がある。そのためには、ポートフォリオ内のUTXOを、特にラベリングという点で 慎重に管理する必要がある。

![BTC204](assets/fr/148.webp)

また、UTXOの混合コインの統合にも注意が必要です。混合されたUTXOに重要なアノンセットがある場合、適度なコンソリデーションは可能ですが、これはコインの機密性を必然的に低下させます。コイン結合サイクルの前後でUTXO間に推測されるリンクが確立される危険性があるため、コンソリデーションが重要すぎないこと、または不十分な数のリミックスの後に実行されないことを確認してください。これらの操作に疑問がある場合、ベストプラクティスはUTXOをポストミックスで統合せず、1つずつハードウェアウォレットに移し、その都度新しい空のアドレスを生成することです。その際、受け取ったUTXOに適切なラベルを付けることを忘れないでください。

また、一般的でないスクリプトを使用しているウォレットにUTXOのポストミックスを移すことはお勧めしません。例えば、`P2WSH`スクリプトを使用しているマルチシグウォレットからWhirlpoolに入った場合、元々同じタイプのウォレットを持っている他のユーザーと混ざってしまう可能性が少なからずあります。この同じマルチシグウォレットでポストミックスを引き出すと、ブレンドされたビットコインのプライバシーレベルは大きく低下します。スクリプトの他にも、あなたを欺くことができるウォレットのフィンガープリントはたくさんあります。

他のビットコイン取引と同様に、受信アドレスを再利用しないことも重要です。それぞれの新しいトランザクションは、新しい空のアドレスで受信する必要があります。

最もシンプルで安全な解決策は、ミックスしたUTXOを**ポストミックス**口座で休ませ、リミックスして使うときだけ触れるようにすることである。SamouraiとSparrowのポートフォリオには、これら全ての連鎖分析リスクに対する追加的な保護がある。このような保護により、ミスを避けることができます。

### 有害な変化を適切に管理するには？

次に、コインジョインプールに入ることができなかった有毒な小銭の取り扱いには注意が必要です。これらの有毒なUTXOは、Whirlpoolの使用から生じたものであり、あなたとcoinjoinの使用との関連性を確立するため、あなたのプライバシーにリスクをもたらします。そのため、他のUTXO、特に混合UTXOと組み合わせず、慎重に取り扱うことが不可欠です。

ここでは、それらを利用するために考慮すべきいくつかの戦略を紹介する：


- 小さいプールで混ぜる：** 有毒なUTXOが、小さいプールに単独で入るほど大きい場合は、混ぜることを検討する。これが最良の選択肢であることが多い。しかし、複数の有毒UTXOを混ぜてプールにアクセスすることは推奨されない。
- 使用不可」とマークする：** もうひとつの方法は、使用を中止し、専用アカウントで「使用不可」とマークし、単にホドルすることだ。こうすることで、誤って使ってしまうことを防ぐことができる。ビットコインの価値が上がれば、有害なUTXOに適した新しいプールが出現するかもしれません；
- 寄付をする:** ビットコインとその関連ソフトウェアに取り組んでいる開発者に、ささやかでも寄付をすることを検討してください。また、BTCを受け入れる組織に寄付することもできます。有毒なUTXOの管理が複雑すぎるようであれば、寄付をすることで単純にUTXOを取り除くことができます。
- ギフトカードの購入:** [Bitrefill](https://www.bitrefill.com/)のようなプラットフォームでは、ビットコインを様々な商店で使えるギフトカードと交換することができます。これは、関連する価値を失うことなく、有毒なUTXOを処分する方法です。
- Moneroへの統合：** Samourai WalletはBTCとXMR間のアトミックスワップサービスを提供しています。これは、有毒なUTXOをビットコインに送り返す前に、KYCを介してプライバシーを損なうことなくMoneroに統合して管理するのに理想的です。しかし、このオプションは流動性の制約のため、採掘手数料やプレミアムの点で高額になる可能性があります。
- ライトニング・ネットワークに送る：** これらのUTXOをライトニング・ネットワークに転送し、取引手数料の削減の恩恵を受けることは魅力的なオプションです。ただし、この方法はLightningの使用状況によっては情報が漏れる可能性があるため、慎重に行う必要がある。

### ワールプールの使い方は？

2024年4月24日にSamourai Walletの創設者が逮捕され、サーバーが押収されたことを受けて、Whirlpoolツールは自分のDojoを持っている人でも使えなくなりました。以前は、Samourai WalletとSparrow Walletで利用可能でした。

![BTC204](assets/fr/149.webp)

しかし、試験の結果次第では、この商品が今後数週間のうちにサービスを再開するか、別の方法で再スタートする可能性は残っている。いずれにせよ、ビットコインのコインジョイント市場は、明確な需要があるため、供給がない状態が長く続くことはないと思う。さらに、Whirlpoolモデルは、プライバシーの面で最も先進的であるため、将来的に他の実装に使用されることは間違いないだろう。

私たちは、本件の進展と関連ツールの動向を注視しています。新しい情報が入り次第、このトレーニングを更新しますのでご安心ください。

次の章では、"アノンセット "とは何か、この指標はどのように計算されるのか、そしてコインジョインサイクルの有効性を推定するためにどのように役立つのかを明らかにする。

https://planb.network/tutorials/privacy/on-chain/coinjoin-sparrow-wallet-84def86d-faf5-4589-807a-83be60720c8b
https://planb.network/tutorials/privacy/on-chain/coinjoin-samourai-wallet-e566803d-ab3f-4d98-9136-5462009262ef
https://planb.network/tutorials/privacy/on-chain/coinjoin-dojo-c4b20263-5b30-4c74-ae59-dc8d0f8715c2
## 匿名セット

<chapterId>be1093dc-1a74-40e5-9545-2b97a7d7d431</chapterId>

コインジョイントがどのように機能するのか、そして効果的なブレンドに関連する課題を学んだので、次はその効果を測定する方法を学ぶことにしよう。コイン結合が効果的であったかどうか、またコインがどの程度の匿名性を獲得したかを判断するにはどうすればよいのだろうか。この章では、アノニマスセット（英語では「anonset」）を使って、この点を探っていく。

### Coinjoinの有用性についての注意喚起

CoinJoinの有用性は、あなたのコインを見分けがつかないコインのグループの中に没入させることによって、もっともらしい否認可能性を作り出す能力にある。このアクションの目的は、過去から現在、現在から過去へのトレーサビリティリンクを断ち切ることである。

言い換えれば、CoinJoinサイクル開始時の最初の取引（Tx0）を知っているアナリストは、リミックスサイクル終了時のUTXOを確実に特定することはできないはずである（サイクル開始から終了までの分析）。

![BTC204](assets/it/55/01.webp)

対照的に、CoinJoinサイクルの出力時にあなたのUTXOを知っているアナリストは、サイクルの入力時に元の取引を決定することができないはずである（サイクル出力からサイクル入力までの分析）。

![BTC204](assets/it/55/02.webp)

分析者が過去と現在を結びつける難しさ、あるいはその逆を評価するためには、あなたのコインが隠されている均質なコイングループの大きさを定量化する必要がある。この尺度によって、同じ確率を持つ分析の数がわかります。したがって、正しい分析が、同じ確率の他の3つの分析に紛れている場合、あなたの隠蔽レベルは非常に低い。しかし、もし正しい分析が2万個の同じ確率の分析セットの中にあれば、あなたのコインは非常によく隠されていることになります。そして正確には、これらの集合の大きさはアノンセットと呼ばれる指標を表している。

### アノンセットを理解する

アノンセットは、特定のUTXOのプライバシーの程度を評価する指標となる。より具体的には、調査対象のコインを含むセット内の区別できないUTXOの数を測定する。均質なUTXOセットの要件は、アノンセットが通常CoinJoinサイクルで計算されることを意味します。ワールプールコインジョインは均一であるため、これらの指標の使用はワールプールコインジョインに特に関係します。

アノンシェットは、適切な場合、CoinJoinsの品質を判断することを可能にする。アノンシェットサイズが大きいと、均質なセットの中で特定のUTXOを区別することが難しくなるため、匿名性が高くなります。

アノンセットには2種類ある：


- アノンシェットの見込み;**
- レトロスペクティブ・アノンセット.**.

### プロスペクティブ・アノンセット

フォワード・ルッキング・アノンセットは、サイクルの出口で調査対象のUTXOが隠れているグループの大きさ、つまり、このグループ内に存在する区別できないコインの数を示す。英語では、この指標は "forward anonset"、または "forward-looking metrics "と呼ばれる。

この指標は、過去から現在への（インプットからアウトプットへの）分析に対する通貨プライバシーの抵抗力を示すものである。

![BTC204](assets/it/55/03.webp)

この指標は、あなたのUTXOが、コイン結合プロセスにおけるエントリーポイントからエグジットポイントまでの履歴を再構築する試みに対して、どの程度保護されているかを推定します。

例えば、あなたの取引が最初のコイン結合サイクルに参加し、さらに2つの降順サイクルが完了した場合、あなたのコインのアノニセットの見込みは`13`となる：

![BTC204](assets/fr/153.webp)

例えば、コイン結合サイクルの入り口にあるコインは、「86,871`」のアノセットの恩恵を受けているとしよう。これは実質的に、「86,871`」の区別のつかないコインの中に隠れていることを意味する。コイン結合サイクルの最初にこのコインを知っている外部の観察者が、そのコインの出口を追跡しようとすると、その観察者は`86,871`枚のUTXOの可能性に直面することになり、それぞれが探しているコインである確率は同じである。

![BTC204](assets/it/55/05.webp)

### レトロスペクティブ・アノンセット

Retrospective anonset（レトロスペクティブ・アノンセット）は、サイクル終了時の UTXO を知ることで、あるコインの出所の可能性の数を示します。この指標は、現在から過去への分析（出口から入口）に対するコインのプライバシーの抵抗力、つまり、アナリストがコイン接合サイクルの前に、あなたのコインの出所をたどることがどれだけ難しいかを測定します。英語では、この指標は "backward anonset"、または "retrospective metrics "と呼ばれています。

サイクルが終了した時点のUTXOを知ることで、遡及的アノニセットは、コインジョインサイクルでエントリーを構成する可能性があった潜在的なTx0トランザクションの数を決定する。下図では、これはオレンジ色のバブルの合計に相当する。

例えば、コインジョインサイクルの出口にあるコインが、42,185`の遡及的なアノセットの恩恵を受けているとします。これは実質的に、このUTXOには42,185`の発生源があることを意味する。外部の観察者がサイクルの終わりにこのコインを識別し、その出所をたどろうとした場合、その観察者は`42,185`の可能性のある出所に直面することになります。

### アノンセットの具体的な計算方法は？

小さな集合であれば、ブロック・エクスプローラーを使って手動でアノ ンセットを計算することができる。しかし、より大きなアノンシェットの場合は、専用のツールを使うことが不可欠になる。私の知る限り、このタスクを実行できる唯一のソフトウェアは_Whirlpool Stats Tool_で、SamouraiチームとOXTチームによって開発されたPythonツールである。残念なことに、このツールは、ブロックチェーンからデータを抽出するために使用されていたSamouraiの創設者の逮捕とOXTの終了に伴い、現在サービスを停止している。

本章で見てきたように、アノンセットはコインジョイント構造に何らかの均質性がある場合にのみ計算できる。そして正確には、次の章では、ビットコイン取引におけるこの同質性を定量化する方法を、それがコインジョインであれ、より伝統的な取引であれ、見つけることになる。

https://planb.network/tutorials/privacy/analysis/wst-anonsets-0354b793-c301-48af-af75-f87569756375
## エントロピー

<chapterId>e4fe289d-618b-49a2-84c9-68c562e708b4</chapterId>

コイン結合のパートで見てきたように、入力と出力における UTXO の同質性は、ビットコイン取引の機密性を向上させる上で重要な役割を果たす。このパラメータは、チェーン分析に対するもっともらしい否認を可能にする。この均質性を測定する方法はいくつかあるが、私が考える最も効果的な方法の1つは、OXTとSamourai Walletチームによって開発された_Boltzmann_ツールによって提供される指標、特にトランザクションエントロピーの使用である。この章ではこれを詳しく研究する。

トランザクションのセットで計算されるアノネットとは異なり、ここで紹介する指標は、コインジョインであれ、より伝統的なトランザクションであれ、単一のトランザクションのみに焦点を当てる。

### 解釈の数

ビットコイン取引で観察できる最初の指標は、取引を分析する外部の観察者の目から見た解釈の可能性の総数である。取引に関与する UTXO の値を考慮すると、この指標は入力を出力に関連付けることができる方法の数を示す。言い換えれば、トランザクションを分析する外部のオブザーバーの視点から、トランザクショ ンがビットコインストリームで生成する可能性のある解釈の数を決定する。

例えば、1入力2出力の単純な支払取引は、1つの解釈しか持たない。すなわち、入力#0が出力#0と出力#1に資金を供給したという解釈である。それ以外の解釈はありえない：

![BTC204](assets/fr/159.webp)

対照的に、ワールプールの5x5モデルに従って構造化されたコインジョイントには、1,496ドルの可能な組み合わせがある：

![BTC204](assets/fr/160.webp)

Whirlpool Surge Cycle 8x8 coinjoinでは、$9,934,563の解釈が可能である：

![BTC204](assets/fr/161.webp)

### エントロピー

ビットコイン取引の解釈の数から、そのエントロピーを計算することができる。

暗号と情報の一般的な文脈では、エントロピーは、データソースやランダムなプロセスに関連する不確実性や予測不可能性を定量的に測定するものである。言い換えれば、エントロピーとは、情報を予測したり推測したりするのがどれだけ難しいかを測る方法である。

連鎖分析に特化した文脈では、エントロピーはシャノンのエントロピーから派生した指標の名前でもあり、[LaurentMTによって発明された](https://gist.github.com/LaurentMT/e758767ca4038ac40aaf)、ビットコインの取引で計算することができる。

ある取引に多くの解釈の可能性がある場合、そのエントロピーを参照することがより適切であることが多い。この指標は、トランザクションの正確な構成に関するアナリストの知識不足の指標となる。言い換えれば、エントロピーが高ければ高いほど、アナリストがインプットとアウトプットの間の ビットコインの流れを特定することが難しくなる。

実際には、エントロピーは、外部のオブザーバーから見て、トランザクショ ンが、他の外部または内部のパターンやヒューリスティックを考慮することなく、入力と出力の量だけに基づいて、 複数の解釈の可能性があるかどうかを明らかにする。従って、エントロピーが高いことは、トランザクションの機密性が高いことと同義である。

エントロピーは可能な組み合わせの数の2進対数として定義される。E$は取引のエントロピー、$C$は可能な解釈の数を表す：

$$
E = \log_2(C)
$$

数学では、2進対数（2の底の対数）は、2をあるべき乗にすることの逆演算に相当する。つまり、$x$の2進対数は、$x$を得るために$2$をべき乗した指数である。この指標はこのようにビットで表される。

5x5のワールプールモデルに従って構造化されたコインジョイン取引のエントロピー計算を例にとると、前節で述べたように、この取引には1,496ドルという解釈の可能性がある：

$$
\begin{align*}
C &= 1.496 \\
E &= \log_2(1.496) \\
E &= 10.5469 \text{ bit}
\end{align*}
$$

従って、このコイン結合取引は10.5469$ビットのエントロピーを示し、これは非常に満足のいくものであると考えられる。この値が高ければ高いほど、トランザクションはより多くの異なる解釈を受け入れ、プライバシーのレベルが向上する。

9,934,563ドルの解釈がある8x8のコインジョイント取引では、エントロピーは次のようになる：

$$
\begin{align*}
C &= 9.934.563 \\
E &= \log_2(9.934.563) \\
E &= 23,244 \text{ bit}
\end{align*}
$$

入力が1つ、出力が2つの、標準的な支払いトランザクションを例にとってみよう：[1b1b0c3f0883a99f1161c64da19471841ed12a1f78e77fab128c69a5f578ccce](https://mempool.space/tx/1b1b0c3f0883a99f1161c64da19471841ed12a1f78e77fab128c69a5f578ccce)

![BTC204](assets/fr/162.webp)

このトランザクションの場合、唯一可能な解釈は、(In.0) > (Out.0 ; Out.1)`である。その結果、エントロピーは$0$に設定される：

$$
\begin{align*}
C &= 1 \\
E &= \log_2(1) \\
E &= 0 \text{ bit}
\end{align*}
$$

### 効率性

トランザクションのエントロピーからプライバシー効率も計算できる。この指標は同じ構成で考えられる最適なトランザクションと比較することでトランザクションの効率を評価する。

これは特定のトランザクション構造が理論的に達成しうる最高のエントロピーに相当する。そして、この最大エントロピーと分析されたトランザクションの実際のエントロピーを比較することで、トランザク ションの効率が計算される。

使用される計算式は以下の通りである：


- E_R$：トランザクションの実際のエントロピーをビットで表したもの；
- E_M$：トランザクション構造で可能な最大のエントロピー；
- Ef$：ビット単位でのトランザクションの効率：

$$
Ef = E_R - E_M
$$

例えば、Whirlpool 5x5型のコイン結合構造では、最大エントロピーは$10.5469$である：

$$
\begin{align*}
E_R &= 10,5469 \\
E_M &= 10,5469 \\
Ef &= E_R - E_M \\
Ef &= 10,5469 - 10,5469 \\
Ef &= 0 \text{ bit}
\end{align*}
$$

この指標はパーセンテージでも表される。使用される計算式は以下の通り：


- C_R$：可能な実数解釈の数；
- C_M$：同じ構造を持つ解釈の可能な最大数；
- Ef$：パーセンテージで表した効率：

$$
\begin{align*}
E_f &= \frac{C_R}{C_M} \\
E_f &= \frac{1.496}{1.496} \\
E_f &= 100\%
\end{align*}
$$

したがって、$100%の効率は、トランザクションがその構造に基づいてプライバシーの可能性を最大化することを示す。

### エントロピー密度

エントロピーはトランザクションのプライバシーを測定するための良い指標であるが、トランザク ションのインプットとアウトプットの数に部分的に依存する。入力と出力の数が同じでない2つの異なるトランザクションのエントロピーを比較するために、エントロピー密度を計算することができる。この指標は、トランザクション内の各入出力に対するエントロピーの視点を提供する。密度は、異なるサイズのトランザクションの効率を評価し比較する際に有用である。

計算するには、単純にトランザクションのエントロピーの合計を、トランザクションに関与するインプットとアウトプットの合計数で割る：


- E_D$：エントロピー密度をビットで表したもの；
- E$：トランザクションのエントロピーをビットで表したもの；
- T$：トランザクションの入力と出力の総数：

$$
E_D = \frac{E}{T}
$$

5×5のワールプールのコインジョイントを例にとってみよう：

$$
\begin{align*}
T &= 5 + 5 = 10 \\
E &= 10.5469 \\
E_D &= \frac{E}{T} \\
E_D &= \frac{10.5469}{10} \\
E_D &= 1.054 \text{ bit}
\end{align*}
$$

また、8x8のワールプール・コインジョインのエントロピー密度も計算する：

$$
\begin{align*}
T &= 8 + 8 = 16 \\
E &= 23.244 \\
E_D &= \frac{E}{T} \\
E_D &= \frac{23.244}{16} \\
E_D &= 1.453 \text{ bit}
\end{align*}
$$

これら2種類のコインジョインのエントロピー密度を分析することで、エントロピーを要素数で正規化しても、「サージサイクル8x8」コインジョインの方が分析に不確実性をもたらすことが明らかになった。

### ボルツマン・スコア

トランザクションで分析されるもう一つの情報は、各要素の他の要素に対する相対的なボルツマンスコアである。これはインプットとアウトプットの対応確率の表である。この表は、ボルツマンスコアを通じて、特定のインプットが所定のアウトプットに関連する条件付き確率を示している。このように、ボルツマンスコアは、ある取引における入力と出力の間の関連性が発生する条件付確率の定量的な尺度であり、解釈の集合において、発生しうる事象の総数に対するこの事象の有利な発生回数の比率で決定される。

ワールプールのコインジョインを例にとると、条件付き確率表は各入力と出力の間のリンクの可能性を強調し、取引における関連付けの曖昧さを定量的に示す：

| 出力0 出力1 出力2 出力3 出力4

| ------- | -------- | -------- | -------- | -------- | -------- |

ここで、各入力がどの出力とも同じ確率で関連することは明らかであり、これにより取引の機密性が高まる。

ボルツマン・スコアの計算には、ある事象が発生する解釈の数を、利用可能な解釈の総数で割ることが含まれる。従って、入力#0と出力#3（$512$個の解釈の中に存在する事象）を関連付けてスコアを決定するには、以下のように処理する：

$$
\begin{align*}
\text{Interpretazioni (IN.0 > OUT.3)} &= 512 \\
\text{Interpretazioni Totali} &= 1496 \\
\text{Punteggio} &= \frac{512}{1496} \\
\text{Punteggio} &= 34\%
\end{align*}
$$

サージ8x8ワールプールのコイン接合サイクルの例を再考すると、ボルツマン表は次のようになる：

| out.0｜out.1｜out.2｜out.3｜out.4｜out.5｜out.6｜out.7｜out.7｜out.7

| ---- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |

| 23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23

| 23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23

| 23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23

| 23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23

| 23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23

| 23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23

| 23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23

| 23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23%｜23

しかし、1つの入力と2つの出力を含む単純なトランザクションの場合、状況は異なる：

| 出力 0 出力 1

| ------- | -------- | -------- |

| 入力0｜100％｜100％｜100

ここで、各出力が入力#0から来る確率は100%であることがわかる。確率が低ければ低いほど、入力と出力の間の直接的な結びつきが希薄になり、プライバシーが高まる。

### 決定論的リンク

取引における決定論的リンクの数を計算することも可能である。この指標は、分析された取引におけるインプットとアウトプットの間のリンクのうち、100％の確率で疑う余地のないリンクがいくつあるかを明らかにするものである。この指標は、決定論的リンクの比率を計算することで完成する。この比率は、トランザクション内のすべてのリンクの中で、これらの決定論的リンクの重みを示すものである。

例えば、Whirlpool のコインジョイン取引では、インプットとアウトプットの間に決定論的なリンクがないため、インジケータのリンクは 0、比率は 0%である。対照的に、2 つ目の単純な支払取引（入力が 1 つ、出力が 2 つ）では、インジケータは 2 つの決定論的リンクがあることを示し、比率は 100%に達する。このように、インプットとアウトプットの間に直接的で議論の余地のないつながりがないため、インジケータがNULLであれば、プライバシーが優れていることを示す。

### これらの指標の計算方法は？

私が提供した方程式を使って手作業でこれらの指標を計算するのは比較的簡単である。主な難しさは、取引の解釈の可能性の数を決定することにある。標準的な取引の場合、この計算は手作業で行うことができる。しかし、コインジョインの場合、この作業はかなり複雑になる。

以前は、OXTとSamouraiのチームによって開発された_Boltzmann Calculator_と呼ばれるPythonツールがあり、ビットコイン取引に関するこれらすべての指標の自動計算を可能にしていた：

![BTC204](assets/fr/163.webp)

これらの分析にはKYCP.orgのウェブサイトを利用することも可能だった：

![BTC204](assets/fr/164.webp)

残念なことに、サムライの創設者が逮捕された後、これらのツールは現在稼働していない。

コインジョイントについて詳しく説明したので、トレーニングの最後のセクションでは、ビットコインで利用可能な他のプライバシー技術を探ります。ペイジョイントランザクション、特定の擬似コインジョイントトランザクションタイプ、静的アドレスプロトコル、そしてトランザクションレベルではなくノードのネットワークレベルでプライバシーを向上させる手段を検討します。

https://planb.network/tutorials/privacy/analysis/boltzmann-entropy-738e45af-18a6-4ce6-af1a-1bf58e15f1fe
# 他の高度なプライバシー技術の利害関係を理解する

<partId>19989ae6-d608-4acf-b698-2cf1e7e5e6ae</partId>

## ペイジョイン取引

<chapterId>c1e90b95-f709-4574-837b-2ec26b11286f</chapterId>

現在のところ、連鎖分析中にコイントラッキングに不確実性を導入するには、コインジョインが最も効果的な方法です。前の章で見てきたように、効果的なミキシングを実現するためには、入力と出力が可能な限り同質である必要があります。さらに、アノセットを最大化するためには、コインジョインをできるだけ大きなグループに統合することが重要です。したがって、コイン結合が効果的であるためには、多数の均一なコインが含まれなければならない。このように多くの要件があるため、コインジョインの取引は非常に厳格な構造を持つことになる。つまり、金額があらかじめ決められており、プロセスの均一性を確保するために、すべての参加者がその金額を守らなければならないのである。加えて、コインジョイントでは、トランザクションの構築中にすべての参加者とコーディネーターの間で同期をとる必要がある。

このような要件があるため、coinjoinは直接の支払いには不向きである。例えば、コインジョインプールで100万サットのピースを所有している場合、それを直接支払いに使うのは複雑だ。他の参加者やコーディネータと同期して、あなたが支払いを行う必要があるタイミングで、協調トランザクションを正確に構築する必要があります。したがって、コインジョイン取引は本質的に協調的なクリーンアップ取引であり、一般的には、インプットの所有者とアウトプットの所有者が同じであることを意味する。

しかし、連鎖分析に疑念を導入することで、現実的な支払いを可能にする取引構造があれば面白い。これこそが、本章と次章で探求することである。

### ペイジョイントランザクションとは何ですか？

Payjoinは特定のビットコイン取引構造であり、支払先と協力することで使用中のユーザーのプライバシーを強化する。

2015年、LaurentMTはアクセス可能な論文[こちら](https://gist.githubusercontent.com/LaurentMT/e758767ca4038ac40aaf/raw/c8125f6a3c3d0e90246dc96d3b603690ab6f1dcc/gistfile1.txt)によると、「ステガノグラフィック・トランザクション」という名前でこの手法に初めて言及した。この手法は後にSamourai Walletによって採用され、2018年にはStowawayツールでこれを実装した最初のクライアントとなった。payjoinの概念は、[BIP79](https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki)や[BIP78](https://github.com/bitcoin/bips/blob/master/bip-0078.mediawiki)にも見られる。このように、payjoinを指定するためにいくつかの用語が使用されている：


- ペイジョイン
- 密航者；
- P2EP（ペイ・ツー・エンド・ポイント）；
- ステガノグラフィー・トランザクション。

payjoinのユニークさは、一見普通の取引に見えるが、実は2人の間のミニCoinjoinを生成する能力にある。このため、取引の構造には、実際の送金者とともに、支払いの受取人が入力に含まれる。そして受取人は、取引の途中で自分自身への支払いを含めることで、支払いを受けることができる。

このプロセスをよりよく理解するために、例を挙げてみよう。アリスは10,000サットのUTXOを使って4,000サットのバゲットを買い、ペイジョインを選んだ。彼女のパン屋であるボブは、アリスの4,000サッツに加え、彼自身の15,000サッツのUTXOを入力に加え、それをすべて出力で回収する。

この例では、パン屋のボブは15,000サットを入力し、19,000サットを出力する。アリスは10,000サッツを入力し、6,000サッツを出力し、差額は-4,000サッツとなり、これがバゲットの値段となる。例を簡単にするために、この取引では採掘手数料を意図的に省略した。

### ペイジョインの目的は何ですか？

payjoinトランザクションは、ユーザーが支払いのプライバシーを向上させることを可能にする2つの目標を達成する。

第一に、ペイジョインは、チェーン分析に陽動をかけることで、外部のオブザーバーを欺くことを目的としている。これは「共通入力所有ヒューリスティック（CIOH）」によって可能となる。第3回で見たように、通常、ブロックチェーン上の取引に複数の入力がある場合、これらの入力はすべて同じエンティティまたはユーザーに属すると仮定される。

そのため、アナリストがペイジョイントランザクションを調査する際、すべてのインプットは同一人物からもたらされたものであると考えるようになる。しかし、実際の支払人とともに受取人もインプットを提供しているため、この認識は正しくない。このため、連鎖分析では、誤っていることが判明する解釈に偏ってしまう。

バゲットの代金を支払うpayjoinトランザクションの例に戻ろう：

ブロックチェーン上のこの取引を見て、チェーン分析の通常のヒューリスティックスに従った外部のオブザーバーは、"Alice joined 2 UTXOs in transaction input to pay 19,000 sats to Bob" このように解釈するだろう。

この解釈は明らかに間違っている。すでにご存知のように、入力された2つのUTXOは同一人物のものではない。一つはバゲットのバイヤーであるアリスのもので、もう一つはパン屋のボブのものである。

こうして、外部オブザーバーの分析は誤った結論に向けられることになり、利害関係者の秘密が守られる。

### ステガノグラフィー・トランザクション

ペイジョインの第二の目的は、実際の支払額について外部の観察者を欺くことである。トランザクションの構造を調べることで、アナリストは支払いがアウトプットの1つの金額と等価であると信じるかもしれない。

バゲットを購入する例で説明すると、アナリストは、支払金額が 6,000 sats の UTXO か 19,000 sats の UTXO のどちらかに対応すると考える。この場合、出力には2つのUTXOがあり、そのうちの少なくとも1つは6,000サットより大きいので、アナリストは支払額を19,000サットと考える可能性が高い（この支払いには1つのUTXOで十分なのに、6,000サットの支払いに2つのUTXOを使用する論理的な理由はない）。

しかし実際には、この分析は間違っている。支払額はどのアウトプットとも一致しない。実際は、アウトプットを受ける側のUTXOとインプットを受ける側のUTXOの差である。

この点で、payjoin取引はステガノグラフィーの領域に入る。これは、取引の本当の金額を偽の取引の中に隠すことを可能にする。

ステガノグラフィとは、他のデータやオブジェクトの中に情報を隠し、隠された情報の存在を識別できないようにする技術である。例えば、秘密のメッセージは、無関係なテキストの点の中に隠すことができ、肉眼では検出できないようにすることができる（これは[マイクロポイント](https://fr.wikipedia.org/wiki/Micropoint)テクニックである）。

復号キーがなければ情報を理解できなくする暗号化とは異なり、ステガノグラフィは情報を変更しない。それらは見えるところに残る。むしろ、その目的は秘密のメッセージの存在そのものを隠すことであり、暗号は鍵なしではアクセスできないものの、隠された情報の存在を明確に明らかにする。ペイジョインの最初の名称が "ステガノグラフィック・トランザクション "であったのはこのためである。

暗号とコインジョインの間にも、ステガノグラフィとペイジョインの間にも類似性がある。実際、コインジョインは暗号と似た性質を持っている。つまり、方法は認識できるが、情報は解読できない。対照的に、ペイジョインはステガノグラフィに似ている。情報は理論的にはアクセス可能だが、その隠し方が認識できないため、アクセスできなくなる。

### payjoinの使い方

payjoinをサポートする既知のソフトウェアには、Sparrow Wallet、Wasabi Wallet、Mutiny、BitMask、BlueWallet、JoinMarket、およびBTCPay支払いプロセッサーが含まれます。

payjoinの最も先進的な実装は、Samourai Wallet上のStowawayだけでした。しかし、ソフトウェア創設者の閉鎖以来、このツールは現在部分的にしか動作しません。Stowawayの利点は、payjoinの受信と送信の両方をサポートする完全で非常に使いやすいプロトコルであることです。部分的に署名された取引は、複数のQRコードをスキャンして手動で、またはソロバンを経由してTorを介して自動的に交換することができる。現在サービスが行われていないのは、後者の通信オプションである。

payjoinの使いにくさは、加盟店の参加に依存している点にある。顧客としては、加盟店がpayjoinをサポートしていない場合、payjoinを使用することは不可能である。ビットコインが使える加盟店を探すのが面倒なだけでなく、payjoinに対応している加盟店を探すとなると、さらに面倒になる。

一つの解決策は、受取人の協力を必要とせずに、連鎖分析に曖昧さを導入する取引構造を使用することであろう。これにより、加盟店の積極的な参加に依存することなく、支払いのプライバシーを向上させることができる。これこそが、次章で研究する内容である。

https://planb.network/tutorials/privacy/on-chain/payjoin-sparrow-wallet-087a0e49-61cd-41f5-8440-ac7b157bdd62
https://planb.network/tutorials/privacy/on-chain/payjoin-samourai-wallet-48a5c711-ee3d-44db-b812-c55913080eab
## ミニコイン決済

<chapterId>300777ee-30ae-43d7-ab00-479dac3522c1</chapterId>

ある程度のプライバシーを守りながら支払い取引を行うには、payjoinは良い選択肢である。しかし、これまで見てきたように、payjoinは受取人の関与を必要とする。では、受取人がpayjoinへの参加を拒否した場合、あるいは単に参加させたくない場合、どうすればいいのでしょうか？一つの選択肢は、StonewallまたはStonewall x2のトランザクションを使用することです。この2種類の取引を詳しく見てみよう。

### ストーンウォール取引

Stonewallはビットコイン取引の特殊な形態で、2人の間の擬似的なコイン結合を模倣することで、買い物中のユーザーのプライバシーを高めることを目的としているが、実際には結合していない。実際、この取引は共同作業ではない。ユーザーは、自分が所有するUTXOのみを入力として、自分自身で構築することができる。そして、他のユーザーや受取人と同期する必要なく、あらゆる機会にストーンウォール取引を作成することができる。

Stonewallトランザクションの動作は以下の通りである：トランザクションの入力において、送信者は自分に属する2つのUTXOを使用する。出力では、トランザクションは4個のUTXOを生成し、そのうちの2個は全く同額となる。残りの2つのUTXOは残りを構成する。同額の2つのアウトプットのうち、実際に支払の受領者に渡るのは1つだけである。

ストーンウォール取引には2つの役割しかない：


- 支払いを行う送り主；
- 受信者は、取引の具体的な内容を知らず、単に送信者からの支払いを待っているだけかもしれない。

この取引構造を理解するために例を挙げてみよう。アリスはパン屋のボブに4,000サットのバゲットを買いに行った。彼女は自分の支払いについてある程度のプライバシーを保ちながらビットコインで支払いたいと考えている。そこで彼女は支払いのためにストーンウォール取引を構築することにした。

この取引を分析すると、パン屋のボブはバゲットの代金として4,000サットを実際に受け取ったことがわかる。アリスは10,000サットと15,000サットの2つのUTXOを入力として使った。アウトプットとして、彼女は3つのUTXOを受け取った：4,000サット、6,000サット、11,000サット。したがって、アリスはこの取引で-4,000サットの純残高を持つことになり、これはバゲットの価格とまったく同じである。

この例では、理解を容易にするため、マイニング手数料を意図的に無視している。実際には、取引手数料はすべて送金者が負担する。

### ストーンウォール取引の目標は何ですか？

ストーンウォール構造は取引に多くのエントロピーを加え、連鎖分析の痕跡を混乱させる。外から見ると、このような取引は2人の間のミニコイン結合と解釈できる。しかし実際には、それは支払いである。したがって、この方法は連鎖分析に不確実性を生じさせ、あるいは誤った痕跡をもたらす。

パン屋のボブにアリスがいる例に戻ろう。ブロックチェーン上の取引は次のようになる：

![BTC204](assets/fr/174.webp)

連鎖分析の一般的なヒューリスティックスに頼る外部の観察者は、"_2人がそれぞれ1 UTXOをインプットし、それぞれ2 UTXOをアウトプットして、小さなコインジョインを行った_"と誤って結論付けるかもしれない。この取引を外部から分析しても、CIOH(Common Ownership Heuristics of Input)を適用することにはならない。したがって、外部からの視点では、CIOHはこの特定のケースには適用されない。

![BTC204](assets/fr/175.webp)

この解釈は不正確である。ご存知のように、1つのUTXOはパン屋のボブに送られ、入力の2つのUTXOはアリスから来たもので、残りの3つの出力を彼女は取り出した。

![BTC204](assets/fr/176.webp)

そして、ストーンウォールの取引の構造で特に興味深いのは、外部のオブザーバーから見ると、ストーンウォール×2の取引とまったく同じに見えることだ。

### ストーンウォール事件 x2

Stonewall x2 はビットコイン取引のもう一つの特殊な形態であり、使用中のユーザーのプライバシーを高めることを目的としているが、今回は使用に関与しない第三者と協力することによっている。この方法は、2人の参加者の間で擬似的なコイン結合として機能する一方、第三者への支払いを行う。

手持ちのUTXOを使って支払いを行い、第三者にもUTXOを提供してもらう。そのうちの2つは同額で、1つは支払先のアドレスに、もう1つは貢献者のアドレスに送られる。3つ目のUTXOは貢献者の別のアドレスに送信され、貢献者は最初の金額を回収することができます（彼らにとってはマイニング手数料を差し引いた中立的な行為です）。

このように、ストーンウォール×2取引では3つの異なる役割が定義されている：


- 実際の支払いを行う送り主；
- 受信者は、取引の具体的な内容を知らず、単に送信者からの支払いを待つだけかもしれない；
- 取引分析に疑念を投げかけるためにビットコインを提供する協力者は、最後に資金を完全に回収する（マイニング手数料を差し引いた、彼らにとって中立的な行為）。

パン屋のボブに4,000サッツのバゲットを買いに来たアリスの例に戻ろう。彼女はビットコインで支払いたいが、支払いについてある程度のプライバシーを保ちたい。そこで、彼女は友人のチャールズに電話する。

![BTC204](assets/fr/177.webp)

この取引を分析すると、パン屋のボブは実際にバゲットの代金として4,000サットを受け取ったことがわかる。アリスは10,000サッツをインプットし、6,000サッツをアウトプットした。シャルルは、15,000サッツを投入し、4,000サッツと11,000サッツの2つのアウトプットを受け取った。

この例では、理解を容易にするため、意図的に手数料を省略している。実際には、マイニング手数料は一般的に、支払いの発行者と貢献者の間で均等に分配されます。

### ストーンウォール×2取引の目標は何か？

ストーンウォール構造と同様に、ストーンウォールx2構造は取引にかなりの量のエントロピーを付加し、連鎖分析の痕跡を不明瞭にする。外部から見れば、このような取引は2人の間の小さなコイン結合と解釈されるかもしれない。しかし実際には、それは支払いである。したがって、この方法は連鎖分析に不確実性をもたらし、また誤った痕跡を残すことになる。

アリス、パン屋のボブ、チャールズの例を見てみよう。ブロックチェーン上の取引は次のようになる：

![BTC204](assets/fr/178.webp)

連鎖分析の一般的なヒューリスティックスに依拠する外部の観察者は、"_アリスとチャールズは、インプットがそれぞれ1 UTXO、アウトプットがそれぞれ2 UTXOで、小規模のコインジョイントを行った_"と誤って結論付けるかもしれない。ここでも、この取引を外部から分析しても、CIOH（Common Ownership Heuristics of Input）は適用されない。したがって、外部からの視点では、CIOHはこの特別なケースでは適用されない。

![BTC204](assets/fr/179.webp)

ご存知のように、パン屋のボブにはUTXOが1つ送られ、アリスにはレスト出力が1つしかなく、チャールズには2つあるから、この解釈は不正確である。

![BTC204](assets/fr/180.webp)

そしてまた、ストーンウォール×2の取引構造で特に興味深いのは、外部のオブザーバーから見ると、ストーンウォールの取引とまったく同じように見えるということだ。

### ストーンウォールとストーンウォール×2の違いは何ですか？

StonewallX2取引はStonewall取引と全く同様に機能するが、前者は協調的であるのに対し、後者はそうではない。これまで見てきたように、Stonewall X2取引には、支払いの外部にいる第三者（Charles）が参加し、取引の機密性を高めるためにビットコインを提供する。古典的なストーンウォール取引では、提供者の役割は送信者が担う。

![BTC204](assets/fr/181.webp)

したがって、外部から見れば、トランザクション・モデルはまったく同じである。

これら2つの取引構造がまったく同じパターンを共有しているという事実は、外部のオブザーバーが「ストーンウォール(x2)」パターンを識別できたとしても、そのオブザーバーがすべての情報を持っているわけではないことを示唆している。彼は、同じ金額の2つのUTXOのどちらが支払いに対応するかを決定することはできない。また、入力された2つのUTXOが2つの異なる人物（Stonewall x2）からのものなのか、それとも1人の人物が参加したもの（Stonewall）なのかを判断することもできない。

この最後の点は、Stonewall x2 取引が Stonewall 取引とまったく同じパターンに従っているという事実によるものである。外から見て、また追加的な文脈情報がなければ、ストーンウォール取引とストーンウォール x2 取引を区別することは不可能である。しかし、前者は共同取引ではなく、後者は共同取引である。このことは、このような取引の分析にさらに疑念を加えるものである。

### StonewallとStonewall x2の取引を利用するタイミングは？

ある取引にプライバシー・ツールを使いたい場合、ロジックは次のようになるはずだ：


- 優先事項として、ペイジョインを選択することができる；
- 加盟店がpayjoinsをサポートしていない場合、Stonewall x2構造を使用して、支払い外で別の人と共同取引を行うことができます；
- ストーンウォールx2取引を行う相手が見つからない場合は、ストーンウォールx2取引の動作を模倣したストーンウォール取引を自分で行うことができる。

### StonewallとStonewall x2の取引を利用するには？

StonewallとStonewall x2の取引は、Samourai WalletアプリとSparrow Walletソフトウェアの両方で利用可能です。

しかし、payjoinsと同様に、Samouraiの創設者が逮捕された後、Stonewall x2の取引は現在、当事者間でPSBTを手動で交換することによってのみ機能する。ソロバンによる自動交換は、残念ながら今のところ利用できない。

この種の取引は、ビットコイン・ウォレットソフトウェアから手動で実行することもできます。

次の章では、これまで研究してきたことに加えて、比較的知られていないが非常に有用なプライバシー・テクニックをもうひとつ研究する。

https://planb.network/tutorials/privacy/on-chain/stonewall-033daa45-d42c-40e1-9511-cea89751c3d4
https://planb.network/tutorials/privacy/on-chain/stonewall-x2-05120280-f6f9-4e14-9fb8-c9e603f73e5b
## リバウンド

<chapterId>db9a20ac-a149-443d-884b-ea6c03f28499</chapterId>

coinjoinのような連鎖分析に曖昧さを加えるビットコイン取引構造の使用は、プライバシー保護に特に有益である。しかし、payjoins の章で述べたように、coin-join の取引は当然ながらチェーン内で識別可能である。ファイルを暗号化する場合、第三者がこの暗号化されたファイルを発見しても、その内容にはアクセスでき ませんが、ファイルの内容を隠すために変更が加えられたことは明確に識別できます。分析者がコインジョイントトランザクションを調査するとき、入力と出力（およびその逆）の間の直接的なリンクを確立することができなくても、観察されたトランザクションがコインジョイントであることを認識することができます。

コインジョインサイクルを経た後のコインの使用目的によっては、このプロセスを経たという事実が問題になることがあります。例えば、規制された取引所プラットフォームでコインを売却する予定であっても、そのコインが最近コインジョイントを受けたものである場合、プラットフォームのチェーン分析ツールはその事実を検出します。するとプラットフォームは、コインジョイントが行われたお客様のUTXOの受け入れを拒否したり、お客様に説明を求めたりする可能性があり、お客様のアカウントが停止されたり、お客様の資金が凍結されたりするリスクがあります。場合によっては、プラットフォームはあなたの行動を国家当局に報告することもあります（例えば、これはフランスのTRACFINがデジタルアセットサービスプロバイダー（PSAN）に要求していることです）。

このような事態を避けるために必要なのは、ビットコインの過去の痕跡をぼかし、何らかの形で換金性を回復させるツールである。これこそが跳弾の目標である。

### 跳弾とは何か？

Ricochetは、ビットコインの所有権の移転をシミュレートするために、自分自身（sweep）に対していくつかのダミー取引を実行するテクニックである。このツールは、これまで説明してきた他の取引構造とは異なり、将来的な匿名性ではなく、むしろ遡及的な匿名性を実現するものである。実際、リコシェはビットコインコインの過去に起因する換金性を損なう可能性のある特異性をぼかすことを可能にする。

例えば、コイン結合サイクルのような、コインに過去に起こった出来事によって残された刻印を難読化するために、ricochetは、ユーザーが異なるアドレスで自分自身に資金を送金する4つの連続したトランザクションを実行する。

この一連のトランザクションの後、跳弾ツールは最終的にビットコインを最終目的地である交換プラットフォームへとルーティングする。

その目的は、コインジョイント取引のようなコインのカジビリティに影響を与える距離と、そのコインの過去が原因でこのコインを拒否するかもしれない最終的な消費行為を作り出すことである。従って、連鎖分析ツールは、イベントの後に所有者の変更があった可能性が高いと結論づけ、このコインは換金可能であると考えるかもしれない。コインジョインの場合、連鎖分析ツールは、ビットコインを送った人物とコインジョインを実行した人物は別人であり、送信者に対してアクションを起こしても無駄であると考えることができる。

### なぜうまくいくのか？

この跳弾法に直面すると、連鎖解析ソフトは4ホップを超えて検査を深めるだろうと想像するかもしれない。しかし、これらのプラットフォームは、検出しきい値を最適化する際にジレンマに直面する。所有者の変更がおそらく起こったと認め、以前のイベント（コイン結合など）へのリンクは無視すべきであるとするホップ数に制限を設ける必要があるのだ。

しかし、この閾値を決定することは危険である。観測されるスキップ回数が増えるごとに、指数関数的に偽陽性の量が増える。つまり、取引が他の誰かによって実行されたにもかかわらず、個人がイベントの参加者として誤ってマークされる。このシナリオは、偽陽性が不満につながり、影響を受けた顧客が競合他社に流れてしまう可能性があるため、これらの企業にとってより大きなリスクとなる。長期的には、検知のしきい値が大きすぎると、プラットフォームは競合他社よりも多くの顧客を失うことになり、その存続が脅かされる可能性がある。したがって、これらのプラットフォームにとって、観察されるジャンプの数を増やすことは複雑であり、分析に対抗するには4つで十分な場合が多い。

ここで観察される現象は、6度の隔たり理論にやや類似している。

六次の隔たりという理論は、地球上のどの人も、6人以上の仲介者を含まない知識の連鎖によって、他のどの人ともつながっていることを示唆している。世界中のどんな個人にも到達するためには、それぞれが個人的に次の個人を知っている6人の人間を経由すれば十分なのである。

ビットコイン取引についても、同様の現象が見られる。十分な数のビットコイン取引を追跡すると、必然的にコイン結合に遭遇することになる。跳躍法では、取引所プラットフォームが合理的に追跡できるホップ数よりも多くのホップを使用することで、この原理を利用している。プラットフォームがより多くのトランザクションを追跡することを決定した場合、この対策を回避するために単純に追加ホップを追加することが可能になる。

### いつ、どのように跳弾を使うのか？

跳ね返りの最も一般的なユースケースは、所有する UTXO のコインジョイントに以前参加したことを隠す必要がある場合です。理想的には、コインジョイントを経たビットコインを規制対象団体に送金することは避けるのが最善です。しかし、他の選択肢がない場合、特にビットコインを不換紙幣に清算することが急務である場合、リコシェは効果的な解決策を提供します。

この方法は、コインの接合だけでなく、コインの流通性を損なう可能性のあるその他のマークにも有効である。

この跳弾法のアイデアはもともとSamourai Walletチームから生まれたもので、プロセスを自動化するために彼らのアプリケーションに統合された。Samouraiのサービスには、採掘手数料に加えて10万サットのサービス料がかかる。そのため、このサービスの利用は、多額の送金の際に推奨される。

サムライのアプリケーションには、跳弾のバリエーションが2種類ある：


- アドバンスト・リコシェ、すなわち「時差配信」は、サムライのサービス料を5回の連続取引に分散させるという利点がある。このオプションはまた、各取引が別々の時間に送信され、異なるブロックに記録されることを保証し、所有者変更の動作を可能な限り忠実に模倣することを可能にする。スピードは遅いが、連鎖分析への耐性を強化することで跳弾の効率を最大化できるため、急いでいない人にはこの方法が望ましい；
- 古典的なリコシェは、短時間にすべてのトランザクションを送信することで、操作を迅速に実行するように設計されている。したがってこの方法は、高度な方法に比べてプライバシーが低く、分析への耐性も低い。緊急の提出にのみ使用すべきである。

リコシェとは、単にビットコインを自分自身に送ることである。特別なツールを使わなくても、どのウォレットソフトウェアでも手動でリコシェを実行することは十分可能です。毎回新しい空のアドレスを使用して、同じコインを後で自分自身に送金するだけです。

次の章では、秘密裏に財産を移転するためのいくつかの技法を検討する。これらの手法は、その仕組みと結果の両面において、これまで検討してきたものとは根本的に異なっている。

https://planb.network/tutorials/privacy/on-chain/ricochet-e0bb1afe-becd-44a6-a940-88a463756589
## 秘密の財産譲渡

<chapterId>a2067036-849c-4d6b-87d2-44235cfae7a1</chapterId>

ビットコインのプライバシー技術の中に、所有権の秘密譲渡がある。この方法は、ある人から別の人へ、あるいはその逆へと、ビットコインの所有権を移転することを目的としており、この取引はブロックチェーン上で明示的に可視化されることはありません。利用可能なさまざまなテクニックと、そのメリットとデメリットを一緒に研究してみましょう。

### コインスワップ

CoinSwapは比較的シンプルなコンセプトに基づいている。スマートコントラクトを使用して、2人のユーザー間のビットコイン所有権の移転を、信頼の必要なく、この移転がブロックチェーン上で明示的に可視化されることなく、促進する。

アリスとボブの単純化した例を想像してみよう。アリスは秘密鍵$A$で保護された1BTCを持っており、ボブも秘密鍵$B$で保護された1BTCを持っている。理論的には、二人は秘密鍵を外部通信路を介して交換し、秘密転送を行うことができる。

しかし、この素朴な方法は信頼という点でリスクが高い。交換後、アリスが$A$秘密鍵のコピーを保持し、鍵がボブに渡った後でそれを使ってビットコインを盗むことを妨げるものは何もない。

さらに、アリスがボブの秘密鍵$B$を受け取って、彼の秘密鍵$A$を決して返送しないことを防ぐ保証はない。したがって、この交換は当事者間の過度の信頼に依存しており、安全な方法で所有権の秘密譲渡を保証するには非効率的であることがわかる。

このような問題を解決し、お互いを信用していない当事者間の交換を可能にするために、代わりにスマート・コントラクト・システムを利用することができる。スマートコントラクトとは、あらかじめ定義された条件が満たされたときに自動的に実行されるプログラムのことで、私たちの場合は、相互の信頼関係を必要とせずに財産の交換が自動的に行われるようにする。

そのためには、HTLC（_Hash Time-Locked Contracts_）またはPTLC（_Point Time-Locked Contracts_）を使用することができます。これら2つのプロトコルは、交換が正常に完了または完全にキャンセルされることを保証するタイムロックシステムを使用して同様に動作し、その結果、両当事者の資金の整合性が保護されます。HTLCとPTLCの主な違いは、HTLCが取引の安全性を確保するためにハッシュと事前画像を使用するのに対し、PTLCは適応署名を使用することです。

アリスとボブの間でHTLCまたはPTLCを使用したCoinSwapシナリオでは、交換は安全な方法で行われます：交換は成功し、それぞれが相手のBTCを受け取るか、失敗し、それぞれが自分のBTCを保持します。したがって、どちらかの当事者が相手のBTCをだましたり盗んだりすることは不可能です。

> HTLCはまた、ライトニング・ネットワークの双方向チャネルを通じて支払いを安全にルーティングするために使用されるメカニズムでもあります。
> アダプティブ・シグネチャーの使用は、従来のスクリプトをバイパスできるため、この文脈では特に興味深い（これは「スクリプトレス・スクリプト」と呼ばれることもある仕組みである）。この機能は、交換に関連する手数料の削減に役立つ。アダプティブ・シグネチャーのもう一つの大きな利点は、トランザクションの双方に共通のハッシュを使用する必要がないため、ある種の取引において両者間の直接的なつながりが明らかになることを避けられることである。
### アダプティブ・サイン

適応署名は、有効な署名と「適応署名」と呼ばれる追加の署名を統合し、データの秘密の部分を明らかにする暗号手法である。この仕組みは、有効な署名、適応署名、秘密の3つの要素のうち2つを知っていれば、3つ目の欠けている要素を推論できるように設計されている。この方法の興味深い特性は、相手の適応署名と、この適応署名を計算するのに使われた秘密に関連する楕円曲線上の特定の点を知っていれば、秘密そのものに直接アクセスすることなく、その同じ秘密に適合する自分自身の適応署名を導き出すことができるということである。

コイン取引所では、適応型署名を使用することで、参加者間で2つの機密情報を同時に開示することができ、相互信頼の必要性を回避することができる。このプロセスを、それぞれ1BTCの所有権を交換したいがお互いを信用していないアリスとボブを例に説明しよう。彼らは適応署名を使い、この交換における信頼の必要性を排除する。以下はその手順である：


- AliceはBobに1BTCを送るトランザクション$m_A$を生成して交換を開始する。アリスは、秘密鍵$p_A$（$P_A = p_A \cdot G$）、ノンス$n_A$（$N_A = n_A G$）、秘密$t$（$T = t G$）を用いて、この取引を検証する署名$s_A$を生成する：

s_A = n_A + t + H(N_A + T ︓平行 P_A ︓平行 m_A) ︓cdot p_A$$.


- アリスは真の署名$s_A$から秘密$t$を引くことで、適応署名$s_A'$を計算する：

s_A' = s_A - t$$.


- アリスはボブに適応署名$s'_A$、未署名のトランザクション$m_A$、 秘密($T$)に対応する点、非信号($N_A$)に対応する点を送る。これらの要素は"_adapter_"と呼ばれるものを構成する。この情報だけでは、ボブはアリスのBTCを取り出せないことに注意。
- しかし、ボブにはアリスが自分から盗もうとしていないことを 検証する能力がある。これを行うには、アリスの適応的署名$s_A'$が提案されたトランザクション$m_A$と実際に一致するかどうかをチェックする。もし次の式が正しければ、ボブはアリスの適応署名が有効であると確信できる：

s_A'  \cdot G = N_A + H(N_A + T ﹑平行 P_A ﹑平行 m_A) ﹑cdot P_A$$.


- この検証により、Bobは確信を持って交換を進めるのに十分な保証を得られる。次に彼は、アリスに1BTCを送るための自分の取引$m_B$を作成し、適応署名$s_B'$を生成する。この時点で、$t$の値を知っているのはアリスだけであり、ボブはアリスが彼に送信した対応する点$T$しか知らない：

s_B' = n_B + H(N_B + T ㎟平行 P_B ㎟平行 m_B) ㎟cdot p_B$.


- ボブは自分の適応署名$s_B'$と、署名のないトランザクション$m_B$、さらに秘密 ($T$)に対応する点と非信号($N_B$)に対応する点をアリスに送信する。秘密$T$を知っているアリスは、ボブの適応署名$s_B'$とこの秘密を組み合わせて、ボブのBTCを彼女に送金する取引$m_B$のための有効な署名$s_B$を生成することができる：

s_B = s_B' + t$$.

(s_B' + t)  \cdot G = N_B + T + H(N_B + T  \parallel P_B ¤parallel m_B) ¤parallel P_B$$ ¤̴̶̷̀ω¤̴̶̷́)


- アリスはこの署名付き取引$m_B$をビットコインのブロックチェーン上に送信し、ボブが約束したBTCを受け取る。ボブはブロックチェーン上でこのトランザクションを見ると、$s_B = s_B' + t$の署名を取り出すことができる。この情報により、ボブは必要な有名な秘密$t$を分離することができる：

t = (s_B' + t) - s_B' = s_B - s_B'$$.


- そして実際、この秘密$t$は、ボブがアリスのアダプタ署名$s_A'$から有効な署名$s_A$を生成するために欠けていた唯一の要素であった。この署名によって、アリスからボブにBTCを送るトランザクション$m_A$を検証することができる。そしてボブは$s_A$を計算し、今度は$m_A$トランザクションをブロックチェーン上に送信する：

s_A = s_A' + t$$.

(s_A' + t)  \cdot G = N_A + T + H(N_A + T  \parallel P_A  \parallel m_A)  \cdot P_A$$.

署名アダプタがコイン交換でどのように機能するかをまとめてみよう。最初にアリスは署名のないトランザクションとアダプタをボブに送り、ボブは後で明かされる 秘密によってビットコインにアクセスできることを確認する。そのお返しとして、ボブはアリスに自分の未署名の取引とアダプターを送る。アリスはその秘密を使った有効な取引を送信することで、ボブの取引を確定し、ビットコインを回収することができる。この取引がブロックチェーン上で公開されると、ボブは秘密を抽出し、アリスの取引をアンロックする能力を持つ。その結果、アリスがボブのビットコインの送金を開始した場合、ボブは相互信頼を必要とせずにアリスのビットコインにアクセスすることができる。

コイン取引所が最初に提案されたのは、2013年10月にビットコイン・トーク（https://bitcointalk.org/index.php?topic=321228.0）でグレゴリー・マクスウェル（Gregory Maxwell）氏であった。

### アトミック・エクスチェンジ

コイン交換と同様に、同じ種類のスマートコントラクトを使用して、アトミック交換を行うことも可能である。アトミック取引所では、信頼や仲介者の介入を必要とせずに、2人のユーザー間でBTCやXMRなどの異なる暗号通貨を直接交換することができる。交換が成功して両者が満足するか、失敗してそれぞれが元の暗号通貨を保持するため、相手を信頼する必要がなくなる。

![BTC204](assets/fr/197.webp)

アトミック・エクスチェンジとコイン・エクスチェンジは操作方法が似ており、プライバシーの面でも同じメリットとデメリットがある。実際、ビットコインの観点から見ると、アトミック交換は2つのステップで行われるコイン交換に匹敵する。まず、私たちはBTCを別の暗号通貨に交換し、次にこの暗号通貨を他のBTCと交換することができます。最後に、別のユーザーのBTCを取得する。これが、プライバシー問題の分析において、この2つのプロトコルを秘密の財産交換というカテゴリーに分類した理由である。

![BTC204](assets/fr/198.webp)

しかし、コイン取引所とは異なり、アトミック取引所では、特にBTC/XMR取引所において、利用可能な流動性の面で不均衡が生じる可能性があります。一般的に、ビットコインに対する需要が大きいため、ビットコインとアルトコインの交換は容易であり、この変換方向のプレミアムは低く抑えられています。しかし、BTCを得るためのアルトコインの取引は、需要が低いためより複雑になる可能性があり、しばしば非常に高いプレミアムが発生します。

最後に、アトミック交換がオンチェーンビットコインとライトニングネットワーク上のビットコインを含む場合、我々はそれを"_submersible exchange_"と呼ぶ。

### 本当に役に立つのか？

コイン交換やアトミック交換のような秘密の所有権移転には、連鎖分析ヒューリスティックスを欺く利点がある。これらの方法は、実際の所有者が変わったとしても、同じユーザーが取引を行っているように見せかけることができる。しかし、これらの方法の主な欠点は、コインの履歴を混乱させる追加的なテクニックを使用しない限り、非常にリスクが高いということである。

事実上、アリスがボブとコイン交換またはアトミックスワップをするとき、アリスは自分のビットコインの所有権をボブのビットコインと交換する。アトミックスワップの場合、交換にはアルトコインが含まれますが、原理は同じです。したがって、アリスはコイン$B$を、ボブはコイン$A$を持つことになる。これは連鎖分析に疑義を加えるが、コインの履歴は追跡可能なままである。アナリストがコイン$A$を調べれば、アリスの以前の行動を追跡することができ、コイン$B$の場合はその逆である。

アリスから見れば、$B$コインの履歴が特定の団体に不審に思われるリスクがある。例えば、ボブがハッキングなどの犯罪行為で$B$コインを手に入れた場合、このコインは彼の違法行為と結びついたままになってしまいます。アリスは、資金を凍結されたり、ボブの犯罪とは無関係であるにもかかわらず、ボブの犯罪の嫌疑をかけられたりするリスクなしに、規制された取引プラットフォームに送金できないコインを所持していることに気づく可能性がある。

そしてもちろん、コインスワップやアトミックスワップといったプライバシーを守る方法は、当局に資金を監視されている犯罪者に好まれている。これらのプロトコルは、監視されているビットコインを処分し、完全に換金可能なビットコインと交換する機会を与える。また、当局を他のユーザーに誘導することで、陽動作戦も可能です。このように、これらの人々には二重の効用がある。

coinjoinでは、自分のコインが監視対象のビットコインと混ざっていたとしても、そのコインの履歴は破棄されるため、コイン交換やアトミックスワップのような秘密の財産移転プロトコルには存在しない、もっともらしい否認可能性を提供することができる。

もしアリスがリスクを避けたいなら、$B$コインの履歴を途絶えさせる方法を使わなければならない。例えば、コインジョイントを通すなどである。このことは、秘密の所有権移転とコインジョイントを組み合わせることの有用性に疑問を投げかける。コイン結合は、コインの履歴を中断することで、すでにアリスに十分なプライバシーを提供しています。したがって、アリスがプライバシーを保護しようとするならば、コイン交換の後にコインジョイントを行うよりも、直接コインジョイントを行う方が賢明であるというのが私の考えである。

所有権を秘密裏に移転する方法が真に効果的で、$A$の利用者の履歴が$B$の利用者にリンクするリスクを回避するためには、逆説的だが、その利用が広く知られる必要がある。コイン交換が大量に使用され、当局がこの一般的な慣行を認識しているのであれば、もっともらしい形の否認が成立しうる。しかし、これらの送金の利用がわずかなものである限り、利用者にとってこれらの方法はリスクが高すぎると私は考える。

これまでのところ、我々は主にトランザクションレベルでのプライバシー手法を研究してきた。次の章では、ネットワークレベルとトランザクションの拡散における問題を探求する。

## P2Pネットワークにおけるプライバシー

<chapterId>04a2467b-db84-4076-a9ff-919be5135106</chapterId>

パート4では、取引のプライバシーを保護するためにフルノードを使用することの重要性について説明した。しかし、あなたのノード自体が、あなたの活動に関する情報を引き出そうとする攻撃の対象となり得ることを理解することが重要です。そこで本章では、取引そのものやビットコインストリームのレベルではなく、ネットワークレベルでの様々なプライバシー保護策について見ていきます。

### ダンデライオン

様々な匿名化解除攻撃を回避する一つの方法は、提案されているDandelionを使用することである。この伝送プロトコルはBIP156で正式に発表されたが、ビットコインには実装されていない。Dandelion のアイデアは、ビットコインネットワークにおけるトランザクションルーティングのプライバシーを改善し、様々な形態の攻撃を阻止することである。その主な目的は、ネットワーク上でトランザクションを最初に送信する送信元ノードを隠すことである。このノードの開示は、ビットコイン取引を特定のIPアドレスにリンクさせ（ノードが暗号化されていないネットワーク上で動作している場合）、連鎖分析のためのエントリーポイントを提供する可能性がある。

ビットコイン上の活動とIPアドレスとの間のこの関連は、ユーザーのプライバシーに重大なリスクをもたらす。実際、多数の団体がIPアドレスと個人の身元を簡単に結びつけることができる。これには政府やインターネット・サービス・プロバイダーも含まれている。さらに、この情報は、例えば、ウェブサイトのデータベースがハッキングされた際のデータリークによってIPアドレスと個人データが公開された場合、一般にアクセス可能になる可能性がある。

ビットコインの標準的な運用では、ユーザーがソフトウェアウォレットで構築したトランザクションは、その個人のノードに送信される。このノードは直ちに、接続しているすべてのピアに新しいトランザクションを送信する。

次にこれらのピアはトランザクションを検証し、それがコンセンサスルールとローカル標準化ルールを満たしていることを確認する。検証されると、各ピアはトランザクションをそのピアに転送する。

ブロックに統合されるのを待つトランザクションの分配は、かなりバランスが取れており、統計的に予測可能な方法で行われる。この脆弱性は、最初にトランザクションを送信したノードを特定するためにネットワークを監視・分析するスパイノードが共謀することによって悪用される可能性がある。観察者が送信元ノードを特定できれば、その取引はそのノードのオペレータから発信されたものだと推測できる。この種の観測は、通常は匿名である取引を特定のIPアドレスに結びつけることができる。

BIP156の目的はこの問題に対処することである。そのためにBIP156は、大規模な公開の前に匿名性を保持するために、新しいトランザクションの送信に追加段階を導入する。Dandelionはまず「ステム」フェーズを使用し、そこではトランザクションがノードのランダムな経路を経由して送信される。

その後、トランザクションは「フラッフ」（吹き溜まり）段階でネットワーク全体に送信される。

茎とタンポポは、ネットワークを通じてトランザクションが伝播する挙動を表しており、タンポポの形に似ている。

したがって、スパイ・ノードはブロー・フェーズ（大量送信）を開始したノードまでトランザクションを追跡できる可能性があるが、このノードはステムの最後のノードからトランザクションを受信したため、最初にトランザクションを送信したノードではない。スパイノードがステムを追跡できなければ、送信元ノードも特定できない。

ステムフェーズでスパイノードが存在しても、拡散グラフで正直なノードに出会うとすぐに、スパイはこのノードが元のソースなのか単なる仲介者なのかを判断できないため、疑念は常に残る。

このルーティング方法は、送信元ノードへの追跡をより困難にし、ネットワークを経由したトランザクションをその送信元まで追跡することを複雑にする。こうして Dandelion は、敵対者がネットワークを非匿名化する能力を制限することで、プライバシーを向上させる。この方法は、TorやP2P Transport V2のように、トランザクションが「ステム」フェーズの間にネットワーク通信を暗号化するノードを通過する場合にさらに効果的である。

BIP156はBitcoin Coreに統合されておらず、現在 "却下 "というステータスに分類されている。このプロトコルに関する主な懸念は、ステムフェーズの間、トランザクションが検証される前に中間ノードによって転送されなければならないという事実にある。これまで見てきたように、通常のビットコインモデルでは、各ノードは仲間に転送する前にまずトランザクションを検証する。トランザクションがノードのコンセンサスまたはローカル標準化ルールを満たさない場合、それは無視され転送されない。有効なトランザクションのみがネットワーク全体に転送されるため、このプロセスはDoS攻撃を阻止する上で重要である。ネットワークに過負荷をかけるために大量に生成される可能性のある無効なトランザクションは、最初に遭遇したノードで停止され、伝播しない。Dandelionの主なリスクは、この新しいプロトコルが、無効なトランザクションがネットワークの一部を通じて送信されることを可能にすることで、DoS攻撃の新たなベクトルを導入する可能性があることである。

### P2PトランスポートV2

P2P Transport V2は、BIP324で発表された別のネットワークプロトコルである。これはBitcoinのP2Pトランスポートプロトコルの新バージョンで、ノード間の通信の機密性とセキュリティを向上させるために日和見暗号を組み込んでいる。

この改良は、P2Pプロトコルの基本バージョンのいくつかの問題を解決することを目的としている。ひとつは、受動的な監視者にとっては、交換されたデータがインターネット上で流通する他のタイプのデータと区別できないようにすることだ。主な目的は、政府やインターネット・サービス・プロバイダー、VPNプロバイダーがビットコインユーザーを大規模に監視するのを防ぐことだ。これはまた、インターネットユーザーがビットコインユーザーでもあるかどうか、つまりフルノードを操作しているかどうかを判断する、これらのエンティティのタスクを複雑にする。

P2P V2はまた、データパケットの特定のパターンを検出することで、検閲や攻撃のリスクを軽減するのに役立つ。ネットワーク・レベルでの様々なタイプのシビル・アタックの実行を複雑化し、よりコスト高にする。シビル攻撃は、行為者が不当な利益を得るために複数の偽のIDを作成する場合に発生する。ビットコインネットワークの文脈では、これは多くの場合、アクターが多数の完全なノードをコントロールし、接続を増やすために積極的にそれらを使用することで現れます。シビル攻撃には、情報を収集してユーザーの機密性を侵害することを目的とする受動的なものと、エクリプス攻撃のような能動的なものがある。後者は、特定のノードをネットワークの残りの部分から隔離し、ユーザーを検閲したり、受信したデータを変更したりすることを可能にする。最後に、P2P V2は中間者（MITM）攻撃をより高価にし、検出しやすくする。

P2P V2が実装する暗号化には、不必要な複雑さを追加せず、ネットワーク接続のパーミッションレスな性質を損なわないようにするため、認証は含まれていない。しかし、この新しいP2Pトランスポート・プロトコルは、パッシブ攻撃に対してより優れたセキュリティを提供し、アクティブ攻撃のコストと検出性を大幅に向上させる。ネットワーク・メッセージに擬似ランダム・データ・ストリームを導入することで、通信の検閲や操作を望む攻撃者のタスクを複雑にしている。

P2P V2トランスポートは、2023年12月にデプロイされたBitcoin Coreのバージョン26.0にオプション（デフォルトでは無効）として含まれていた。その後、2024年4月のバージョン27.0ではデフォルトで有効になった。設定ファイルの `v2transport=` オプションで変更できる。

### トーア

ネットワークレベルのノードの機密性喪失のリスクを回避する比較的簡単な解決策は、それを完全にTorの下で実行することである。Torは、インターネット上のTCP接続の発信元を匿名化するリレー・サーバー（ノード）のネットワークである。Torはデータを複数の暗号化レイヤーでカプセル化することで機能する。各リレーノードは、最終的な宛先に到達するまで、次のノードのアドレスを明らかにするために1つのレイヤーを削除します。Torネットワークは、中間ノードがデータの発信元と宛先の両方を知ることを防ぐことで匿名性を確保し、監視者がユーザーの活動を追跡することを非常に困難にしています。

したがって、Torは通信データを暗号化するだけでなく、通信の発信元と宛先をマスクすることもできる。インターネットサービスプロバイダ（ISP）は通信を解読できず、ビットコインネットワークの他のノードは送信元ノードのIPアドレスを特定できない。さらに、TorはISPからビットコインの使用を隠すこともできる。

この方法に関連する主なリスクは、Torがビットコインに依存しないプロトコルであることだ。Torの下にビットコインノードがあり、Torが機能しなくなった場合、ビットコインノードは通信できなくなる。

また、Tor上の通信が遅くなることにも注意が必要だ。初期ブロックダウンロード（IBD）は多くの通信を必要とするため、このレイテンシはノードの初期起動時に特に問題となる。その結果、ビットコインネットワークとの初期同期にTorを使うと大幅に時間がかかる可能性がある。オープンネットワーク上でIBDを実行し、後でTorを起動することも可能です。この方法はISPにビットコインノードの存在を明らかにしますが、Torに切り替えた後の個人取引情報は保護されます。

ネットワーク・レベルでのさまざまなプライバシーの取り方を探ったところで、次の章ではアドレスの再利用を避けるための2つのエレガントなソリューションも紹介したい：BIP47とサイレント・ペイメントである。

## BIP47と再利用可能な支払いコード

<chapterId>ad88e076-a04b-4aec-b3b2-7b4760175504</chapterId>

第3回で見たように、アドレスの再利用はビットコインプロトコルのユーザープライバシーにとって重大な障害である。このようなリスクを軽減するために、ウォレットで新しい支払いを受け取るたびに新しい受け取りアドレスを生成することが強く推奨される。今日、新しいアドレスの生成は、最新のソフトウェアと階層的な決定論的ウォレットの使用によって簡素化されていますが、この実践は直感に反すると思われるかもしれません。

例えば、従来の銀行システムでは、私たちは常に同じIBANを共有することに慣れている。一旦誰かに伝えると、その人は私たちと再度やりとりすることなく、複数の支払いを送ってくることができる。ネオバンクはまた、ペイパルでのユニークなEメールアドレスの使用や、リボルトでのRevTagsの使用など、より現代的な可能性を提供している。金融分野以外でも、住所、電話番号、電子メールアドレスなど、私たちの日常的な識別子はユニークで永続的なものだ。私たちは、新しいやりとりのたびにそれらを更新する必要はありません。

しかし、ビットコインの仕組みは異なる。着信トランザクションごとに新しい受信アドレスを生成することが必須なのだ。使いやすさとプライバシーの間のこのトレードオフは、ビットコインのホワイトペーパーの起源にまでさかのぼる。サトシ・ナカモトは2008年末に論文の最初のバージョンを発表して以来、すでにこのリスクを警告していた：

**追加のファイアウォールとして、各トランザクションに新しいキーペアを使用し、共通の所有者にリンクされないようにすることができます。

アドレスの再利用を招くことなく、1つの識別子で複数の支払いを受ける方法は数多くある。これらの方法にはそれぞれトレードオフとデメリットがある。これらの方法の中で、Justus Ranvierによって開発され、2015年に発表された提案であるBIP47がある。この提案は、アドレスの再利用を避けつつ、同一人物への複数の取引を可能にする再利用可能な決済コードを作成することを目的としている。要するに、BIP47は取引のプライバシーを守りながら、一意の識別子として直感的な決済システムを提供しようとしている。

![BTC204](assets/fr/212.webp)

BIP47による支払いは、新しいアドレスを使用した従来のビットコイン取引と同レベルのプライバシーを提供するため、BIP47が直接ユーザーのプライバシーを向上させることはありません。しかし、BIP47はビットコインの使用をより便利で直感的なものにします。BIP47のおかげで、この使いやすさは古典的な取引と同じレベルのプライバシーを実現しています。これが、BIP47がプライバシー保護のための貴重なツールである理由です。

当初、BIP47はBitcoin Coreに統合するために策定された提案だったが、採用されることはなかった。しかし、一部のソフトウェアはアプリケーションレベルで独自に実装することを選択した。そのため、Samourai Walletチームは "PayNym "と呼ばれるBIP47の独自の実装を開発した。

### BIP47とPayNymの一般原則

BIP47の目的は、アドレスの再利用を引き起こすことなく、多数の支払いの受領を可能にすることである。これは、再利用可能な支払いコードを使用することに基づいており、異なる送信者が、別のユーザーに属する単一のコードに複数の支払いを送信することを可能にする。このため、受信者は取引のたびに新しいアドレスを提供する必要がなく、プライバシーを守りながらやり取りが非常に容易になる。

![BTC204](assets/it/66/4.webp)

ユーザーは、従来の受信アドレスや公開鍵の場合とは異なり、プライバシーが失われるリスクを負うことなく、ソーシャルネットワークや自分のウェブサイトで、自分の支払いコードを自由に共有することができる。

取引を行うには、両者がBIP47を実装したビットコインウォレット（PayNym on Samourai WalletやSparrow Walletなど）を持っている必要がある。支払いコードを共同使用することで、両者の間に秘密チャネルが形成される。このチャネルを効率的に確立するために、送信者はビットコインのブロックチェーン上で「通知トランザクション」として知られる特定のトランザクションを実行する必要があります（これについては後で詳しく説明します）。

両ユーザーの支払いコードの組み合わせにより、共有された秘密が生成され、それにより多数のユニークなビットコイン受け取りアドレス（正確には2^32、つまり約40億）が作成される。したがって、BIP47を通じて行われる支払いは、実際には支払いコードそのものではなく、関係するユーザーの支払いコードから派生した古典的な受け取りアドレスに宛てられている。

決済コードは、ウォレットのシードから派生した仮想識別子として機能する。ポ ートフォリオの階層的派生構造では、支払いコードはレベル 3、つまりアカウントレベルに配置される。

![BTC204](assets/it/66/5.webp)

BIP47の派生ターゲットは、BIP47を参照するインデックス`47'`（`0x8000002F`）で識別される。再利用可能な支払いコードの派生パスの例は以下の通りである：

```plaintext
m/47'/0'/0'/
```

ペイメントコードがどのようなものか、私のものをご覧いただきたい：

```plaintext
M8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5
```

このコードはQRコードにエンコードすることもでき、古典的な受信アドレスのように簡単に通信することができる。

PayNymボットについては、Twitterで時々見かけるこれらのロボットは、Samourai Walletによって作成された支払いコードの視覚的表現である。ハッシュ関数によって生成されるため、ほぼ一意性を持っている。で始まる小さな文字列として表示される：

```plaintext
+throbbingpond8B1
+twilightresonance487
+billowingfire340
```

これらのアバターは画像として表現することもできる：

![BTC204](assets/fr/215.webp)

これらのロボットは、BIP47のフレームワークの中では特定の技術的機能を持たないが、容易に認識できる視覚的アイデンティティを提供することで、ユーザー間のインタラクションを促進する役割を果たしている。

---
*本章のBIP47に関する以下のセクションでは、BIP47の運用について、特に使用されている暗号手法に焦点を当てながら、詳細に検証していく。これらのやや専門的な説明を完全に理解するためには、まずHDウォレットの構造、鍵の導出プロセス、楕円曲線ベースの暗号の基本原理を理解することが不可欠です。これらの概念についてさらに学びたい方は、Plan ₿ Network:*から別の無料コースをご利用いただけます。

https://planb.network/courses/cyp201
*BIP47の技術的な仕組みを理解することで、これから説明する他の同様の提案をより理解しやすくなるからだ*。

---
### 再利用可能な支払いコード

前述したように、再利用可能なペイメントコードはHDウォレットのレベル3に位置し、ウォレット構造内での位置とその役割の両方において、`xpub`に匹敵する。

80バイトの支払コードは以下のように分割される：


- バイト `0`：バージョン**。BIP47 の最初のバージョンでは、このバイトは `0x01` に設定される；
- バイト `1`：ビットフィールド**。このスペースは、特定の用途で追加の表示を組み込むために確保される。PayNym での標準的な使用では、このバイトは `0x00` として定義される；
- バイト `2`：y`** のパリティ。このバイトは `0x02` または `0x03` であり、公開鍵の縦軸が偶数か奇数かを示す；
- バイト `3` からバイト `34` まで：x`**の値。これらのバイトは公開鍵の横軸を表す。x` とパリティ `y` を連結したものが、圧縮された公開鍵の完全な形となる；
- バイト`35`からバイト`66`まで：チェーンコード**。この領域には公開鍵に関連付けられたチェーンコードが格納される；
- バイト `67` からバイト `79` まで：充填**。このスペースは将来の開発のためのものである。現在のバージョンでは、`OP_RETURN`の出力に必要な80バイトのサイズを達成するために、ここにゼロが配置されています。

前節で紹介した再利用可能な支払いコードを16進数で表したものがこちら：

```plaintext
0x010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000
```

![BTC204](assets/it/66/7.webp)

まず、ペイメントコードであることを明確に示すために、先頭にプレフィックスバイト `P` を付加する必要がある。このバイトは`0x47`で表される：

```plaintext
0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000
```

最後に、ペイメントコードの完全性を保証するために、`SHA256`関数によるダブルハッシュからなる`HASH256`を使用してチェックサム計算が実行される。このハッシュの最初の 4 バイトがペイメントコードの最後に連結される：

```plaintext
0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000567080c4
```

これらのステップが完了すれば、支払いコードの準備は完了だ。残る唯一のステップは、最終版を得るために58ベースに変換することである：

```plaintext
PM8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5
```

この決済コード作成プロセスでは、圧縮された公開鍵とチェーンコードを使用する。どちらもウォレットシードから決定論的かつ階層的に導出される。このために使用される導出パスは以下のとおりである：

```plaintext
m/47'/0'/0'/
```

再利用可能な支払いコード用に圧縮された公開鍵と関連するチェーンコードを生成するた め、まずウォレットシードからメインの秘密鍵を計算する。次に、インデックス `47 + 2^31` を使用して娘鍵ペアを導出する(導出を強化する)。このステップに続いて、インデックス `2^31` (強化された導出)を使用して、娘鍵ペアをさらに 2 つ連続して導出する。

### 楕円曲線ディフィー・ヘルマン鍵交換(ECDH)

BIP47の核となる暗号プロトコルは、Elliptic-Curve Diffie-Hellman_の頭文字をとってECDHと呼ばれている。この方法は、オリジナルのDiffie-Hellman鍵交換の変形である。

1976年に発表されたディフィー・ヘルマン（Diffie-Hellman）は、公開鍵と秘密鍵のペアを持つ2つの当事者が、公開された安全でない通信路を通じてのみ通信している間でも、共通の秘密について合意することを可能にする鍵合意プロトコルである。

![BTC204](assets/it/66/10.webp)

この共有秘密（ここでは青い鍵）は、他の操作に使うことができる。通常、この共有秘密は安全でないネットワーク上の通信の暗号化と復号化に使われる：

![BTC204](assets/fr/220.webp)

この交換を達成するために、ディフィー・ヘルマンではモジュール演算を使って共有秘密を計算する。以下にその仕組みを簡単に説明する：


- アリスとボブは共通の色、ここでは黄色で合意し、これが公開データとなる（攻撃者はこの色を知っている）；
- アリスは秘密の色、ここでは赤を選び、2つを混ぜてオレンジにする；
- ボブも秘密の色、ここでは青を選び、黄色と混ぜて緑にする；
- そして、得られた色、オレンジと緑を交換する。この交換は、安全でない、観測されたネットワーク上で行われる；
- ボブの緑と彼の秘密の色を混ぜると、アリスは茶色を作り出す；
- ボブは、アリスのオレンジと彼女の秘密の青で同じことをして、茶色を得る。

![BTC204](assets/it/66/12.webp)

この単純化では、茶色はアリスとボブの間で共有される秘密を表す。現実には、攻撃者がオレンジ色と緑色を分離して、アリスやボブの秘密の色を発見することは不可能であることを理解することが重要である。

では、このプロトコルが実際にどのように機能するのか、色に例えるのではなく、実数とモジュラー演算を使って検証してみよう！

ディフィー・ヘルマン・メカニズムについて説明する前に、これから必要となる2つの重要な数学的概念を簡単に思い出していただきたい：


- 素数**とは、$1$とそれ自身の2つしか約数を持たない自然数のことである：とそれ自身である。例えば、$7$は$1$と$7$でしか割り切れないので素数である。一方、$8$は$1$、$2$、$4$、$8$で割り切れるので、素数ではない。したがって、$8$は2つではなく4つの正の整数の約数を持つ；
- mod**（$mod$または$%$と表記）は、2つの整数の間で、前者を後者でユークリッド除算した余りを返す数学演算である。例えば、$16 \bmod 5 = 1$である。

**AliceとBobの間のDiffie-Hellman鍵交換は以下のように行われる。


- p$は素数で、この数が大きいほどディフィー・ヘルマンの安全性は高くなる。g$は$p$の原始根である。g$は$p$の原始根である。これら2つの数は、安全でないネットワーク上でオープンに通信することができる。これらは上記の単純化における**黄色**に相当する。したがって、アリスとボブは$p$と$g$に全く同じ値を使うことが重要である。

これらのパラメータが定義されると、アリスとボブはそれぞれランダムな 秘密数を選ぶ。アリスは自分の乱数秘密数を $a$ (**色の赤** に相当) と呼び、ボブは自分の乱数秘密数を $b$ (**色の青*** に相当) と呼ぶ。これらの数字は厳重に秘密にしておかなければならない。

a$と$b$の数字を直接交換する代わりに、双方は$A$と$B$を次のように計算する：

A$は$g$を$a$のp$乗にしたものに等しい：

$$
A = g^a \bmod p
$$

B$は$p$を$b$乗した$g$に等しい：

$$
B = g^b \bmod p
$$

A$(**オレンジ色**に相当)と$B$(**緑色**に相当)の値が、両者の間で交換される。この交換は、セキュアでないネットワーク上でオープンに行うことができる；

B$を受け取ったアリスは、$z$の値を次のように計算する：

z$は$p$を$a$乗した$B$に等しい：

$$
z = B^a \bmod p
$$

リコールだ：

$$
B = g^b \bmod p
$$

したがって、こうなる：

$$
z = B^a \bmod p
$$

$$
z = (g^b)^a \bmod p
$$

指数の規則を適用する：

$$
(x^n)^m = x^{nm}
$$

こうして得られたのが

$$
z = g^{ba} \bmod p
$$


- A$を受け取ったボブ側も、次のように$z$の値を計算する：

z$ は $p$ を $b$ 乗した $A$ に等しい：

$$
z = A^b \bmod p
$$

したがって、こうなる：

$$
z = (g^a)^b \bmod p
$$

$$
z = g^{ab} \bmod p
$$

$$
z = g^{ba} \bmod p
$$

モジュロ演算子の分配性により、アリスとボブは全く同じ$z$の値を得る。この数値は二人の共通の秘密であり、先ほどの絵の具壺を使った簡略化における**茶色**に相当する。この共通の秘密を使って、安全でないネットワーク上の通信を対称的に暗号化することができる。

攻撃者は$p$、$g$、$A$、$B$（公開値）を持っていても、$a$、$b$、$z$（非公開値）を計算することはできない。なぜなら、それは離散対数、すなわち有限環状群における指数の逆数を計算することに等しいからである。

したがって、$a$、$b$、$p$の値が十分に大きい限り、ディフィー・ヘルマン・プロトコルは安全である。通常、2048ビットのパラメータ（10進数で600桁の数字）では、$a$と$b$のすべての可能性をテストすることは非現実的である。現在までのところ、このような数では、このアルゴリズムは安全であると考えられている。

ディフィー・ヘルマン・プロトコルの主な欠点はまさにここにある。安全であるためには、アルゴリズムは大きな数を使わなければならない。そのため現在では、代数曲線、より正確には楕円曲線に基づくDiffie-Hellmanの変種であるECDH（_Elliptic Curve Diffie-Hellman_）アルゴリズムが好まれている。このアプローチにより、同等のセキュリティを維持しながら、より小さな数を扱うことが可能になり、計算と保存に必要なリソースが削減される。

アルゴリズムの一般原理は変わらない。ただし、乱数$a$と、モジュラー指数法によって$a$から計算された 数$A$を使う代わりに、楕円曲線上で確立された鍵ペアを使う。モジュロ演算子の分配性に依存する代わりに、楕円曲線上の群法則、特にこの法則の連想性を利用する。

楕円曲線暗号の原理を簡単に説明すると、秘密鍵は$1$から$n-1$の間の乱数で表される。一方、公開鍵はこの曲線上の特定の点であり、生成点を始点とする点の加算・倍加演算によって、秘密鍵から式に従って得られる：

$$
K = k \cdot G
$$

この式において、$K$は公開鍵、$k$は秘密鍵、$G$は生成点を表す。

これらの鍵の本質的な特徴の一つは、$k$と$G$から$k$を計算するのが簡単なことである。この非対称性が一方向性関数を生み出す。言い換えれば、秘密鍵が分かれば公開鍵を計算するのは簡単だが、公開鍵から秘密鍵を見つけるのは不可能である。この安全性は、やはり離散対数の計算の難しさに依存している。

この性質を利用して、Diffie-Hellmanアルゴリズムを適応させる。 **ECDHの動作原理は以下の通りである。


- アリスとボブは暗号的に安全な楕円曲線とそのパラメータに合意する。この情報は公開される；
- アリスは秘密鍵となる乱数$ka$を生成する。この秘密鍵は秘密にしておかなければならない。彼女は、選んだ楕円曲線上の点の足し算と2倍算によって公開鍵$Ka$を決定する：

$$
K_a = k_a \cdot G
$$


- Bobはまた、自分の秘密鍵となる乱数$kb$を生成する。彼は関連する公開鍵$kb$を計算する：

$$
K_b = k_b \cdot G
$$


- アリスとボブは、安全でない公衆ネットワーク上で公開鍵$Ka$と$Kb$を交換する。
- アリスは、ボブの公開鍵$Kb$に自分の秘密鍵$ka$を適用することで、曲線上の点$(x,y)$を計算する：

$$
(x,y) = k_a \cdot K_b
$$


- ボブはアリスの公開鍵$Ka$に自分の秘密鍵$kb$を適用して、曲線上の点$(x,y)$を計算する：

$$
(x,y) = k_b \cdot K_a
$$


- アリスとボブは楕円曲線上の同じ点を得る。共有秘密はこの点の$x$座標となる。

実際、彼らは同じ共有秘密を手に入れる：

(x,y) = k_a ∕ K_b = k_a ∕ (k_b ∕ G) = (k_a ∕ k_b) ∕ G = (k_b ∕ k_a) ∕ (k_a ∕ G) = k_b ∕ K_a

$$
Un attaccante che osserva la rete pubblica non protetta può ottenere solo le chiavi pubbliche di ciascuna parte e i parametri della curva ellittica scelta. Come precedentemente spiegato, queste informazioni da sole non sono sufficienti per determinare le chiavi private. Pertanto, l'attaccante non può trovare il segreto condiviso tra Alice e Bob.
ECDH è quindi un algoritmo che consente lo scambio di chiavi. È spesso utilizzato in combinazione con altri metodi crittografici per stabilire un protocollo completo. Ad esempio, ECDH è integrato nel nucleo di TLS (_Transport Layer Security_), un protocollo di crittografia e autenticazione utilizzato per il livello di trasporto di Internet. TLS utilizza ECDHE per lo scambio di chiavi, una variante di ECDH dove le chiavi sono effimere, per garantire la confidenzialità persistente. Inoltre, TLS utilizza algoritmi di autenticazione come ECDSA, algoritmi di crittografia come AES e funzioni hash come SHA256.
TLS è notevolmente responsabile della `s` in `https` così come del lucchetto visibile nella barra degli indirizzi del tuo browser, simboli delle comunicazioni criptate. Seguendo questo corso, stai quindi utilizzando ECDH, ed è molto probabile che lo usi quotidianamente senza nemmeno saperlo.
### La Transazione di Notifica
Come abbiamo visto nella sezione precedente, ECDH è una variante dello scambio Diffie-Hellman che utilizza coppie di chiavi stabilite su una curva ellittica. Convenientemente, possediamo già molte coppie di chiavi aderenti a questo standard nei nostri portafogli Bitcoin! L'idea di BIP47 è di utilizzare le coppie di chiavi dei portafogli Bitcoin gerarchici deterministici di entrambe le parti per stabilire segreti condivisi ed effimeri tra di loro. Nel contesto di BIP47, viene utilizzato ECDHE (_Elliptic Curve Diffie-Hellman Ephemeral_).
ECDHE viene utilizzato per la prima volta in BIP47 per trasmettere il codice di pagamento dal mittente al destinatario. Questo è il famoso **notification transaction**. Questo passaggio è essenziale perché affinché BIP47 funzioni efficacemente, entrambe le parti coinvolte (il mittente e il destinatario) devono conoscere il codice di pagamento dell'altro. Questa conoscenza consente la derivazione di chiavi pubbliche effimere e, di conseguenza, indirizzi di ricezione vuoti associati.
Prima di questo scambio, il mittente è logicamente già a conoscenza del codice di pagamento del destinatario poiché lo ha recuperato off-chain, ad esempio, dal loro sito web, una fattura o i loro social media. Tuttavia, il destinatario potrebbe non conoscere necessariamente il codice di pagamento del mittente. Eppure, questo codice deve essere trasmesso a loro; altrimenti, non saranno in grado di derivare le chiavi effimere necessarie per identificare gli indirizzi dove sono conservati i loro bitcoin, né accedere ai loro fondi. Sebbene questa trasmissione del codice del mittente possa tecnicamente essere effettuata off-chain attraverso altri mezzi di comunicazione, ciò pone un problema se il portafoglio deve essere recuperato solo dal seme.
Infatti, a differenza degli indirizzi convenzionali, gli indirizzi BIP47 non sono derivati direttamente dal seed del destinatario—utilizzare un `xpub` sarebbe più semplice in questo caso—ma risultano da un calcolo che combina i codici di pagamento di entrambi: quello del mittente e quello del destinatario. Pertanto, se il destinatario perde il proprio portafoglio e tenta di ripristinarlo dal proprio seed, recupererà il proprio codice di pagamento, che è derivato direttamente dal loro seed. Tuttavia, per trovare gli indirizzi effimeri, sarà essenziale per loro avere anche i codici di pagamento di tutti coloro che hanno inviato loro bitcoin tramite BIP47. Da qui l'importanza della transazione di notifica, che consente di salvare queste informazioni sulla blockchain di Bitcoin, pur essendo in grado di trovarle molto facilmente senza dover cercare tra il miliardo di transazioni eseguite dal suo lancio nel 2009.
![BTC204](assets/it/66/15.webp)
Pertanto, sarebbe possibile implementare BIP47 senza ricorrere alla transazione di notifica, a condizione che ogni utente conservi un backup dei codici di pagamento dei propri pari. Tuttavia, questo metodo si rivela complesso da gestire finché non viene sviluppata una soluzione semplice, robusta ed efficiente per creare, conservare e aggiornare questi backup. Nello stato attuale delle cose, la transazione di notifica diventa quasi indispensabile.
Nei capitoli seguenti, studieremo altri protocolli con obiettivi simili a quelli di BIP47, ma che non richiedono una transazione di notifica. Queste alternative, tuttavia, introducono i propri compromessi.
Oltre al suo ruolo nel backup dei codici di pagamento, la transazione di notifica serve anche una funzione di notifica per il destinatario, come suggerisce il suo nome. Segnala al client del destinatario che è stato stabilito un nuovo canale di pagamento e suggerisce quindi di monitorare gli indirizzi effimeri risultanti.
### Il Modello di Privacy di BIP47
Prima di dettagliare il funzionamento tecnico della transazione di notifica, è importante discutere il modello di privacy associato a BIP47, che giustifica alcune misure prese durante la creazione di questa transazione iniziale.
Il codice di pagamento, di per sé, non rappresenta un rischio diretto per la privacy. A differenza del modello Bitcoin tradizionale, che mira a rompere il collegamento tra l'identità di un utente e le sue transazioni (che sono pubbliche) preservando l'anonimato di chiavi e indirizzi, il codice di pagamento può essere apertamente associato a un'identità senza rappresentare una minaccia.
Infatti, il codice di pagamento non è utilizzato per derivare direttamente gli indirizzi che ricevono pagamenti BIP47. Questi indirizzi sono invece generati attraverso l'applicazione di ECDH tra le chiavi derivate dai codici di pagamento delle due parti coinvolte.
Così, un codice di pagamento di per sé non porta direttamente a una perdita di privacy, poiché solo l'indirizzo di notifica è derivato da esso. Sebbene questo indirizzo possa rivelare alcune informazioni, normalmente non consente di scoprire le parti con cui si stanno conducendo transazioni, a meno che non si effettui un'analisi approfondita della catena. Infatti, se il mittente utilizza UTXO che possono essere collegati alla loro identità per eseguire la transazione di notifica, allora diventa possibile dedurre che la loro identità è probabilmente collegata ai pagamenti BIP47 al tuo codice di pagamento. Questo non rivelerà le transazioni sottostanti, ma indicherà la loro probabile esistenza.
Pertanto, è essenziale mantenere questa stretta separazione tra i codici di pagamento degli utenti. Verso questo obiettivo, il passo iniziale di comunicazione del codice è un momento critico per la privacy del pagamento, ma obbligatorio per il corretto funzionamento del protocollo. Se uno dei codici di pagamento può essere ottenuto pubblicamente (come su un sito web), il secondo codice, quello del mittente, non deve essere collegato al primo in nessun caso.
Prendiamo un esempio concreto: voglio fare una donazione a un movimento politico tramite BIP47:
- L'organizzazione ha reso pubblico il suo codice di pagamento sul suo sito web o tramite i suoi social network;
- Questo codice è quindi collegato al movimento politico;
- Recupero questo codice di pagamento;
- Prima di procedere con un invio, devo assicurarmi che conoscano il mio codice di pagamento, che è anche collegato alla mia identità poiché lo uso per ricevere transazioni sui miei social network.
Come trasmettere il mio codice senza rischi? L'uso di mezzi di comunicazione convenzionali potrebbe portare a una fuga di informazioni e, di conseguenza, associarmi a questo movimento politico. La transazione di notifica offre una soluzione grazie a uno strato di crittografia che impedisce precisamente questa associazione tra due codici. Sebbene questo non sia l'unico metodo per trasmettere segretamente il codice di pagamento del mittente, si dimostra molto efficace.
Nel diagramma sottostante, le linee arancioni indicano i punti in cui il flusso di informazioni deve essere interrotto, e le frecce nere mostrano le connessioni che potrebbero potenzialmente essere osservate da terze parti:
![BTC204](assets/it/66/16.webp)
In realtà, all'interno del modello tradizionale di privacy di Bitcoin, è spesso complesso dissociare completamente il flusso di informazioni tra la coppia di chiavi e l'utente, specialmente durante le transazioni a distanza. Ad esempio, nel contesto di una campagna di donazione, il destinatario deve inevitabilmente divulgare un indirizzo o una chiave pubblica tramite il loro sito web o social network. L'uso corretto di BIP47, in particolare con la transazione di notifica, permette di aggirare questo problema grazie a ECDHE e allo strato di crittografia che studieremo ulteriormente.
Ovviamente, il modello classico di privacy di Bitcoin si applica ancora alle chiavi pubbliche effimere, che sono derivate dalla combinazione dei due codici di pagamento. I due modelli sono in realtà complementari. Quello che voglio evidenziare qui è che, contrariamente all'uso abituale di una chiave pubblica per ricevere bitcoin, il codice di pagamento può essere collegato a una specifica identità, perché l'informazione "_Alice effettua una transazione con Bob_" viene interrotta in un'altra fase. Il codice di pagamento viene utilizzato per generare indirizzi di pagamento, ma basandosi unicamente sull'osservazione della blockchain, è impossibile collegare una transazione di pagamento BIP47 ai codici di pagamento utilizzati per eseguirla, a meno che gli UTXO coinvolti non fossero già collegati a un'identità precedentemente e gli utenti non abbiano associato i loro codici di pagamento alle rispettive identità.
Per riassumere, il modello di privacy offerto dai pagamenti BIP47 potrebbe essere considerato superiore a quello della base di Bitcoin, anche se non è magico in alcun modo.
### Costruzione della Transazione di Notifica
Ora, vediamo come funziona questa transazione di notifica. Immaginiamo che Alice voglia inviare fondi a Bob con BIP47. Nel mio esempio, Alice agisce come mittente e Bob come destinatario. Quest'ultimo ha pubblicato il suo codice di pagamento sul suo sito web. Pertanto, Alice è già a conoscenza del codice di pagamento di Bob.
**1- Alice calcola un segreto condiviso con ECDH:**
- Seleziona una coppia di chiavi dal suo portafoglio HD situato su un ramo diverso dal suo codice di pagamento. Nota, questa coppia non dovrebbe essere facilmente associata all'indirizzo di notifica di Alice, né all'identità di Alice (vedi sezione precedente);
- Alice seleziona la chiave privata da questa coppia. La chiamiamo $a$ (minuscolo);
$$

a

$$
```text
- Alice recupera la chiave pubblica associata all'indirizzo di notifica di Bob. Questa chiave è la prima figlia derivata dal codice di pagamento di Bob (indice $/0$). Chiamiamo questa chiave pubblica $B$ (maiuscolo). La chiave privata associata a questa chiave pubblica è chiamata $b$ (minuscolo). $B$ è determinata dall'addizione e dal raddoppio dei punti sulla curva ellittica da $G$ (il punto generatore) con $b$ (la chiave privata):
$$ B = b \cdot G $$
- Alice calcola un punto segreto $S$ (maiuscolo) sulla curva ellittica tramite l'addizione e il raddoppio dei punti applicando la sua chiave privata $a$ dalla chiave pubblica di Bob $B$.
$$ S = a \cdot B $$
- Alice calcola il fattore di oscuramento $f$ che le permetterà di criptare il suo codice di pagamento. Per fare ciò, determinerà un numero pseudo-casuale con la funzione HMAC-SHA512. Nel secondo input di questa funzione, utilizza un valore che solo Bob potrà recuperare: $x$ che è l'ascissa del punto segreto precedentemente calcolato. Il primo input è $o$ che è l'UTXO consumato in input di questa transazione (outpoint).
$$ f = \text{HMAC-SHA512}(o, x) $$
**2- Alice converte il suo codice di pagamento personale in base 2 (binario).**
**3- Utilizza questo fattore di oscuramento come chiave per eseguire la crittografia simmetrica sul payload del suo codice di pagamento.** L'algoritmo di crittografia utilizzato è semplicemente un `XOR`. L'operazione eseguita è paragonabile alla cifratura di Vernam, anche denominata "One-Time Pad".
- Alice prima divide il suo fattore di oscuramento in due: i primi 32 byte sono denominati $f1$ e gli ultimi 32 byte sono denominati $f2$. Quindi, abbiamo:
$$ f = f1 || f2 $$
- Alice calcola l'$x'$ criptato dell'ascissa della chiave pubblica $x$ del suo codice di pagamento, e il $c'$ criptato del suo codice catena $c$ separatamente. $f1$ e $f2$ agiscono rispettivamente come chiavi di crittografia. L'operazione utilizzata è il `XOR` (o esclusivo).
$$ x' = x \oplus f1 $$
$$ c' = c \oplus f2 $$
- Alice sostituisce i valori reali dell'ascissa della chiave pubblica $x$ e del codice catena $c$ nel suo codice di pagamento con i valori criptati $x'$ e $c'$.
**4-** Alice ora ha il suo codice di pagamento con un payload criptato. Costruirà e trasmetterà una transazione che coinvolge la sua chiave pubblica $A$ come input, un output all'indirizzo di notifica di Bob, e un output `OP_RETURN` contenente il suo codice di pagamento con il payload criptato. **Questa transazione è la transazione di notifica**.
Un `OP_RETURN` è un opcode che segna un output di una transazione Bitcoin come non valido. Oggi, è utilizzato per trasmettere o ancorare informazioni sulla blockchain di Bitcoin. Fino a 80 byte di dati possono essere memorizzati, che sono scritti sulla catena e quindi visibili a tutti gli altri utenti.
Come abbiamo visto nelle sezioni precedenti, ECDH è utilizzato per generare un segreto condiviso tra due utenti che comunicano su una rete non sicura, potenzialmente osservata da attaccanti. In BIP47, ECDH è utilizzato per la comunicazione sulla rete Bitcoin, che per sua natura è una rete di comunicazione trasparente osservata da molti attaccanti. Il segreto condiviso calcolato tramite lo scambio di chiavi ECDH è poi utilizzato per criptare le informazioni segrete da trasmettere: il codice di pagamento del mittente (di Alice).
Ricapitoliamo i passaggi che abbiamo appena esaminato insieme per eseguire una transazione di notifica:
- Alice recupera il codice di pagamento e l'indirizzo di notifica di Bob;
- Alice seleziona un UTXO che possiede nel suo portafoglio HD con la corrispondente coppia di chiavi;
- Calcola un punto segreto sulla curva ellittica utilizzando ECDH;
- Utilizza questo punto segreto per calcolare un HMAC, che è il fattore di oscuramento;
- Utilizza questo fattore di oscuramento per criptare il payload del suo codice di pagamento personale.
- Lei utilizza un output di transazione `OP_RETURN` per comunicare il codice di pagamento mascherato a Bob.
![BTC204](assets/it/66/17.webp)
### Transazione di Notifica: Studio Concreto
Per comprendere meglio il suo funzionamento, in particolare l'uso di `OP_RETURN`, esaminiamo insieme una vera transazione di notifica. Ho eseguito tale transazione sulla testnet, che potete trovare [cliccando qui](https://mempool.space/fr/testnet/tx/0e2e4695a3c49272ef631426a9fd2dae6ec3a469e3a39a3db51aa476cd09de2e).
![BTC204](assets/fr/227.webp)
Osservando questa transazione, possiamo vedere che ha un singolo input e 4 output:
- Il primo output è l'`OP_RETURN` che contiene il mio codice di pagamento mascherato;
- Il secondo output di 546 sats punta all'indirizzo di notifica del mio destinatario;
- Il terzo output di 15.000 sats rappresenta le commissioni di servizio, poiché ho utilizzato Samourai Wallet per costruire questa transazione;
- Il quarto output di 2 milioni di sats rappresenta il resto, ovvero la differenza rimanente dal mio input che ritorna a un altro indirizzo che mi appartiene.
Il più interessante da studiare è ovviamente l'output 0 che utilizza l'`OP_RETURN`. Vediamo più da vicino cosa contiene. Ecco lo `scriptPubKey` in esadecimale:
6a4c50010002b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d800000000000000000000000000
```

```text
In questo script, possiamo sezionare diverse parti. Prima di tutto, gli opcode:
6a4c
```

```text
Tra gli opcode, possiamo riconoscere `0x6a` che designa l'`OP_RETURN` e `0x4c` che designa l'`OP_PUSHDATA1`.
Il byte seguente questo ultimo opcode indica la dimensione del payload che segue. Indica `0x50`, ovvero 80 byte:
6a4c50
```

```text
Poi, abbiamo i metadati del mio codice di pagamento in chiaro:
010002
```

```text
La coordinata x criptata della chiave pubblica del mio codice di pagamento:
b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164
```

```text
Il codice catena criptato del mio codice di pagamento:
927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d8
```

```text
E infine, il padding per raggiungere 80 byte, la dimensione standard di un `OP_RETURN`:
00000000000000000000000000
```

```
Per capire meglio, ecco il mio codice di pagamento in chiaro in base 58:
````text
PM8TJQCyt6ovbozreUCBrfKqmSVmTzJ5vjqse58LnBzKFFZTwny3KfCDdwTqAEYVasn11tTMPc2FJsFygFd3YzsHvwNXLEQNADgxeGnMK8Ugmin62TZU
Quando si confronta il mio codice di pagamento in chiaro con l'`OP_RETURN`, è evidente che l'HRP (`0x47`) e il checksum (`0x8604e4db`) non vengono trasmessi. Questo è previsto, poiché queste informazioni sono destinate agli esseri umani.
Successivamente, possiamo identificare la versione (`0x01`), il campo di bit (`0x00`) e la parità della chiave pubblica (`0x02`). E, alla fine del codice di pagamento, i byte vuoti (`0x00000000000000000000000000`) sono utilizzati per riempire il codice fino a un totale di 80 byte. Tutti questi metadati vengono trasmessi in chiaro (non criptati).
Infine, si può osservare che la coordinata x della chiave pubblica (`0x77507c9c17a89cfca2d3af554745d6c2db0e7f6b2721a3941a504933103cc42a`) e il codice catena (`0xdd94881210d6e752a9abc8a9fa0070e85184993c4f643f1121dd807dd556d1dc`) sono stati criptati. Questo costituisce il payload del codice di pagamento.
### Cos'è XOR?
Nelle sezioni precedenti, abbiamo visto che il codice di pagamento è stato trasmesso criptato utilizzando l'operazione XOR. Prendiamoci un momento per capire come funziona questo operatore, poiché è ampiamente utilizzato nella crittografia.
XOR è un operatore logico bit a bit basato sull'algebra booleana. Con due operandi bit, restituisce `1` se i bit dello stesso rango sono diversi, e restituisce `0` se i bit dello stesso rango sono uguali. Ecco la tabella di verità di XOR basata sui valori degli operandi `D` e `E`:
| D   | E   | D XOR E |
| --- | --- | ------- |
| 0   | 0   | 0       |
| 0   | 1   | 1       |
| 1   | 0   | 1       |
| 1   | 1   | 0       |
Per esempio:
$$

$$
0110 \oplus 1110 = 1000
Oppure:
$$

$$
010011 \oplus 110110 = 100101
Con ECDH, l'uso di XOR come strato di crittografia è particolarmente adatto. Innanzitutto, a causa di questo operatore, la crittografia è simmetrica. Questo consente al destinatario di decifrare il codice di pagamento con la stessa chiave utilizzata per la crittografia. La chiave di crittografia e decrittografia viene calcolata dal segreto condiviso grazie a ECDH. Questa simmetria è resa possibile dalle proprietà commutativa e associativa dell'operatore XOR:
- Altre proprietà:
$$

$$
D \oplus D = 0
D ⊕ 0 = D
- Commutatività:
$$

$$
D \oplus E = E \oplus D
- Associatività:
$$

$$
D \oplus (E \oplus Z) = (D \oplus E) \oplus Z = D \oplus E \oplus Z
Se:
$$

$$
D \oplus E = L
Allora:
$$

$$
D \oplus L = D \oplus (D \oplus E) = D \oplus D \oplus E = 0 \oplus E = E \\
\therefore D \oplus L = E
Successivamente, questo metodo di cifratura assomiglia molto al cifrario di Vernam (One-Time Pad), l'unico algoritmo di cifratura conosciuto fino ad oggi che possiede sicurezza incondizionata (o assoluta). Affinché il cifrario di Vernam abbia questa caratteristica, la chiave di cifratura deve essere perfettamente casuale, deve essere della stessa dimensione del messaggio e deve essere utilizzata una sola volta. Nel metodo di cifratura utilizzato qui per BIP47, la chiave è effettivamente della stessa dimensione del messaggio, il fattore di offuscamento è esattamente della stessa dimensione della concatenazione della coordinata x della chiave pubblica con il codice catena del codice di pagamento. Questa chiave di cifratura è effettivamente utilizzata una sola volta. Tuttavia, questa chiave non è il risultato di una casualità perfetta poiché è un HMAC. È piuttosto pseudo-casuale. Pertanto, non si tratta di un cifrario di Vernam, ma il metodo è simile.
### Ricezione della Transazione di Notifica
Ora che Alice ha inviato la transazione di notifica a Bob, vediamo come lui la interpreta. Come promemoria, Bob deve essere in grado di accedere al codice di pagamento di Alice. Senza queste informazioni, come vedremo nella sezione seguente, non sarà in grado di derivare le coppie di chiavi create da Alice e, quindi, non sarà in grado di accedere ai suoi bitcoin ricevuti tramite BIP47. Per ora, il payload del codice di pagamento di Alice è criptato. Vediamo come Bob lo decifra.
**1-** Bob monitora le transazioni che creano output con il suo indirizzo di notifica.
**2-** Quando una transazione ha un output sul suo indirizzo di notifica, Bob la analizza per vedere se contiene un output OP_RETURN che segue lo standard BIP47.
**3-** Se il primo byte del payload OP_RETURN è `0x01`, Bob inizia la sua ricerca di un possibile segreto condiviso con ECDH:
- Bob seleziona la chiave pubblica nell'input della transazione. Ovvero, la chiave pubblica di Alice denominata $A$ con:
$$ A = a \cdot G $$
- Bob seleziona la chiave privata $b$ associata al suo indirizzo di notifica personale:
$$ b $$
- Bob calcola il punto segreto $S$ (segreto condiviso ECDH) sulla curva ellittica sommando e raddoppiando i punti, applicando la sua chiave privata $b$ alla chiave pubblica di Alice $A$:
$$ S = b \cdot A $$
- Bob determina il fattore di offuscamento $f$ che gli permetterà di decifrare il payload del codice di pagamento di Alice. Nello stesso modo in cui Alice aveva precedentemente calcolato, Bob troverà $f$ applicando HMAC-SHA512 su $x$ la coordinata x del punto segreto $S$, e su $o$ l'UTXO consumato come input in questa transazione di notifica:
$$ f = \text{HMAC-SHA512}(o, x) $$
**4-** Bob interpreta i dati nell'OP_RETURN della transazione di notifica come un codice di pagamento. Egli semplicemente decifra il payload di questo potenziale codice di pagamento usando il fattore di offuscamento $f$:
- Bob divide il fattore di offuscamento $f$ in 2 parti: i primi 32 byte di $f$ saranno $f1$ e gli ultimi 32 byte saranno $f2$;
- Bob decifra la coordinata x cifrata $x'$ della chiave pubblica dal codice di pagamento di Alice:
$$ x = x' \oplus f1 $$
- Bob decifra il valore del codice catena cifrato $c'$ dal codice di pagamento di Alice:
$$ c = c' \oplus f2 $$
**5-** Bob verifica se il valore della chiave pubblica dal codice di pagamento di Alice è effettivamente parte del gruppo secp256k1. Se è così, lo interpreta come un codice di pagamento valido. Altrimenti, ignora questa transazione.
Ora che Bob è a conoscenza del codice di pagamento di Alice, lei può inviargli fino a `2^32` pagamenti, senza mai dover effettuare un'altra transazione di notifica di questo tipo.
Perché funziona? Come fa Bob a determinare lo stesso fattore di offuscamento di Alice, e quindi a decifrare il suo codice di pagamento? Esaminiamo più da vicino il ruolo di ECDH in quello che abbiamo appena descritto.
Prima di tutto, stiamo trattando con la crittografia simmetrica. Questo significa che la chiave di cifratura e la chiave di decifratura sono lo stesso valore. Questa chiave nella transazione di notifica è il fattore di offuscamento:
$$ f = f1 || f2 $$
Pertanto, Alice e Bob devono ottenere lo stesso valore per $f$, senza trasmetterlo direttamente poiché un attaccante potrebbe rubarlo e decifrare le informazioni segrete. Questo fattore di offuscamento si ottiene applicando HMAC-SHA512 su 2 valori:
- la coordinata x di un punto segreto;
- e l'UTXO consumato come input nella transazione.
Bob, quindi, ha bisogno di queste due informazioni per decifrare il payload del codice di pagamento di Alice. Per l'UTXO come input, Bob può semplicemente recuperarlo osservando la transazione di notifica. Per il punto segreto, Bob dovrà usare ECDH. Come visto nella sezione precedente su Diffie-Hellman, semplicemente scambiando le rispettive chiavi pubbliche e applicando segretamente le proprie chiavi private alla chiave pubblica dell'altro, Alice e Bob possono trovare un punto specifico e segreto sulla curva ellittica. La transazione di notifica si basa su questo meccanismo:
- Coppia di chiavi di Bob:
$$ B = b \cdot G $$
- Coppia di chiavi di Alice:
$$ A = a \cdot G $$
- Per un segreto $S (x, y)$:
$$ S = a \cdot B = a \cdot (b \cdot G) = (b \cdot a) \cdot G = b \cdot A $$
Ora che Bob conosce il codice di pagamento di Alice, sarà in grado di rilevare i suoi pagamenti BIP47, e può derivare le chiavi private che bloccano i bitcoin ricevuti.
Ricapitoliamo i passaggi che abbiamo appena esaminato per ricevere e interpretare una transazione di notifica:
- Bob monitora gli output delle transazioni al suo indirizzo di notifica;
- Quando ne rileva uno, recupera le informazioni contenute nell'OP_RETURN;
- Bob seleziona la chiave pubblica in input e calcola un punto segreto usando ECDH;
- Usa questo punto segreto per calcolare un HMAC che è il fattore di offuscamento;
- Usa questo fattore di offuscamento per decifrare il payload del codice di pagamento di Alice contenuto nell'OP_RETURN.
### La Transazione di Pagamento BIP47
Studiamo ora insieme il processo di pagamento con BIP47. Per ricordarvi lo stato attuale delle cose:
- Alice conosce il codice di pagamento di Bob, che ha semplicemente recuperato dal suo sito web;
- Bob conosce il codice di pagamento di Alice grazie alla transazione di notifica;
- Alice effettuerà un primo pagamento a Bob. Potrà effettuarne molti altri allo stesso modo.
Prima di spiegare questo processo, penso sia importante ricordare gli indici su cui stiamo attualmente lavorando. Il percorso di derivazione di un codice di pagamento è descritto come segue: `m/47'/0'/0'`. La profondità successiva distribuisce gli indici in questo modo:
- La prima coppia di chiavi figlio normali (non rinforzate) è quella utilizzata per generare l'indirizzo di notifica di cui abbiamo parlato nella parte precedente: `m/47'/0'/0'/0`;
- Le coppie di chiavi figlio normali sono utilizzate all'interno di ECDH per generare indirizzi di ricezione dei pagamenti BIP47 come vedremo in questa sezione: da `m/47'/0'/0'/0` a `m/47'/0'/0'/2 147 483 647`;
- Le coppie di chiavi figlio rinforzate sono codici di pagamento effimeri: da `m/47'/0'/0'/0'` a `m/47'/0'/0'/2 147 483 647'`.
Ogni volta che Alice desidera inviare un pagamento a Bob, deriva un nuovo indirizzo vergine unico, grazie ancora al protocollo ECDH:
- Alice seleziona la prima chiave privata derivata dal suo codice di pagamento personale riutilizzabile:
$$ a $$
- Alice seleziona la prima chiave pubblica inutilizzata derivata dal codice di pagamento di Bob. Questa chiave pubblica, la chiameremo $B$. È associata alla chiave privata $b$ che solo Bob conosce:
$$ B = b \cdot G $$
- Alice calcola un punto segreto $S$ sulla curva ellittica tramite addizione e raddoppio di punti applicando la sua chiave privata $a$ alla chiave pubblica $B$ di Bob:
$$ S = a \cdot B $$
- Da questo punto segreto, Alice calcolerà il segreto condiviso $s$ (minuscolo). Per fare ciò, seleziona la coordinata x del punto segreto $S$ denominata $Sx$, e passa questo valore attraverso la funzione hash SHA256:
$$ S = (Sx, Sy) $$
$$ s = \text{SHA256}(Sx) $$
- Alice utilizza questo segreto condiviso $s$ per calcolare un indirizzo Bitcoin di ricezione dei pagamenti. Inizialmente, verifica che $s$ sia contenuto nell'ordine della curva secp256k1. In caso contrario, incrementa l'indice della chiave pubblica di Bob per derivare un altro segreto condiviso;
- In secondo luogo, calcola una chiave pubblica $K0$ aggiungendo sulla curva ellittica i punti $B$ e $s·G$. In altre parole, Alice aggiunge la chiave pubblica derivata dal codice di pagamento di Bob $B$ con un altro punto calcolato sulla curva ellittica tramite addizione e raddoppio con il segreto condiviso $s$ dal punto generatore della curva secp256k1 $G$. Questo nuovo punto rappresenta una chiave pubblica, e lo chiamiamo $K0$:
$$ K0 = B + s \cdot G $$
- Con questa chiave pubblica $K0$, Alice può derivare un indirizzo vergine standard di ricezione (per esempio, SegWit V0 in bech32).
Una volta che Alice ha ottenuto l'indirizzo di ricezione di Bob $K0$, può eseguire una transazione Bitcoin in modo standard. Per fare ciò, seleziona un UTXO di sua proprietà, assicurato da una coppia di chiavi di un ramo diverso del suo portafoglio HD, e lo spende per soddisfare un output all'indirizzo di Bob $K0$. È importante notare che questo pagamento, una volta derivato l'indirizzo, segue un processo convenzionale e non dipende più dalle chiavi associate a BIP47.
Ricapitoliamo i passaggi che abbiamo appena eseguito insieme per inviare un pagamento BIP47:
- Alice seleziona la prima chiave privata derivata dal suo codice di pagamento personale;
- Calcola un punto segreto sulla curva ellittica utilizzando ECDH dalla prima chiave pubblica derivata non utilizzata dal codice di pagamento di Bob;
- Utilizza questo punto segreto per calcolare un segreto condiviso con SHA256;
- Utilizza questo segreto condiviso per calcolare un nuovo punto segreto sulla curva ellittica;
- Aggiunge questo nuovo punto segreto alla chiave pubblica di Bob;
- Ottiene una nuova chiave pubblica effimera per la quale solo Bob ha la chiave privata associata;
- Alice può effettuare una transazione standard a Bob con l'indirizzo di ricezione effimero derivato.
![BTC204](assets/it/66/21.webp)
Se Alice desidera effettuare un secondo pagamento, seguirà gli stessi passaggi di prima, eccetto che questa volta selezionerà la seconda chiave pubblica derivata dal codice di pagamento di Bob. Specificamente, utilizzerà la prossima chiave non utilizzata. Otterrà così un nuovo indirizzo di ricezione appartenente a Bob, designato $K1$:
![BTC204](assets/it/66/22.webp)
Può continuare in questo modo e derivare fino a `2^32` indirizzi non utilizzati appartenenti a Bob.
Da un punto di vista esterno, osservando la blockchain, è teoricamente impossibile differenziare un pagamento BIP47 da un pagamento standard. Ecco un esempio di transazione di pagamento BIP47 sul Testnet:
```

94b2e59510f2e1fa78411634c98a77bbb638e28fb2da00c9f359cd5fc8f87254
````
Questo sembra una transazione standard con un input consumato, un output di pagamento e un resto:
![BTC204](assets/fr/232.webp)
### Ricevere il Pagamento BIP47 e Derivare la Chiave Privata
Alice ha appena effettuato il suo primo pagamento a un nuovo indirizzo BIP47 appartenente a Bob. Ora vediamo come Bob riceve questo pagamento. Vedremo anche perché Alice non ha accesso alla chiave privata dell'indirizzo che ha appena generato da sola, e come Bob recupera questa chiave per spendere i bitcoin che ha appena ricevuto.
Non appena Bob riceve la transazione di notifica da Alice, deriva la chiave pubblica BIP47 $K0$ anche prima che lei abbia inviato qualsiasi pagamento. Poi monitora qualsiasi pagamento all'indirizzo associato. Infatti, deriva immediatamente diversi indirizzi che monitorerà ($K0$, $K1$, $K2$, $K3$...). Ecco come deriva questa chiave pubblica $K0$:
- Bob seleziona la prima chiave privata derivata dal suo codice di pagamento. Questa chiave privata è denominata $b$. È associata alla chiave pubblica $B$ con cui Alice aveva fatto i suoi calcoli nel passaggio precedente:
$$ b $$
- Bob seleziona la prima chiave pubblica di Alice derivata dal suo codice di pagamento. Questa chiave è denominata $A$. È associata alla chiave privata $a$ con cui Alice aveva fatto i suoi calcoli, e di cui solo Alice è a conoscenza. Bob può eseguire questo processo poiché è a conoscenza del codice di pagamento di Alice che le è stato trasmesso con la transazione di notifica:
$$ A = a \cdot G $$
- Bob calcola il punto segreto $S$, mediante addizione e raddoppio di punti sulla curva ellittica, applicando la sua chiave privata $b$ alla chiave pubblica di Alice $A$. Qui troviamo l'uso di ECDH che garantisce che questo punto $S$ sarà lo stesso sia per Bob che per Alice:
$$ S = b \cdot A $$
- Proprio come ha fatto Alice, Bob isola la coordinata x di questo punto $S$. Abbiamo chiamato questo valore $Sx$. Egli passa questo valore attraverso la funzione SHA256 per trovare il segreto condiviso $s$ (minuscolo):
$$ s = \text{SHA256}(Sx) $$
- Proprio come Alice, Bob calcola il punto $s·G$ sulla curva ellittica. Poi, aggiunge questo punto segreto alla sua chiave pubblica $B$. Ottiene così un nuovo punto sulla curva ellittica che interpreta come una chiave pubblica $K0$:
$$ K0 = B + s \cdot G $$
Una volta che Bob ha questa chiave pubblica $K0$, può derivare la chiave privata associata per essere in grado di spendere i suoi bitcoin. È l'unico che può generare questa chiave privata:
- Bob aggiunge la sua chiave privata figlio $b$ derivata dal suo codice di pagamento personale. È l'unico che può ottenere il valore di $b$. Poi, aggiunge $b$ con il segreto condiviso $s$ per ottenere $k0$, la chiave privata di $K0$:
$$ k0 = b + s $$
Grazie alla legge di gruppo della curva ellittica, Bob ottiene esattamente la chiave privata corrispondente alla chiave pubblica usata da Alice. Abbiamo quindi:
$$ K0 = k0 \cdot G $$
Riassumerò i passaggi che abbiamo appena esaminato insieme per ricevere un pagamento BIP47 e calcolare la chiave privata corrispondente:
- Bob seleziona la prima chiave privata figlio derivata dal suo codice di pagamento personale;
- Calcola un punto segreto sulla curva ellittica usando ECDH dalla prima chiave pubblica figlio derivata dal codice catena di Alice;
- Usa questo punto segreto per calcolare un segreto condiviso con SHA256;
- Usa questo segreto condiviso per calcolare un nuovo punto segreto sulla curva ellittica;
- Aggiunge questo nuovo punto segreto alla sua chiave pubblica personale;
- Ottiene una nuova chiave pubblica effimera, alla quale Alice invierà il suo primo pagamento;
- Bob calcola la chiave privata associata a questa chiave pubblica effimera aggiungendo la sua chiave privata figlio derivata dal suo codice di pagamento e il segreto condiviso.
![BTC204](assets/it/66/24.webp)
Poiché Alice non può ottenere $b$ (la chiave privata di Bob), lei non è in grado di determinare $k0$ (la chiave privata associata all'indirizzo di ricezione BIP47 di Bob). Schematicamente, possiamo rappresentare il calcolo del segreto condiviso $S$ così:
![BTC204](assets/it/66/19.webp)
Una volta trovato il segreto condiviso con ECDH, Alice e Bob calcolano la chiave pubblica di pagamento BIP47 $K0$, e Bob calcola anche la chiave privata associata $k0$:
![BTC204](assets/it/66/25.webp)
### Rimborsare il Pagamento BIP47
Poiché Bob è a conoscenza del codice di pagamento riutilizzabile di Alice, ha già tutte le informazioni necessarie per inviarle un rimborso. Non avrà bisogno di contattare nuovamente Alice per chiedere informazioni. Dovrà semplicemente notificarla con una transazione di notifica, specialmente affinché lei possa recuperare i suoi indirizzi BIP47 con il suo seed, e poi potrà anche inviarle fino a `2^32` pagamenti.
La funzionalità di rimborso è specifica per BIP47 ed è uno dei suoi vantaggi rispetto ad altri metodi che studieremo nei prossimi capitoli, come i Pagamenti Silenziosi.
Bob può quindi rimborsare Alice nello stesso modo in cui lei gli ha inviato i pagamenti. I ruoli si invertono:
![BTC204](assets/it/66/26.webp)
_Un grande ringraziamento a [Fanis Michalakis](https://x.com/FanisMichalakis) per la sua revisione e preziosi consigli esperti sull'articolo che ha ispirato la scrittura di questo capitolo!_
https://planb.network/tutorials/privacy/on-chain/paynym-bip47-a492a70b-50eb-4f95-a766-bae2c5535093
## Pagamenti Silenziosi
<chapterId>2871d594-414e-4598-a830-91c9eb84dfb8</chapterId>
Il BIP47 è stato criticato per la sua inefficienza sulla blockchain. Come spiegato nel capitolo precedente, richiede una transazione di notifica per ogni nuovo destinatario. Questo vincolo diventa trascurabile se si prevede di stabilire un canale di pagamento duraturo con questo destinatario. Infatti, una singola transazione di notifica apre la strada a un numero quasi infinito di pagamenti BIP47 successivi.
Tuttavia, in determinate situazioni, la transazione di notifica può rappresentare un ostacolo per l'utente. Prendiamo l'esempio di una donazione una tantum a un destinatario: con un indirizzo Bitcoin classico, una singola transazione è sufficiente per effettuare la donazione. Ma con il BIP47, sono necessarie due transazioni: una per la notifica e un'altra per il pagamento effettivo. Quando la domanda di spazio nel blocco è bassa e le commissioni di transazione sono minime, questo passaggio aggiuntivo generalmente non rappresenta un problema. Tuttavia, durante i periodi di congestione, le commissioni di transazione possono diventare esorbitanti per un singolo pagamento, potenzialmente raddoppiando il costo per l'utente rispetto a una transazione Bitcoin standard, il che può essere inaccettabile per l'utente.
Per situazioni in cui l'utente prevede di effettuare solo pochi pagamenti a un identificatore statico, sono state sviluppate altre soluzioni. Tra queste ci sono i Pagamenti Silenziosi, descritti nel [BIP352](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki). Questo protocollo consente l'uso di un identificatore statico per ricevere pagamenti senza generare riutilizzo dell'indirizzo e senza richiedere l'uso di transazioni di notifica. Esaminiamo come funziona questo protocollo.
---
_Per comprendere appieno questo capitolo, è essenziale essere familiari con il funzionamento di ECDH (Elliptic Curve Diffie-Hellman) e la derivazione delle chiavi crittografiche in un portafoglio HD. Questi concetti sono stati dettagliati nel capitolo precedente sul BIP47. Non li ripeterò qui. Se non sei ancora familiare con queste nozioni, ti consiglio di consultare il capitolo precedente prima di continuare con questo. Non riprenderò nemmeno i rischi associati al riutilizzo degli indirizzi di ricezione, né l'importanza di avere un identificatore unico per ricevere pagamenti._
---
### Perché non spostare la notifica?
Come discusso nel capitolo sul BIP47, la transazione di notifica svolge principalmente due funzioni:
- Notifica il destinatario;
- Trasmette il codice di pagamento del mittente.
Si potrebbe ingenuamente pensare che questo processo di notifica potrebbe essere effettuato off-chain. In teoria, ciò è completamente fattibile: sarebbe sufficiente per il destinatario indicare un mezzo di comunicazione per ricevere i codici di pagamento BIP47 dai mittenti. Tuttavia, questo approccio presenta due problemi principali:
- Primo, ciò sposterebbe il processo di trasmissione del codice su un altro protocollo di comunicazione. Le questioni relative ai costi e alla privacy dello scambio rimarrebbero, ma sarebbero semplicemente trasferite a questo nuovo protocollo. In termini di privacy, ciò potrebbe anche creare un collegamento tra l'identità di un utente e l'attività sulla blockchain, cosa che cerchiamo di evitare eseguendo la notifica direttamente sulla blockchain. Inoltre, effettuare la notifica fuori dalla blockchain introdurrebbe rischi di censura (come il blocco dei fondi) che non esistono su Bitcoin;
Successivamente, ciò porrebbe un problema di recupero. Con BIP47, il destinatario deve assolutamente conoscere i codici di pagamento dei mittenti per accedere ai fondi. Questo è vero al momento della ricezione, ma anche in caso di recupero dei fondi tramite il seed in caso di perdita del portafoglio. Con le notifiche onchain, questo rischio viene evitato, poiché l'utente può trovare e decifrare le transazioni di notifica semplicemente conoscendo il proprio seed. Tuttavia, se la notifica viene eseguita fuori dalla blockchain, l'utente dovrebbe mantenere un backup dinamico di tutti i codici di pagamento ricevuti, il che è impraticabile per l'utente medio.
Tutti questi vincoli rendono l'uso della notifica onchain indispensabile nel contesto di BIP47. Eppure, i Pagamenti Silenziosi cercano specificamente di evitare questo passaggio di notifica onchain a causa del suo costo. Pertanto, la soluzione adottata non è spostare la notifica, ma eliminarla completamente. Per raggiungere questo obiettivo, deve essere accettato un compromesso: quello della scansione. A differenza di BIP47, dove l'utente sa esattamente dove trovare i propri fondi grazie alle transazioni di notifica, nel contesto dei Pagamenti Silenziosi, l'utente deve esaminare tutte le transazioni Bitcoin esistenti per rilevare eventuali pagamenti che potrebbero essere destinati a loro. Per ridurre questo onere operativo, la ricerca di Pagamenti Silenziosi è limitata solo alle transazioni che probabilmente contengono tali pagamenti, ovvero quelle che includono almeno un output Taproot P2TR. La scansione si concentra esclusivamente anche sulle transazioni dalla data di creazione del portafoglio (non c'è bisogno di scandire transazioni risalenti al 2009 se il portafoglio è stato creato nel 2024).
Pertanto, potete vedere perché BIP47 e Pagamenti Silenziosi, sebbene mirino a un obiettivo simile, comportano compromessi diversi e **quindi si rivolgono effettivamente a casi d'uso distinti**. Per i pagamenti una tantum, come le donazioni occasionali, i Pagamenti Silenziosi sono più appropriati a causa del loro costo inferiore. Al contrario, per le transazioni regolari allo stesso destinatario, come nel caso delle piattaforme di scambio o dei pool di mining, BIP47 potrebbe essere preferito.
Esploriamo insieme il funzionamento tecnico dei Pagamenti Silenziosi per capirne meglio le implicazioni. Per fare ciò, suggerisco di adottare lo stesso approccio del documento esplicativo di BIP352. Scomporremo gradualmente i calcoli da eseguire, elemento per elemento, giustificando ogni nuova aggiunta.
### Alcuni concetti da comprendere
Prima di iniziare, è importante chiarire che i Pagamenti Silenziosi si basano esclusivamente sull'uso di tipi di script P2TR (_Pay to Taproot_). A differenza di BIP47, non è necessario derivare gli indirizzi di ricezione dalle chiavi pubbliche figlie tramite hashing. Infatti, nello standard P2TR, la chiave pubblica modificata viene utilizzata direttamente e apertamente nell'indirizzo. Così, un indirizzo di ricezione Taproot è essenzialmente una chiave pubblica accompagnata da alcuni metadati. Questa chiave pubblica modificata è l'aggregazione di altre due chiavi pubbliche: una che consente la spesa diretta e tradizionale tramite una semplice firma, e l'altra che rappresenta la radice di Merkle del MAST, che autorizza la spesa soggetta alla soddisfazione di una delle condizioni potenzialmente iscritte nell'albero di Merkle.
![BTC204](assets/it/67/01.webp)
La decisione di limitare i Pagamenti Silenziosi esclusivamente a Taproot è motivata da due ragioni principali:
- Primo, facilita significativamente l'implementazione e gli aggiornamenti futuri nel software del portafoglio, poiché è necessario aderire a un solo standard;
- In secondo luogo, questo approccio aiuta a migliorare l'insieme di anonimato degli utenti incoraggiandoli a non disperdersi tra diversi tipi di script, che generano impronte di portafoglio distinte nell'analisi della catena (per maggiori informazioni su questo concetto, vi invito a consultare il capitolo 4 della parte 2).
### Derivazione naive di una chiave pubblica di Pagamenti Silenziosi
Iniziamo con un semplice esempio che ti aiuterà a comprendere il funzionamento di base dei Pagamenti Silenziosi (SP, Silent Payments). Prendiamo Alice e Bob, due utenti Bitcoin. Alice vuole inviare bitcoin a Bob su un nuovo indirizzo di ricezione. Tre obiettivi devono essere raggiunti in questo processo:
- Alice deve essere in grado di generare un nuovo indirizzo;
- Bob deve essere in grado di identificare un pagamento inviato a questo specifico indirizzo;
- Bob deve essere in grado di ottenere la chiave privata associata a questo indirizzo per poter spendere i suoi fondi.
Alice ha un UTXO nel suo portafoglio Bitcoin protetto con la seguente coppia di chiavi:
- $a$: la chiave privata;
- $A$: la chiave pubblica ($A = a \cdot G$)
Bob ha un indirizzo SP che ha pubblicato su internet con:
- $b$: la chiave privata;
- $B$: la chiave pubblica ($B = b \cdot G$)
Recuperando l'indirizzo di Bob, Alice è in grado di calcolare un nuovo indirizzo vuoto che appartiene a Bob usando ECDH. Chiamiamo questo indirizzo $P$:
$$ P = B + \text{hash}(a \cdot B) \cdot G $$
In questa equazione, Alice ha semplicemente calcolato il prodotto scalare della sua chiave privata $a$ e della chiave pubblica di Bob $B$. Ha passato questo risultato attraverso una funzione hash conosciuta da tutti. Il valore di output è poi moltiplicato scalarmente per il punto generatore $G$ della curva ellittica `secp256k1`. Infine, Alice aggiunge il punto ottenuto alla chiave pubblica di Bob $B$. Una volta che Alice ha questo indirizzo $P$, lo usa come output in una transazione, il che significa che invia bitcoin ad esso.
> _Nel contesto dei Pagamenti Silenziosi, la funzione "hash" corrisponde a una funzione hash SHA256 etichettata specificamente con `BIP0352/SharedSecret`, assicurando che gli hash generati siano unici per questo protocollo e non possano essere riutilizzati in altri contesti, fornendo anche una protezione aggiuntiva contro il riutilizzo di nonce nelle firme. Questo standard corrisponde a quello [specificato nel BIP340 per le firme Schnorr](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) su `secp256k1`._
Grazie alle proprietà della curva ellittica su cui si basa ECDH, sappiamo che:
$$ a \cdot B = b \cdot A $$
Bob sarà quindi in grado di calcolare l'indirizzo di ricezione su cui Alice ha inviato i bitcoin. Per fare ciò, monitora tutte le transazioni Bitcoin che soddisfano i criteri dei Pagamenti Silenziosi e applica il seguente calcolo a ciascuna di esse per vedere se il pagamento è indirizzato a lui (_scanning_):
$$ P' = B + \text{hash}(b \cdot A) \cdot G $$
Quando esamina la transazione di Alice, si rende conto che $P'$ è uguale a $P$. Sa quindi che questo pagamento è indirizzato a lui:
$$ P' = B + \text{hash}(b \cdot A) \cdot G = B + \text{hash}(a \cdot B) \cdot G = P $$
Da qui, Bob sarà in grado di calcolare la chiave privata $p$ che consente di spendere l'indirizzo $P$:
$$ p = (b + \text{hash}(b \cdot A)) \bmod n $$
Come puoi vedere, per calcolare questa chiave privata $p$, è necessario avere la chiave privata $b$. Solo Bob ha questa chiave privata $b$. Sarà quindi effettivamente l'unico in grado di spendere i bitcoin inviati al suo indirizzo di Pagamenti Silenziosi.
![BTC204](assets/fr/236.webp)
_Didascalia:_
- $B$: La chiave pubblica / indirizzo statico pubblicato da Bob
- $b$: La chiave privata di Bob
- $A$: La chiave pubblica dell'UTXO di Alice usata come input per la transazione
- $a$: La chiave privata di Alice
- $G$: Il punto generatore della curva ellittica `secp256k1`
- $\text{SHA256}$: La funzione di hashing SHA256 etichettata con `BIP0352/SharedSecret`
- $s$: Il segreto comune ECDH
- $P$: La chiave pubblica / indirizzo unico per il pagamento a Bob
Ecco un approccio inizialmente piuttosto ingenuo nell'uso dell'indirizzo statico di Bob, denotato $B$, per derivare un indirizzo unico $P$ per inviare bitcoin. Tuttavia, questo metodo è troppo semplicistico e presenta diversi difetti che necessitano di correzione. Il primo problema è che, in questo schema, Alice non può creare molteplici output per Bob all'interno della stessa transazione.
### Come creare molteplici output?
Nell'esempio della sezione precedente, Alice crea un singolo output che andrà a Bob al suo indirizzo unico $P$. Con lo stesso input selezionato, è impossibile per Alice creare due indirizzi vergini distinti per Bob, poiché il metodo utilizzato porterebbe sempre allo stesso risultato per $P$, quindi allo stesso indirizzo. Tuttavia, ci possono essere molte situazioni in cui Alice desidera dividere il suo pagamento a Bob in diverse piccole somme, creando così molteplici UTXO. È quindi necessario trovare un metodo che permetta di farlo.
Per raggiungere questo obiettivo, modificheremo leggermente il calcolo che Alice esegue per derivare $P$, in modo che possa generare due indirizzi distinti per Bob, ovvero $P_0$ e $P_1$.
Per modificare il calcolo e ottenere 2 indirizzi diversi, è sufficiente aggiungere un intero che modifica il risultato. Così, Alice aggiungerà $0$ nel suo calcolo per ottenere l'indirizzo $P_0$ e $1$ per ottenere l'indirizzo $P_1$. Chiamiamo questo intero $i$:
$$ P_i = B + \text{hash}(a \cdot B \text{ ‖ } i) \cdot G $$
Il processo di calcolo rimane invariato rispetto al metodo precedente, eccetto che questa volta Alice concatenerà $a \cdot B$ con $i$ prima di procedere al hash. È quindi sufficiente cambiare $i$ per avere un nuovo indirizzo appartenente a Bob. Ad esempio:
$$ P_0 = B + \text{hash}(a \cdot B \text{ ‖ } 0) \cdot G $$
$$ P_1 = B + \text{hash}(a \cdot B \text{ ‖ } 1) \cdot G $$
Quando Bob esamina la blockchain per i Pagamenti Silenziosi destinati a lui, inizia utilizzando $i = 0$ per l'indirizzo $P_0$. Se non trova nessun pagamento su $P_0$, conclude che questa transazione non contiene nessun Pagamento Silenzioso per lui e smette di analizzarla. Tuttavia, se $P_0$ è valido e contiene un pagamento per lui, procede con $P_1$ nella stessa transazione per verificare se Alice ha effettuato un secondo pagamento. Se $P_1$ risulta essere invalido, interrompe la sua ricerca per questa transazione; altrimenti, continua a testare valori successivi di $i$.
$$ P_1 = B + \text{hash}(b \cdot A \text{ ‖ } 1) \cdot G $$
Poiché Bob si ferma immediatamente a $i = 0$ se $P_0$ non produce risultati, l'uso di questo intero aggiunge quasi nessun onere operativo aggiuntivo a Bob per la fase di scansione delle transazioni.
Bob può quindi calcolare le chiavi private nello stesso modo:
$$

p_0 = (b + \text{hash}(b ∕A ∕text{‖ } 0)) ∕bmod n

$$
p_1 = (b + \text{hash}(b \cdot A \text{ ‖ } 1)) \bmod n
$$

[ディダスカリア:_]


- $B$:ボブから公開された公開キー / 静的インデックス
- $b$:ボブの私生活
- $A$:トランザクションの入力として使用されるアリスのUTXOの公開キーボード
- $a$:アリスの私生活
- G$: エリッター曲線 `secp256k1` の発生点
- text{SHA256}$：SHA256 ハッシュ関数が `BIP0352/SharedSecret` でサポートされていない。
- s_0$: ECDHの凝縮された最初のセグレット
- s_1$: ECDHの凝縮された2番目の部分
- $P_0$:公開された最初の名前 / ボブへの支払いのための唯一の名前
- $P_1$:2番目の公開番号 / Bobへの支払い専用番号

この方法によって、最高のプロトコールができるようになったが、特にインディアンの不正使用を防ぐという点で、まだ克服すべき課題がある。

### インドリルを使用しないようにするには？

前節で見たように、Aliceは自分のUTXOを保護するために、BobとのECDHの計算のために使う暗号を利用する。このセグレットによって、$P_0$という一意性を導出することができる。しかし、アリスが使用したキアの組み合わせ($a$, $A$)は、この識別子を何度も使用した場合、より多くのUTXOを保護することができる。アリスが$A$からUTXOをプロテクトして、ボブの$B$スタティックIDに2回パケットを送った場合、ボブはこのIDを1回しか使っていないことになる。

> このような場合、このフォームの最初の部分を参照することをお勧めします。その理由を知るために、このマニュアルの最初の部分を再読することをお勧めします。
そのため、$P_0$の一意名が$A$と$B$から派生したものであっても、 アリスが$A$と同じキーで$B$に二回目の支払いをするために、 二番目の一意名を派生させると、$P_0$の一意名が得られることになる。このようなリスクを回避し、サイレント・パケットの内部でインジケータが使用されるのを防ぐために、計算を少し修正する必要があります。

必要なことは、Aliceが入力として消費したUTXOが、Bobのラテラルから1つの識別子となることです。従って、単一識別子$P_0$の計算には、UTXOを参照するだけで十分です。この参照元は、単に入力として消費されるUTXOのハッシュです：

を入力する。

この入力の参照によって、アリスは $P_0$ の一意性を計算する：

スキャン中、Bobは$text{inputHash}$を追加することができる：

P_0 = B + ⅳtext{hash}(ⅳtext{inputHash} b ⅳtext{A

有効な$P_0$を見つけたら、それに対応する$p_0$を計算できる：

$$
p_0 = (b + \text{hash}(\text{inputHash} \cdot b \cdot A \text{ ‖ } 0)) \bmod n
$$

```text
_Legenda:_
- $B$: La chiave pubblica / indirizzo statico pubblicato da Bob
- $b$: La chiave privata di Bob
- $A$: La chiave pubblica dell'UTXO di Alice usata come input per la transazione
- $a$: La chiave privata di Alice
- $H$: L'hash dell'UTXO usato come input
- $G$: Il punto generatore della curva ellittica `secp256k1`
- $\text{SHA256}$: La funzione di hash SHA256 etichettata con `BIP0352/SharedSecret`
- $s_0$: Il primo segreto condiviso ECDH
- $P_0$: La prima chiave pubblica / indirizzo unico per il pagamento a Bob
Al momento, i nostri calcoli presuppongono che Alice utilizzi un singolo input per la sua transazione. Tuttavia, dovrebbe essere in grado di utilizzare più input. Di conseguenza, da parte di Bob, per ogni transazione contenente più input, teoricamente avrebbe bisogno di calcolare l'ECDH per ogni input per determinare se un pagamento è destinato a lui. Questo metodo non è soddisfacente, quindi abbiamo bisogno di trovare una soluzione per ridurre il carico di lavoro!
### Modificare le chiavi pubbliche negli input
Per risolvere questo problema, invece di utilizzare la coppia di chiavi che protegge un input specifico da parte di Alice, useremo la somma di tutte le coppie di chiavi utilizzate negli input della transazione. Questa somma sarà quindi considerata come una nuova coppia di chiavi. Questa tecnica è nota come "tweak".
Per esempio, immagina che la transazione di Alice abbia 3 input, ognuno protetto con una coppia di chiavi diversa:
- $a_0$ protegge l'input #0;
- $a_1$ protegge l'input #1;
- $a_2$ protegge l'input #2.
Seguendo il metodo descritto sopra, Alice dovrebbe scegliere una singola coppia di chiavi tra $a_0$, $a_1$ e $a_2$ per calcolare il segreto ECDH e generare l'indirizzo di pagamento unico $P$ dall'indirizzo statico $B$ di Bob. Tuttavia, questo approccio richiede a Bob di testare ogni possibilità sequenzialmente, partendo da $a_0$, poi $a_1$, e così via, fino all'identificazione di una coppia che genera un indirizzo valido $P$. Questo processo richiede che Bob esegua il calcolo ECDH su tutti gli input di tutte le transazioni, aumentando significativamente il carico di lavoro operativo di scansione.
Per evitare ciò, chiederemo ad Alice di eseguire il suo calcolo di $P$ utilizzando la somma di tutte le chiavi in input. Prendendo il nostro esempio, la chiave privata modificata $a$ sarebbe calcolata come segue:
$$ a = a_0 + a_1 + a_2 $$
Allo stesso modo, Alice e Bob saranno in grado di calcolare la chiave pubblica modificata:
$$ A = A_0 + A_1 + A_2 $$
Grazie a questo metodo, a Bob basta calcolare la somma delle chiavi pubbliche della transazione, poi calcolare il segreto ECDH da $A$ soltanto, il che riduce notevolmente il numero di calcoli da fare per la fase di scansione. Tuttavia, ricorda dalla sezione precedente. Avevamo incluso nel nostro calcolo l'hash $\text{inputHash}$ che viene usato come nonce per prevenire il riutilizzo degli indirizzi:
$$ \text{inputHash} = \text{hash}(\text{outpoint} \text{ ‖ } A) $$
Ma se ci sono più input in una transazione, è necessario determinare quale $\text{outpoint}$ viene scelto in questo calcolo. Secondo il BIP352, il criterio di selezione per $\text{outpoint}$ da usare è scegliere il più piccolo lessicograficamente, il che significa selezionare l'UTXO che appare per primo in ordine alfabetico. Questo metodo standardizza l'UTXO da scegliere in ogni transazione. Ad esempio, se questo $\text{outpoint}$ più piccolo lessicograficamente è $\text{outpoint}_L$, il calcolo di $\text{inputHash}$ sarà:
$$ \text{inputHash} = \text{hash}(\text{outpoint}\_L \text{ ‖ } A) $$
I calcoli rimangono quindi identici a quelli presentati nella sezione precedente, eccetto che la chiave privata $a$ e la sua corrispondente chiave pubblica $A$ non rappresentano più una coppia che protegge un singolo input, ma ora rappresentano la modifica di tutte le coppie di chiavi negli input.
### Separare le Chiavi di Spesa e di Scansione
Finora, abbiamo discusso dell'indirizzo statico di Pagamento Silenzioso $B$ come di una chiave pubblica unica. Ricorda, è questa chiave pubblica $B$ che viene usata da Alice per creare il segreto condiviso ECDH, che a sua volta viene usato per calcolare l'indirizzo di pagamento unico $P$. Bob usa questa chiave pubblica $B$ e la corrispondente chiave privata $b$ per la fase di scansione. Ma userà anche la chiave privata $b$ per calcolare la chiave privata $p$ che consente di spendere dall'indirizzo $P$.
Lo svantaggio di questo metodo è che la chiave privata $b$, che viene usata per calcolare tutte le chiavi private per gli indirizzi che ricevono Pagamenti Silenziosi, viene anche usata da Bob per scansionare le transazioni. Questo passaggio richiede che la chiave $b$ sia disponibile su un software di portafoglio connesso a Internet, il che la espone a un rischio maggiore di furto rispetto al mantenerla su un portafoglio freddo. Idealmente, sarebbe vantaggioso poter approfittare dei Pagamenti Silenziosi mantenendo la chiave privata $b$, che controlla l'accesso a tutte le altre chiavi private, al sicuro su un portafoglio hardware. Fortunatamente, il protocollo è stato adattato per permettere esattamente questo.
Per raggiungere questo obiettivo, il BIP352 specifica che il ricevente usa 2 diverse coppie di chiavi:
- $B_{\text{spend}}$: per calcolare le chiavi private degli indirizzi di pagamento unici;
- $B_{\text{scan}}$: per trovare indirizzi di pagamento unici.
In questo modo, Bob può mantenere la chiave privata $b_{\text{spend}}$ su un portafoglio hardware e usare la chiave privata $b_{\text{scan}}$ su software online per trovare i suoi Pagamenti Silenziosi, senza rivelare $b_{\text{spend}}$. Tuttavia, le chiavi pubbliche $B_{\text{scan}}$ e $B_{\text{spend}}$ sono entrambe pubblicamente rivelate, poiché si trovano nell'indirizzo statico di Bob $B$:
Per calcolare un indirizzo di pagamento unico $P_0$ appartenente a Bob, Alice eseguirà il seguente calcolo:
$$ P*0 = B*{\text{spend}} + \text{hash}(\text{inputHash} \cdot a \cdot B\_{\text{scan}} \text{ ‖ } 0) \cdot G $$
Per trovare i pagamenti indirizzati a lui, Bob eseguirà il seguente calcolo:
$$ P*0 = B*{\text{spend}} + \text{hash}(\text{inputHash} \cdot b\_{\text{scan}} \cdot A \text{ ‖ } 0) \cdot G $$
Come puoi vedere, fino a questo momento, Bob non ha avuto bisogno di usare $b_{\text{spend}}$ che si trova sul suo portafoglio hardware. Quando desidera spendere $P_0$, può quindi eseguire il seguente calcolo per trovare la chiave privata $p_0$:
$$ p*0 = (b*{\text{spend}} + \text{hash}(\text{inputHash} \cdot b\_{\text{scan}} \cdot A \text{ ‖ } 0)) \bmod n $$
_Didascalia:_
- $B_{\text{scan}}$: Chiave pubblica di scansione di Bob (indirizzo statico)
- $b_{\text{scan}}$: Chiave privata di scansione di Bob
- $B_{\text{spend}}$: Chiave pubblica di spesa di Bob (indirizzo statico)
- $b_{\text{spend}}$: Chiave privata di spesa di Bob
- $A$: La somma delle chiavi pubbliche in input (tweak)
- $a$: La chiave privata corrispondente alla chiave pubblica modificata
- $H$: L'hash dell'UTXO più piccolo (lessicograficamente) usato in input
- $G$: Il punto generatore della curva ellittica `secp256k1`
- $\text{SHA256}$: La funzione di hashing SHA256 etichettata con `BIP0352/SharedSecret`
- $s_0$: Il primo segreto condiviso ECDH
- $P_0$: La prima chiave pubblica / indirizzo di pagamento unico per Bob
### Utilizzando indirizzi SP con un'etichetta
Bob ha quindi un indirizzo statico $B$ per i Pagamenti Silenziosi come segue:
$$ B = B*{\text{scan}} \text{ ‖ } B*{\text{spend}} $$
Il problema con questo metodo è che non permette di segregare i diversi pagamenti inviati a questo indirizzo. Ad esempio, se Bob ha 2 clienti diversi per la sua attività e vuole differenziare chiaramente i pagamenti da ciascuno, avrebbe bisogno di 2 indirizzi statici diversi. Una soluzione ingenua, con l'approccio attuale, sarebbe che Bob crei due portafogli separati, ognuno con il proprio indirizzo statico, o addirittura stabilisca due indirizzi statici diversi all'interno dello stesso portafoglio. Tuttavia, questa soluzione richiede la scansione dell'intera blockchain due volte (una per ciascun indirizzo) per rilevare rispettivamente i pagamenti destinati a ciascun indirizzo. Questa doppia scansione aumenta in modo irragionevole l'onere operativo per Bob.
Per risolvere questo problema, BIP352 utilizza un sistema di etichettatura che consente di avere diversi indirizzi statici senza aumentare in modo irragionevole il carico di lavoro per trovare Pagamenti Silenziosi sulla blockchain. Per fare ciò, viene aggiunto un intero $m$ alla chiave pubblica di spesa $B_{\text{spend}}$. Questo intero può assumere il valore di $1$ per il primo indirizzo statico, poi $2$ per il secondo, e così via. Le chiavi di spesa $B_{\text{spend}}$ saranno d'ora in poi chiamate $B_m$ e saranno costruite in questo modo:
$$ B*m = B*{\text{spend}} + \text{hash}(b\_{\text{scan}} \text{ ‖ } m) \cdot G $$
Per esempio, per la prima chiave di spesa con l'etichetta $1$:
$$ B*1 = B*{\text{spend}} + \text{hash}(b\_{\text{scan}} \text{ ‖ } 1) \cdot G $$
L'indirizzo statico pubblicato da Bob consisterà ora di $B_{\text{scan}}$ e $B_m$. Per esempio, il primo indirizzo statico con l'etichetta $1$ sarà:
$$ B = B\_{\text{scan}} \text{ ‖ } B_1 $$
> _Iniziamo solo dall'etichetta 1 perché l'etichetta 0 è riservata per il resto._
Alice, da parte sua, deriverà l'indirizzo di pagamento unico $P$ nello stesso modo di prima, ma utilizzando il nuovo $B_1$ invece di $B_{\text{spend}}$.
$$ P*0 = B_1 + \text{hash}(\text{inputHash} \cdot a \cdot B*{\text{scan}} \text{ ‖ } 0) \cdot G $$
In realtà, Alice potrebbe non sapere nemmeno che Bob ha un indirizzo etichettato, poiché lei semplicemente utilizza la seconda parte dell'indirizzo statico che lui le ha fornito, che in questo caso, è il valore $B_1$ piuttosto che $B_{\text{spend}}$.
Per scansionare i pagamenti, Bob utilizzerà sempre il valore del suo indirizzo statico iniziale con $B_{\text{spend}}$ in questo modo:
$$ P*0 = B*{\text{spend}} + \text{hash}(\text{inputHash} \cdot b\_{\text{scan}} \cdot A \text{ ‖ } 0) \cdot G $$
Poi, semplicemente sottrae il valore che trova per $P_0$ da ogni output uno per uno. Poi controlla se uno dei risultati di queste sottrazioni corrisponde al valore di una delle etichette che usa nel suo portafoglio. Se corrisponde, per esempio, per l'output #4 con l'etichetta $1$, ciò significa che questo output è un Pagamento Silenzioso associato al suo indirizzo statico etichettato $B_1$:
$$ Out*4 - P_0 = \text{hash}(b*{\text{scan}} \text{ ‖ } 1) \cdot G $$
Questo funziona perché:
$$ B*1 = B*{\text{spend}} + \text{hash}(b*{\text{scan}} \text{ ‖ } 1) \cdot G $$
Grazie a questo metodo, Bob può utilizzare una moltitudine di indirizzi statici ($B_1$, $B_2$, $B_3$...), tutti derivati dal suo indirizzo statico base ($B = B*{\text{scan}} \text{ ‖ } B*{\text{spend}}$), al fine di separare correttamente gli usi.
Tuttavia, questa separazione degli indirizzi statici è valida solo da una prospettiva di gestione personale del portafoglio e non consente la separazione delle identità. Poiché tutti hanno lo stesso $B*{\text{scan}}$, è molto facile associare tutti gli indirizzi statici insieme e dedurre che appartengono a una singola entità.
_Didascalia:_
- $B_{\text{scan}}$: chiave pubblica di scansione di Bob (indirizzo statico)
- $b_{\text{scan}}$: chiave privata di scansione di Bob
- $B_{\text{spend}}$: chiave pubblica di spesa di Bob (indirizzo iniziale)
- $B_m$: chiave pubblica di spesa etichettata di Bob (indirizzo statico)
- $b_m$: chiave privata di spesa etichettata di Bob
- $A$: La somma delle chiavi pubbliche in input (tweak)
- $a$: La chiave privata corrispondente alla chiave pubblica modificata
- $H$: L'hash del più piccolo UTXO (lessicograficamente) utilizzato come input
- $G$: Il punto generatore della curva ellittica `secp256k1`
- $\text{SHA256}$: La funzione di hashing SHA256 etichettata con `BIP0352/SharedSecret`
- $s_0$: Il primo segreto condiviso ECDH
- $P_0$: La prima chiave pubblica / indirizzo unico per il pagamento a Bob
- $p_0$: La chiave privata del primo indirizzo di pagamento unico a Bob
- $X$: L'hash della chiave privata di scansione con l'etichetta
### Come Costruire un Indirizzo per Pagamenti Silenziosi?
Per costruire un indirizzo dedicato ai Pagamenti Silenziosi, è necessario prima derivare 2 coppie di chiavi nel proprio portafoglio Bitcoin HD:
- La coppia $b_{\text{scan}}$, $B_{\text{scan}}$ per cercare i pagamenti indirizzati a noi;
- La coppia $b_{\text{spend}}$, $B_{\text{spend}}$ per spendere i bitcoin che abbiamo ricevuto.
Queste coppie sono derivate seguendo questi percorsi (_Bitcoin Mainnet_):
scan: m / 352' / 0' / 0' / 1' / 0
spend: m / 352' / 0' / 0' / 0' / 0
```

```text
Una volta disponibili queste 2 coppie di chiavi, si concatenano semplicemente (una di seguito all'altra) per creare il payload dell'indirizzo statico:
$$ B = B*{\text{scan}} \text{ ‖ } B*{\text{spend}} $$
Se si desidera utilizzare etichette, $B_{\text{spend}}$ viene sostituito con $B_m$:
$$ B = B\_{\text{scan}} \text{ ‖ } B_m $$
Con l'etichetta $m$:
$$ B*m = B*{\text{spend}} + \text{hash}(b\_{\text{scan}} \text{ ‖ } m) \cdot G $$
Una volta disponibile questo payload, si aggiunge la HRP (_Human-Readable Part_) `sp` e la versione `q` (= versione 0). Viene anche aggiunto un checksum, e l'indirizzo è formattato in bech32m.
Ad esempio, ecco il mio indirizzo statico per i Pagamenti Silenziosi:
sp1qqvhjvsq2vz8zwrw372vuzle7472zup2ql3pz64yn5cpkw5ngv2n6jq4nl8cgm6zmu48yk3eq33ryc7aam6jrvrg0d0uuyzecfhx2wgsumcurv77e
```