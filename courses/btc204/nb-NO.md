---
name: Personvern på Bitcoin
goal: Forstå og beherske prinsippene for personvern ved bruk av Bitcoin
objectives: 

  - Definere de teoretiske begrepene som trengs for å forstå hva som står på spill når det gjelder personvern
  - Vite hvordan man identifiserer og reduserer risikoer knyttet til tap av brukernes personvern på Bitcoin
  - Bruk av metoder og verktøy for å beskytte personvernet ditt på Bitcoin
  - Forstå metoder for kjedeanalyse og utvikle forsvarsstrategier

---
# Beskytt personvernet ditt på bitcoin

I en verden der personvern i forbindelse med finansielle transaksjoner gradvis blir en luksus, er det viktig å forstå og beherske prinsippene for personvern i din bruk av Bitcoin. Denne opplæringen gir deg alle nøklene, både teoretiske og praktiske, til å nå dette målet på egen hånd.

I dag, på Bitcoin, er det selskaper som spesialiserer seg på kjedeanalyse. Deres kjernevirksomhet er nettopp å trenge seg inn i personvernet ditt for å kompromittere konfidensialiteten til transaksjonene dine. Faktisk eksisterer ikke "retten til personvern" på Bitcoin. Det er derfor opp til deg, brukeren, å hevde dine naturlige rettigheter og beskytte konfidensialiteten til transaksjonene dine, fordi ingen andre vil gjøre det for deg.

Denne opplæringen presenteres som et omfattende generalistkurs. Alle tekniske begreper er utdypet og understøttet av forklarende diagrammer. Målet er å gjøre kunnskapen tilgjengelig for alle. BTC204 er derfor tilgjengelig for nybegynnere og viderekomne brukere. Kurset gir også merverdi til mer erfarne bitcoin-brukere, ettersom vi går i dybden på noen ofte ukjente tekniske begreper.

Bli med oss for å endre din bruk av Bitcoin og bli en informert bruker, i stand til å forstå problemene rundt konfidensialitet og beskytte personvernet ditt.

+++
# Innledning

<partId>e17474a8-8899-4bdb-a7f8-bc52ddb01440</partId>

## Introduksjon til opplæring

<chapterId>08ba1933-f393-4fb5-8279-777d874caedb</chapterId>

I en verden der personvern i forbindelse med finansielle transaksjoner gradvis blir en luksus, er det viktig å forstå og beherske prinsippene for personvern i din bruk av Bitcoin. Denne opplæringen gir deg alle nøklene, både teoretiske og praktiske, til å nå dette målet på egen hånd.

I dag finnes det selskaper i Bitcoin-økosystemet som spesialiserer seg på blokkjedeanalyse. Deres kjernevirksomhet er nettopp å trenge seg inn i personvernet ditt og kompromittere konfidensialiteten til transaksjonene dine. Faktisk eksisterer ikke "retten til personvern" på Bitcoin. Det er derfor opp til deg, brukeren, å hevde dine naturlige rettigheter og beskytte konfidensialiteten til transaksjonene dine, fordi ingen andre vil gjøre det for deg.

Bitcoin er ikke bare der for "Number Go Up" og bevaring av verdien av besparelser. På grunn av sine unike funksjoner og historie er det først og fremst verktøyet for den alternative økonomien. Takket være denne bemerkelsesverdige oppfinnelsen kan du fritt administrere pengene dine, bruke dem og akkumulere dem, uten at noen kan stoppe deg.

Bitcoin tilbyr en fredelig flukt fra statenes åk, slik at du fullt ut kan nyte dine naturlige rettigheter, som ikke kan utfordres av etablerte lover. Takket være Satoshi Nakamotos oppfinnelse har du makt til å håndheve din rett til privat eiendom og gjenvinne din frihet til å inngå kontrakter.

Bitcoin er imidlertid ikke anonym som standard, noe som kan utgjøre en risiko for personer som driver med alternativ økonomi, spesielt i regioner med despotiske regimer. Men dette er ikke den eneste faren. Fordi bitcoin er en verdifull og usensurert eiendel, kan den tiltrekke seg tyvenes oppmerksomhet. Derfor blir det å beskytte personvernet ditt også et sikkerhetsspørsmål: Det kan hjelpe deg med å forhindre cyberangrep og fysiske overfall.

Som vi skal se, er det avgjørende å bruke flere verktøy for å optimalisere og forsvare personvernet, selv om protokollen tilbyr en viss iboende personvernbeskyttelse. Dette kurset er utformet som en omfattende, generell innføring i personvernspørsmål knyttet til Bitcoin. Hvert teknisk begrep diskuteres i detalj og støttes av forklarende diagrammer. Målet er å gjøre kunnskapen tilgjengelig for alle, inkludert nybegynnere og viderekomne brukere. For mer erfarne bitcoin-brukere tar vi også for oss svært tekniske og noen ganger mindre kjente konsepter i løpet av kurset for å utdype forståelsen av hvert emne.

Målet med dette kurset er ikke å gjøre deg helt anonym i din bruk av Bitcoin, men snarere å gi deg de viktigste verktøyene for å vite hvordan du kan beskytte personvernet ditt i henhold til dine personlige mål. Du vil ha frihet til å velge fra konseptene og verktøyene som presenteres for å utvikle dine egne strategier, skreddersydd til dine spesifikke mål og behov.

### Del 1: Definisjoner og nøkkelbegreper

Til å begynne med skal vi sammen se på de grunnleggende prinsippene som styrer hvordan Bitcoin fungerer, for deretter å ta en rolig tilnærming til personvernrelaterte begreper. Det er viktig å beherske noen grunnleggende konsepter, som UTXO-er, mottaksadresser eller skript, før vi kan forstå konseptene vi skal ta for oss i de følgende avsnittene. Vi vil også introdusere den generelle personvernmodellen for Bitcoin, slik Satoshi Nakamoto så for seg den, slik at vi kan forstå problemene og risikoene som er forbundet med den.

![BTC204](assets/it/11/1.webp)

### Del 2: Forstå kjedeanalyse og hvordan du kan beskytte deg selv

I den andre delen studerer vi teknikkene som brukes av blockchain-analyseselskaper for å spore aktiviteten din på Bitcoin. Å forstå disse metodene er avgjørende for å forbedre beskyttelsen av personvernet ditt. Denne delen tar sikte på å undersøke angripernes strategier for å få en bedre forståelse av risikoen og legge grunnlaget for teknikkene vi skal studere i de påfølgende delene. Vi vil analysere transaksjonsmønstre, interne og eksterne heuristikker samt plausible tolkninger av disse mønstrene. I tillegg til en teoretisk del lærer vi hvordan vi kan bruke en blokkutforsker til å utføre kjedeanalyser ved hjelp av praktiske eksempler og øvelser.

![BTC204](assets/fr/002.webp)

### Del 3: Beherskelse av beste praksis for å beskytte personvernet ditt

I den tredje delen av kurset vårt går vi til kjernen av saken: øvelse! Målet er å mestre alle de essensielle beste praksisene som bør bli naturlige reflekser for enhver Bitcoin-bruker. Vi vil dekke bruk av ferske adresser, merking, konsolidering, bruk av fulle noder, samt KYC og anskaffelsesmetoder. Målet er å gi deg en omfattende oversikt over fallgruvene du bør unngå for å etablere et solid grunnlag i vår søken etter personvern. For noen av disse metodene vil du bli veiledet til en spesifikk veiledning for å implementere dem.

![BTC204](assets/it/11/3.webp)

### Del 4: Forståelse av Coinjoin-transaksjoner

Hvordan kan vi snakke om bitcoin-personvern uten å diskutere coinjoin? I del 4 får du vite alt du trenger å vite om denne blandingsmetoden. Du vil lære hva en coinjoin er, dens historie og mål, samt de ulike typene coinjoins som finnes. Til slutt, for mer erfarne brukere, vil vi finne ut hva anonsets og entropi er, og hvordan man beregner disse indikatorene.

![BTC204](assets/it/11/4.webp)

### Del 5: Forståelse av problemene med andre avanserte personvernteknikker

I den femte delen vil vi gi en oversikt over alle de andre eksisterende teknikkene for å beskytte personvernet ditt på Bitcoin i tillegg til coinjoin. I årenes løp har utviklere vist stor kreativitet når det gjelder å utforme verktøy som er dedikert til personvern. Vi vil undersøke alle disse metodene, som payjoin, samarbeidstransaksjoner, Coin Swap og Atomic Swap, og beskrive hvordan de fungerer, deres mål og potensielle svakheter.

Vi vil også ta for oss personvern på nodesystemnivå og transaksjonsspredning. Vi vil også diskutere de ulike protokollene som har blitt foreslått i årenes løp for å forbedre brukernes personvern på Bitcoin, inkludert statiske adresseprotokoller.

![BTC204](assets/fr/005.webp)

# Definisjoner og nøkkelbegreper

<partId>b9bbbde3-34c0-4851-83e8-e2ffb029cf31</partId>

## UTXO-modellen for Bitcoin

<chapterId>8d6b50c5-bf74-44f4-922b-25204991cb75</chapterId>

Bitcoin er først og fremst en valuta, men vet du konkret hvordan BTC er representert i protokollen?

### UTXOer av Bitcoin: Hva er de?

I Bitcoin-protokollen er håndteringen av pengeenheter basert på UTXO-modellen, som står for "_Unspent Transaction Output_"

Denne modellen skiller seg vesentlig fra tradisjonelle banksystemer, som baserer seg på en konto- og saldomekanisme for å spore finansielle strømmer. I banksystemet er det faktisk slik at den enkeltes saldo holdes på kontoer som er knyttet til en identitet. Når du for eksempel kjøper en baguette av en baker, trekker banken din beløpet fra din konto og reduserer dermed saldoen din, mens bakerens konto krediteres med det samme beløpet og øker saldoen sin. I dette systemet er det ingen kobling mellom pengene som kommer inn på kontoen din og pengene som går ut av den, annet enn transaksjonsregistreringer.

På Bitcoin fungerer ting annerledes. Konseptet med en konto eksisterer ikke, og monetære enheter administreres ikke gjennom saldoer, men gjennom UTXOer. En UTXO representerer en bestemt mengde bitcoin som ennå ikke er brukt, og utgjør dermed et "stykke bitcoin", som kan være stort eller lite. En UTXO kan for eksempel være verdt 500 BTC eller bare 700 SATS.

**> Påminnelse:** Satoshi, ofte forkortet til sat, er den minste enheten av Bitcoin, som kan sammenlignes med en penny i fiat-valutaer.

```plaintext
1 BTC = 100,000,000 SATS
```

Teoretisk sett kan en UTXO representere en hvilken som helst verdi i bitcoin, alt fra en sat opp til det teoretiske maksimumet på rundt 21 millioner BTC. Det er imidlertid logisk umulig å eie alle 21 millioner bitcoins, og det finnes en lavere økonomisk terskel kalt "dust", under hvilken en UTXO anses som økonomisk uøkonomisk å bruke.

**>Visste du at den største UTXO som noensinne er opprettet på Bitcoin hadde en verdi på `500,000 BTC`. Den ble opprettet av MtGox-plattformen under en konsolideringsoperasjon i november 2011: [29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf](https://mempool.space/fr/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)

### UTXO og utgiftsbetingelser

UTXO-er er verktøyene for utveksling på Bitcoin. Hver transaksjon innebærer forbruk av UTXO-er som input og opprettelse av nye UTXO-er som output. Når en transaksjon gjennomføres, anses UTXO-ene som brukes som input som "brukt", og nye UTXO-er genereres og tilordnes mottakerne som er angitt i transaksjonens output. En UTXO representerer dermed ganske enkelt en ubrukt transaksjonsutgang, og dermed en mengde bitcoin som tilhører en bruker på et gitt tidspunkt.

![BTC204](assets/it/21/2.webp)

Alle UTXO-er er beskyttet av skript som definerer under hvilke betingelser de kan brukes. For å bruke en UTXO må en bruker vise nettverket at han eller hun oppfyller vilkårene som er fastsatt i skriptet som beskytter UTXO-en. UTXO-er er vanligvis beskyttet av en offentlig nøkkel (eller en mottakeradresse som representerer denne offentlige nøkkelen). For å bruke en UTXO som er knyttet til denne offentlige nøkkelen, må brukeren bevise at han eller hun har den tilsvarende private nøkkelen ved å levere en digital signatur som er laget med denne nøkkelen. Det er derfor man sier at bitcoin-lommeboken din ikke inneholder bitcoins, men at den inneholder de private nøklene dine, som i sin tur gir deg tilgang til UTXO-ene dine og, i forlengelsen av dette, bitcoinsene de representerer.

![BTC204](assets/it/21/3.webp)

Siden konseptet med en konto er fraværende i Bitcoin, er saldoen til en lommebok ganske enkelt summen av verdiene til alle UTXO-ene den kan bruke. For eksempel, hvis Bitcoin-lommeboken din kan bruke følgende 4 UTXOer:

```plaintext
- 2 BTC
- 8 BTC
- 5 BTC
- 2 BTC
```

Den totale saldoen på lommeboken din vil være `17 BTC`.

![BTC204](assets/it/21/4.webp)

## Strukturen til Bitcoin-transaksjoner

<chapterId>29d3aaab-de2e-4746-ab40-c9748898850c</chapterId>

### Inn- og utdata for en transaksjon

En bitcoin-transaksjon er en transaksjon registrert i blokkjeden som muliggjør overføring av eierskap av bitcoins fra en person til en annen. Mer spesifikt, fordi vi er i en UTXO-modell og det ikke finnes noen kontoer, tilfredsstiller transaksjonen utgiftsbetingelsene som beskyttet en eller flere UTXO-er, forbruker dem og, tilsvarende, skaper nye UTXO-er utstyrt med nye utgiftsbetingelser. Kort sagt flytter en transaksjon bitcoins fra et skript som er oppfylt, til et nytt skript som skal beskytte dem.

![BTC204](assets/it/22/1.webp)

Hver Bitcoin-transaksjon består dermed av en eller flere innganger og en eller flere utganger. Inndataene er UTXO-er som forbrukes av transaksjonen for å generere utdataene. Utgangene er nye UTXO-er som kan brukes som innganger for fremtidige transaksjoner.

![BTC204](assets/it/22/2.webp)

**> Visste du at en bitcoin-transaksjon i teorien kan ha et uendelig antall innganger og utganger? Det er bare den maksimale blokkstørrelsen som begrenser dette antallet. Hver input i en bitcoin-transaksjon refererer til en tidligere ubrukt UTXO (Unspent Transaction Output). For å bruke en UTXO som input må innehaveren bevise at han eller hun er den rettmessige eieren ved å validere skriptet som er knyttet til UTXO-en, det vil si å oppfylle den pålagte utgiftsbetingelsen. Vanligvis innebærer dette å levere en digital signatur som er produsert med den private nøkkelen som tilsvarer den offentlige nøkkelen som opprinnelig sikret UTXO-en. Skriptet verifiserer deretter at signaturen samsvarer med den offentlige nøkkelen som ble brukt ved mottak av midlene.

Hver utgang spesifiserer derimot mengden bitcoin som skal overføres, samt mottakeren. Sistnevnte defineres av et nytt skript som vanligvis låser den nyopprettede UTXO-en med en mottakeradresse eller en ny offentlig nøkkel.

For at en transaksjon skal anses som gyldig i henhold til konsensusreglene, må de totale utgangene være mindre enn eller lik de totale inngangene. Med andre ord må summen av nye UTXO-er som genereres av transaksjonen, ikke overstige summen av UTXO-er som forbrukes som input. Dette prinsippet er logisk: Hvis du bare har 500 000 SATS, kan du ikke kjøpe for 700 000 SATS.

### Utveksling og konsolidering i en Bitcoin-transaksjon

En Bitcoin-transaksjon på UTXO-er kan dermed sammenlignes med smeltingen av en gullmynt. En UTXO er faktisk ikke delelig, men bare enhetlig. Dette betyr at en bruker ikke bare kan dele en UTXO som representerer en viss mengde bitcoin i flere mindre UTXO-er. Han må forbruke den i sin helhet i en transaksjon for å skape en eller flere nye UTXO-er med vilkårlige verdier i utgangene, som må være mindre enn eller lik den opprinnelige verdien.

Denne mekanismen ligner på den som gjelder for en gullmynt. Tenk deg at du eier en mynt på 2 unse og ønsker å betale for 1 unse, forutsatt at selgeren ikke kan gi deg vekslepenger. Da må du smelte mynten din og prege to nye mynter på 1 unse hver.

På bitcoin er operasjonen lik. Anta at Alice har en UTXO på 10 000 SATS og ønsker å kjøpe en baguette som koster 4 000 SATS. Alice vil utføre en transaksjon med en input på 1 UTXO på 10 000 SATS` som hun vil forbruke i sin helhet, og i outputen vil hun skape 2 UTXOer til en verdi av 4 000 SATS` og 6 000 SATS`. UTXO-en på 4 000 SATS` sendes til bakeren som betaling for baguetten, mens UTXO-en på 6 000 SATS` går tilbake til Alice som vekslepenger. Denne UTXO-en som går tilbake til den opprinnelige avsenderen av transaksjonen er det som kalles "vekslepenger" i Bitcoin-sjargongen.

Tenk deg nå at Alice ikke har én UTXO på 10 000 SATS, men to UTXOer på 3 000 SATS hver. I denne situasjonen er ingen av de individuelle UTXO-ene tilstrekkelige til å dekke baguettens 4 000 SATS. Alice må derfor bruke begge UTXO-ene på 3 000 SATS` samtidig som input til transaksjonen. På denne måten vil den totale innsatsen komme opp i 6 000 SATS`, slik at hun kan dekke betalingen på 4 000 SATS` til bakeren. Denne metoden, som innebærer å gruppere flere UTXO-er i innsatsfaktorene i en transaksjon, kalles ofte "konsolidering".

### Transaksjonsgebyrer

Intuitivt skulle man kanskje tro at transaksjonsgebyrer også representerer et resultat av en transaksjon. Men i virkeligheten er dette ikke tilfelle. Transaksjonsgebyrer representerer differansen mellom totale inndata og totale utdata. Det betyr at etter at en del av verdien av innsatsfaktorene er brukt til å dekke de ønskede resultatene i en transaksjon, gjenstår det en viss sum av innsatsfaktorene som ikke blir brukt. Denne gjenværende summen utgjør transaksjonsgebyret.

```plaintext
Commissioni = input totali - output totali
```

La oss gå tilbake til eksemplet med Alice som har en UTXO på 10 000 SATS og ønsker å kjøpe en baguette for 4 000 SATS. Alice oppretter en transaksjon med UTXO på 10 000 SATS som input. Deretter genererer hun et output på 4 000 SATS, som bakeren skal bruke til å betale for baguetten. For å oppmuntre utvinnerne til å inkludere transaksjonen hennes i en blokk, tildeler Alice 200 SATS som provisjon. Dermed skaper hun et nytt output, restbeløpet, som vil bli returnert til henne, og som utgjør 5800 SATS.

Ved å bruke provisjonsformelen ser vi faktisk at det er `200 SATS` igjen til gruvearbeiderne:

```plaintext
Commissioni = input totali - output totali
Spese = 10.000 - (4.000 + 5.800)
Spese = 10.000 - 9.800
Spese = 200
```

Når en utvinner validerer en blokk, har vedkommende rett til å kreve inn disse avgiftene for alle transaksjonene som inngår i blokken, gjennom en såkalt "coinbase"-transaksjon.

### Opprettelsen av UTXO på Bitcoin

Hvis du har fulgt de foregående avsnittene nøye, vet du nå at UTXO-er bare kan opprettes ved å konsumere andre eksisterende UTXO-er. Dermed danner mynter på Bitcoin en kontinuerlig kjede. Du lurer kanskje på hvordan de første UTXO-ene dukket opp i denne kjeden. Dette reiser et problem som ligner på høna og egget: hvor kom disse opprinnelige UTXO-ene fra?

Svaret ligger i **coinbase-transaksjonen**.

Coinbase er en spesifikk type Bitcoin-transaksjon, unik for hver blokk og alltid den første i dem. Den gjør det mulig for utvinneren som har funnet et gyldig arbeidsbevis, å motta blokkbelønningen sin. Denne belønningen består av to elementer: **blokktilskuddet** og **transaksjonsgebyr** som ble diskutert i forrige del.

Det unike med Coinbase-transaksjonen er at den er den eneste som kan skape bitcoins fra ingenting, uten behov for å forbruke input for å generere output. Disse nyopprettede bitcoinsene utgjør det som kan kalles de "originale UTXO-ene"

Bitcoins fra blokktildelingen er nye BTC som skapes ut av løse luften, etter en forhåndsdefinert utstedelsesplan i konsensusreglene. Blokktilskuddet halveres hver 210 000. blokk, omtrent hvert fjerde år, i en prosess som kalles "halvering" Opprinnelig ble det opprettet 50 bitcoins per tilskudd, men dette beløpet har gradvis blitt redusert; for tiden er det 3125 bitcoins per blokk.

Selv om transaksjonsgebyrene representerer nyopprettede BTC, må de ikke overstige differansen mellom den totale inngangen og utgangen av alle transaksjonene i en blokk. Vi så tidligere at disse avgiftene representerer den delen av inndataene som ikke brukes i utdataene fra transaksjonene. Denne delen "går teknisk sett tapt" under transaksjonen, og utvinneren har rett til å gjenskape denne verdien i form av en eller flere nye UTXO-er. Det er derfor en overføring av verdi fra avsenderen av transaksjonen til utvinneren som legger den til i blokkjeden.

**> Visste du at bitcoins generert fra en coinbase-transaksjon er underlagt en modningsperiode på 100 blokker der de ikke kan brukes av utvinneren. Denne regelen er ment å unngå komplikasjoner forbundet med bruk av nyopprettede bitcoins i en kjede som senere kan bli foreldet.

### Konsekvensene av UTXO-modellen

For det første påvirker UTXO-modellen transaksjonsgebyrene i Bitcoin direkte. Fordi kapasiteten til hver blokk er begrenset, favoriserer utvinnere transaksjoner som gir de beste avgiftene i forhold til plassen de vil oppta i blokken. Jo mer UTXO en transaksjon inkluderer som input og output, jo tyngre er den, og jo høyere avgifter krever den. Dette er en av grunnene til at man ofte forsøker å redusere antallet UTXO-er i porteføljen, noe som også kan påvirke personvernet, et tema vi skal se nærmere på i den tredje delen av denne opplæringen.

Som nevnt i de foregående delene, er mynter på Bitcoin i hovedsak en kjede av UTXO-er. Hver transaksjon skaper dermed en kobling mellom en tidligere UTXO og en fremtidig UTXO. UTXO-er gjør det dermed mulig å spore bitcoins fra de blir skapt til de brukes i dag. Denne gjennomsiktigheten kan ses på som positiv, ettersom den gjør det mulig for hver bruker å sikre ektheten til mottatte bitcoins. Det er imidlertid også på dette prinsippet om sporbarhet og etterprøvbarhet at kjedeanalyse er basert, en praksis som er utformet for å kompromittere personvernet ditt. Vi vil studere denne praksisen i dybden i den andre delen av opplæringen.

## Bitcoins personvernmodell

<chapterId>769d8963-3ed5-4094-b21d-9203c7d9e465</chapterId>

### Valuta: Autentisitet, integritet og dobbeltbruk

En av valutaens funksjoner er å løse problemet med dobbelt sammenfall av behov. I et byttebasert system krever et bytte ikke bare at man finner en person som tilbyr en vare som tilfredsstiller mitt behov, men også at man gir vedkommende en vare av tilsvarende verdi som tilfredsstiller deres behov. Å finne denne balansen viser seg å være komplisert.

Derfor brukes valuta, som gjør det mulig å overføre verdier både i tid og rom.

For at valuta skal løse dette problemet, er det avgjørende at den som tilbyr en vare eller tjeneste, er overbevist om at han eller hun er i stand til å bruke beløpet senere. Derfor vil ethvert rasjonelt individ som ønsker å akseptere en form for valuta, enten den er digital eller fysisk, sørge for at den oppfyller to grunnleggende kriterier:


- Mynten må være intakt og autentisk;**- **og må ikke være brukt to ganger.**

Når man bruker fysisk valuta, er den første egenskapen den mest komplekse å påvise. Gjennom ulike historiske perioder har metallmyntenes integritet ofte blitt kompromittert av praksiser som kutting eller stansing. I antikkens Roma var det for eksempel vanlig at borgerne skrapte kantene på gullmyntene for å samle opp noe av det edle metallet, samtidig som de tok vare på dem for fremtidige transaksjoner. Myntenes egenverdi ble dermed redusert, men den pålydende verdien forble den samme. Dette er bemerkelsesverdig nok grunnen til at det senere ble preget striper på kanten av myntene.

Autentisitet er også en egenskap som er vanskelig å verifisere med fysiske, monetære midler. I dag blir teknikkene for å bekjempe forfalskninger stadig mer komplekse, noe som tvinger forhandlerne til å investere i dyre verifiseringssystemer.

På den annen side er dobbeltbetaling ikke noe problem for fysiske valutaer på grunn av deres natur. Hvis jeg gir deg en 10-euroseddel, går den ugjenkallelig ut av min besittelse og inn i din, noe som selvsagt utelukker enhver mulighet til å bruke de samme pengeenhetene flere ganger. Kort sagt vil jeg ikke kunne bruke den 10-euroseddelen igjen.

For digital valuta er det annerledes. Det er ofte enklere å sikre en mynts autentisitet og integritet. Som vi så i forrige avsnitt, gjør Bitcoins UTXO-modell det mulig å spore en mynt tilbake til dens opprinnelse, og dermed verifisere at den faktisk ble opprettet i samsvar med konsensusreglene av en utvinner.

Det er imidlertid mer komplisert å sikre at det ikke forekommer dobbeltbetaling, ettersom alle digitale varer i bunn og grunn er informasjon. I motsetning til fysiske varer deles ikke informasjon under utveksling, men forplanter seg ved å multiplisere. Hvis jeg for eksempel sender deg et dokument på e-post, blir det duplisert. Du på din side kan ikke med sikkerhet bekrefte at jeg har slettet originaldokumentet.

### Forhindre dobbeltbetaling på Bitcoin

Den eneste måten å unngå duplisering av en digital eiendel på, er å ha oversikt over alle utvekslinger i systemet. På den måten kan man vite hvem som eier hva, og oppdatere alles eierskap basert på transaksjonene som gjøres. Det er dette som for eksempel gjøres med skriftens penger i banksystemet. Når du betaler 10 euro til en kjøpmann med et kredittkort, registrerer banken denne utvekslingen og oppdaterer hovedboken.

På Bitcoin oppnås forebygging av dobbeltbetaling på samme måte. Målet er å bekrefte at det ikke har skjedd en transaksjon som allerede har brukt de aktuelle myntene. Hvis disse myntene aldri har blitt brukt, kan vi være sikre på at det ikke vil forekomme noen dobbeltbetaling. Dette prinsippet ble beskrevet av Satoshi Nakamoto i White Paper med denne berømte setningen:

**"Den eneste måten å bekrefte fraværet av en transaksjon på, er å være klar over alle transaksjoner."

I motsetning til bankmodellen er det imidlertid ikke noe ønske om å måtte stole på en sentral enhet på Bitcoin. Det er nødvendig for alle brukere å kunne bekrefte dette fraværet av dobbeltbetaling, uten å stole på en tredjepart. Derfor må alle være klar over alle Bitcoin-transaksjoner. Derfor blir Bitcoin-transaksjoner kringkastet offentlig på alle noder i nettverket og registrert i klartekst på blokkjeden.

Det er nettopp denne offentlige spredningen av informasjon som gjør det vanskelig å beskytte personvernet på Bitcoin. I det tradisjonelle banksystemet er det i teorien bare finansinstitusjonen som kjenner til transaksjonene som gjøres. På Bitcoin derimot, blir alle brukere informert om alle transaksjoner via sine respektive noder.

### Personvernmodellen: banksystem vs. Bitcoin

I det tradisjonelle systemet er bankkontoen din knyttet til identiteten din. Bankmannen kan vite hvilken kunde som tilhører hvilken bankkonto, og hvilke transaksjoner som er knyttet til den. Denne informasjonsflyten er imidlertid avbrutt mellom banken og det offentlige rom. Det er med andre ord umulig å vite saldo og transaksjoner på en bankkonto som tilhører en annen person. Det er bare banken som har tilgang til denne informasjonen.

For eksempel vet bankmannen din at du kjøper baguetten din hver morgen hos bakeren i nabolaget, men naboen din er uvitende om denne transaksjonen. Informasjonsflyten er dermed tilgjengelig for de interesserte partene, spesielt banken, men forblir utilgjengelig for utenforstående.

På grunn av begrensningen med offentlig formidling av transaksjoner som vi så i forrige del, kan ikke Bitcoins personvernmodell følge modellen til banksystemet. I Bitcoins tilfelle, fordi informasjonsflyten ikke kan avbrytes mellom transaksjonene og det offentlige domenet, er ** personvernmodellen basert på separasjonen mellom brukerens identitet og selve transaksjonene**.

Hvis du for eksempel kjøper en baguette av bakeren som betaler i BTC, kan naboen din, som eier sin egen fulle node, se transaksjonen din finne sted, akkurat som han kan se alle andre transaksjoner i systemet. Men hvis personvernprinsippene respekteres, skal de ikke kunne koble denne spesifikke transaksjonen til identiteten din.

Men fordi Bitcoin-transaksjoner offentliggjøres, blir det likevel mulig å etablere koblinger mellom dem for å utlede informasjon om de involverte partene. Denne aktiviteten utgjør til og med en spesialitet i seg selv, kalt "kjedeanalyse" I neste del av kurset inviterer jeg deg til å utforske det grunnleggende i kjedeanalyse for å forstå hvordan bitcoinsene dine spores og hvordan du bedre kan forsvare deg.

# Forstå kjedeanalyse og hvordan du kan beskytte deg selv

<partId>4739371e-9fef-45b0-bcaa-b7a4df6b4470</partId>

## Hva er kjedeanalyse på Bitcoin?

<chapterId>7d198ba6-4af2-4f24-86cb-3c79cb25627e</chapterId>

### Definisjon og drift

Kjedeanalyse er en praksis som omfatter alle metoder som brukes til å spore strømmen av bitcoin i blokkjeden. Kjedeanalyse baserer seg vanligvis på å observere trekk i eksempler på tidligere transaksjoner. Deretter identifiserer man de samme trekkene i en transaksjon man ønsker å analysere, og utleder plausible tolkninger. Denne metoden for problemløsning ut fra en praktisk tilnærming til å finne en god nok løsning er det som kalles "heuristikk"

For å forenkle er kjedeanalysen utført i tre hovedtrinn:

1. **Observerer blokkjeden;**

2. **Identifiser kjente egenskaper;**

3. **Utdannende forutsetninger

Blockchain-analyse kan utføres av hvem som helst. Det er tilstrekkelig å ha tilgang til den offentlige informasjonen i blokkjeden gjennom en full node for å observere transaksjonsbevegelser og gjøre antakelser. Det finnes også gratis verktøy som gjør denne analysen enklere, for eksempel nettstedet [OXT.me] (https://oxt.me/), som vi vil utforske i detalj i de to siste kapitlene i denne delen. Den største personvernrisikoen kommer imidlertid fra selskaper som spesialiserer seg på kjedeanalyse. Disse selskapene har tatt kjedeanalyse til industriell skala og selger tjenestene sine til finansinstitusjoner eller myndigheter. Blant disse selskapene er Chainalysis trolig det mest kjente.

### Målene med kjedeanalyse

Et av målene med kjedeanalysen er å gruppere ulike aktiviteter på Bitcoin for å finne ut hvem som er den unike brukeren som har utført dem. Deretter vil det være mulig å forsøke å knytte dette settet med aktiviteter til en faktisk identitet.

Husk forrige kapittel. Jeg forklarte hvorfor Bitcoins personvernmodell opprinnelig var basert på å skille brukeridentiteter fra transaksjonene deres. Derfor er det fristende å tro at kjedeanalyse er ubrukelig, for selv om man kan gruppere aktiviteter i kjeden, kan de ikke knyttes til en faktisk identitet.

Teoretisk sett er denne påstanden korrekt. I den første delen av denne opplæringen så vi at kryptografiske nøkkelpar brukes til å etablere betingelser på UTXO. Disse nøkkelparene avslører i utgangspunktet ingen informasjon om identiteten til innehaverne. Selv om vi er i stand til å gruppere aktiviteter som er knyttet til ulike nøkkelpar, sier dette oss ingenting om enheten som står bak disse aktivitetene.

Den praktiske virkeligheten er imidlertid mye mer kompleks. Det finnes en rekke atferdsmønstre som risikerer å knytte en ekte identitet til en aktivitet i kjeden. I analyse kalles dette et inngangspunkt, og det finnes mange.

Det vanligste er selvfølgelig KYC (_Know Your Customer_). Hvis du tar ut bitcoins fra en regulert plattform til en av dine personlige mottaksadresser, er det noen som kan knytte identiteten din til denne adressen. Mer generelt kan et inngangspunkt være enhver form for interaksjon mellom ditt virkelige liv og en bitcoin-transaksjon. Hvis du for eksempel legger ut en mottakeradresse på sosiale nettverk, kan dette være et inngangspunkt for analyse. Hvis du betaler med bitcoin til bakeren din, kan de knytte ansiktet ditt (som er en del av identiteten din) til en bitcoin-adresse.

Disse inngangspunktene er nesten uunngåelige ved bruk av Bitcoin. Selv om du kan prøve å begrense omfanget av dem, vil de forbli til stede. Derfor er det avgjørende å kombinere metoder som tar sikte på å bevare personvernet ditt. Selv om det å opprettholde et skille mellom din virkelige identitet og transaksjonene dine er en attraktiv tilnærming, er det fortsatt utilstrekkelig i dag. Hvis alle aktivitetene dine i kjeden kan grupperes sammen, er det sannsynlig at det minste inngangspunkt vil kompromittere det ene laget av personvern du har etablert.

### Forsvar mot kjedeanalyse

Derfor er det også nødvendig å kunne ta hensyn til blokkjedeanalyse i vår bruk av Bitcoin. Ved å gå frem på denne måten kan vi minimere aggregeringen av aktivitetene våre og begrense innvirkningen av et inngangspunkt på personvernet vårt.

Faktisk, for å bedre motvirke blockchain-analyse, hvilken bedre tilnærming enn å gjøre deg kjent med metodene som brukes i blockchain-analyse? Hvis du vil vite hvordan du kan forbedre personvernet ditt på Bitcoin, må du forstå disse metodene. Dette vil gjøre deg i stand til å bedre forstå teknikker som coinjoin eller payjoin (teknikker som vi vil studere i de siste delene av opplæringen), og redusere feilene du kan gjøre.

I denne sammenhengen kan vi trekke en analogi til kryptografi og kryptoanalyse. En god kryptograf er først og fremst en god kryptoanalytiker. For å utvikle en ny kryptografisk algoritme må du vite hvilke angrep den vil bli utsatt for, og du må også studere hvorfor tidligere algoritmer har blitt hacket. Det samme prinsippet gjelder for personvern på Bitcoin. Å forstå metodene for å analysere blokkjeden er nøkkelen til å beskytte seg mot den. Det er derfor jeg foreslår en hel seksjon om blokkjedeanalyse i denne opplæringen.

https://planb.network/tutorials/privacy/on-chain/coinjoin-samourai-wallet-e566803d-ab3f-4d98-9136-5462009262ef
https://planb.network/fr/tutorials/privacy/on-chain/payjoin-848b6a23-deb2-4c5f-a27e-93e2f842140f
### Metodene for blokkjedeanalyse

Det er viktig å forstå at blokkjedeanalyse ikke er en eksakt vitenskap. Den baserer seg på heuristikker utledet fra tidligere observasjoner eller logiske tolkninger. Disse reglene gir ganske pålitelige resultater, men aldri med absolutt presisjon. Med andre ord innebærer **blokkjedeanalyse alltid en sannsynlighetsdimensjon i konklusjonene som trekkes**. For eksempel kan man med større eller mindre sikkerhet anslå at to adresser tilhører samme enhet, men total sikkerhet vil alltid være utenfor rekkevidde.

Hovedmålet med blokkjedeanalyse ligger nettopp i aggregeringen av ulike heuristikker for å minimere risikoen for feil. Det er på en måte en opphopning av bevis som gjør at vi kan komme nærmere virkeligheten.

Disse berømte heuristikkene kan grupperes i flere kategorier som vi skal gå nærmere inn på sammen:


- Transaksjonsmodeller (eller transaksjonsmodeller);**
- Transaksjonens interne heuristikk;**
- Heuristikk utenfor transaksjonen**

### Satoshi Nakamoto og blokkjedeanalyse

Det bør bemerkes at de to første heuristikkene for kjedeanalyse ble oppdaget av Satoshi Nakamoto selv. Han diskuterer dem i del 10 av Bitcoin White Paper. Disse er


- den felles heuristikken for inngangsegenskaper (CIOH);
- og gjenbruk av adresser.

![BTC204](assets/fr/031.webp)

Kilde: S. Nakamoto: S. Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System", https://bitcoin.org/bitcoin.pdf, 2009.

I de neste kapitlene skal vi se nærmere på hva dette dreier seg om, men allerede nå er det interessant å merke seg at disse to heuristikkene fortsatt har en fremtredende plass i dagens kjedeanalyse.

## Transaksjonsmaler

<chapterId>d365a101-2d37-46a5-bfb9-3c51e37bf96b</chapterId>

En transaksjonsmodell er ganske enkelt et generelt mønster eller en struktur for en typisk transaksjon som finnes i blokkjeden, og som man antagelig vet hvordan den skal tolkes. Når vi studerer mønstre, fokuserer vi på én enkelt transaksjon som vi analyserer på et høyt nivå.

Med andre ord vil vi bare se på antall UTXO-er i inndataene og antall UTXO-er i utdataene, uten å gå inn på de mer spesifikke detaljene eller miljøet rundt transaksjonen. Ut fra det observerte mønsteret vil vi kunne tolke transaksjonens natur. Deretter ser vi etter trekk i strukturen og utleder en tolkning.

![BTC204](assets/it/32/01.webp)

I denne delen vil vi sammen oppdage de viktigste transaksjonsmønstrene som kan oppstå i kjedeanalyser, og for hvert mønster vil jeg gi deg en sannsynlig tolkning av denne strukturen, sammen med et konkret eksempel.

### Enkel sending (eller enkel betaling)

La oss starte med en veldig populær modell, siden det er den som forekommer i de fleste bitcoinbetalinger. Den enkle betalingsmodellen kjennetegnes ved at man forbruker én eller flere UTXO-er i input og produserer 2 UTXO-er i output. Denne modellen vil derfor se slik ut:

![BTC204](assets/it/32/02.webp)

Når vi identifiserer denne transaksjonsstrukturen på blokkjeden, kan vi allerede trekke en tolkning. Som navnet antyder, indikerer dette mønsteret at vi har å gjøre med en send- eller betal-transaksjon. Brukeren har brukt sine UTXO-er i input for å tilfredsstille en UTXO for betaling og en UTXO for endring (penger returneres til samme bruker) i output.

Dermed vet vi at den observerte brukeren sannsynligvis ikke lenger er i besittelse av den ene av de to UTXO-ene (betalings UTXO-en), men at han fortsatt er i besittelse av den andre UTXO-en (endrings UTXO-en).

For øyeblikket er det umulig for oss å spesifisere hvilken utgang som representerer hvilken UTXO, siden dette ikke er målet med studiet av modeller. Vi vil oppnå dette målet ved å benytte oss av heuristikkene som vi vil studere i de følgende delene. På dette stadiet er målet vårt begrenset til å identifisere hva slags transaksjon det er snakk om, som i dette tilfellet er en enkel sending.

Her er for eksempel en Bitcoin-transaksjon som bruker den enkle sendemodellen:

```plaintext
b6cc79f45fd2d7669ff94db5cb14c45f1f879ea0ba4c6e3d16ad53a18c34b769
```

![BTC204](assets/it/32/03.webp)

Fonte: [Mempool.space](https://mempool.space/fr/tx/b6cc79f45fd2d7669ff94db5cb14c45f1f879ea0ba4c6e3d16ad53a18c34b769)

Etter dette første eksemplet bør du ha fått en bedre forståelse av hva det vil si å studere en "transaksjonsmodell" Vi undersøker en transaksjon ved kun å fokusere på dens struktur, uten å ta hensyn til omgivelsene eller transaksjonsspesifikke detaljer. I dette første trinnet ser vi bare på den globalt.

Nå som du har forstått hva en modell er, kan vi gå videre til de andre eksisterende modellene.

### Feiing

Denne andre modellen kjennetegnes ved at den bruker én UTXO som inngang og produserer én UTXO som utgang.

![BTC204](assets/it/32/04.webp)

Tolkningen av denne modellen er at vi har å gjøre med en automatisk overføring. Brukeren har overført sine bitcoins til seg selv, til en annen adresse som eies av ham. Siden det ikke er noen rest i transaksjonen, er det svært usannsynlig at vi har å gjøre med en betaling. Når en betaling utføres, er det faktisk nesten umulig for betaleren å ha en UTXO som nøyaktig samsvarer med beløpet som selgeren har bedt om, pluss transaksjonsgebyrer. Som regel er betaleren derfor tvunget til å produsere en restutgang.

Derfor vet vi at den observerte brukeren sannsynligvis fortsatt er i besittelse av denne UTXO-en. I forbindelse med en kjedeanalyse, hvis vi vet at UTXO-en som ble brukt som input i transaksjonen tilhører Alice, kan vi anta at UTXO-en i output også tilhører henne. Det som vil bli interessant senere, er å finne heuristikker internt i transaksjonen som kan styrke denne antagelsen (vi vil studere disse heuristikkene i avsnitt 3.3).

Her er for eksempel en Bitcoin-transaksjon som tar i bruk den feiende modellen:

```plaintext
35f1072a0fda5ae106efb4fda871ab40e1f8023c6c47f396441ad4b995ea693d
```

![BTC204](assets/it/32/05.webp)

Kilde:[Mempool.space](https://mempool.space/fr/tx/35f1072a0fda5ae106efb4fda871ab40e1f8023c6c47f396441ad4b995ea693d) Denne typen mønster kan imidlertid også avsløre en selvoverføring til en kryptovaluta-utvekslingsplattformkonto. Det vil være studiet av de kjente adressene og konteksten til transaksjonen som gjør at vi kan vite om det er en konsolidering til en selvlagringslommebok eller et uttak til en plattform. Faktisk er adressene til utvekslingsplattformer ofte lett identifiserbare.

La oss gå tilbake til Alice-eksemplet: Hvis konsolideringen fører til en kjent adresse på en plattform (som for eksempel Binance), kan dette bety at bitcoinsene ble overført ut av Alices direkte besittelse, sannsynligvis med den hensikt å selge dem eller lagre dem på denne plattformen. Hvis destinasjonsadressen derimot er ukjent, er det rimelig å anta at det rett og slett er en annen lommebok som fortsatt tilhører Alice. Men denne typen studier faller mer inn under kategorien heuristikk og ikke studier av mønstre.

### Konsolidering

Denne modellen kjennetegnes ved at den bruker flere UTXO-er som input og produserer én UTXO som output.

![BTC204](assets/it/32/06.webp)

Tolkningen av dette mønsteret er at vi står overfor en konsolidering. Dette er en vanlig praksis blant Bitcoin-brukere å slå sammen flere UTXO-er i påvente av en mulig økning i transaksjonsgebyrene. Ved å utføre denne operasjonen i en periode hvor avgiftene er lave, er det mulig å spare på fremtidige avgifter. Vi kommer tilbake til denne praksisen i kapittel 4.3.

Vi kan slutte at brukeren bak denne transaksjonsmodellen sannsynligvis var i besittelse av alle UTXO-ene som ble sendt inn, og at han fortsatt er i besittelse av UTXO-ene som sendes ut. Dette er definitivt en autotransfer.

Akkurat som konsolidering kan denne typen mønster også avsløre en selvoverføring til en konto på en utvekslingsplattform. Det vil være studiet av de kjente adressene og konteksten for transaksjonen som vil gjøre det mulig for oss å vite om det er en konsolidering til en selvbevarende lommebok eller et uttak til en plattform.

Her er for eksempel en Bitcoin-transaksjon som tar i bruk konsolideringsskjemaet:

```plaintext
77c16914211e237a9bd51a7ce0b1a7368631caed515fe51b081d220590589e94
```

![BTC204](assets/it/32/07.webp)

Fonte: [Mempool.space](https://mempool.space/fr/tx/77c16914211e237a9bd51a7ce0b1a7368631caed515fe51b081d220590589e94)

I forbindelse med en kjedeanalyse kan denne modellen avsløre mye informasjon. Hvis vi for eksempel vet at en av inndataene tilhører Alice, kan vi anta at alle andre inn- og utdata i denne transaksjonen tilhører henne. Denne antakelsen gjør det mulig for oss å spore tilbake gjennom tidligere transaksjonskjeder for å oppdage og analysere andre transaksjoner som sannsynligvis er knyttet til Alice.

![BTC204](assets/it/32/08.webp)

### Grupperte utgifter

Denne modellen kjennetegnes av forbruk av noen få UTXO-er som input (ofte bare én) og produksjon av mange UTXO-er som output.

![BTC204](assets/it/32/09.webp)

Tolkningen av dette mønsteret er at vi har å gjøre med bundled spending. Dette er en praksis som sannsynligvis vil avsløre betydelig økonomisk aktivitet, for eksempel en utvekslingsplattform. Grupperte utgifter gjør det mulig for disse enhetene å spare gebyrer ved å samle utgiftene sine i én enkelt transaksjon.

Vi kan utlede fra denne modellen at UTXO-inngangen kommer fra et selskap med betydelig økonomisk aktivitet, og at UTXO-utgangen vil spre seg. Mange vil tilhøre selskapets kunder som har tatt ut bitcoin fra plattformen. Andre kan gå til partnerbedrifter. Til slutt vil det helt sikkert være en eller flere utvekslinger som går tilbake til det utstedende selskapet.

Her er for eksempel en Bitcoin-transaksjon som bruker den grupperte utgiftsmodellen (sannsynligvis er det en transaksjon utstedt av Bybit-plattformen):

```plaintext
8a7288758b6e5d550897beedd13c70bcbaba8709af01a7dbcc1f574b89176b43
```

![BTC204](assets/it/32/10.webp)

Fonte: [Mempool.space](https://mempool.space/fr/tx/8a7288758b6e5d550897beedd13c70bcbaba8709af01a7dbcc1f574b89176b43)

### Protokollspesifikke transaksjoner

Blant transaksjonsmønstrene kan vi også identifisere mønstre som avslører bruken av en bestemt protokoll. For eksempel vil Whirlpool coinjoins (som vi vil diskutere i del 5) ha en lett identifiserbar struktur som gjør det mulig å skille dem fra andre mer tradisjonelle transaksjoner.

![BTC204](assets/it/32/11.webp)

Analyse av dette mønsteret tyder på at vi sannsynligvis har å gjøre med en samarbeidstransaksjon. Det er også mulig å observere en coinjoin. Hvis sistnevnte hypotese viser seg å stemme, kan antallet utganger gi oss et grovt estimat av antallet deltakere i en coinjoin.

Her er for eksempel en Bitcoin-transaksjon som bruker samarbeidsmodellen coinjoin:

```plaintext
00601af905bede31086d9b1b79ee8399bd60c97e9c5bba197bdebeee028b9bea
```

![BTC204](assets/it/32/12.webp)

Fonte: [Mempool.space](https://mempool.space/fr/tx/00601af905bede31086d9b1b79ee8399bd60c97e9c5bba197bdebeee028b9bea)

Det finnes mange andre protokoller som har sine egne spesifikke strukturer. Vi kan for eksempel skille mellom transaksjoner av typen Wabisabi, Stamps transaksjoner eller til og med Runes.

Takket være disse transaksjonsmodellene kan vi allerede tolke en viss mengde informasjon om en gitt transaksjon. Men transaksjonens struktur er ikke den eneste kilden til informasjon som kan analyseres. Vi kan også studere detaljene. Disse detaljene, som er interne i en transaksjon, er det jeg liker å kalle "interne heuristikker", og vi skal se nærmere på dem i neste kapittel.

## Interne heuristikker

<chapterId>c54b5abe-872f-40f4-a0d0-c59faff228ba</chapterId>

En intern heuristikk er en spesifikk egenskap som er identifisert i selve transaksjonen, uten at det er nødvendig å undersøke omgivelsene, og som gjør det mulig for oss å trekke slutninger. I motsetning til modeller som fokuserer på transaksjonens overordnede struktur på et høyt nivå, er interne heuristikker basert på et sett med data som kan hentes ut. Dette inkluderer


- Mengden av ulike UTXO-er inn og ut;
- Alt om skript: mottaksadresser, versjonering, låsetider osv.

Vanligvis vil denne typen heuristikk gjøre det mulig for oss å identifisere resten i en bestemt transaksjon. På den måten kan vi fortsette å spore en enhet på tvers av flere transaksjoner. Hvis vi identifiserer en UTXO som tilhører en bruker vi ønsker å spore, er det faktisk avgjørende å finne ut hvilken utgang som er overført til en annen bruker, og hvilken utgang som representerer resten, og som dermed forblir i brukerens besittelse, når han eller hun foretar en transaksjon.

![BTC204](assets/it/33/01.webp)

Jeg minner igjen om at disse heuristikkene på ingen måte er nøyaktige. Hver for seg gir de oss bare mulighet til å identifisere plausible scenarier. Det er akkumuleringen av ulike heuristikker som bidrar til å redusere usikkerheten, uten å eliminere den helt.

### Interne likheter

Denne heuristikken går ut på å studere likhetene mellom inn- og utdataene i samme transaksjon. Hvis vi observerer det samme trekket på inndataene og på bare én av utdataene i transaksjonen, er det sannsynlig at denne utdataen utgjør resten.

Den mest åpenbare funksjonen er gjenbruk av en mottakeradresse i samme transaksjon.

![BTC204](assets/it/33/02.webp)

Denne heuristikken gir lite rom for tvil. Med mindre den private nøkkelen er blitt hacket, vil den samme mottakeradressen uunngåelig avsløre aktiviteten til én enkelt bruker. Tolkningen som følger, er at resten av transaksjonen er output med samme adresse som input. Dette muliggjør kontinuerlig sporing av personen basert på denne resten.

Her er for eksempel en transaksjon som denne heuristikken med rimelighet kan brukes på:

```plaintext
54364146665bfc453a55eae4bfb8fdf7c721d02cb96aadc480c8b16bdeb8d6d0
```

![BTC204](assets/fr/046.webp)

Fonte: [Mempool.space](https://mempool.space/tx/54364146665bfc453a55eae4bfb8fdf7c721d02cb96aadc480c8b16bdeb8d6d0)

Disse likhetene mellom input og output stopper ikke ved gjenbruk av adresser. Alle likheter i bruken av skript kan gjøre det mulig å bruke heuristikk. Noen ganger kan man for eksempel observere samme versjonering mellom en inngang og en av transaksjonsutgangene.

![BTC204](assets/it/33/04.webp)

I dette diagrammet kan vi se at inngang nr. 0 låser opp et P2WPKH-skript (SegWit V0 som starter med `bc1q`). Utgang nr. 0 bruker samme type skript. Utdata nr. 1 bruker imidlertid et P2TR-skript (SegWit V1 som begynner med `bc1p`). Tolkningen av denne funksjonen er at det er sannsynlig at adressen med samme versjonering som input er adressen til resten. Den vil derfor fortsatt tilhøre den samme brukeren.

Her er en transaksjon der denne heuristikken med rimelighet kan anvendes:

```plaintext
db07516288771ce5d0a06b275962ec4af1b74500739f168e5800cbcb0e9dd578
```

![BTC204](assets/fr/048.webp)

Fonte: [Mempool.space](https://mempool.space/tx/db07516288771ce5d0a06b275962ec4af1b74500739f168e5800cbcb0e9dd578)

I dette tilfellet kan vi se at inngang nr. 0 og utgang nr. 1 bruker P2WPKH-skript (SegWit V0), mens utgang nr. 0 bruker en annen type skript, P2PKH (Legacy). På begynnelsen av 2010-tallet var denne heuristikken basert på skriptversjon relativt lite nyttig på grunn av begrensningen i tilgjengelige skripttyper. Over tid, og med senere oppdateringer av Bitcoin, har imidlertid et økende mangfold av skripttyper blitt introdusert. Denne heuristikken blir stadig mer relevant, fordi med et større utvalg av skripttyper blir brukerne delt inn i mindre grupper, noe som øker sjansene for å bruke denne interne heuristikken for gjenbruk av versjoner. Av denne grunn er det, bare ut fra et personvernperspektiv, tilrådelig å velge den vanligste skripttypen. I skrivende stund er for eksempel Taproot-skript (`bc1p`) mindre utbredt enn SegWit V0-skript (`bc1q`). Selv om førstnevnte gir økonomiske og personvernmessige fordeler i visse spesifikke sammenhenger, kan det være lurt å holde seg til en eldre standard av personvernhensyn til den nye standarden er mer utbredt for mer tradisjonell bruk med én signatur.

### Betalinger med avrundede tall

En annen intern heuristikk som kan hjelpe oss med å identifisere restbeløpet, er det avrundede tallet. Når vi står overfor et enkelt betalingsopplegg (1 inngang og 2 utganger), er det vanligvis slik at hvis en av utgangene bruker et avrundet beløp, så representerer det betalingen.

![BTC204](assets/it/33/06.webp)

Ved eliminering, hvis den ene utdata representerer betaling, representerer den andre endring. Det kan derfor utledes at det er sannsynlig at brukeren som har lagt inn transaksjonen, fortsatt er i besittelse av utdataene som er identifisert som endring.

Det er verdt å merke seg at denne heuristikken ikke alltid er anvendelig, ettersom de fleste betalinger fortsatt gjøres i fiat-valutaenheter. Når en forhandler i Frankrike aksepterer bitcoin, viser han som regel ikke stabile priser i sats. Han velger heller å konvertere prisen i euro til beløpet i bitcoin som skal betales. Derfor bør det ikke være et avrundet tall i transaksjonsutdataene.

En analytiker kan imidlertid forsøke å gjøre denne konverteringen ved å ta hensyn til valutakursen som gjaldt på det tidspunktet transaksjonen ble overført over nettverket. Ta et eksempel på en transaksjon med en inngang på 97 552 sats og to utganger, den ene på 31 085 sats og den andre på 64 152 sats. Ved første øyekast ser det ikke ut til at denne transaksjonen involverer avrundede beløp. Men ved å bruke valutakursen på 64,339 euro på transaksjonstidspunktet, får vi en omregning til euro som ser ut som følger:


- En innsats på 62,76 euro;
- En produksjon på 20 euro;
- Et resultat på 41,27 euro.

Når transaksjonen er konvertert til fiat-valuta, kan heuristikken for betalinger med avrundede beløp anvendes. Utbetalingen på 20 euro var sannsynligvis tiltenkt en kjøpmann, eller byttet eier på annen måte. Utbetalingen på 41,27 euro forble sannsynligvis i den opprinnelige brukerens besittelse.

![BTC204](assets/it/33/07.webp)

Hvis Bitcoin en dag blir den foretrukne regningsenheten i transaksjonene våre, kan denne heuristikken bli enda mer nyttig for analyse.

Her er for eksempel en transaksjon der denne heuristikken sannsynligvis kan brukes:

```plaintext
2bcb42fab7fba17ac1b176060e7d7d7730a7b807d470815f5034d52e96d2828a
```

![BTC204](assets/fr/051.webp)

Fonte: [Mempool.space](https://mempool.space/tx/2bcb42fab7fba17ac1b176060e7d7d7730a7b807d470815f5034d52e96d2828a)

### Den største produksjonen

Når det er en betydelig stor forskjell mellom to utganger av en transaksjon i en enkel betalingsmodell, kan det anslås at den største utgangen sannsynligvis er restbeløpet.

![BTC204](assets/it/33/09.webp)

Denne heuristikken er sannsynligvis den mest unøyaktige av alle. Når den identifiseres alene, er den ganske svak. Denne funksjonen kan imidlertid kombineres med andre heuristikker for å redusere usikkerheten i tolkningen vår.

Hvis vi for eksempel undersøker en transaksjon som har en utbetaling med et rundt beløp og en annen utbetaling med et større beløp, kan vi redusere usikkerheten ved å bruke både heuristikken for runde betalinger og heuristikken knyttet til den større utbetalingen.

Her er for eksempel en transaksjon der denne heuristikken sannsynligvis kan brukes:

```plaintext
b79d8f8e4756d34bbb26c659ab88314c220834c7a8b781c047a3916b56d14dcf
```

![BTC204](assets/fr/053.webp)

Fonte: [Mempool.space](https://mempool.space/tx/b79d8f8e4756d34bbb26c659ab88314c220834c7a8b781c047a3916b56d14dcf)

## Ekstern heuristikk

<chapterId>4a170e3b-200d-431a-8285-18a23ff617ba</chapterId>

Studiet av eksterne heuristikker innebærer å analysere likheter, mønstre og egenskaper ved visse elementer som ikke er iboende i selve transaksjonen. Med andre ord: Mens vi tidligere begrenset oss til å utnytte elementer i selve transaksjonen med interne heuristikker, utvider vi nå analysefeltet til å omfatte transaksjonens omgivelser gjennom eksterne heuristikker.

### Gjenbruk av adresser

Dette er en av de mest kjente heuristikkene blant Bitcoin-entusiaster. Gjenbruk av adresser gjør det mulig å opprette en forbindelse mellom ulike transaksjoner og ulike UTXO-er. Det observeres når en Bitcoin-mottakeradresse brukes flere ganger.

Dermed er det mulig å utnytte gjenbruk av adresser innenfor samme transaksjon som en intern heuristikk for å identifisere resten (som vi så i forrige kapittel). Gjenbruk av adresser kan imidlertid også fungere som en ekstern heuristikk for å gjenkjenne en unik enhet bak flere transaksjoner.

Tolkningen av gjenbruk av adresser er at alle UTXO-er som er låst på denne adressen, tilhører (eller har tilhørt) samme enhet. Denne heuristikken gir lite rom for usikkerhet. Når den kan identifiseres, er det mest sannsynlig at tolkningen som følger, stemmer overens med virkeligheten. Den gjør det dermed mulig å gruppere ulike aktiviteter i kjeden.

![BTC204](assets/it/34/01.webp)

Som forklart i innledningen til denne del 3, ble denne heuristikken oppdaget av Satoshi Nakamoto selv. I hvitboken nevner han spesifikt en løsning for å unngå dette, nemlig å bruke en ny adresse for hver nye transaksjon:

"_Som en ekstra beskyttelse kan et nytt nøkkelpar brukes for hver transaksjon for å forhindre at de knyttes til en felles eier."

![BTC204](assets/fr/055.webp)

Kilde: S. Nakamoto: S. Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System", https://bitcoin.org/bitcoin.pdf, 2009.

Her er for eksempel en adresse som gjenbrukes i flere transaksjoner:

```plaintext
bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0
```

Kilde:[Mempool.space](https://mempool.space/address/bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0)

### Likhet mellom skript og fingeravtrykk av lommebøker

I tillegg til gjenbruk av adresser finnes det en rekke andre heuristikker for å knytte aksjer til samme portefølje eller til en klynge av adresser.

Først og fremst kan en analytiker dra nytte av likheter i skriptbruken. For eksempel kan visse minoritetsskript som multisig identifiseres lettere enn SegWit V0-skript. Jo større gruppe vi gjemmer oss i, desto vanskeligere er det å identifisere oss. Dette er grunnen til at alle deltakerne i gode Coinjoin-protokoller bruker nøyaktig samme type skript.

Mer generelt kan en analytiker også fokusere på fingeravtrykkskarakteristikkene til en portefølje. Dette er spesifikke prosesser knyttet til bruk som man kan forsøke å identifisere med sikte på å utnytte dem som sporingsheuristikk. Med andre ord, hvis man observerer en opphopning av de samme interne karakteristikkene på transaksjoner som tilskrives den sporede enheten, kan man forsøke å identifisere de samme karakteristikkene på andre transaksjoner.

For eksempel kan det identifiseres at den sporede brukeren systematisk sender resten til P2TR-adresser (`bc1p...`). Hvis denne prosessen gjentas, kan den brukes som en heuristikk for den videre analysen. Andre fingeravtrykk kan brukes, for eksempel rekkefølgen på UTXO-ene, plasseringen av restbeløpet i utdataene, RBF-signaleringen (Replace-by-Fee), eller til og med versjonsnummeret, `nSequence`-feltet og `nLockTime`-feltet.

Som [@LaurentMT] (https://twitter.com/LaurentMT) spesifiserer i [Space Kek #19] (https://podcasters.spotify.com/pod/show/decouvrebitcoin/episodes/SpaceKek-19---Analyse-de-chane--anonsets-et-entropie-e1vfuji) (en franskspråklig podcast), øker nytten av lommebokfingeravtrykk i kjedeanalyse betydelig over tid. Det økende antallet skripttyper og den stadig mer gradvise implementeringen av disse nye funksjonene i lommebokprogramvaren forsterker forskjellene. Det kan til og med være slik at man nøyaktig kan identifisere programvaren som brukes av enheten som spores. Det er derfor viktig å forstå at studiet av en lommebøkenes digitale fotavtrykk viser seg å være spesielt relevant for nyere transaksjoner, mer enn for dem som ble initiert tidlig på 2010-tallet.

Et fingeravtrykk kan være en hvilken som helst spesifikk praksis, utført automatisk av lommeboken eller manuelt av brukeren, som kan gjenfinnes på andre transaksjoner for å hjelpe oss i analysen.

### Heuristikken for felles eierskap av inndata (CIOH)

CIOH, som står for "Common Input Ownership Heuristic" på engelsk, er en heuristikk som sier at når en transaksjon inneholder flere inndata, er det sannsynlig at de kommer fra én og samme enhet. Dermed er eierskapet til dem felles.

For å bruke Common Ownership Heuristics of Inputs (CIOH) observerer vi først en transaksjon som har flere innganger. Dette kan være fra minimum 2 innganger til maksimalt 30 innganger. Når denne karakteristikken er identifisert, sjekker vi om transaksjonen ikke passer inn i en kjent transaksjonsmodell. Hvis den for eksempel har fem innganger med omtrent like store beløp og fem utganger med nøyaktig samme beløp, vet vi at det er strukturen til en coinjoin. Derfor kan vi ikke bruke IOCH.

Men hvis transaksjonen ikke passer inn i noen kjent modell for samarbeidstransaksjoner, kan vi slutte at alle inndataene sannsynligvis kommer fra samme enhet. Dette kan være svært nyttig for å utvide en kjent klynge eller for å fortsette sporingen.

CIOH ble oppdaget av Satoshi Nakamoto. Han diskuterer dette i del 10 av hvitboken:

"_[...] kobling er uunngåelig med transaksjoner med flere inndata, som nødvendigvis avslører at inndataene var eid av samme eier. Risikoen er at hvis eieren av en nøkkel blir avslørt, kan koblinger avsløre andre transaksjoner som tilhørte samme eier."

Det er spesielt fascinerende å merke seg at Satoshi Nakamoto, allerede før den offisielle lanseringen av Bitcoin, hadde identifisert de to viktigste sårbarhetene for brukernes personvern, nemlig IOCH og gjenbruk av adresser. En slik spådom er ganske bemerkelsesverdig, ettersom disse to heuristikkene den dag i dag fortsatt er de mest nyttige i blokkjedeanalyse.

Her er et eksempel på en transaksjon som vi sannsynligvis kan bruke IOCH på:

```plaintext
20618e63b6eed056263fa52a2282c8897ab2ee71604c7faccfe748e1a202d712
```

Fonte: [Mempool.space](https://mempool.space/tx/20618e63b6eed056263fa52a2282c8897ab2ee71604c7faccfe748e1a202d712)

### Data utenfor kjeden

Kjedeanalyse er selvsagt ikke begrenset til data fra kjeden. Data fra tidligere analyser eller data som er tilgjengelige på Internett, kan også brukes til å avgrense en analyse.

Hvis man for eksempel observerer at sporede transaksjoner systematisk sendes fra samme Bitcoin-node og IP-adressen kan identifiseres, kan det være mulig å identifisere andre transaksjoner fra samme enhet, samt å fastslå deler av avsenderens identitet. Selv om dette ikke er lett å gjennomføre, ettersom det krever mange noder for å fungere, er det mulig at noen selskaper som spesialiserer seg på kjedeanalyse vil benytte seg av det.

Analytikeren har også muligheten til å basere seg på analyser som tidligere er gjort med åpen kildekode, eller på sine egne tidligere analyser. Kanskje kan man finne en output som peker mot en adresseklynge som allerede er identifisert. Noen ganger er det også mulig å basere seg på utdata som peker mot en utvekslingsplattform, ettersom adressene til disse selskapene er allment kjent.

På samme måte kan man utføre analyse ved eliminering. Hvis for eksempel en transaksjon med to utganger analyseres, og en av dem er koblet til en adresseklynge som allerede er kjent, men som er forskjellig fra enheten som spores, kan det tolkes som at den andre utgangen sannsynligvis representerer resten.

Kjedeanalyse omfatter også en del av OSINT (_Open Source Intelligence_) som er litt mer generalistisk med internettsøk. Derfor anbefales det ikke å legge ut mottakeradresser direkte på sosiale medier eller på en nettside, enten det er under pseudonym eller ikke.

![BTC204](assets/fr/063.webp)

### Temporale mønstre

Det er mindre vanlig å tenke på det, men visse menneskelige atferdsmønstre er gjenkjennelige i kjeden. Det mest nyttige i analysen kan være sovemønsteret ditt! Ja, når du sover, overfører du antageligvis ikke Bitcoin-transaksjoner. Fordi du generelt sover på de samme tidspunktene, er det vanlig å bruke tidsanalyse i kjedeanalyse. Dette innebærer ganske enkelt å katalogisere tidspunktene når en gitt enhets transaksjoner overføres til Bitcoin-nettverket. Ved å analysere disse tidsmønstrene kan vi utlede mye informasjon.

Først og fremst vil en tidsanalyse noen ganger kunne identifisere hvilken type enhet som spores. Hvis man observerer at transaksjonene overføres konsekvent over 24 timer, vil dette avsløre sterk økonomisk aktivitet. Enheten som står bak disse transaksjonene, er sannsynligvis et selskap, potensielt internasjonalt, og kanskje med internt automatiserte prosedyrer.

For eksempel [hadde jeg gjenkjent dette mønsteret for noen måneder siden](https://twitter.com/Loic_Pandul/status/1701127409712452072) ved å analysere [transaksjonen som feilaktig hadde allokert 19 bitcoins i gebyrer](https://mempool.space/tx/d5392d474b4c436e1c9d1f4ff4be5f5f9bb0eb2e26b61d2781751474b7e870fd). En enkel tidsanalyse hadde gjort det mulig for meg å anta at vi hadde å gjøre med en automatisert tjeneste, og derfor sannsynligvis en stor enhet som en utvekslingsplattform.

Noen dager senere ble det oppdaget at pengene tilhørte PayPal, via utvekslingsplattformen Paxos.

Hvis vi derimot ser at tidsmønsteret er spredt utover 16 helt bestemte timer, kan vi anslå at vi har å gjøre med en enkeltbruker, eller kanskje en lokal bedrift, avhengig av handelsvolumene.

I tillegg til den observerte enhetens natur kan tidsmodellen også gi oss en omtrentlig lokalisering av brukeren gjennom tidssoner. Vi kan deretter koble sammen andre transaksjoner, og bruke tidsstemplene for disse som ytterligere heuristikk som kan legges til i analysen vår.

På den gjenbrukte adressen jeg nevnte tidligere, kan vi for eksempel observere at transaksjonene, både innkommende og utgående, er konsentrert til et 13-timers intervall.

```plaintext
bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0
```

![BTC204](assets/fr/064.webp)

Kilde: OXT.me

Dette området tilsvarer sannsynligvis Europa, Afrika eller Midtøsten. Vi kan derfor slutte at brukeren bak disse transaksjonene bor der.

I et annet register er det også en slik tidsanalyse som muliggjorde hypotesen om at Satoshi Nakamoto ikke opererte fra Japan, men faktisk fra USA: [_The Time Zones of Satoshi Nakamoto_](https://medium.com/@insearchofsatoshi/the-time-zones-of-satoshi-nakamoto-aa40f035178f)

## Praktisk anvendelse med en Block Explorer

<chapterId>6493cf2f-225c-405f-9375-c4304f1087ed</chapterId>

I dette siste kapittelet skal vi konkret anvende konseptene vi har studert så langt. Jeg vil presentere eksempler på ekte Bitcoin-transaksjoner, og du må selv hente ut informasjonen jeg ber om.

Ideelt sett ville det være å foretrekke å bruke et profesjonelt kjedeanalyseverktøy for disse øvelsene. Etter nedleggelsen av skaperne av Samourai Wallet er imidlertid det eneste gratis analyseverktøyet OXT.me ikke lenger tilgjengelig. Derfor vil vi velge en klassisk blokkutforsker for disse øvelsene. Jeg anbefaler å bruke [Mempool.space] (https://mempool.space/) på grunn av de mange funksjonene og utvalget av kjedeanalyseverktøy, men du kan også velge en annen utforsker som [Bitcoin Explorer] (https://bitcoinexplorer.org/). Til å begynne med vil jeg introdusere øvelsene. Bruk blokkutforskeren din til å fullføre dem, og skriv svarene dine på et stykke papir. På slutten av dette kapittelet vil jeg gi deg svarene, slik at du kan sjekke og korrigere resultatene dine.

transaksjonene som er valgt ut til disse øvelsene, er valgt noe tilfeldig på grunn av sine egenskaper. Dette kapittelet er kun ment for opplærings- og informasjonsformål. Jeg vil gjøre det klart at jeg ikke anbefaler eller oppfordrer til bruk av disse verktøyene til ondsinnede formål. Målet er å lære deg hvordan du kan beskytte deg mot kjedeanalyser, ikke å utføre analyser for å avsløre andres private opplysninger._

### Øvelse 1

ID for transaksjonen som skal analyseres:

```plaintext
3769d3b124e47ef4ffb5b52d11df64b0a3f0b82bb10fd6b98c0fd5111789bef7
```

Hva er modellnavnet på denne transaksjonen, og hvilke plausible tolkninger kan man trekke ved kun å se på modellen, det vil si strukturen i transaksjonen?

### Øvelse 2

ID for transaksjonen som skal analyseres:

```plaintext
baa228f6859ca63e6b8eea24ffad7e871713749d693ebd85343859173b8d5c20
```

Hva er modellnavnet på denne transaksjonen, og hvilke plausible tolkninger kan man trekke ved kun å se på modellen, det vil si strukturen i transaksjonen?

### Øvelse 3

ID for transaksjonen som skal analyseres:

```plaintext
3a9eb9ccc3517cc25d1860924c66109262a4b68f4ed2d847f079b084da0cd32b
```

Hva er mønsteret i denne transaksjonen?

Etter å ha identifisert modellen, ved hjelp av transaksjonens interne heuristikk, hvilken utdata vil sannsynligvis representere resten?

### Øvelse 4

ID for transaksjonen som skal analyseres:

```plaintext
35f0b31c05503ebfdf7311df47f68a048e992e5cf4c97ec34aa2833cc0122a12
```

Hva er mønsteret i denne transaksjonen?

Etter å ha identifisert modellen, ved hjelp av transaksjonens interne heuristikk, hvilken utdata vil sannsynligvis representere resten?

### Øvelse 5

Tenk deg at Loïc la ut en av Bitcoin-adressene sine for å motta betalinger på det sosiale nettverket Twitter:

![BTC204](assets/fr/065.webp)

```plaintext
bc1qja0hycrv7g9ww00jcqanhfpqmzx7luqalum3vu
```

Hvilke Bitcoin-transaksjoner kan vi knytte til Loïcs identitet ved å bruke **kun gjenbruk av adresser**?

_Jeg er selvsagt ikke den virkelige eieren av denne mottaksadressen, og jeg har ikke lagt den ut på sosiale medier. Det er en adresse som jeg tilfeldig valgte fra blokkjeden

### Øvelse 6

Etter øvelse 5, ved hjelp av heuristikk for gjenbruk av adresser, var du i stand til å identifisere flere Bitcoin-transaksjoner der Loïc ser ut til å være involvert. Normalt sett burde du ha identifisert denne transaksjonen blant de identifiserte transaksjonene:

Denne transaksjonen representerer den aller første som sender penger til Loïcs adresse. Hvor tror du bitcoinsene som Loïc mottok gjennom denne transaksjonen kom fra?

### Øvelse 7

Etter øvelse 5, der du brukte heuristikk for gjenbruk av adresser, klarte du å identifisere flere Bitcoin-transaksjoner som Loïc ser ut til å være involvert i. Du ønsker nå å finne ut hvor Loïc kom fra. Basert på transaksjonene du har funnet, gjennomfører du en tidsanalyse for å finne den sannsynlige tidssonen som Loïc har brukt. Ut fra denne tidssonen kan du finne ut hvor Loïc ser ut til å bo (land, stat/region, by...).

### Øvelse 8

Her er Bitcoin-transaksjonen å studere:

```plaintext
bb346dae645d09d32ed6eca1391d2ee97c57e11b4c31ae4325bcffdec40afd4f
```

Hvilken informasjon kan vi tolke ut fra denne transaksjonen?

### Løsninger til oppgavene

**Øvelse 1: _**

Modellen for denne transaksjonen er en enkel betaling. Hvis vi bare studerer strukturen, kan vi tolke det slik at den ene utgangen representerer endring og den andre utgangen representerer en faktisk betaling. Vi vet da at den observerte brukeren sannsynligvis ikke lenger er i besittelse av den ene av de to UTXOene i utdataene (den for betaling), men fortsatt er i besittelse av den andre UTXOen (den for veksling).

**Øvelse 2: _**

Mønsteret i denne transaksjonen er at det er snakk om batch-utgifter. Dette mønsteret indikerer sannsynligvis en betydelig økonomisk aktivitet, for eksempel en utvekslingsplattform. Vi kan slutte at input UTXO kommer fra et selskap med betydelig økonomisk aktivitet, og at output UTXO vil spre seg. Noen vil tilhøre selskapets kunder som har tatt ut bitcoinsene sine til selvlagrede lommebøker. Andre kan gå til partnerselskaper. Til slutt vil det helt sikkert være en rest som går tilbake til det utstedende selskapet.

**Øvelse 3: _**

Modellen for denne transaksjonen er en enkel betaling. Derfor kan vi bruke interne heuristikker på transaksjonen for å prøve å identifisere restbeløpet.

Selv har jeg identifisert minst to interne heuristikker som støtter den samme hypotesen:


- Gjenbruk av samme type skript;
- Største produksjon.

Den mest åpenbare heuristikken er gjenbruk av samme type skript. Faktisk er utdata `0` en `P2SH`, gjenkjennelig ved at mottakeradressen begynner med `3`:

```plaintext
3Lcdauq6eqCWwQ3UzgNb4cu9bs88sz3mKD
```

Mens utgangen `1` er en `P2WPKH`, som kan identifiseres ved at adressen begynner med `bc1q`:

```plaintext
bc1qya6sw6sta0mfr698n9jpd3j3nrkltdtwvelywa
```

UTXO-en som brukes som input for denne transaksjonen, bruker også et `P2WPKH`-skript:

```plaintext
bc1qyfuytw8pcvg5vx37kkgwjspg73rpt56l5mx89k
```

Vi kan dermed anta at output `0` tilsvarer en betaling og output `1` er resten av transaksjonen, noe som betyr at input-brukeren fortsatt eier output `1`.

For å underbygge eller avkrefte denne hypotesen kan vi lete etter andre heuristikker som bekrefter vår tankegang eller reduserer sannsynligheten for at hypotesen er riktig.

Jeg har identifisert minst én annen heuristikk. Det er den største utgangen. 0-utgangen måler 123 689 satser, mens 1-utgangen måler 505 839 satser. Det er derfor en betydelig forskjell mellom disse to utgangene. Heuristikken om at den største utdataene er størst, tyder på at den mest omfangsrike utdataen sannsynligvis er resten. Denne heuristikken styrker derfor vår opprinnelige hypotese ytterligere.

Det virker sannsynlig at brukeren som leverte inndata UTXO, fortsatt har utdata `1`, som ser ut til å representere resten av transaksjonen.

**Øvelse 4: _**

Modellen for denne transaksjonen er en enkel betaling. Derfor kan vi bruke interne heuristikker på transaksjonen for å prøve å identifisere restbeløpet.

Selv har jeg identifisert minst to interne heuristikker som støtter den samme hypotesen:


- Gjenbruk av samme type skript;
- Utgangen av et rundt beløp.

Den mest åpenbare heuristikken er gjenbruk av samme type skript. Faktisk er utdata `0` en `P2SH`, gjenkjennelig ved at mottakeradressen begynner med `3`:

```plaintext
3FSH5Mnq6S5FyQoKR9Yjakk3X4KCGxeaD4
```

Mens utgangen `1` er en `P2WPKH`, som kan identifiseres ved at adressen begynner med `bc1q`:

```plaintext
bc1qvdywdcfsyavt4v8uxmmrdt6meu4vgeg439n7sg
```

UTXO-en som brukes som input for denne transaksjonen, bruker også et `P2WPKH`-skript:

```plaintext
bc1qku3f2y294h3ks5eusv63dslcua2xnlzxx0k6kp
```

Dermed kan vi anta at output `0` tilsvarer en betaling og output `1` er resten av transaksjonen, noe som betyr at input-brukeren fortsatt har output `1`.

For å underbygge eller avkrefte denne hypotesen kan vi lete etter andre heuristikker som bekrefter vår tankegang eller reduserer sannsynligheten for at hypotesen er riktig.

Jeg har identifisert minst én annen heuristikk. Det er resultatet av en rund mengde. Utgangen `0` måler `70 000 sats`, mens utgangen `1` måler `22 962 sats`. Vi har derfor å gjøre med en perfekt rund utgang i BTC-kontoenheter. Heuristikken om rund utgang antyder at UTXO med ett rundt beløp sannsynligvis er betalingen, og ved eliminering representerer den andre resten. Denne heuristikken styrker derfor vår opprinnelige hypotese ytterligere.

I dette eksemplet kan imidlertid en annen heuristikk utfordre vår opprinnelige antakelse. Utgangen `0` er faktisk større enn utgangen `1`. Hvis vi baserer resonnementet vårt på heuristikken om at den største utgangen vanligvis er resten, kan vi slutte at utgangen `0` er resten. Denne mothypotesen virker imidlertid usannsynlig, siden de to andre heuristikkene virker vesentlig mer overbevisende enn heuristikken om største utgang. Derfor virker det rimelig å opprettholde vår opprinnelige hypotese til tross for denne tilsynelatende selvmotsigelsen.

Derfor virker det sannsynlig at brukeren som leverte UTXO som input, fortsatt har `1` output, som ser ut til å representere resten av transaksjonen.

**Øvelse 5: _**

Vi ser at åtte transaksjoner kan knyttes til Loïcs identitet. Av disse involverer 4 mottak av bitcoin:

```plaintext
2d9575553c99578268ffba49a1b2adc3b85a29926728bd0280703a04d051eace
8b70bd322e6118b8a002dbdb731d16b59c4a729c2379af376ae230cf8cdde0dd
d5864ea93e7a8db9d3fb113651d2131567e284e868021e114a67c3f5fb616ac4
bc4dcf2200c88ac1f976b8c9018ce70f9007e949435841fc5681fd33308dd762
```

De andre fire handler om å sende bitcoin:

```plaintext
8b52fe3c2cf8bef60828399d1c776c0e9e99e7aaeeff721fff70f4b68145d540
c12499e9a865b9e920012e39b4b9867ea821e44c047d022ebb5c9113f2910ed6
a6dbebebca119af3d05c0196b76f80fdbf78f20368ebef1b7fd3476d0814517d
3aeb7ce02c35eaecccc0a97a771d92c3e65e86bedff42a8185edd12ce89d89cc
```

**Øvelse 6: _**

Hvis vi undersøker mønsteret til denne transaksjonen, er det tydelig at det er en gruppert utgift. Transaksjonen har faktisk én inngang og 51 utganger, noe som indikerer betydelig økonomisk aktivitet. Vi kan derfor anta at Loïc har gjort et bitcoinuttak fra en vekslingsplattform.

Flere elementer styrker denne hypotesen. For det første er skripttypen som brukes til å beskytte UTXO-inngangen, et P2SH multisig 2/3-skript, noe som indikerer et avansert sikkerhetsnivå som er typisk for utvekslingsplattformer:

```plaintext
OP_PUSHNUM_2
OP_PUSHBYTES_33 03eae02975918af86577e1d8a257773118fd6ceaf43f1a543a4a04a410e9af4a59
OP_PUSHBYTES_33 03ba37b6c04aaf7099edc389e22eeb5eae643ce0ab89ac5afa4fb934f575f24b4e
OP_PUSHBYTES_33 03d95ef2dc0749859929f3ed4aa5668c7a95baa47133d3abec25896411321d2d2d
OP_PUSHNUM_3
OP_CHECKMULTISIG
```

I tillegg ble den analyserte adressen `3PUv9tQMSDCEPSMsYSopA5wDW86pwRFbNF` gjenbrukt i mer enn 220 000 forskjellige transaksjoner, noe som ofte er karakteristisk for utvekslingsplattformer som generelt ikke er opptatt av personvernet sitt. Temporale heuristikker anvendt på denne adressen viser også en regelmessig spredning av transaksjoner nesten daglig over en tremånedersperiode, med lengre perioder over 24 timer, noe som tyder på kontinuerlig aktivitet på en utvekslingsplattform.

Endelig er volumene som behandles av denne enheten enorme. Faktisk mottok og sendte adressen 44 BTC i løpet av 222 262 transaksjoner mellom desember 2022 og mars 2023. Disse betydelige volumene bekrefter ytterligere den sannsynlige arten av aktiviteten til en utvekslingsplattform.

**Øvelse 7: _**

Når vi analyserer bekreftelsestidene for transaksjoner, ser vi følgende UTC-tider:

```plaintext
05:43
20:51
18:12
17:16
04:28
23:38
07:45
21:55
```

Ved å analysere disse tidene er det tydelig at UTC-7 og UTC-8 tidssoner stemmer overens med en rekke vanlige menneskelige aktiviteter (mellom kl. 08.00 og 23.00) på de fleste tidspunktene:

```plaintext
05:43 UTC > 22:43 UTC-7
20:51 UTC > 13:51 UTC-7
18:12 UTC > 11:12 UTC-7
17:16 UTC > 10:16 UTC-7
04:28 UTC > 21:28 UTC-7
23:38 UTC > 16:38 UTC-7
07:45 UTC > 00:45 UTC-7
21:55 UTC > 14:55 UTC-7
05:43 UTC > 21:43 UTC-8
20:51 UTC > 12:51 UTC-8
18:12 UTC > 10:12 UTC-8
17:16 UTC > 09:16 UTC-8
04:28 UTC > 20:28 UTC-8
23:38 UTC > 15:38 UTC-8
07:45 UTC > 23:45 UTC-8
21:55 UTC > 13:55 UTC-8
```

Tidssonen UTC-7 er spesielt relevant om sommeren, ettersom den omfatter stater og regioner som f.eks:


- California (med byer som Los Angeles, San Francisco og San Diego);
- Nevada (med Las Vegas);
- Oregon (sammen med Portland);
- Washington (med Seattle);
- Den kanadiske regionen British Columbia (med byer som Vancouver og Victoria).

Denne informasjonen tyder på at Loïc kan tenkes å være bosatt på vestkysten av USA eller Canada.

**Øvelse 8: _**

Analyse av denne transaksjonen viser fem inndata og én utdata, noe som tyder på konsolidering. Anvendelse av CIOH-heuristikken tyder på at alle UTXO-er i inndataene eies av én og samme enhet, og at UTXO-en i utdataene også tilhører denne enheten. Det ser ut til at brukeren valgte å konsolidere flere UTXO-er som han eide, til én UTXO i utdataene, med det formål å konsolidere sine egne mynter. Denne tilnærmingen var sannsynligvis motivert av et ønske om å dra nytte av de lave transaksjonsgebyrene for øyeblikket for å redusere fremtidige gebyrer.

---
_For å skrive denne del 3 om kjedeanalyse har jeg støttet meg på følgende ressurser:_


- _Den fire-artikkel-serien med tittelen: [Understanding Bitcoin Privacy with OXT] (https://medium.com/oxt-research/understanding-bitcoin-privacy-with-oxt-part-1-4-8177a40a5923), produsert av Samourai Wallet i 2021;_ _
- _De ulike rapportene fra [OXT Research] (https://medium.com/oxt-research), samt deres gratis kjedeanalyseverktøy (som for øyeblikket ikke lenger er tilgjengelig etter arrestasjonen av grunnleggerne av Samourai Wallet);_
- _Mer generelt kommer min kunnskap fra de forskjellige tweets og innholdet til [@LaurentMT](https://twitter.com/LaurentMT) og [@ErgoBTC](https://twitter.com/ErgoBTC);_
- \_[Space Kek #19](https://podcasters.spotify.com/pod/show/decouvrebitcoin/episodes/SpaceKek-19---Analyse-de-chane--anonsets-et-entropie-e1vfuji) som jeg deltok i sammen med [@louneskmt](https://twitter.com/louneskmt), [@TheoPantamis](https://twitter.com/TheoPantamis), [@Sosthene\_\_](https://twitter.com/Sosthene___) og [@LaurentMT](https://twitter.com/LaurentMT).\_

_Jeg vil gjerne takke forfatterne, utviklerne og produsentene. Takk også til korrekturleserne som omhyggelig korrigerte artikkelen som lå til grunn for denne del 3, og som beæret meg med sine ekspertråd:_


- _[Gilles Cadignan](https://twitter.com/gillesCadignan);_
- _[Ludovic Lars](https://viresinnumeris.fr/)._ _[Ludovic Lars](https://viresinnumeris.fr/)._

# Beste praksis for å beskytte personvernet ditt

<partId>9bd04b63-f1af-4e50-9061-6bc90009df68</partId>

## Gjenbruk av adresser

<chapterId>f3e97645-3df3-41bc-a4ed-d2c740113d96</chapterId>

Etter å ha studert teknikkene som kan kompromittere personvernet ditt på Bitcoin, vil vi i denne tredje delen nå undersøke de beste fremgangsmåtene du kan ta i bruk for å beskytte deg selv. Denne delen tar ikke sikte på å utforske metoder for å forbedre personvernet, et tema som vil bli tatt opp senere, men heller å forstå hvordan du kan samhandle med Bitcoin på riktig måte for å opprettholde personvernet det naturlig tilbyr, uten å ty til tilleggsteknikker.

For å begynne denne tredje delen vil vi selvfølgelig snakke om gjenbruk av adresser. Dette fenomenet er den største trusselen mot brukernes personvern. Derfor er dette kapittelet sannsynligvis det viktigste i hele kurset.

### Hva er en mottaksadresse?

En bitcoin-mottaksadresse er en tegnstreng eller identifikator som brukes til å motta bitcoin i en lommebok.

Teknisk sett "mottar" ikke en bitcoin-mottakeradresse bitcoin i bokstavelig forstand, men definerer heller betingelsene for hvordan bitcoins kan brukes. Når en betaling sendes til deg, oppretter avsenderens transaksjon en ny UTXO til deg i utdataene fra UTXO-ene den forbrukte i inndataene. På denne outputen brukes et skript som definerer hvordan denne UTXO-en kan brukes senere. Dette skriptet kalles "_ScriptPubKey_" eller "_Locking Script_" Mottaksadressen din, nærmere bestemt nyttelasten, er innebygd i dette skriptet. For å forenkle, sier dette skriptet i hovedsak:

> "_For å bruke denne nye UTXO-en må det leveres en digital signatur ved hjelp av den private nøkkelen som er knyttet til denne mottakeradressen._"
![BTC204](assets/fr/067.webp)

Bitcoin-adresser kommer i forskjellige typer, avhengig av hvilken skriptmodell som brukes. De første modellene, kjent som "_Legacy_", inkluderer `P2PKH` (_Pay-to-PubKey-Hash_) og `P2SH` (_Pay-to-Script-Hash_) adresser. P2PKH-adresser begynner alltid med "1" og P2SH med "3". Selv om disse formatene fortsatt er sikre, er de nå foreldet, ettersom de medfører høyere transaksjonsgebyrer og gir mindre personvern enn de nye standardene.

SegWit V0-adresser (`P2WPKH` og `P2WSH`) og Taproot/SegWit V1-adresser (`P2TR`) representerer moderne formater. SegWit-adresser begynner med `bc1q`, og Taproot-adresser, som ble introdusert i 2021, begynner med `bc1p`.

Her er for eksempel en mottaksadresse for Taproot:

```text
bc1ps5gd2ys8kllz9alpmcwxqegn7kl3elrpnnlegwkm3xpq2h8da07spxwtf5
```

Hvordan ScriptPubKey er konstruert, avhenger av hvilken standard du bruker:

| Script Template | ScriptPubKey | ---------------- | ----------------------------------------------------------- | ----------------------------------------------------------- | ----------------------------------------------------------- | ----------------

| P2PKH | OP_DUP OP_HASH160 `<pubKeyHash>`` OP_EQUALVERIFY OP_CHECKSIG | OP_EQUALVERIFY OP_CHECKSIG

| P2SH | OP_HASH160 `<scriptHash>` `<scriptHash>` OP_EQUAL | OP_EQUAL

| P2WPKH | 0 `<pubKeyHash>` | | P2WPKH | 0

| P2WSH | 0 `<witnessScriptHash>` | | <<witnessScriptHash>` | <<witnessScriptHash>

| P2SH - P2WPKH | OP_HASH160 `<redeemScriptHash>` OP_EQUAL | OP_EQUAL

| P2SH - P2WSH | OP_HASH160 `<redeemScriptHash>` OP_EQUAL | OP_EQUAL

| P2TR | 1 `<pubKey>` | | P2TR | 1

Når det gjelder oppbyggingen av mottakeradressene, avhenger det også av hvilken skriptmal som er valgt:


- For `P2PKH`- og `P2WPKH`-adresser representerer nyttelasten, eller kjernen i adressen, hashen av den offentlige nøkkelen;
- For `P2SH`- og `P2WSH`-adresser representerer nyttelasten hashen til et skript;
- Som for `P2TR`-adresser er nyttelasten en modifisert offentlig nøkkel. `P2TR`-utgangene kombinerer aspekter av _Pay-to-PubKey_ og _Pay-to-Script_. Den modifiserte offentlige nøkkelen er resultatet av å legge til en klassisk offentlig nøkkel med en "modifikasjon", avledet fra Merkle-roten til et sett med skript som også kan brukes til å bruke bitcoin.

![BTC204](assets/it/67/01.webp)

Adressene som vises i lommebokprogramvaren inkluderer også en HRP (_Human-Readable Part_), vanligvis `bc` for post-SegWit-adresser, en separator `1`, og et versjonsnummer `q` for SegWit V0 og `p` for Taproot/SegWit V1. Det legges også til en kontrollsum for å sikre adressens integritet og gyldighet under overføringen.

Til slutt blir adressene satt inn i et standardformat:


- Base58check for gamle Legacy-adresser;
- Bech32 for SegWit-adresser;
- Bech32m for Taproot-adresser.

Her er addisjonsmatrisen for bech32- og bech32m-formatene (SegWit og Taproot) fra base 10:

| + | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |

| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

| 0 | q | p | z | r | y | 9 | x | 8 | 8

| 8 g f 2 t v d w 0

| 16 | s | 3 | j | n | 5 | 4 | k | h | | 24 | c | e | 6 | m | u | a | 7 | l | l

### Hva er gjenbruk av adresser?

Gjenbruk av adresser betyr at samme mottakeradresse brukes til å blokkere flere forskjellige UTXO-er.

Som vi så i forrige avsnitt, har hver UTXO sin egen ScriptPubKey som låser den, og som må oppfylles for at UTXO-en skal kunne brukes som input i en ny transaksjon. Det er i denne ScriptPubKey at mottaksadressene (payloads) er innebygd.

Når flere ScriptPubKeys inneholder samme mottakeradresse, kalles dette gjenbruk av adresser. I praksis betyr dette at en bruker har oppgitt den samme adressen flere ganger til avsendere for å motta bitcoin gjennom flere betalinger. Og denne praksisen er faktisk katastrofal for personvernet ditt.

### Hvorfor er gjenbruk av adresser et problem?

Fordi blokkjeden er offentlig, er det enkelt å se hvilke adresser som blokkerer hvilke UTXO-er og hvor mange bitcoins. Hvis samme adresse brukes til flere transaksjoner, er det mulig å slutte at alle bitcoins knyttet til denne adressen tilhører samme person. Denne praksisen går på bekostning av brukernes personvern ved å gjøre det mulig å etablere deterministiske koblinger mellom ulike transaksjoner og spore bitcoins i blokkjeden. Satoshi Nakamoto fremhevet selv dette problemet i Bitcoin White Paper:

> som en ekstra brannmur kan man bruke et nytt nøkkelpar for hver transaksjon for å hindre at de knyttes til en felles eier
![BTC204](assets/fr/055.webp)

Kilde: S. Nakamoto: S. Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System", https://bitcoin.org/bitcoin.pdf, 2009.

Målet Satoshi søkte med denne uttalelsen var å skape en ekstra brannmur i tilfelle en kobling mellom brukerens identitet og et nøkkelpar på Bitcoin, for å unngå at all aktiviteten deres ble offentlig knyttet til identiteten deres. I dag, med utbredelsen av blockchain-analyseselskaper og KYC-regelverk, er bruken av unike adresser ikke lenger en "ekstra brannmur", men en nødvendig praksis for alle som ønsker å bevare personvernet sitt på et minimum.

Når du gjenbruker en adresse, skaper du en nesten udiskutabel kobling mellom alle transaksjoner som er knyttet til denne adressen. Selv om dette ikke direkte truer pengene dine, fordi kryptering på elliptiske kurver sikrer sikkerheten til de private nøklene dine, gjør det det lettere å overvåke aktivitetene dine. Faktisk kan hvem som helst med en node observere transaksjonene og adressesaldoen din, noe som går helt på bekostning av anonymiteten din.

![BTC204](assets/it/34/01.webp)

For å illustrere dette poenget kan vi ta et eksempel med Bob, en bruker som regelmessig kjøper bitcoins i små mengder via Dollar Cost Averaging (DCA) og alltid sender dem til samme adresse. Etter to år inneholder denne adressen en betydelig mengde bitcoin. Hvis Bob bruker denne adressen til å betale til en lokal forhandler, kan forhandleren se alle de tilknyttede midlene og trekke fra Bobs formue. Dette kan føre til personlige sikkerhetsrisikoer, inkludert forsøk på tyveri eller utpressing. Hvis Bob hadde brukt en ny adresse til å motta hvert periodiske kjøp, ville han ha avslørt uendelig mye mindre informasjon til forhandleren.

I kjedeanalysen skiller vi mellom to typer gjenbruk av adresser:


- Ekstern gjenbruk;
- Intern gjenbruk innenfor en transaksjon.

Den første observeres når en adresse gjenbrukes i flere forskjellige Bitcoin-transaksjoner. Dette er det vi diskuterte tidligere: Denne heuristikken lar oss slutte at alle UTXO-er som sendes gjennom denne adressen, tilhører en enkelt enhet.

Gjenbruk av interne adresser observeres ikke når gjenbruk skjer på tvers av flere transaksjoner, men når det skjer innenfor samme transaksjon. Hvis den samme adressen som ble brukt til å låse en inngang, brukes som en utgang i en transaksjon, kan vi slutte at denne utgangen fortsatt tilhører den samme brukeren (restbeløpet), og at den andre utgangen representerer den faktiske betalingen. Denne andre heuristikken gjør det mulig å spore midler på tvers av flere transaksjoner.

![BTC204](assets/it/33/02.webp)

Gjenbruk av adresser er en reell svøpe på Bitcoin. Ifølge nettstedet OXT.me (for øyeblikket utilgjengelig) var den totale gjenbruksraten for adresser på Bitcoin omtrent 52 prosent i 2022:

![BTC204](assets/fr/069.webp)

Dette er en enorm andel, men den kommer i overveldende grad fra utvekslingsplattformer snarere enn fra individuelle brukere.

### Hvordan unngå gjenbruk av adresser?

Det er ganske enkelt å unngå gjenbruk av adresser: **Bruk bare en ny adresse for hver nye innkommende betaling i lommeboken**.

Takket være BIP32 er moderne porteføljer nå deterministiske og hierarkiske. Det betyr at en bruker kan generere et stort antall adresser ut fra én enkelt del av den opprinnelige informasjonen: frøet. Ved å lagre denne ene informasjonen kan alle de private nøklene i lommeboken gjenopprettes, slik at man får tilgang til midlene som er sikret av de tilsvarende adressene.

![BTC204](assets/fr/070.webp)

Når du trykker på "_mottak_"-knappen i lommebokprogramvaren din, blir du derfor tilbudt en ubrukt mottakeradresse hver gang. Etter at du har mottatt bitcoin på denne adressen, foreslår programvaren automatisk en ny adresse.

> _PS: Nylig har noen lommebokprogramvare kunngjort at de har til hensikt å slutte å generere blanke adresser, i frykt for at dette kan oppfattes som en form for hvitvasking av penger av myndighetene. Hvis programvaren din er blant dem, anbefaler jeg deg på det sterkeste å bytte den ut umiddelbart, da dette ikke er akseptabelt for brukeren
Hvis du trenger en statisk identifikator for å motta betalinger, for eksempel for å motta donasjoner, anbefales det ikke å bruke en klassisk Bitcoin-adresse på grunn av risikoen for gjenbruk. Du foretrekker å bruke en Lightning-adresse, eller du kan velge BIP47 eller Silent Payments for å få en statisk betalingsidentifikator i kjeden. Hvordan disse protokollene fungerer, er beskrevet i del 6 av denne opplæringen.

## Myntmerking og kontroll

<chapterId>fbdb07cd-c025-48f2-97b0-bd1bc21c68a8</chapterId>

Som vi oppdaget i avsnittet om kjedeanalyse, finnes det en rekke heuristikker og mønstre som kan brukes til å utlede informasjon om en transaksjon. Som bruker er det viktig å være klar over disse teknikkene for å beskytte seg bedre.

Dette innebærer i stor grad streng forvaltning av lommeboken i personlig varetekt, noe som inkluderer å kjenne opprinnelsen til UTXOene, samt gjennomtenkt valg av UTXOer som skal brukes under betalinger. Denne effektive lommebokforvaltningen er avhengig av to viktige funksjoner i gode Bitcoin-lommebøker: merking og myntkontroll.

I dette kapittelet skal vi studere disse funksjonene og se hvordan du kan bruke dem på en intelligent måte, uten å legge for mye arbeidsbelastning, for å optimalisere personvernet ditt på Bitcoin.

### Hva er merking?

Tagging er en praksis som innebærer å tilordne en merknad eller etikett til en bestemt UTXO i en Bitcoin-lommebok. Disse merknadene lagres lokalt av lommebokprogramvaren og overføres aldri over Bitcoin-nettverket. Tagging er dermed et verktøy for personlig administrasjon.

Hvis jeg for eksempel eier en UTXO fra et P2P-kjøp på Bisq med Charles, kan jeg tildele den merkelappen "`Non-KYC Bisq Charles`".

Tagging er en god praksis som hjelper deg med å huske opprinnelsen eller den tiltenkte destinasjonen til en UTXO, noe som gjør det enklere å forvalte midler og optimalisere personvernet. Det er sannsynlig at Bitcoin-lommeboken din inneholder flere UTXO-er. Hvis kildene til disse UTXO-ene er forskjellige, kan det være lurt å ikke slå sammen disse UTXO-ene i fremtiden, ellers kan du avsløre deres felles eierskap. Ved å merke alle myntene dine på riktig måte sikrer du at du husker opprinnelsen deres når du trenger dem, selv om det ikke er før om flere år.

### Hva er myntkontroll?

Den aktive bruken av tagging blir enda mer attraktiv når den kombineres med muligheten for myntkontroll i lommebokprogramvaren.

Myntkontroll er en funksjon som finnes i god programvare for Bitcoin-lommebøker, og som gir deg muligheten til å manuelt velge bestemte UTXO-er som skal brukes som input for å utføre en transaksjon. For å utføre en utgående betaling må du faktisk forbruke en innkommende UTXO i retur. Av flere grunner, som vi skal se senere, kan det være lurt å velge nøyaktig hvilke mynter som skal brukes som input for å utføre en gitt betaling. Det er akkurat dette myntkontrollen gjør mulig. For å gi deg en analogi, kan denne funksjonaliteten sammenlignes med å velge en bestemt mynt i lommeboken når du betaler for baguetten din.

Bruken av myntstyrt lommebokprogramvare, kombinert med merking av UTXO-er, gjør det mulig for brukerne å skille og velge UTXO-er for transaksjonene sine på en nøyaktig måte.

### Hvordan merker du UTXO-ene dine riktig?

Det finnes ingen universell metode for merking av UTXO-er som passer for alle. Det er opp til deg å definere et merkesystem slik at du enkelt kan navigere i porteføljen din. Husk uansett at god merking er det du vil være i stand til å forstå når du trenger det. Hvis Bitcoin-lommeboken din først og fremst er til sparing, kan det være at etikettene ikke vil være nyttige for deg før om flere tiår. Sørg derfor for at de er tydelige, nøyaktige og inkluderende.

Det er viktig at dine nærmeste enkelt kan identifisere hvor pengene kommer fra hvis de en dag skulle trenge tilgang til porteføljen din. Dette kan være til hjelp både av personvernhensyn og av juridiske hensyn, dersom de må forklare hvor midlene kommer fra overfor en myndighet.

Det viktigste aspektet ved merking er å notere kilden til UTXO. Du bør ganske enkelt angi hvordan denne mynten kom til lommeboken din. Kom den fra et kjøp på en utvekslingsplattform? En betaling fra en kunde? En peer-to-peer-utveksling? Eller er det restbeløpet av et kjøp? Så du kan spesifisere:


- "Pickup Exchange.com";
- "Betalingsklient David";
- "Kjøp P2P Charles";
- "Tilbakeholdelse fra sofakjøp

For å forbedre forvaltningen av UTXO-er og følge strategiene dine om å holde fondene atskilt i porteføljen, kan du utstyre etikettene med en ekstra markør for å gjenspeile disse skillene. Hvis porteføljen din inneholder to kategorier UTXO-er som du ikke ønsker å blande, kan du integrere en markør i etikettene dine for å skille disse gruppene tydelig fra hverandre. Disse separasjonsmarkørene vil avhenge av kriteriene dine, for eksempel å skille mellom UTXOer fra en oppkjøpsprosess som involverer KYC, eller mellom profesjonelle og personlige fond. Hvis vi tar utgangspunkt i de tidligere nevnte eksemplene på etiketter, kan dette oversettes til


- `KYC - Exchange.com Uttak`;
- kYC - Kundebetaling David;
- `NO KYC - Kjøp P2P Charles`;
- `NO KYC - Restbeløp fra sofakjøp`

Det anbefales også å forevige merkingen av en mynt under transaksjoner. For eksempel, når du konsoliderer UTXO-er uten KYC, må du sørge for å merke den resulterende UTXO-en ikke bare som `konsolidering`, men spesifikt som `no-KYC-konsolidering` for å opprettholde et tydelig spor av myntens opprinnelse.

Til slutt er det ikke obligatorisk å sette en dato på en etikett. De fleste lommebokprogrammer viser allerede datoen for transaksjonen, og det er alltid mulig å hente denne informasjonen på en blokkutforsker ved hjelp av TXID.

### Hvordan velge mynter riktig?

Når du foretar en transaksjon, kan du ved hjelp av myntkontroll spesifikt velge hvilke UTXO-er som skal brukes som input for å tilfredsstille betalingsoutputen. To aspekter bør vurderes i dette valget:


- Muligheten for betalingsmottakeren til å knytte en del av identiteten din til UTXO-ene som brukes som input;
- Evnen en utenforstående observatør har til å se sammenhenger mellom alle UTXO-er som brukes som input.

La oss ta et konkret eksempel for å illustrere det første poenget. Anta at du kjøper en baguette med bitcoins fra din lokale baker. Du bruker en eller flere av dine egne UTXO-er som input for å dekke minst prisen på baguetten i output, pluss transaksjonsgebyrer. Bakeren din kan da potensielt knytte ansiktet ditt, eller en annen del av identiteten din som han kjenner, til myntene som brukes som input. Når du vet at denne koblingen eksisterer, vil du kanskje foretrekke å velge én bestemt UTXO fremfor en annen når du skal betale.

Hvis en av UTXO-ene dine for eksempel kommer fra en utvekslingsplattform, og du foretrekker at bakeren ikke kjenner til kontoen din på denne plattformen, bør du unngå å bruke denne UTXO-en til betaling. Hvis du har en UTXO med høy verdi som avslører en betydelig mengde bitcoin, kan du også velge å ikke bruke den for å forhindre at bakeren får vite om BTC-formuen din.

Valget av UTXO-er som skal brukes til dette første punktet, er derfor basert på en personlig beslutning, påvirket av hva du er villig til å avsløre eller ikke. Merkelappene du har tildelt UTXO-ene dine ved mottak, vil hjelpe deg med å velge dem som, når de brukes, bare viser den informasjonen du er komfortabel med å avsløre for mottakeren.

I tillegg til informasjonen som potensielt avsløres for mottakeren, påvirker valget av inndata også hva du avslører for alle observatører av blokkjeden. Ved å bruke flere UTXO-er som input i transaksjonen avslører du faktisk at de eies av samme enhet, i henhold til Common Ownership Heuristics of Inputs (CIOH).

Når du velger myntene dine, bør du derfor være klar over at transaksjonen du skal overføre, vil skape en kobling mellom alle UTXO-ene som brukes. Denne koblingen kan være problematisk for personvernet ditt, spesielt hvis UTXO-ene kommer fra forskjellige kilder.

Tilbake til eksemplet med UTXO-en min uten KYC fra Bisq; jeg vil unngå å kombinere den med en UTXO fra for eksempel en regulert børsplattform som kjenner identiteten min. Hvis jeg noen gang brukte disse to UTXO-ene som input i samme transaksjon, ville den regulerte plattformen kunne koble identiteten min til UTXO-en jeg kjøpte på Bisq, mens den tidligere ikke var knyttet til identiteten min.

Til slutt, for å velge hvilke UTXO-er som skal brukes som input for en transaksjon, er det viktigste å unngå å bruke flere UTXO-er. Når det er mulig, velg en enkelt mynt som er stor nok til å dekke betalingen din. På denne måten unngår du helt risikoen forbundet med COINJOIN. Men hvis ingen UTXO er tilstrekkelig for betalingen din og du må bruke flere, må du sørge for at de kommer fra lignende kilder for å minimere risikoen for uønskede forbindelser. Husk også at mottakeren kan knytte informasjonen de har om deg til historikken til myntene som brukes som input.

### Forstå automatisk myntvalg

I de foregående avsnittene har vi diskutert manuell utvelgelse av UTXO-er for en transaksjon. Men hva skjer når lommebokprogramvaren gjør dette valget automatisk? Det finnes flere metoder for å avgjøre hvilke mynter som skal brukes, og utvalget av UTXO-er er et reelt forskningsfelt innen Bitcoin. Hovedmålet med denne automatiske prosessen er ofte å minimere transaksjonsgebyrene for brukeren.

UTXO-valgmetoder som FIFO (_First In First Out_) og LIFO (_Last In First Out_) er blant de enkleste, men også de minst effektive. Med FIFO brukes de eldste myntene i porteføljen først. Denne tilnærmingen er generelt ineffektiv både med tanke på å minimere transaksjonsgebyrene og bevare personvernet, bortsett fra i tilfeller der det brukes relative tidslåser som må fornyes regelmessig. LIFO prioriterer derimot bruken av de nyeste UTXO-ene. Selv om disse to metodene er enkle, viser de seg ofte å være ineffektive.

En mer avansert metode er _Knapsack Solver_. Dette var metoden som ble brukt i Bitcoin Core-lommeboken frem til versjon 0.17. Den innebærer at man iterativt og tilfeldig velger UTXO-er fra lommeboken, summerer dem i undergrupper og beholder den løsningen som reduserer transaksjonsvekten så mye som mulig for å redusere brukeravgiftene.

_Branch-and-Bound_ (BNB), ofte kalt "Murchs algoritme" med referanse til oppfinneren, erstattet _Knapsack Solver_ i Bitcoin Core fra og med versjon 0.17. Denne mer avanserte metoden tar sikte på å finne et sett med UTXO-er som nøyaktig samsvarer med beløpet som trengs for å tilfredsstille utgangene til en transaksjon. Målet med BNB er å minimere restbeløpet og avgiftene ved å redusere det som kalles avfallskriteriet, som tar hensyn til både umiddelbare kostnader og forventede fremtidige kostnader for restbeløpet. Denne metoden er avledet av det opprinnelige _Branch-and-Bound_-konseptet, som ble utviklet i 1960 av Ailsa Land og Alison Harcourt, og gir mer presis provisjonsoptimalisering enn _Knapsack Solver_.

Alle disse metodene for automatisk UTXO-valg kan være effektive når det gjelder å redusere transaksjonsgebyrene, men de er ofte ineffektive når det gjelder å bevare brukernes personvern. Faktisk kan disse algoritmene slå sammen flere UTXO-er i inndata, og dermed avsløre et felles eierskap til disse UTXO-ene på grunn av COH. Disse metodene kan selvsagt ikke ta hensyn til merkelappene som er knyttet til UTXO-ene, noe som er avgjørende for et bevisst valg av hvilke mynter som skal avsløres for transaksjonsmottakeren. For øyeblikket er den eneste løsningen for å optimalisere personvernet ved myntvalg å gjøre det manuelt.

### Opplæring i UTXO-merking

Hvis du vil finne ut hvordan du merker UTXO-ene dine, har vi satt sammen en omfattende veiledning om de viktigste eksisterende Bitcoin-lommebokprogrammene:

https://planb.network/tutorials/privacy/on-chain/utxo-labelling-d997f80f-8a96-45b5-8a4e-a3e1b7788c52
## KYC og nøkkelidentifikasjon

<chapterId>cec6b9d9-0eed-4f85-bc4e-1e9aa59ca605</chapterId>

KYC står for "Know Your Customer", som er en regulatorisk prosedyre som er implementert av noen selskaper som opererer i Bitcoin-bransjen. Denne prosedyren har som mål å verifisere og registrere identiteten til kundene deres med det uttalte målet å bekjempe hvitvasking av penger og finansiering av terrorisme.

Konkret innebærer KYC innsamling av ulike personopplysninger fra kunden, som kan variere fra jurisdiksjon til jurisdiksjon, men som regel inkluderer ID, fotografi og bevis på bosted. Denne informasjonen blir deretter verifisert og lagret for fremtidig bruk.

Denne prosedyren har blitt obligatorisk for alle regulerte vekslingsplattformer i de fleste vestlige land. Det betyr at alle som ønsker å veksle fiat-valutaer til bitcoin gjennom disse plattformene, må oppfylle kravene til KYC.

Denne prosedyren er ikke uten risiko for brukernes personvern og sikkerhet. I dette kapittelet vil vi undersøke disse risikoene i detalj og analysere de spesifikke konsekvensene av KYC og identifikasjonsprosesser for Bitcoin-brukernes personvern.

### Tilrettelegging for sporing i kjeden

Den første risikoen forbundet med KYC er at det gir et foretrukket inngangspunkt for blokkjedeanalyse. Som vi så i forrige avsnitt, kan analytikere gruppere og spore aktivitet i blokkjeden ved hjelp av transaksjonsmønstre og heuristikk. Når de har klart å gruppere en brukers aktivitet i blokkjeden, er det nok å finne bare ett inngangspunkt blant alle transaksjonene og nøklene for å kompromittere personvernet fullstendig.

![BTC204](assets/fr/078.webp)

Når du underkaster deg KYC, gir du et inngangspunkt av svært høy kvalitet for kjedeanalyse, ettersom du knytter mottakeradressene som brukes når du tar ut bitcoins fra en utvekslingsplattform, til din fulle, bekreftede identitet. I teorien er denne informasjonen kun kjent for selskapet du har oppgitt den til, men som vi skal se senere, er risikoen for tap av data reell. Dessuten kan bare det faktum at et selskap har denne informasjonen være problematisk, selv om det ikke deler den.

Med mindre andre tiltak iverksettes for å begrense sammenslåingen av ens aktiviteter på blokkjeden, kan alle som er klar over inngangspunktet som KYC er, potensielt knytte all deres aktivitet på Bitcoin til deres identitet. Fra dette selskapets perspektiv mister bruken av Bitcoin derfor all konfidensialitet.

![BTC204](assets/fr/079.webp)

For å illustrere dette med en sammenligning, er det som om ens bankmann i _Bank X_ ikke bare hadde tilgang til alle transaksjoner med _Bank X_, men også kunne observere transaksjoner med _Bank Y_ og alle ens egne kontanttransaksjoner.

Husk fra første del av denne opplæringen: Personvernmodellen til Bitcoin, som designet av Satoshi Nakamoto, er basert på separasjonen mellom brukerens identitet og nøkkelparene hans. Selv om dette laget av personvern ikke lenger er tilstrekkelig i dag, er det likevel lurt å begrense forringelsen av det så mye som mulig.

### Eksponering for statlig overvåkning

Det andre store problemet med KYC er at det avslører for staten at man har vært i besittelse av bitcoin på et eller annet tidspunkt. Når du kjøper bitcoins gjennom en regulert aktør, blir det mulig for staten å vite om denne besittelsen. Foreløpig kan dette virke trivielt, men det er viktig å huske på at landets politiske og økonomiske fremtid ikke ligger i ens egne hender.

For det første kan staten raskt innta en autoritær holdning. Historien er full av eksempler på at politikken har endret seg brått. I dag kan Bitcoin-entusiaster i Europa skrive artikler om Bitcoin, delta på konferanser og administrere sine egne selvlagrede lommebøker. Men hvem kan si hva morgendagen vil bringe? Hvis Bitcoin plutselig blir folkefiende nummer én, kan det være problematisk å bli assosiert med det i statlige registre.

Senere, i møte med alvorlige økonomiske kriser, kan staten vurdere å beslaglegge bitcoins som innbyggerne eier. Kanskje vil bitcoinere i morgen bli sett på som utnyttere av krisen og bli overbeskattet på grunn av kapitalgevinstene sine i møte med devaluering av fiat-valuta.

Du tenker kanskje at dette ikke er et problem fordi bitcoinsene dine er stokket og derfor ikke kan spores. Sporbarhet er imidlertid ikke problemet her. Det virkelige problemet er at staten vet at du har vært i besittelse av bitcoins. Denne enkle informasjonen kan være nok til å inkriminere deg eller kreve en konto. Du kan prøve å hevde at du har brukt opp bitcoinsene dine, men det vil måtte gjenspeiles i selvangivelsen din, og du vil bli avslørt. Du kan også si at du mistet nøklene dine i en båtulykke, men tror du virkelig at det vil være nok til å renvaske deg?

Derfor er det viktig å vurdere risikoen forbundet med det enkle faktum at staten kan få vite at du eier BTC, selv om denne risikoen kan virke fjern i dag.

Et annet spørsmål som oppstår i forbindelse med statlig tilsyn, er obligatorisk rapportering fra regulerte plattformer. Selv om jeg ikke kjenner til regelverket i andre jurisdiksjoner, er _Digital Asset Service Providers_ (PSAN) i Frankrike pålagt å rapportere til finanstilsynsmyndighetene om alle pengebevegelser de anser som mistenkelige.

I Frankrike ble det i 2023 rapportert 1449 mistenkelige handlinger fra PSAN-ene. Foreløpig er de fleste av disse handlingene kriminalitetsrelaterte. Myndighetene ber imidlertid også regulerte plattformer om å rapportere mistenkelige Bitcoin-transaksjoner basert utelukkende på strukturen. Hvis du gjennomfører en samarbeidstransaksjon, eller til og med bare en transaksjon som har et noe atypisk mønster, og denne transaksjonen skjer i nærheten av uttaket av dine bitcoins fra disse plattformene, kan du bli rapportert til myndighetene. Selv om du ikke har gjort noe galt og utøver dine rettigheter på en legitim måte, kan denne rapporteringen føre til økt kontroll og overvåking, noe du ville ha unngått uten KYC.

### Risikoen for tap av personopplysninger

Et annet problem med KYC er at det krever lagring av alle personopplysningene dine på et privat selskaps servere. Den siste tidens hendelser har minnet oss på at ingen er immune mot svikt, verken økonomisk eller IT-relatert. I 2022 fikk Celsius-kunder merke konsekvensene. Som følge av selskapets konkurs ble navnene på kreditorene og størrelsen på eiendelene deres offentliggjort av det amerikanske rettssystemet under en administrativ saksbehandling.

For litt over to år siden ble en ledende cybersikkerhetsenhet innen kryptovaluta utsatt for tyveri av kundenes personopplysninger. Selv om denne hendelsen ikke var direkte relatert til kjøp av bitcoin, gjelder denne risikoen også for utvekslingsplattformer. Derfor er det en klar risiko forbundet med disse personopplysningene.

Riktignok overlater vi allerede mye av personopplysningene våre til private selskaper. Risikoen her er imidlertid dobbel, siden disse dataene ikke bare gjør det mulig å identifisere deg, men også er knyttet til aktivitet på bitcoin. Når en hacker får tilgang til dataene til kunder på en vekslingsplattform, er det rimelig å anta at disse kundene eier bitcoin. Denne risikoen forsterkes av det faktum at bitcoin, som alle andre verdifulle eiendeler, tiltrekker seg tyvenes interesse.

Ved et datainnbrudd kan du i beste fall bli utsatt for målrettede phishing-forsøk. I verste fall kan du bli utsatt for fysiske trusler mot hjemmet ditt.

I tillegg til de spesifikke risikoene forbundet med Bitcoin, er det også nødvendig å vurdere farene forbundet med overføring av identitetsdokumenter. I tilfelle en datalekkasje er det faktisk mulig å bli offer for identitetstyveri. Derfor er det ikke bare snakk om å beskytte konfidensialiteten til transaksjonene, men også den personlige sikkerheten til hver enkelt person.

### Vanlige misforståelser når det gjelder KYC

Det er viktig å oppklare noen vanlige misoppfatninger om KYC som ofte dukker opp på Twitter eller i diskusjoner blant bitcoinere.

Først og fremst er det feil å tro at det er nytteløst å beskytte personvernet for bitcoins som er anskaffet gjennom KYC (Know Your Customer). Verktøyene og metodene for personvern på bitcoin er varierte og tjener forskjellige formål. Å bruke coinjoin-transaksjoner på bitcoin fra KYC er for eksempel ikke en dårlig idé. Selvfølgelig må du være forsiktig med regulerte utvekslingsplattformer for å unngå at kontoen din blir frosset eller utestengt, men fra et strengt teknisk synspunkt er ikke disse metodene uforenlige. Coinjoin har den effekten at en mynts historikk forstyrres, noe som bidrar til å motvirke noen av risikoene ved kjedeanalyse forbundet med KYC. Selv om det ikke eliminerer alle risikoer, er det allerede en betydelig fordel.

Personvern på bitcoin bør ikke ses på på en binær måte, som et skille mellom "anonyme" bitcoins og andre som ikke er det. Å eie bitcoins ervervet gjennom KYC betyr ikke at alt er tapt; tvert imot kan bruk av personvernverktøy vise seg å være enda mer fordelaktig.

På den annen side garanterer ikke anskaffelse av bitcoin gjennom en metode som ikke er basert på kundeskydd, perfekt personvern og fritar deg ikke fra behovet for å iverksette andre beskyttelsestiltak. Hvis du har bitcoin som ikke er KYC-godkjente, men gjenbruker mottaksadresser flere ganger, kan transaksjonene dine spores og grupperes. Den minste forbindelse til verden utenfor bitcoin kan kompromittere det ene laget av personvern du hadde. Derfor er det viktig å se på alle verktøy og metoder som forbedrer personvernet på Bitcoin som komplementære. Hver teknikk adresserer en spesifikk risiko og kan legge til et ekstra lag med beskyttelse. Å eie bitcoin som ikke er KYC-fri, fritar deg derfor absolutt ikke fra å ta andre forholdsregler.

### Kan KYC kanselleres?

Jeg får noen ganger spørsmål om det er mulig å "gå tilbake" etter å ha fullført KYC, og som du kan forestille deg fra de foregående avsnittene, er svaret nyansert. For å unngå risikoen forbundet med KYC, er den enkleste metoden å ikke bruke den når du anskaffer bitcoins. Vi vil utdype dette temaet i neste kapittel. Men hvis KYC allerede er utført og bitcoins er kjøpt, finnes det måter å redusere risikoen på?

Når det gjelder risikoen for å spore transaksjonene dine, er bruken av coinjoin en løsning. Vi vil diskutere denne metoden i detalj senere i opplæringen, men vet at coinjoin kan forstyrre en mynts historie og forhindre sporbarhet fra fortid til nåtid og nåtid til fortid. Selv for BTC som er anskaffet gjennom en regulert plattform, kan denne teknikken forhindre sporbarheten.

Coinjoin eliminerer imidlertid ikke den andre risikoen forbundet med KYC: det faktum at staten er informert om bitcoin-beholdningen din. Selv om myntene dine ikke lenger kan spores, kan staten, avhengig av jurisdiksjon, faktisk ha tilgang til dine kryptoaktive alienasjonsoversikter. Siden denne risikoen ikke er teknisk, men administrativ, finnes det ingen bitcoin-spesifikke løsninger for å eliminere den, annet enn å unngå å bli utsatt for KYC. Den eneste lovlige måten å redusere denne risikoen på, er å selge bitcoins som er anskaffet gjennom regulerte plattformer på regulerte plattformer, og deretter kjøpe dem tilbake på en måte som ikke innebærer KYC. Ved å selge og deklarere avhendingen bør administrasjonen merke seg at du ikke lenger eier dem.

Når det gjelder risikoen for at personopplysninger og identitetsdokumenter blir utlevert, er dette en fare som ligger utenfor Bitcoin, og det finnes ingen teknisk løsning for å unngå dette. Når dataene dine først er avslørt, er det vanskelig å reversere dette. Du kan prøve å stenge kontoen din på plattformen, men dette garanterer ikke at KYC-dataene dine blir fjernet, spesielt ikke når identitetsverifiseringen er outsourcet. Det er umulig å verifisere at opplysningene dine er fullstendig fjernet. Derfor finnes det ingen løsning som helt kan forhindre denne risikoen og sikre at den ikke lenger eksisterer.

### Forskjellen mellom KYC og nøkkelidentifikasjon

Noen ganger har noen bitcoinere en tendens til å utvide begrepet "KYC" til enhver BTC-utveksling som involverer en overføring eller kredittkortbetaling, siden disse virkemidlene også kan avsløre opprinnelsen til betalingen, akkurat som KYC ville gjort. Det er imidlertid viktig å ikke forveksle KYC med nøkkelidentifikasjon. Personlig må jeg innrømme at min oppfatning av dette temaet har utviklet seg over tid.

KYC refererer spesifikt til en regulatorisk prosedyre som er implementert av noen selskaper for å verifisere og registrere identiteten til kundene sine. Det er et binært spørsmål: Når du anskaffer bitcoins, underkaster du deg enten KYC, eller så gjør du det ikke. Nøkkelidentifikasjon, som handler om å knytte et aspekt av en brukers identitet til aktivitet i kjeden, er imidlertid ikke så binært, men representerer snarere et kontinuum. I forbindelse med kjøp eller salg av bitcoin er denne identifikasjonen alltid mulig i varierende grad.

Hvis du for eksempel kjøper bitcoin på en regulert plattform i Sveits, er det ikke nødvendig med KYC (Know Your Customer). Det kan imidlertid være en identifisering av nøklene dine, siden kjøpet ble gjort via bankkontoen din. Det er her de to første risikoene forbundet med KYC oppstår - å legge til rette for sporing i kjeden og eksponering for statlig overvåking - som også kan oppstå i en veksling uten KYC. Hvis den sveitsiske enheten rapporterer mistenkelige transaksjoner til myndighetene i landet ditt, kan de ganske enkelt sjekke bankkontoen som ble brukt til kjøpet for å finne identiteten din. Dermed er kjøp uten KYC på regulerte plattformer ganske høyt på risikoskalaen for nøkkelidentifikasjon.

Ved å unngå regulerte plattformer og velge P2P (Peer-to-Peer)-innkjøpsmetoder eliminerer man imidlertid ikke risikoen for nøkkelidentifikasjon helt, men man reduserer den bare. Ta et eksempel med et kjøp på Bisq eller en annen P2P-plattform. For å gjøre opp med motparten vil du sannsynligvis bruke bankkontoen din. Hvis myndighetene stiller spørsmål ved personen du har handlet med, og ber om navnet ditt, oppstår risiko 1 og 2 nevnt ovenfor. Disse risikoene er riktignok mye lavere enn ved et kjøp uten KYC på en plattform, og enda lavere enn ved et kjøp med KYC, men de er likevel til stede i mindre grad.

Selv om du kjøper bitcoins gjennom en fysisk vekslingsplass, er du ikke helt anonym. Personen du handlet med, så ansiktet ditt, som er en del av identiteten din. Selv om muligheten for en identifikasjonsnøkkel er minimal i dette eksempelet, eksisterer den fortsatt.

Konklusjonen er at det alltid foregår en form for nøkkelidentifikasjon ved veksling av bitcoin mot andre aktiva, enten det er et kjøp av fiat-valuta eller et salg mot et reelt aktivum. Avhengig av hvilken byttemetode som velges, kan denne identifikasjonen variere i intensitet. Det er viktig å ikke forveksle denne identifikasjonen med KYC, som er en veldefinert regulatorisk prosess. Det er imidlertid en kobling mellom KYC og identifikasjonsspekteret, siden KYC befinner seg i den øvre enden av dette spekteret, ettersom det systematisk legger til rette for at myndighetene kan identifisere brukernøkler.

## Salgs- og anskaffelsesmetoder

<chapterId>756598af-95aa-4c77-ac48-243c7ad89530</chapterId>

Etter å ha lest forrige kapittel lurer du kanskje på hvordan du kan kjøpe eller selge bitcoin uten å måtte gjennomgå en identitetsverifiseringsprosess for å unngå risikoen forbundet med KYC. Det finnes flere metoder for å foreta vekslinger.

### P2P-utveksling i kontanter

Som vi har sett, er den beste metoden når det gjelder personvern fortsatt P2P (peer-to-peer) utveksling med kontantoppgjør. Denne metoden lar deg minimere sporene som etterlates og reduserer muligheten for nøkkelidentifikasjon betydelig, enten du er kjøper eller selger.

Denne praksisen innebærer imidlertid en personlig sikkerhetsrisiko. Den største faren ligger i at motparten i løpet av vekslingsprosessen vil få vite at du har et betydelig beløp, enten i kontanter eller bitcoin. Denne informasjonen kan tiltrekke seg oppmerksomhet fra ondsinnede personer. Faktisk anbefales det generelt å være diskret når det gjelder besittelse av bitcoin. Dette rådet kan også brukes på kontanter. Under en personlig utveksling er det imidlertid uunngåelig å avsløre at du besitter bitcoin, noe som kan vekke grådighet.

For å begrense denne risikoen anbefaler jeg at du prioriterer kontanttransaksjoner med personer du stoler på, for eksempel familiemedlemmer eller nære venner. Alternativt kan du også vurdere å gjøre utvekslinger på [lokale Bitcoin-møter] (https://btcmap.org/communities/map), etter å ha deltatt flere ganger. Da blir du bedre kjent med de andre deltakerne og slipper å være alene under den fysiske utvekslingen. Det er imidlertid viktig å være klar over at P2P-kontantbytte i seg selv innebærer en risiko for din personlige sikkerhet som ikke eksisterer når du gjør kjøp via en regulert plattform og bankkontoen din.

Avhengig av hvor du bor, kan transport og oppbevaring av store pengesummer utgjøre en risiko, enten det dreier seg om bitcoin eller kontanter.

Utveksling av kontanter kan også utgjøre en juridisk risiko i forbindelse med politikontroller eller andre kontroller. Selv om det i de fleste land ikke er noen begrensning på hvor mye kontanter du kan ha på deg, kan for store summer vekke mistanke. Vær derfor forsiktig, spesielt hvis du skal reise langt, og unngå for store transaksjoner på én gang, slik at du ikke trenger å rettferdiggjøre at du har med deg store summer.

En annen ulempe med P2P-kjøp er at prisen ofte er høyere enn på regulerte plattformer. Selgerne pålegger ofte et pristillegg på alt fra 1 % til noen ganger mer enn 10 %. Det er flere grunner til denne prisforskjellen. For det første er det en vanlig praksis blant P2P-selgere som har blitt etablert over tid. I tillegg har selgerne transaksjonsgebyrer forbundet med å sende penger til kjøperen. Det er også en høyere risiko for tyveri ved P2P-salg enn ved plattformtransaksjoner, noe som rettferdiggjør et gebyr for den risikoen som tas. Til slutt kan premien stå i forhold til etterspørselen og kvaliteten på utvekslingen når det gjelder personvern. Som kjøper er personverngevinsten priset inn i tilleggsavgiften som selgeren krever. Noen bitcoinere mener også at den økte prisen på BTC kjøpt i P2P gjenspeiler deres sanne verdi, og hevder at de lavere prisene på regulerte plattformer er et resultat av en avveining av personvernet til dine personlige opplysninger.

### P2P-utveksling via en matchende plattform

Et mindre risikabelt alternativ når det gjelder personlig sikkerhet, er å gjennomføre P2P-utvekslinger utelukkende på nettet, via elektroniske betalingsmetoder som PayPal, bankoverføringer eller Revolut.

På denne måten unngår man mange av de risikoene som er forbundet med kontanttransaksjoner. Risikoen for at motparten ikke overholder sine forpliktelser under en nettbasert veksling er imidlertid større. Hvis du overleverer penger til en selger som ikke sender deg bitcoins i retur under en fysisk veksling, kan du umiddelbart påpeke det, siden han står foran deg. På nettet, derimot, er det ofte umulig å finne en person som har stjålet fra deg.

For å redusere denne risikoen kan man bruke spesialiserte matchingsplattformer for P2P-utveksling. Disse plattformene bruker konfliktløsningsmekanismer for å beskytte fornærmede brukere. Vanligvis tilbyr de et escrow-system, der bitcoins oppbevares inntil betalingen i fiat-valuta er bekreftet av selgeren.

Når det gjelder personlig sikkerhet, er denne kjøpsmetoden betydelig tryggere enn fysisk kontantutveksling. Som nevnt tidligere etterlater imidlertid P2P-børser på nettet flere spor enn en fysisk utveksling, noe som kan være skadelig for personvernet på Bitcoin. Ved å bruke en fiat-betalingsmetode på nettet, for eksempel en bank, eksponerer du mer informasjon som kan gjøre det lettere å identifisere nøkkelpersoner.

Nok en gang anbefaler jeg å ikke gjøre store handler i én enkelt transaksjon på disse plattformene. Ved å dele opp transaksjonene dine sprer du risikoen forbundet med potensielt tyveri fra motparten.

En annen ulempe med P2P-kjøp er at prisen ofte er høyere enn på regulerte plattformer. Selgerne pålegger ofte et påslag på alt fra 1 % til noen ganger mer enn 10 %. Det er flere grunner til denne prisforskjellen. For det første er det en vanlig praksis blant P2P-selgere som har blitt etablert over tid. I tillegg har selgerne transaksjonsgebyrer forbundet med å sende penger til kjøperen. Det er også en høyere risiko for tyveri ved P2P-salg enn ved plattformtransaksjoner, noe som rettferdiggjør et gebyr for den risikoen som tas. Til slutt kan premien stå i forhold til etterspørselen og kvaliteten på utvekslingen når det gjelder personvern. Som kjøper er personverngevinsten priset inn i tilleggsavgiften som selgeren krever. Noen bitcoinere mener også at den høyere prisen på P2P-kjøpte BTC gjenspeiler den sanne verdien, og hevder at de lavere prisene på regulerte plattformer er et resultat av en avveining av personvernet til dine personlige opplysninger.

Når det gjelder løsninger, har jeg personlig alltid brukt [Bisq] (https://bisq.network/) og er veldig fornøyd med dem. Systemet deres er veletablert og virker pålitelig. Bisq er imidlertid bare tilgjengelig på PC, og grensesnittet kan være for komplisert for nybegynnere. En annen ulempe er at Bisq utelukkende opererer med onchain-transaksjoner, noe som kan bli dyrt i perioder med høye transaksjonsgebyrer på Bitcoin.

-> Lær mer om veiledningen vår på Bisq.

https://planb.network/tutorials/exchange/peer-to-peer/bisq-fe244bfa-dcc4-4522-8ec7-92223373ed04
Hvis du ønsker et enklere alternativ, kan du prøve [Peach] (https://peachbitcoin.com/), en mobilapp som forenkler forbindelsen mellom kjøpere og selgere med et integrert system for tvisteløsning. Prosessen er mer intuitiv enn Bisqs.

-> Lær mer om veiledningen vår på Peach.

Et annet online-alternativ er [HodlHodl] (https://hodlhodl.com/), en veletablert plattform som tilbyr god likviditet, selv om jeg personlig ikke har testet den.

-> Lær mer om vår veiledning om HodlHodl.

https://planb.network/tutorials/exchange/peer-to-peer/peach-wallet-db64fe42-17ca-4b24-abb8-e7d4c03b2028
https://planb.network/tutorials/exchange/peer-to-peer/hodlhodl-d7344cd5-6b18-40f5-8e78-2574a93a3879
For Lightning Network-baserte løsninger kan du prøve [RoboSats] (https://learn.robosats.com/) og [LNP2PBot] (https://lnp2pbot.com/). RoboSats er tilgjengelig via en nettside og er relativt enkel å bruke. LNP2PBot er mer atypisk ved at den opererer gjennom et utvekslingssystem på meldingsappen Telegram.

-> Sjekk ut veiledningen vår om RoboSats.

-> Ta en titt på veiledningen vår om LNP2PBot.

https://planb.network/tutorials/exchange/peer-to-peer/robosats-b60e4f7c-533a-4295-9f6d-5368152e8c06
https://planb.network/tutorials/exchange/peer-to-peer/lnp2pbot-v2-e6bcb210-610b-487d-970c-7cce85273e3c
### Regulerte plattformer uten KYC

Avhengig av hvilket land du bor i, kan du ha tilgang til regulerte plattformer som ikke krever en KYC-prosedyre for å kjøpe eller selge bitcoin. I Sveits kan du for eksempel bruke plattformer som [Relai] (https://relai.app/) og [MtPelerin] (https://www.mtpelerin.com/).

-> Lær mer om vår veiledning om Relai.

Som vi så i forrige kapittel, sparer denne typen plattformer deg for risikoen forbundet med KYC-prosedyrer, men de utgjør en høyere risiko for nøkkelidentifikasjon. Når det gjelder personvern på Bitcoin, tilbyr disse plattformene derfor bedre beskyttelse enn KYC-kjøpsmetoder, men er mindre attraktive enn P2P-børser.

Når det gjelder personlig sikkerhet, er det imidlertid betydelig mindre risikabelt å bruke disse plattformene enn P2P-børser. De er også ofte enklere å bruke enn plattformer som legger til rette for P2P-børser.

https://planb.network/tutorials/exchange/centralized/relai-v2-30a9671d-e407-459d-9203-4c3eae15b30e
### MINIBANK

Et annet alternativ for å kjøpe eller selge bitcoin uten KYC er minibanker for kryptovaluta. Personlig har jeg aldri hatt muligheten til å teste denne løsningen, da det ikke finnes noen i mitt land. Men denne metoden kan være veldig interessant, avhengig av hvor du bor.

Problemet med minibanker er at de er forbudt i noen land eller sterkt regulert i andre. Hvis en minibank krever en identitetsbekreftelsesprosess, står den overfor de samme risikoene som regulerte KYC-plattformer. Men hvis minibanken tillater transaksjoner uten identitetsbekreftelse for små beløp, kan den tilby et personvernnivå som kan sammenlignes med en kontantbasert P2P-børs, og man unngår de fleste av risikoene som er forbundet med denne typen utveksling.

Den største ulempen med minibanker er de ofte høye vekslingsgebyrene, som kan variere fra noen få prosent og opp til 15 prosent av vekslingsbeløpet.

### Gavekort

Til slutt ville jeg også presentere en løsning som fungerer godt for de som ønsker å bruke bitcoinsene sine daglig til kjøp i stedet for å selge dem for fiat-valutaer.

Den beste måten å bruke BTC på er selvsagt å bruke bitcoin direkte eller via Lightning Network for å kjøpe varer eller tjenester. I mange land er det imidlertid fortsatt begrenset hvor mange forretninger som aksepterer bitcoin. Et praktisk alternativ er derfor å bruke gavekort.

Flere plattformer som ikke krever en KYC-prosedyre, tilbyr muligheten til å veksle bitcoin til gavekort som kan brukes i større butikker. Disse plattformene inkluderer [CoinsBee] (https://www.coinsbee.com/), [The Bitcoin Company] (https://thebitcoincompany.com/) og [Bitrefill] (https://www.bitrefill.com/). Disse plattformene gjør den daglige bruken av bitcoins enklere ved å gi deg tilgang til et bredt spekter av produkter og tjenester uten å måtte veksle til fiat-valuta.

https://planb.network/tutorials/exchange/centralized/bitrefill-8c588412-1bfc-465b-9bca-e647a647fbc1
### Andre metoder for anskaffelse

En av de andre metodene for å skaffe seg bitcoin samtidig som du beskytter personvernet ditt, er selvfølgelig mining. For å starte utvinning av sats trenger du ikke å oppgi identiteten din; du trenger bare å finne et gyldig ansettelsesbevis og sende det til nettverket. Hvis du velger utvinning i en pool, krever noen pooler en form for identifikasjon, for eksempel KYC, mens andre ikke gjør det.

En annen metode er å jobbe i bytte mot bitcoin. Denne anskaffelsesmetoden kan være attraktiv, men graden av identifikasjon som kreves, varierer sterkt avhengig av omstendighetene.

\\NFor å skrive dette kapittelet brukte jeg BTC205-kurset laget av [@pivi\_\_] (https://x.com/pivi___) på Plan ₿ Network (foreløpig bare tilgjengelig på fransk).\__

## Konsolidering, UTXO og CIOH Management

<chapterId>d0486c8f-332d-402b-ae2e-949416752b9c</chapterId>

Et av de mest kompliserte aspektene å håndtere når man har sin egen self-storage-portefølje, er utvilsomt konsolidering. Bør du konsolidere? Hva er formålet? Hvilken størrelse på UTXO bør du søke å oppnå? Hvilke avveininger må man gjøre når det gjelder personvern? Det er det vi skal prøve å finne ut av i denne delen.

### Hva er konsolidering?

Driften av Bitcoin ligner på et auksjonsmarked, der transaksjoner som tilbyr de beste avgiftene favoriseres av utvinnerne. Hver blokk har imidlertid en maksimal vekt, noe som begrenser antallet transaksjoner som kan inkluderes. Siden en blokk produseres i gjennomsnitt hvert tiende minutt, er den tilgjengelige plassen i hver blokk en sjelden ressurs.

Gruvearbeidere, hvis virksomhet innebærer betydelige kostnader i form av strøm, kapital og vedlikehold, søker naturlig nok å maksimere lønnsomheten. De har en tendens til å favorisere transaksjoner som gir dem de høyeste avgiftene i forhold til vekten deres.

Faktisk veier ikke alle Bitcoin-transaksjoner det samme. De med mer input og output vil veie mer. Tenk for eksempel på to transaksjoner:


- Transaksjon A inkluderer 1 inngang og 1 utgang. Den tildeler 1 994 satser med avgifter, og vekten er 141 vB;
- Den mer komplekse transaksjonen B, med 2 innganger og 2 utganger, allokerer 2640 sats provisjoner med en vekt på 220 vB.

I eksempelet vil utvinnerne foretrekke transaksjon A, selv om transaksjon B tilbyr en høyere provisjonssum, fordi den gir et bedre forhold mellom provisjon og vekt. Her er beregningen for hver transaksjon, uttrykt i sats per virtuell byte (sat/vB):

```text
TXA: 1994 / 141 = 14 sat/vB
TXB: 2640 / 220 = 12 sat / vB
```

Det betyr at for hver vektenhet tilbyr transaksjon A høyere gebyrer enn transaksjon B, selv om sistnevnte tilbyr høyere gebyrer i absoluttverdi.

Derfor blir det stadig mer attraktivt for brukeren å forbruke minst mulig input i transaksjonene sine. Det er imidlertid nødvendig å forbruke tilstrekkelige mengder for å tilfredsstille betalingen for output. I forvaltningen av porteføljen er det derfor nødvendig å ha tilstrekkelig store UTXO-er.

Konsolideringsprinsippet går nettopp ut på å utnytte perioder med lave gebyrer på Bitcoin til å slå sammen sine små UTXO-er til én større UTXO. Når avgiftene på Bitcoin stiger, kan man dermed gjennomføre transaksjoner med minimal innsats, og dermed bruke mindre i absolutte avgifter. Målet er å planlegge for obligatoriske transaksjoner i perioder med høye provisjoner.

I tillegg til å spare transaksjonsgebyrer bidrar konsolidering av UTXO-er til å unngå at det oppstår "dust" Med "dust" menes UTXOer som har så lav verdi i sats at den ikke er tilstrekkelig til å dekke transaksjonsgebyrene som kreves for å bruke dem. Dette gjør det økonomisk irrasjonelt å bruke disse UTXO-ene så lenge transaksjonsgebyrene forblir høye. Ved å gruppere UTXO-ene dine proaktivt forhindrer du at de blir til støv, og sikrer at alle midlene dine forblir brukbare.

### Hva er minimumsstørrelsen for UTXO-ene dine?

Noen ganger får jeg spørsmål om hva som er den minste anbefalte verdien for en UTXO. Dessverre finnes det ikke noe universelt svar, ettersom det avhenger av dine preferanser og markedsforholdene for provisjoner. Her er imidlertid en formel som kan hjelpe deg med å finne en terskel som passer dine behov:

$$
\frac {P \times F}T = M
$$

Hvor?


- $P$ er vekten av transaksjonen;
- $F$ representerer den maksimale satsen i satoshi per vbyte (sats/vB) som du er villig til å dekke;
- $T$ er prosentandelen av transaksjonsgebyret du er villig til å betale i forhold til den totale verdien av UTXO;
- $M$ er minimumsbeløpet i satoshi for hver UTXO.

Hvis vi antar at du ønsker å dekke provisjonene for en standard SegWit-transaksjon med 1 inngang og 2 utganger, som veier 141 vB. Hvis du dekker opptil 800 sats/vB, og du er villig til å bruke opptil 12 prosent av UTXO-verdien i provisjon, blir beregningen som følger:

$$
\frac{141 \times 800}{0.12} = 940\ 000
$$

I dette eksemplet vil det være klokt å opprettholde en minimumsverdi på 940 000 sat for UTXOer i porteføljen din.

### Konsolidering og COIH

En av de mest brukte heuristikkene i blokkjedeanalyse er COIH (_Common Input Ownership Heuristic_), som lar oss anta at alle inndataene til en Bitcoin-transaksjon tilhører samme enhet. Konsolideringsprinsippet går ut på å konsumere flere UTXO-er som input og skape én UTXO som output. Derfor tillater konsolidering anvendelse av COIH.

![BTC204](assets/fr/097.webp)

I praksis betyr dette at en utenforstående observatør kan slutte at alle de konsoliderte UTXO-ene sannsynligvis tilhører samme person, og at den eneste genererte utdataen også tilhører vedkommende. Denne situasjonen kan kompromittere personvernet ditt ved å koble sammen ulike transaksjonshistorikker. La oss si at jeg konsoliderer tre UTXO-er som er anskaffet via P2P, med én UTXO som er anskaffet via en plattform som krever KYC:

![BTC204](assets/fr/098.webp)

Dermed kan enhver enhet med tilgang til data fra utvekslingsplattformen, potensielt inkludert offentlige etater, identifisere at jeg har andre beløp i BTC. Tidligere var ikke disse UTXO-ene direkte knyttet til identiteten min, men nå er de det. Videre avslører dette for alle kilder at jeg er i besittelse av en viss mengde bitcoin.

I forvaltningen av UTXO-er kommer økonomiske hensyn, som taler for konsolidering for å redusere avgiftene, dermed i konflikt med god personvernpraksis, som anbefaler at man aldri slår sammen UTXO-er. Valget mellom økonomi og personvern avhenger dermed av den enkelte brukers prioriteringer.

Hvis du kan unngå konsolidering og samtidig opprettholde en betydelig størrelse på UTXO-er, er det ideelt. For å gjøre dette må du optimalisere anskaffelsesmetodene dine. Hvis du kjøper bitcoins i DCA, bør du prøve å spre engangskjøpene dine så mye som mulig for å gruppere verdien i færre UTXO-er. Det vil være lettere å administrere et engangskjøp på 1 000 euro annenhver måned enn et kjøp på 120 euro hver uke. Dette minimerer antallet UTXO-er som genereres, og forenkler forvaltningen av porteføljen samtidig som personvernet ditt bevares.

Hvis du har behov for å slå sammen bitcoins, bør du prioritere å slå sammen UTXO-er fra samme kilde. For eksempel vil sammenslåing av 10 UTXO-er fra én enkelt plattform ha mindre innvirkning på personvernet ditt enn å blande 5 UTXO-er fra plattform A med 5 UTXO-er fra plattform B. Hvis konsolidering fra ulike kilder er uunngåelig, bør du prøve å skille dem etter deres egenskaper. Grupper for eksempel UTXO-er som er anskaffet gjennom KYC, i én transaksjon, og UTXO-er som er anskaffet gjennom P2P, i en annen.

Husk uansett at enhver konsolidering uunngåelig fører til tap av personvern. Vurder derfor nøye behovet for dette og de potensielle konsekvensene for personvernet ditt, og ta hensyn til risikoen.

## Annen god praksis

<chapterId>b5216965-7d13-4ea1-9b7c-e292966a487b</chapterId>

La oss sammen utforske noen andre beste fremgangsmåter som kan hjelpe deg med å optimalisere personvernet ditt på Bitcoin.

### Den komplette knuten

Å ha bitcoins i personlig forvaring er bra, men å bruke din egen fulle node er bedre! Dette er grunnen til at det å ha din egen node er avgjørende for fullt ut suveren bruk av bitcoin:


- Motstand mot sensur**: Transaksjonene dine kan ikke blokkeres av noen;
- Uavhengighet fra tredjeparter**: Du er ikke lenger avhengig av noen ekstern tjeneste for å verifisere blokkjededata;
- Aktiv deltakelse**: Du har muligheten til å sette dine egne valideringsregler og delta direkte i konsensus;
- Bidrag til nettverket**: Ved å drive en node bidrar du til å styrke og distribuere Bitcoin-nettverket;
- Teknisk utdanning**: Å kjøre en full node er en flott måte å utdype din tekniske kunnskap om Bitcoin på.

I tillegg til disse fordelene gir bruk av en full node også bedre personvern når du overfører transaksjonene dine. Når du utsteder en transaksjon, blir den først opprettet og signert gjennom lommeboken din. For å overføre den i Bitcoin-nettverket må den være kjent for minst én node. Ved å bruke din egen node kontrollerer du denne overføringen direkte, noe som forbedrer personvernet ditt og begrenser risikoen for tap av data.

![BTC204](assets/fr/099.webp)

Hvis du ikke har din egen Bitcoin-node, må du bruke noden til en tredjepart, for eksempel en som tilbys av leverandøren av lommebokprogramvaren din. I tillegg til overføring av transaksjoner trenger lommeboken din tilgang til diverse informasjon, for eksempel ventende transaksjoner, saldoer knyttet til adressene dine eller antall bekreftelser for transaksjonene dine. For å få tilgang til alle disse dataene må du forespørre en node.

![BTC204](assets/fr/100.webp)

Den største risikoen når du ikke bruker Bitcoin-noden din, er at tredjepartsoperatøren av noden kan observere aktivitetene dine på blokkjeden, eller til og med dele denne informasjonen med andre enheter. For å begrense denne risikoen kan du bruke lommebokprogramvare som lar deg maskere forbindelsene dine via Tor. Dette kan redusere eksponeringen av dataene dine. Den optimale løsningen er imidlertid å ha din egen Bitcoin-node og bruke den til å overføre transaksjonene dine. Du må selvfølgelig også sørge for at ingen informasjon lekker ut av noden din, men det er et annet tema vi skal se nærmere på i de følgende avsnittene.

I tillegg til den åpenbare fordelen for personvernet ditt, sikrer det å ha din egen komplette node også sannheten til data på blokkjeden, beskytter mot sensur og lar deg delta aktivt i Bitcoin-styringen. Ved å bruke din egen node bidrar du med din økonomiske tyngde til den blokkjeden du velger, noe som er viktig under konflikter i samfunnet, som for eksempel under Block Size War fra 2015 til 2017. I tilfelle en gaffel kan det å bruke en tredjeparts node føre til at du støtter en kjede du ikke ønsker å favorisere, ettersom nodeoperatøren tar valget for deg. Som du kan forstå, er det fra et personvern- og mer generelt individuelt suverenitetsperspektiv viktig å kjøre og bruke din egen fulle node!

### Villedende analyseheuristikk

Mer generelt er det viktig å forstå heuristikkene vi diskuterte i forrige avsnitt, slik at man bedre kan unngå eller lure dem. Det kan være fordelaktig å ta i bruk en rekke beste praksiser, selv om de ikke er essensielle. De tilbyr et ekstra lag med beskyttelse som kan være viktig for å opprettholde et godt personvern ved bruk av Bitcoin.

Det første rådet jeg kan gi er å blande seg inn i den tetteste mengden. På Bitcoin betyr dette å bruke de mest brukte skriptmalene. For eksempel er P2WSH-skript, som ofte brukes til multisig SegWit V0-konfigurasjoner, svært sjeldne. De lar deg ikke gjemme deg i et stort sett med anonymitet. Det samme gjelder for eldre modeller som P2PKH eller P2SH. Selv om de er mye til stede i UTXO-settet, brukes de mindre og mindre for nye transaksjoner.

Generelt er det tryggere å gå mot den nyeste skriptstandarden, så lenge den er tilstrekkelig adoptert. Mens jeg i 2022 ville ha frarådet bruk av P2TR (Taproot) på grunn av den lave adopsjonen, ville jeg i 2024 ha anbefalt å velge denne typen skript, eller i motsatt fall SegWit V0-skriptet, siden antallet transaksjoner som bruker P2TR begynner å utgjøre en svært betydelig andel.

Kilde:[txstats.com](https://txstats.com/d/000000054/utxo-set-repartition-by-output-type)

Et annet tips for å bevare personvernet er å prøve å omgå interne transaksjonsheuristikker. Når du for eksempel foretar en betaling, kan du prøve å unngå å opprette en utdata med et rundt beløp, da dette kan signalisere at den andre utdataen representerer endring. Hvis du må sende 100 000 satoshi til en venn, kan du vurdere å overføre et litt høyere beløp for å unngå denne heuristikken. På samme måte bør du prøve å unngå å opprette restutganger som er uforholdsmessig høye sammenlignet med betalingen som er gjort, da dette også kan avsløre hvilken av utgangene som representerer rest.

Til slutt, hvis du gjennomfører Bitcoin-transaksjoner regelmessig, må du sørge for at du ikke alltid overfører dem på samme tidspunkter. Ved å fordele overføringen av transaksjonene dine utover dagen og uken, unngår du å gi utenforstående observatører muligheten til å oppdage et tidsmønster basert på tidssoner som kan forbedre analysen deres.

I tillegg til alle disse beste praksisene du kan ta i bruk på daglig basis, finnes det enda mer effektive metoder for å fullstendig bryte sporbarheten til bitcoinsene dine. Disse inkluderer selvfølgelig coinjoin-transaksjoner, som vi vil studere i dybden i det følgende avsnittet.

# Forståelse av Coinjoin-transaksjoner

<partId>6d0bbf16-3714-4db1-9897-2d45019f6bdc</partId>

## Hva er en Coinjoin-transaksjon?

<chapterId>0862bc6b-1c48-4aa4-b76d-4f547b469008</chapterId>

Etter å ha studert det grunnleggende om personvern, skal vi nå diskutere mer sofistikerte teknikker som tar sikte på å aktivt forsvare personvernet ditt, spesielt ved å skille ut bitcoin-historikken din. I neste del skal vi utforske mange små teknikker, men først vil jeg fortelle deg om coinjoin.

Coinjoin anses ofte som den mest effektive måten å beskytte personvernet til Bitcoin-brukere på. Men hva er egentlig en coinjoin-transaksjon? La oss finne ut av det sammen.

### De grunnleggende prinsippene for Coinjoin

Coinjoin er en teknikk som forstyrrer sporingen av bitcoins på blokkjeden. Den er basert på en samarbeidstransaksjon med en spesifikk struktur med samme navn: coinjoin-transaksjonen.

Som vi så i de første delene av denne opplæringen, er transaksjoner på Bitcoin kjent for alle brukere via noden deres. Det er derfor enkelt å verifisere den elektroniske signaturkjeden til hver enkelt mynt og observere dens historikk. Dette betyr at alle brukere kan forsøke å analysere andre brukeres transaksjoner. Dermed er anonymitet på transaksjonsnivå umulig. Anonymiteten er imidlertid ivaretatt på individnivå. I motsetning til tradisjonell bankvirksomhet, der hver konto er knyttet til en personlig identitet, er midler i Bitcoin knyttet til kryptografiske nøkkelpar (eller skript), noe som gir brukerne en form for pseudonymitet bak kryptografiske identifikatorer.

![BTC204](assets/it/51/01.webp)

Konfidensialiteten til bitcoin kompromitteres dermed når utenforstående observatører kan knytte spesifikke UTXO-er til identifiserte brukere. Når denne tilknytningen er etablert, blir det mulig å spore transaksjonene deres og analysere bitcoin-historikken deres. Coinjoin er nettopp en teknikk som er utviklet for å forstyrre sporingen av UTXO-er for å gi Bitcoin-brukere en viss grad av konfidensialitet på transaksjonsnivå.

Coinjoins forbedrer Bitcoin-brukernes konfidensialitet ved å gjøre det vanskeligere for utenforstående å analysere kjeden. Strukturen gjør det mulig å slå sammen flere mynter fra ulike brukere til én enkelt transaksjon, noe som tilslører spor og gjør det vanskelig å finne koblinger mellom inngangs- og utgangsadresser.

Det er viktig å forstå at målet med en coinjoin-transaksjon er å forstyrre en mynts historie. Denne teknikken gir ikke permanent anonymitet eller stopper sporbarheten til bitcoins permanent, i motsetning til hva man kanskje skulle tro. Coinjoin tar kun sikte på å avbryte historikken på det punktet der coinjoin-transaksjonen utføres. Før og etter denne transaksjonen er mynten imidlertid fortsatt utsatt for den samme personvernrisikoen.

![BTC204](assets/fr/104.webp)

### Hvordan fungerer coinjoins?

Prinsippet med coinjoin er basert på en samarbeidstilnærming: Flere brukere som ønsker å blande bitcoinsene sine, setter inn identiske beløp i inndataene til samme transaksjon. Disse beløpene blir deretter omfordelt i utganger med like verdier til hver bruker.

![BTC204](assets/fr/105.webp)

På slutten av transaksjonen blir det umulig å knytte en spesifikk utgang til en kjent brukerinngang. Det er ingen direkte kobling mellom input og output, noe som bryter forbindelsen mellom brukerne og deres UTXO-er, samt historikken til hver enkelt mynt.

![BTC204](assets/fr/106.webp)

La oss ta et eksempel med Alice. Hun ønsker å sende rundt 100 000 satoshi (sats) til søsteren Eve i bursdagsgave. Alice vil imidlertid ikke at Eve skal kunne spore transaksjonshistorikken hennes, fordi hun ikke ønsker å avsløre hvor mange bitcoins hun eier eller hvordan hun har fått tak i dem. Derfor bestemmer Alice seg for å avbryte UTXO-historikken sin med en coinjoin-transaksjon. Hun avtaler med Bob, Charles, David og Frank å gjennomføre en samarbeidstransaksjon: Alice, Bob, Charles, David og Frank forplikter seg til å gi hver sin UTXO på 105 000 sats (med 5 000 sats for utvinningsavgifter) som input til transaksjonen:

![BTC204](assets/fr/107.webp)


- Til gjengjeld for å bruke disse inndataene genererer hver deltaker en ny adresse for å lage fem identiske utdata på 100 000 satser hver. Hver deltaker henter én utgang:

![BTC204](assets/fr/108.webp)


- Alice ender opp med en UTXO på 100 000 satser med en blandet historikk. Hun bruker denne UTXO-en i en ny transaksjon for å sende beløpet til Eve på bursdagen hennes:

![BTC204](assets/fr/109.webp)


- Hvis Eve prøver å analysere denne transaksjonen for å hente ut informasjon, vil hun komme over coinjoin-transaksjonen som involverer Alice, Bob, Charles, David og Frank. Siden Eve ikke kan skille mellom hvem hver inngang tilhører på grunn av beløpets ensartethet, kan hun ikke spore historikken til Alices UTXO eller finne ut hvor mange bitcoins søsteren hennes eier, eller hvordan hun skaffet seg dem:

![BTC204](assets/fr/110.webp)

I dette scenariet brukte Alice coinjoin-teknikken for å øke personvernet sitt mot analyse bakover. Alice beskytter seg mot en mulig analyse fra Eve som tar utgangspunkt i en bestemt transaksjon for å spore UTXO-historikken bakover. Denne beskyttelsen mot analyse fra nåtid til fortid er det vi kaller retrospektiv anonset. Vi skal se nærmere på dette konseptet i de siste kapitlene i denne delen.

Coinjoin gir imidlertid også muligheten til å forbedre personvernet mot fortid-til-nåtid-analyse, det som kalles prospektiv anonset. La oss gå tilbake til eksempelet der Alice sendte 98 000 sats til Eva på bursdagen hennes, men bytt om på rollene. La oss nå tenke oss at det er Eva som er bekymret for personvernet sitt. Alice kan faktisk bli fristet til å følge mynten hun sendte til Eva for å samle informasjon. Eva kan slå sammen den nylige mottatte UTXO-en med alle de andre UTXO-ene sine, noe som kan avsløre hvor mange bitcoin hun har i lommeboken sin. For å unngå dette kan Eva også forstyrre historikken til den nylig mottatte mynten.


- Eve, Grace, Mallory, Oscar og Victor la hver inn en UTXO på 98 000 sats som input i en Bitcoin-transaksjon:

![BTC204](assets/fr/111.webp)


- I bytte mot å bruke disse inndataene får hver bruker en ny adresse for å lage fem utdata på 97 500 satser hver, helt like. Hver bruker henter én utgang:

![BTC204](assets/fr/112.webp)


- Eve har nå en UTXO på 97 500 satser med en ødelagt historikk. Hun kan bruke den uten frykt for fremtidige transaksjoner. Hvis Alice prøver å følge bitcoinsene hun sendte til Eve, vil hun faktisk støte på en coinjoin-transaksjon. Hun vil ikke være i stand til å avgjøre hvilken UTXO-utgang Eve tilhører. Analyse blir da umulig:

![BTC204](assets/fr/113.webp)

I det første eksempelet så vi hvordan coinjoin kan beskytte personvernet til en mynt i forhold til dens fortid, og i det andre eksempelet så vi hvordan det også kan sikre en mynts historie i forhold til dens fremtid. Det er derfor jeg nevnte at coinjoin bør ses på som en engangshendelse som segmenterer en mynts historie i begge retninger:

![BTC204](assets/fr/104.webp)

### Mixing, coinjoins, mixere... Hva er forskjellen?

Begrepet "mixing" brukes noen ganger for å beskrive coinjoins, et begrep som noen bitcoinere avviser fordi de frykter at det kan forveksles med custodial mixers. Jeg mener imidlertid at denne frykten er ubegrunnet, fordi coinjoin i en matematisk sammenheng nettopp er et uttrykk for begrepet mixing.

I matematikken generelt refererer blanding til egenskapen til et dynamisk system der alle deler av det opprinnelige rommet etter en viss tid teoretisk sett kan blandes med en hvilken som helst annen del. Blanding innebærer at posisjonen til en partikkel eller tilstanden til et system utvikler seg på en slik måte at den fremtidige fordelingen er uavhengig av den opprinnelige fordelingen, slik at man når en tilstand der egenskapene til den opprinnelige tilstanden er jevnt fordelt i systemets rom. Dette er nøyaktig hva som skjer i en coinjoin med bitcoins. Så etter min mening er coinjoin egentlig en myntblandingsmetode.

![BTC204](assets/fr/114.webp)

Det er imidlertid viktig å skille mellom coinjoins og mixere. En mikser er en tjeneste der brukerne sender sine bitcoins for å bli mikset. Disse tjenestene var populære på 2010-tallet, men bruken av dem har gått ned på grunn av to store ulemper sammenlignet med coinjoin:


- De krever at brukerne gir fra seg pengene sine under blandingsprosessen, noe som utsetter dem for tyveririsiko;
- Det er ingen garanti for at mikseren ikke registrerer transaksjonsdetaljer, eller til og med selger denne informasjonen til blokkjedeanalyseselskaper.

![BTC204](assets/fr/115.webp)

I dag foretrekker brukere derfor coinjoin, ettersom det lar dem beholde full kontroll over midlene sine gjennom hele prosessen. Deltakerne i en coinjoin risikerer ikke å få bitcoinsene sine stjålet av andre involverte parter. Hvordan dette er mulig, skal vi se nærmere på i neste kapittel.

## Zerolink og Chaumian Coinjoins

<chapterId>326c9654-b359-4906-b23d-d6518dd5dc3e</chapterId>

Personvernet som en coinjoin gir, er basert på størrelsen på gruppen som brikken vår er skjult i. Derfor er det nødvendig å finne så mange deltakere som mulig. Det er fullt mulig å kjøre en coinjoin manuelt, med brukere som er funnet uavhengig av hverandre, men denne metoden er kompleks og gir ikke mulighet for store anonsett.

Dette er grunnen til at coinjoin-koordinatorer har utviklet seg på Bitcoin. Deres rolle er å koble sammen ulike brukere og overføre informasjonen som er nødvendig for å fullføre samarbeidstransaksjonen.

![BTC204](assets/fr/116.webp)

Men hvordan kan vi sikre at koordinatoren aldri har kontroll over brukernes bitcoins, og selv om det er han eller hun som konstruerer coinjoin-transaksjonen, hvordan kan vi sikre at han eller hun ikke kan koble brukernes inn- og utdata, noe som kan være et tap av personvern?

### Chaums blinde signaturer

Moderne coinjoin-implementeringer bruker David Chaums blindsignaturer for å forhindre informasjonslekkasje. La oss raskt studere hvordan disse blindsignaturene fungerer.

Chaum-blindsignaturer er en form for digital signatur der utstederen av signaturen ikke kjenner innholdet i meldingen den signerer. Signaturen kan imidlertid verifiseres senere med den opprinnelige meldingen. Denne teknikken ble utviklet av kryptografen David Chaum i 1983.

Ta et eksempel med en bedrift som ønsker å autentisere et konfidensielt dokument, for eksempel en kontrakt, uten å avsløre innholdet. Bedriften bruker en maskeringsprosess som kryptografisk transformerer originaldokumentet på en reversibel måte. Det modifiserte dokumentet sendes til en sertifiseringsinstans som bruker en blind signatur uten å kjenne til det underliggende innholdet. Etter å ha mottatt det signerte dokumentet fjerner selskapet maskeringen fra signaturen. Resultatet er et originaldokument som er autentisert med autoritetens signatur, uten at autoriteten noen gang har sett det opprinnelige innholdet.

Chaums blindsignaturer gjør det dermed mulig å sertifisere autentisiteten til et dokument uten å kjenne til innholdet, noe som sikrer både konfidensialiteten til brukerens data og integriteten til det signerte dokumentet.

### Chaumian Coinjoins

I "Chaumian CoinJoins" kombineres bruken av Tor og David Chaums blindsignaturer for å sikre at koordinatoren ikke kan vite hvilken bruker hver utgang tilhører. Prosessen med å lage en coinjoin-transaksjon består av tre hovedtrinn: registrering av input, registrering av output og signering av transaksjonen. La oss se nærmere på denne prosessen gjennom eksemplet med Alice, en av deltakerne i coinjoin. Alle andre deltakere følger de samme trinnene som Alice, hver for seg.

**Trinn 1: Registrering av inndata


- Alice sender koordinatoren UTXO-en hun ønsker å bruke som input for transaksjonen, samt den maskerte mottakeradressen hun ønsker å bruke som output for å motta bitcoinsene sine. Koordinatoren kan derfor ikke kjenne Alices adresse. Den ser bare den maskerte versjonen hennes.
- Koordinatoren verifiserer gyldigheten av inndataene, og signerer deretter Alices maskerte adresse med hennes private nøkkel. Deretter sender han den blinde signaturen til Alice.

**Trinn 2: Innspilling av utganger


- Alice kan nå fjerne maskeraden fra adressen sin som er signert med koordinatorens private nøkkel. Hun oppretter en ny tilkobling under en annen Tor-identitet. Koordinatoren kan ikke identifisere at det er Alice som kobler seg til under denne nye identiteten.
- Alice sender den skjulte adressen og signaturen til koordinatoren (som fortsatt ikke vet at det er Alice).

**Trinn 3: Signer transaksjonen


- Koordinatoren henter på samme måte inn umaskerte utdata fra alle deltakerne. Med de tilhørende signaturene kan han verifisere at hver utdata som sendes anonymt, faktisk ble signert med hans private nøkkel tidligere, noe som sikrer at den er legitim. Deretter er han klar til å konstruere coinjoin-transaksjonen, og sender den til deltakerne slik at de kan signere den.
- Alice, i likhet med de andre deltakerne, verifiserer at hennes input og output er korrekt inkludert i transaksjonen som er konstruert av koordinatoren. Hvis alt er i orden, sender hun signaturen som låser opp skriptet til koordinatoren.
- Etter å ha samlet inn signaturer fra alle coinjoin-deltakerne, kan koordinatoren sende transaksjonen over Bitcoin-nettverket slik at den kan legges til i en blokk.

I dette systemet kan ikke koordinatoren koble en input til en spesifikk output. I tillegg kan han ikke ta i besittelse deltakernes midler, siden han aldri har tilgang til de private nøklene som trengs for å låse opp UTXO-ene deres. Gjennom hele prosessen, og frem til slutten av trinn 3, har han ikke engang tilgang til signaturene. Når Alice og de andre deltakerne signerer den globale transaksjonen, etter å ha verifisert at alt er korrekt, kan koordinatoren ikke lenger endre denne transaksjonen, inkludert utdataene, uten å ugyldiggjøre den. Dette forhindrer dermed tyveri av bitcoin fra koordinatorens side.

Når de til slutt registrerer resultatet sitt i transaksjonen, ønsker coinjoin-brukeren garantier som ligner på garantiene til en borger som stemmer i et valg. Det er en dualitet mellom de offentlige og private aspektene ved disse handlingene. På den ene siden er det det man ønsker å holde privat: Velgerne ønsker ikke at stemmeseddelen deres skal knyttes til identiteten deres, og coinjoin-brukerne ønsker ikke at deres output skal knyttes til deres input. Hvis koordinatoren, eller noen annen part, klarer å etablere en kobling mellom en input og en output, mister coinjoin faktisk hele sitt formål. Som forklart tidligere, må coinjoin fungere som en pause i historien til en mynt. Denne pausen oppstår nettopp fordi det ikke er mulig å knytte en spesifikk input til en spesifikk output i coinjoin-transaksjonen (prospektiv anonset) og vice versa (retrospektiv anonset).

På den andre siden har vi det offentlige aspektet: Velgeren ønsker å forsikre seg om at stemmeseddelen deres er inkludert i valgurnen, og på samme måte ønsker coinjoin-brukeren å forsikre seg om at resultatet deres er inkludert i coinjoin-transaksjonen. Det er faktisk helt nødvendig for coinjoin-deltakerne å kunne verifisere at deres output er til stede før de signerer transaksjonen, ellers kan koordinatoren stjele pengene.

Det er nettopp disse to offentlige og private aspektene, muliggjort ved bruk av David Chaums blindsignaturer, som forsikrer Chaumians coinjoin-deltakere om at bitcoinsene deres ikke vil bli stjålet, og at midlene deres ikke kan spores.

### Hvem oppfant begrepet coinjoin?

Det er vanskelig å fastslå med sikkerhet hvem som først introduserte ideen om coinjoin på Bitcoin, og hvem som kom opp med ideen om å bruke David Chaums blindsignaturer i denne sammenhengen. Det antas ofte at det var Gregory Maxwell som først nevnte det i [et innlegg på BitcoinTalk i 2013] (https://bitcointalk.org/index.php?topic=279249.0):

Ved hjelp av Chaums blindsignaturer: Brukerne kobler seg til og oppgir inndata (og adresser for resten) samt en kryptografisk skjult versjon av adressen de ønsker å sende de private myntene sine til. Brukerne kobler seg anonymt til igjen, avslører utgangsadressene sine og sender dem tilbake til serveren. Serveren kan se at alle utdataene er signert av den, og at alle utdataene dermed kommer fra gyldige deltakere. Senere kobler folk seg til igjen og signerer.

Maxwell, G. (2013, 22. august). _CoinJoin: Bitcoins personvern for den virkelige verden_. BitcoinTalk Forum. https://bitcointalk.org/index.php?topic=279249.0

Det har imidlertid tidligere blitt nevnt både Chaum-signaturer i forbindelse med miksing og coinjoins. [I juni 2011 presenterte Duncan Townsend på BitcoinTalk (https://bitcointalk.org/index.php?topic=12751.0) en mikser som bruker Chaum-signaturer på en måte som er ganske lik moderne Chaumians coinjoins.

I samme tråd er det [en hashcoin-melding som svar til Duncan Townsend](https://bitcointalk.org/index.php?topic=12751.msg315793#msg315793) for å forbedre mikseren hans. Prosessen som beskrives i denne meldingen representerer nettopp det som ligger nærmest coinjoins. Et lignende system er også nevnt i [en melding fra Alex Mizrahi i 2012](https://gist.github.com/killerstorm/6f843e1d3ffc38191aebca67d483bd88#file-laundry), da han ga råd til skaperne av Tenebrix, en av de første altcoins som senere dannet grunnlaget for opprettelsen av Litecoin. Selv begrepet "coinjoin" ble ikke oppfunnet av Greg Maxwell, men kom fra en idé av Peter Todd.

![BTC204](assets/fr/125.webp)

### Zerolink

Zerolink er en omfattende blandingsprotokoll som integrerer Chaumiani coinjoins og ulike strategier for å beskytte brukeranonymitet mot ulike former for kjedeanalyse, noe som i stor grad reduserer feil knyttet til lommebokadministrasjon. Denne protokollen [ble introdusert av nopara73 og TDevD i 2017] (https://github.com/nopara73/ZeroLink/blob/master/README.md).

![BTC204](assets/fr/126.webp)

Som navnet antyder, er prinsippet i Zerolink å utføre coinjoin-transaksjoner som sikrer at koblinger mellom inn- og utdata ikke kan spores. Denne funksjonen oppnås ved å sikre at alle utganger har helt identiske beløp.

![BTC204](assets/fr/127.webp)

Et viktig forebyggende tiltak fra Zerolink innebærer fullstendig separasjon av ublandede UTXO-er fra blandede UTXO-er ved hjelp av separate sett med kryptografiske nøkler, eller til og med separate lommebøker. På denne måten skilles "pre-mix"-lommeboken, som er beregnet på mynter før blanding, fra "post-mix"-lommeboken, som er reservert for mynter som har blitt blandet.

![BTC204](assets/fr/128.webp)

Denne strenge separasjonen av UTXO-er tjener først og fremst til å forhindre utilsiktede koblinger mellom en blandet og en ublandet UTXO. Hvis slike koblinger oppstår, blir effekten av coinjoin på den blandede UTXO-en opphevet uten at brukeren er klar over det, og dermed går det ut over konfidensialiteten til en UTXO som man trodde hadde blitt brutt. Disse koblingene kan oppstå enten gjennom gjenbruk av adresser for å sikre en blandet UTXO med en ublandet UTXO, eller ved å bruke Common Input Ownership Heuristics (CIOH) hvis brukeren bruker blandede og ublandede UTXO-er som inndata i samme transaksjon. Ved å skille porteføljer før og etter blanding unngås slike utilsiktede assosiasjoner, og brukeren beskyttes mot utilsiktede feil.

![BTC204](assets/fr/129.webp)

Dette skillet gjør det også mulig å bruke forskjellige regler for pre-mixing- og post-mixing-porteføljer på porteføljeprogramvarenivå. I post-mixing-porteføljen kan programvaren for eksempel forby sammenslåing av inngangs-UTXO-er for å forhindre bruk av CIOH, noe som vil kompromittere brukerens anonset. Det er også mulig å standardisere bruken av skript og transaksjonsalternativer (som for eksempel RBF-signalering) for å forhindre identifisering ved hjelp av lommebokfingeravtrykk.

Whirlpool er for øyeblikket den eneste coinjoin-implementeringen som strengt håndhever Zerolink-protokollen. I det følgende kapittelet skal vi se nærmere på de ulike eksisterende coinjoin-implementeringene og fordelene og ulempene ved hver av dem.

## Coinjoin-implementeringer

<chapterId>e37ed073-9498-4e4f-820b-30951e829596</chapterId>

i 2024 ser vi betydelige endringer i verktøyene som er tilgjengelige for brukere som ønsker å kjøre coinjoins på Bitcoin. Vi er inne i en avgjørende periode, og coinjoin-markedet gjennomgår en stor omstrukturering. Derfor vil dette kapittelet sannsynligvis bli oppdatert over tid

For øyeblikket finnes det hovedsakelig tre ulike implementeringer av coinjoin på Bitcoin:


- Whirlpool;
- Wabisabi;
- JoinMarket.

Alle disse implementeringene har som mål å bryte UTXO-historikken gjennom coinjoin-transaksjoner. Mekanismene deres varierer imidlertid betydelig. Derfor er det viktig å forstå hvordan de fungerer, slik at du kan velge det alternativet som passer best til dine behov.

### JoinMarket

JoinMarket, som ble opprettet i 2015 av Adam Gibson og Chris Belcher, skiller seg fra andre coinjoin-implementeringer på grunn av sin unike brukermatchingsmodell. Dette systemet er basert på en P2P-børsmarkedsplass der noen brukere, "makers", gjør bitcoinsene sine tilgjengelige for miksing, mens andre, "takers", bruker disse midlene til å utføre coinjoins i bytte mot en avgift.

![BTC204](assets/fr/130.webp)

I denne modellen lar "produsentene" bitcoinsene sine være tilgjengelige for "mottakerne" og mottar gebyrer i bytte for tjenesten. "Takerne", på sin side, betaler for å bruke "makernes" bitcoins til å gjennomføre sine egne coinjoin-transaksjoner. Serviceavgiftene varierer etter rolle: "makers" akkumulerer avgifter for likviditetstilbudene sine, mens "takers" betaler provisjon. Denne markedsplassen opererer fritt uten bruksvilkår.

En stor ulempe med JoinMarket er at det er komplisert å bruke, noe som krever en viss kjennskap til terminaler for å utnytte det effektivt. Selv om denne kompleksiteten ikke er noen hindring for en erfaren bruker, kan den begrense tilgangen for allmennheten. Den nylige introduksjonen av et webgrensesnitt kalt JAM har imidlertid gjort det noe enklere å bruke det.

![BTC204](assets/fr/131.webp)

Kilde: [JAM]() [JAM](https://github.com/joinmarket-webui/jam/blob/devel/docs/assets/screenshot-dark.webp)

Den tekniske barrieren er imidlertid fortsatt et stort hinder. I coinjoin-økosystemet, der konfidensialiteten styrkes av antall deltakere, påvirker enhver begrensning som reduserer tilgjengeligheten direkte tilgjengelig likviditet, noe som er en avgjørende faktor for å blande effektivitet. Bitcoin, som allerede er en nisje innen finansielle transaksjoner, ser på bruken av coinjoins som en undernisje, og JoinMarket representerer en enda mer spesialisert fraksjon, noe som begrenser potensialet for å øke anonsettene til brukerne.

Til tross for sin innovative P2P-matchingmodell for coinjoins har JoinMarket noen betydelige ulemper, spesielt når det gjelder transaksjonsstrukturen. I motsetning til andre implementeringer, som Whirlpool, garanterer ikke JoinMarket perfekt likhet mellom utganger, og det kan trekkes deterministiske koblinger mellom innganger og utganger. Det mangler også verktøy for å forhindre at allerede blandede mynter blandes på nytt, noe som kan gå på bekostning av konfidensialiteten som brukerne ønsker. Selv om JoinMarket-konseptet er attraktivt, spesielt for dem som er interessert i et dynamisk likviditetsmarked, gjør dets strukturelle svakheter og tekniske kompleksitet det etter min mening mindre attraktivt, både for nybegynnere og eksperter som ønsker å implementere coinjoin.

### Wabisabi

Wabisabi er en annen implementering av coinjoin, med en tilnærming som sentraliserer koordineringen av transaksjoner. Denne modellen ble designet av Ádám Ficsór (nopara73), Yuval Kogman, Lucas Ontivero og István András Seres i 2021, og ble integrert i Wasabi 2.0-programvaren året etter. Wabisabi representerer nettopp en videreutvikling av coinjoin-modellen til Wasabi-programvaren som ble lansert i 2018.

På slutten av 2010-tallet tok Wasabi i bruk en transaksjonsstruktur for sine coinjoins som var radikalt forskjellig fra Whirlpools. For å øke anonsettene til deltakerne brukte Wasabi svært store coinjoin-transaksjoner som grupperte dusinvis av deltakere. Whirlpool valgte derimot flere små transaksjoner, noe som muliggjorde en eksponentiell økning i anonsets for hver syklus.

Metodene for å håndtere restleddet skilte også de to implementeringene fra hverandre. I Whirlpool ble restene ekskludert og isolert fra UTXO-er før coinjoin-sykluser av TX0, et konsept jeg vil forklare nærmere i neste kapittel. I Wasabi, derimot, var restmengden en av utgangene i coinjoin-transaksjonen, slik at deterministiske koblinger mellom noen innganger og utganger ble opprettholdt.

Med Wabisabi, versjon 2.0 av Wasabi, har Wasabi tilpasset sin tilnærming til coinjoins for å tilnærme seg Whirlpools tilnærming. Selv om coinjoin-transaksjonene fortsatt er svært store, er det nå mulig å kjede flere påfølgende runder, og dermed følge Whirlpools modell. Det er også gjort en spesiell innsats når det gjelder håndteringen av vekslepengene: I motsetning til Wasabi 1.0, der vekslepengene var direkte knyttet til brukerens input, forsøker Wasabi å dele vekslepengene opp i flere små beløp, som fordeles i like store valører til alle deltakerne.

Vi vil illustrere dette med et forenklet eksempel med bare to brukere: Alice ønsker å blande 115 000 sats og Bob 210 000 sats. Hvis vi ser bort fra provisjoner, ville en coinjoin-transaksjon med Wasabi 1.0 ha generert 3 utganger på 100 000 satser, pluss 1 rest på 15 000 satser for Alice og 1 rest på 10 000 satser for Bob. De resterende utgangene ville alltid være knyttet til inngangene:

Under Wabisabi vil den samme transaksjonen produsere 3 utganger på 100 000 satser og 5 utganger på 5 000 satser, slik at resten ikke kan spores direkte til en bestemt inngang:

Personlig mener jeg at endringshåndteringen i Wabisabi innebærer flere risikoer som kan svekke effektiviteten når det gjelder personvern:


- Når en bruker bidrar med en UTXO som er betydelig større enn de andre deltakernes, vil han uunngåelig ende opp med en endringsmengde som kan knyttes til hans innspill. Dette strider mot protokollens opprinnelige mål, som er å eliminere enhver identifiserbar endring;
- Multiplikasjon av betegnelser for å fragmentere resten kan paradoksalt nok skade blandingseffektiviteten. Denne prosessen kan føre til en nedgang i antall anonsett for visse utganger, ettersom de blir lettere å identifisere;
- Denne metoden genererer også UTXO-er med lav verdi som utgjør et forvaltningsproblem for brukeren. Hvis disse små UTXO-ene blir for dyre å bruke i forhold til verdien, kan de bli til "støv" Dette fenomenet får brukeren til å slå sammen flere inngående UTXO-er i fremtidige transaksjoner eller konsolidere dem. I begge tilfeller kan dette, på grunn av COH, redusere de oppnådde anonsettene eller helt oppheve personvernfordelene som ble oppnådd ved den første coinjoiningen.

I motsetning til Whirlpool, som implementerer ZeroLink-protokollen ved å sikre streng segregering mellom UTXO pre-mix og post-mix, opprettholder ikke Wabisabi denne strenge segregeringen. Det har også vært problemer med gjenbruk av adresser hos noen av Wasabis kunder, noe som åpenbart er svært skadelig for brukeren.

I versjon 2.0 av Wasabi ble det innført en ny prispolitikk for coinjoin. Nå er koordinatoravgiftene satt til 0,3 prosent for UTXOer større enn 0,01 bitcoin, mens for mindre UTXOer er disse avgiftene helt nullet ut. I tillegg er remixer for disse mindre UTXO-ene gratis, selv om det fortsatt påløper utvinningsgebyrer for alle transaksjoner, inkludert remixer.

Denne policyen står i kontrast til Whirlpool, der provisjonene forblir faste, uavhengig av størrelsen på de oppnådde anonsettene. Med Wasabi 2.0 må brukeren fortsatt betale utvinningsprovisjoner for alle transaksjoner, inkludert remixer, selv om koordinatorprovisjoner nullstilles for små UTXO-er.

I skrivende stund har bruken av Wabisabi blitt betydelig mer kompleks som et resultat av nylige hendelser. Etter arrestasjonen av grunnleggerne av Samourai Wallet kunngjorde zkSNACKs, selskapet som finansierer og administrerer utviklingen av Wasabi, faktisk avslutningen av sin coinjoin-koordineringstjeneste 1. juni 2024. Denne koordinatoren, som var satt til standard til Wasabi, hadde det store flertallet av likviditeten.

Etter at denne hovedkoordinatoren ble lagt ned, må brukerne nå koble seg til nye, uavhengige koordinatorer. Denne endringen gir grunn til bekymring: På den ene siden kan det hende at de nye koordinatorene ikke har tilstrekkelig likviditet, noe som reduserer effektiviteten av coinjoins med tanke på personvern. På den andre siden er det en risiko for å støte på en ondsinnet koordinator. Denne situasjonen medfører betydelig ny risiko for dem som ønsker å bruke Wabisabi.

I tillegg til tekniske problemer reiser beslutningen til zkSNACKs, selskapet bak Wasabi, om å bruke tjenestene til et blockchain-analyseselskap for å filtrere deltakere i coinjoins alvorlige etiske og strategiske spørsmål. Den opprinnelige tanken var å forhindre at kriminelle bruker coinjoins på Wasabi, noe som kan virke legitimt. Det reiser imidlertid et paradoks: å betale avgifter til en koordinator, hvis hovedoppgave er å øke brukernes personvern, for deretter å finansiere et selskap hvis mål er å kompromittere det samme personvernet.

Enda mer bekymringsfullt er prinsippet om filtrering, som står i skarp kontrast til Bitcoins filosofi om å tilby et åpent og usensurert finanssystem. Selv om det kan virke berettiget å ønske å utelukke kriminell aktivitet, kan denne filtreringen også ramme personer hvis handlinger, selv om de er klassifisert som ulovlige i noen sammenhenger, kan være moralsk forsvarlige eller samfunnsnyttige. Edward Snowden er et godt eksempel på denne todelingen: Noen regjeringer anser ham som kriminell på grunn av avsløringene hans, mens andre ser på ham som en varsler som handlet i allmennhetens interesse. Denne kompleksiteten understreker den potensielle faren ved filtrering, som selv om den starter med en god intensjon, til syvende og sist kan skade rettighetene og sikkerheten til legitime brukere. Jeg kunne også ha nevnt forfulgte aktivister og journalister under visse autoritære regimer. Som du kanskje har gjettet, foretrekker jeg utvilsomt Whirlpool-modellen for å gjennomføre coinjoins på Bitcoin. Dette systemet skiller seg ut for sin strenghet og tilbyr overlegne garantier når det gjelder personvern. Det er også den eneste som foreslår en blanding som anses som perfekt i en matematisk sammenheng. Etter min mening representerer denne modellen fremtiden for coinjoins på Bitcoin. Jeg inviterer deg derfor til å utforske denne modellen mer inngående i neste kapittel.

## Driften av Whirlpool

<chapterId>bdbd7109-e36d-4b4f-a3c6-928df4e9bfda</chapterId>

Whirlpool skiller seg fra andre coinjoin-metoder ved å bruke "_ZeroLink_"-transaksjoner, som sikrer at det teknisk sett ikke er noen mulig forbindelse mellom alle innganger og alle utganger. Denne perfekte blandingen oppnås gjennom en struktur der hver deltaker bidrar med et identisk beløp i input (med unntak av utvinningsavgifter), og dermed genererer utganger av helt like mengder.

Denne restriktive tilnærmingen til input gir Whirlpools coinjoin-transaksjoner en unik egenskap: det totale fraværet av deterministiske koblinger mellom input og output. Med andre ord har hver utgang like stor sannsynlighet for å bli tilskrevet en hvilken som helst deltaker, i forhold til alle andre utganger i transaksjonen.

![BTC204](assets/fr/136.webp)

### Den generelle driften av Whirlpool

Opprinnelig var antallet deltakere i hver Whirlpool coinjoin begrenset til 5, med 2 nye deltakere og 3 remixere (vi vil forklare disse konseptene senere). Økningen i avgiftene for transaksjoner i kjeden som ble observert i 2023, fikk imidlertid Samourais team til å revurdere modellen for å forbedre personvernet og samtidig redusere kostnadene. Dermed, med tanke på provisjonsmarkedssituasjonen og antall deltakere, kan koordinatoren nå organisere coinjoins som inkluderer 6, 7 eller 8 deltakere. Disse forbedrede øktene går under navnet "_Surge Cycles_" Det er viktig å merke seg at uansett konfigurasjon er det alltid bare to nye deltakere i Whirlpool coinjoins.

Whirlpool-transaksjoner kjennetegnes dermed av et identisk antall innganger og utganger, som kan være:


- 5 innganger og 5 utganger;

![BTC204](assets/fr/137.webp)


- 6 innganger og 6 utganger;

![BTC204](assets/fr/138.webp)


- 7 innganger og 7 utganger;

![BTC204](assets/fr/139.webp)


- 8 innganger og 8 utganger.

![BTC204](assets/fr/140.webp)

Whirlpools foreslåtte modell er dermed basert på små coinjoin-transaksjoner. I motsetning til Wabisabi og JoinMarket, der robustheten til anonsets er basert på volumet av deltakere i en enkelt syklus (eller noen få sykluser), baserer Whirlpool seg på sammenkjedningen av flere små sykluser. I denne modellen påløper det kun kostnader for brukerne ved første gangs deltakelse i en pool, slik at de kan delta i en rekke remikser uten ekstra kostnader. Det er de nye deltakerne som dekker utvinningskostnadene for de som remikser.

For hver ekstra coinjoin en mynt deltar i, sammen med de andre myntene som har oppstått tidligere, vil anonsettene vokse eksponentielt. Målet er derfor å dra nytte av disse gratis remixene, som for hver gang bidrar til å styrke tettheten av anonsett som er knyttet til hver myntmiks.

Whirlpool ble designet med to viktige krav i tankene:


- Tilgjengeligheten til implementering på mobile enheter, siden Samourai Wallet først og fremst er en smarttelefonapplikasjon;
- Hastigheten på remixing-syklusene bidrar til en betydelig økning i antall anonsett.

Disse kravene styrte Samourai Wallet-utviklernes valg i utformingen av Whirlpool, og førte til at de valgte å begrense antall deltakere per syklus. For få deltakere ville ha gått på bekostning av effektiviteten til coinjoin og drastisk redusert anonsettene som genereres i hver syklus, mens for mange deltakere ville ha skapt problemer med å administrere mobilapplikasjonene og hemmet syklusflyten.

Til syvende og sist er det ikke nødvendig å ha et høyt antall deltakere for å bli med i Whirlpool, siden anonsett realiseres ved akkumulering av flere sammenføyningssykluser. Det viktigste prinsippet her er at UTXO-ene til alle deltakerne er homogene, ettersom dette muliggjør en perfekt miks, og dermed fullt utbytte av miksing- og remixing-syklusene.

### Sammenfallende bassenger og priser

For at disse flere syklusene effektivt skal øke anonsettene til de blandede myntene, må det etableres et rammeverk for å begrense mengden UTXO som brukes. Whirlpool definerer derfor flere bassenger.

En pool representerer en gruppe brukere som ønsker å blande seg sammen, og som blir enige om hvor mye UTXO som skal brukes for å optimalisere coinjoin-prosessen og samtidig opprettholde perfekt mynthomogenitet. Hver pool spesifiserer et fast beløp for UTXO, som brukeren må oppfylle for å kunne delta. For å utføre coinjoins med Whirlpool må man derfor velge en pool. De tilgjengelige poolene er for øyeblikket som følger:


- 0.5 bitcoin;
- 0.05 bitcoin;
- 0.01 bitcoin;
- 0.001 bitcoin (= 100 000 sats).

Ved å bli med i en pool med dine bitcoins, vil disse bli delt for å generere UTXOer som er helt homogene med de andre deltakerne i poolen. Hver pool har en maksimumsgrense, og for beløp som overstiger denne grensen, vil du derfor bli tvunget til å enten gjøre to separate oppføringer i samme pool eller gå til en annen pool med et større beløp:

| Pool (bitcoin) | Maksimumsbeløp per inngang (bitcoin) | Maksimumsbeløp per inngang (bitcoin)

|----------------|----------------------------------------|

| 0,5 | 35 |

| 0,05 | 3,5 |

| 0,01 | 0,7 |

| 0,001 | 0,025 |

En UTXO anses å tilhøre en pool når den er klar til å bli integrert i en coinjoin. Dette betyr imidlertid ikke at brukeren mister kontrollen over den. Som vi så i de første kapitlene i denne delen, beholder du full kontroll over nøklene dine og følgelig bitcoinsene dine gjennom de ulike blandingssyklusene. Det er dette som skiller coinjoin-teknikken fra andre sentraliserte blandingsteknikker.

For å bli med i et coinjoin-basseng må det betales serviceavgifter samt utvinningsavgifter. Serviceavgiftene er faste for hvert basseng og er ment å kompensere teamene som er ansvarlige for utvikling og vedlikehold av Whirlpool.

Serviceavgifter for bruk av Whirlpool må betales én gang når du går inn i bassenget. Når dette trinnet er fullført, har du muligheten til å delta i et ubegrenset antall remixer uten ekstra avgifter. Her er de gjeldende faste avgiftene for hvert basseng:

| Pool (bitcoin) | Inngangsavgift (bitcoin) | Inngangsavgift (bitcoin)

| -------------- | --------------------------------- |

| 0.5 | 0.0175 |

| 0.05 | 0.00175 |

| 0,01 | 0,0005 (50 000 sats) | 0,01 | 0,0005 (50 000 sats)

| 0,001 | 0,00005 (5 000 sats) | 0,001 | 0,00005 (5 000 sats)

Disse avgiftene fungerer i hovedsak som en inngangsbillett til bassenget du velger, uavhengig av beløpet du legger inn i coinjoin. Så uansett om du går inn i 0.01 BTC-bassenget med nøyaktig 0.01 BTC eller går inn med 0.5 BTC, vil avgiftene forbli de samme i absolutt verdi.

Før man går videre med Whirlpool coinjoins, kan brukeren velge mellom to strategier:


- Velg en mindre pool for å minimere serviceavgiftene, vel vitende om at de vil motta flere mindre UTXO-er i retur;
- Eller foretrekker en større pool, og godtar å betale høyere gebyrer for å ende opp med et mindre antall UTXOer med høyere verdi.

Generelt anbefales det ikke å slå sammen flere blandede UTXO-er etter coinjoin-sykluser, da dette kan gå på bekostning av personvernet, spesielt på grunn av heuristikken for felles inngangseierskap (CIOH: _Common-Input-Ownership-Heuristic_). Derfor kan det være lurt å velge en større pool, selv om det betyr at man må betale mer, for å unngå å få for mange UTXO-er med liten verdi som output. Brukeren må vurdere disse avveiningene for å velge den puljen han eller hun foretrekker.

I tillegg til serviceavgifter, må også utvinningsavgiftene som ligger i enhver Bitcoin-transaksjon vurderes. Som Whirlpool-bruker må du betale utvinningsgebyr for forberedelsestransaksjonen (`Tx0`) samt for den første mynttilknytningen. Alle påfølgende remixer vil være gratis, på grunn av Whirlpools modell for å betale nye deltakere.

I hver Whirlpool-sammenslåing er faktisk to av brukerne blant de nye deltakerne. De andre inputene kommer fra remixere. Som et resultat dekkes utvinningsavgiftene for alle deltakerne i transaksjonen av disse to nye deltakerne, som da også vil dra nytte av gratis remikser:

![BTC204](assets/it/54/07.webp)

På grunn av dette gebyrsystemet skiller Whirlpool seg virkelig fra andre coinjoin-implementeringer fordi anonsettene til UTXO-er ikke er proporsjonale med prisen som betales av brukeren. Dermed kan man oppnå svært høy grad av anonymitet ved kun å betale inngangsbilletten til bassenget og utvinningsavgifter for to transaksjoner (`Tx0` og den første blandingen).

Det er viktig å merke seg at brukeren også må dekke utvinningsgebyrene for å ta ut UTXO-ene sine fra bassenget etter å ha kjørt flere coinjoins, med mindre de har valgt alternativet `mix to`, som lar dem oppgi en ekstern adresse som vil motta midlene direkte som resultatet av en coinjoin, uten noen ekstra transaksjon.

### HD Wallet-kontoer

For å utføre en coinjoin gjennom Whirlpool, må lommeboken generere flere separate kontoer. Dette er prinsippet i ZeroLink-protokollen. En konto, i sammenheng med en HD-lommebok (_Hierarchical Deterministic_), utgjør en seksjon som er fullstendig isolert fra de andre, og denne separasjonen skjer på det tredje dybdenivået i lommebokhierarkiet, dvs. på `xpub`-nivået.

![BTC204](assets/it/54/08.webp)

En HD-lommebok kan teoretisk sett utlede opptil `2^(32/2)` forskjellige kontoer. Den første kontoen, som brukes som standard på alle Bitcoin-lommebøker, tilsvarer indeksen `0'.

For porteføljer tilpasset Whirlpool brukes 4 kontoer for å oppfylle kravene i ZeroLink-prosessen:


- **innskuddskontoen**, identifisert med indeksen `0`;
- Den **dårlige bankkontoen** (eller "giftige børsen"), identifisert med indeksen `2 147 483 644`;
- **premix-kontoen**, identifisert med indeksen "2 147 483 645";
- **postmix-kontoen**, identifisert med indeksen "2 147 483 646".

Hver av disse kontoene har en spesifikk funksjon i coinjoin-prosessen, som vi skal se nærmere på i de neste avsnittene.

Alle disse kontoene er knyttet til et enkelt frø, slik at brukeren kan gjenopprette tilgangen til alle sine bitcoins ved hjelp av gjenopprettingsfrasen og, om nødvendig, passordfrasen. Det er imidlertid nødvendig å spesifisere de forskjellige indeksene til kontoene som har blitt brukt, til programvaren under denne gjenopprettingsoperasjonen.

La oss nå se nærmere på de ulike stadiene av en Whirlpool coinjoin i disse regnskapene.

### TX0

Utgangspunktet for enhver Whirlpool coinjoin er **deposit-kontoen**. Denne kontoen er det du automatisk bruker når du oppretter en ny bitcoin-lommebok. Denne kontoen må krediteres med bitcoinsene du ønsker å blande.

Tx0 er det første trinnet i Whirlpool-blandingsprosessen. Formålet er å klargjøre og utjevne UTXO-ene for coinjoin ved å dele dem inn i enheter som tilsvarer mengden av det valgte bassenget, for å sikre en homogen blanding. De utjevnede UTXO-ene sendes deretter til **premix-kontoen**. Når det gjelder differansen som ikke kan komme inn i bassenget, skilles den ut på en spesifikk konto: **bad bank** (eller "toxic exchange").

Denne første Tx0-transaksjonen tjener også til å betale serviceavgiftene til coinjoin-koordinatoren. I motsetning til de påfølgende trinnene er ikke denne transaksjonen samarbeidsbasert, og brukeren må derfor bære hele kostnaden for utvinningsgebyrene:

![BTC204](assets/it/54/09.webp)

I dette eksemplet på en `Tx0`-transaksjon blir en input på `372 000 sats` fra vår **innskuddskonto** delt inn i flere UTXOer med output, som fordeles på følgende måte:


- Et beløp på 5 000 sats` allokert til koordinatoren for servicehonorar, tilsvarende inngangen til poolen på 100 000 sats`;
- 3 UTXOer klargjort for miksing, omdirigert til vår **premix-konto** og registrert hos koordinatoren. Disse UTXO-ene er utlignet til 108 000 sats hver, for å dekke utvinningsavgiftene for den fremtidige første blandingen;
- Overskuddet som ikke kan gå inn i bassenget, fordi det er for lite, regnes som giftig valuta. Det sendes til den spesifikke kontoen. Her utgjør denne utvekslingen 40 000 sats;
- Til slutt er det "3000 sats" som ikke utgjør produksjon, men som er gruveavgiftene som kreves for å bekrefte "Tx0".

Her er for eksempel en ekte Tx0 Whirlpool (ikke min):[edef60744f539483d868caff49d4848e5cc6e805d6cdc8d0f9bdbbaedcb5fc46](https://mempool.space/fr/tx/edef60744f539483d868caff49d4848e5cc6e805d6cdc8d0f9bdbbaedcb5fc46)

![BTC204](assets/fr/145.webp)

### Den giftige forandringen

Det overskytende som ikke kunne integreres i poolen, her tilsvarende 40 000 sats, omdirigeres til kontoen **bad bank**, også kalt "toxic exchange", for å sikre streng separasjon fra andre UTXOer i porteføljen.

Denne UTXO-en er farlig for brukernes personvern, ikke bare fordi den fortsatt er knyttet til brukerens fortid, og dermed muligens til eierens identitet, men den er også merket som tilhørende en bruker som har deltatt i en coinjoin.

![BTC204](assets/fr/146.webp)

Hvis denne UTXO-en slås sammen med blandede utganger, vil de miste alt personvernet de har oppnådd under coinjoin-sykluser, noe som i stor grad skyldes CIOH (_Common-Input-Ownership-Heuristic_). Hvis den slås sammen med andre giftige endringer, risikerer brukeren å miste personvernet siden dette vil koble sammen de ulike inndataene fra coinjoin-sykluser. Derfor bør det håndteres med forsiktighet. Vi vil diskutere håndteringen av disse giftige UTXO-ene nærmere i siste del av dette kapittelet.

### Den innledende miksen

Etter at `Tx0` er fullført, sendes de utlignede UTXO-ene til **premix**-kontoen i porteføljen vår, klare til å bli introdusert i sin første coinjoin-syklus, også kalt "initial mix" Hvis `Tx0`, som i vårt eksempel, genererer flere UTXO-er som skal mikses, vil hver av dem bli integrert i en egen initial miks.

På slutten av disse første blandingene vil **premix**-kontoen være tom, mens myntene våre, etter å ha betalt gruveavgiftene for denne første mynttilkoblingen, vil bli avgjort til nøyaktig det beløpet som er definert av det valgte bassenget. I vårt eksempel vil våre opprinnelige UTXO-er på 108 000 sats ha blitt redusert til nøyaktig 100 000 sats.

![BTC204](assets/fr/147.webp)

### Remixene

Etter den første miksen overføres UTXO-ene til **postmix**-kontoen. Denne kontoen samler både UTXO-er som allerede har blitt mikset, og UTXO-er som venter på remiksing. Når Whirlpool-klienten er aktiv, er UTXO-ene på **postmix**-kontoen automatisk tilgjengelige for remiksing, og de blir tilfeldig valgt ut til å delta i de nye rundene.

Som en påminnelse er remixer da helt gratis: ingen ekstra serviceavgifter eller utvinningsavgifter er påkrevd. Ved å beholde UTXO-er på **postmix**-kontoen holder du dermed verdien intakt og forbedrer samtidig anonsettene deres. Det er derfor det er viktig å la disse myntene delta i flere coinjoin-sykluser. Det koster deg absolutt ingenting og øker anonset-nivåene deres.

Når du bestemmer deg for å bruke blandede UTXO-er, kan du gjøre det direkte fra denne **postmix**-kontoen. Det anbefales å oppbevare blandede UTXO-er på denne kontoen for å dra nytte av gratis remikser og for å forhindre at de forlater Whirlpool-kretsen, noe som kan redusere personvernet deres.

### Hvordan administrere postmix-kontoen din på riktig måte?

Etter at du har kjørt coinjoin-sykluser, er den beste strategien å beholde UTXO-ene dine på **postmix**-kontoen i påvente av fremtidig bruk. Det er til og med tilrådelig å la dem remixes på ubestemt tid til du trenger å bruke dem.

Noen brukere kan vurdere å overføre sine blandede bitcoins til en beskyttet maskinvarelommebok. Dette er mulig, men det er viktig å følge Samourai Wallet's anbefalinger nøye for ikke å kompromittere konfidensialiteten som oppnås.

Å kombinere UTXO-er er den vanligste feilen som gjøres. Du må unngå å kombinere blandede UTXO-er med ublandede UTXO-er i samme transaksjon for å unngå CIOH-heuristikk (Common-Input-Ownership). Dette krever nøye styring av UTXO-er i porteføljen, spesielt når det gjelder merking.

![BTC204](assets/fr/148.webp)

Det er også viktig å være forsiktig med å slå sammen blandede UTXO-er. Moderate konsolideringer kan tenkes hvis de blandede UTXO-ene har betydelige anonsett, men dette vil uunngåelig redusere konfidensialiteten til myntene dine. Sørg for at konsolideringene ikke er for omfattende eller utføres etter et utilstrekkelig antall remikser, med risiko for at det etableres avledede koblinger mellom UTXO-ene dine før og etter coinjoin-sykluser. Hvis du er i tvil om disse manipulasjonene, er den beste praksisen å ikke konsolidere UTXO-er etter blanding, og overføre dem én etter én til maskinvarelommeboken din, og generere en ny tom adresse hver gang. Husk likevel å merke hver UTXO som mottas på riktig måte.

Det anbefales heller ikke å overføre UTXO-postmixene dine til en lommebok som bruker uvanlige skript. Hvis du for eksempel går inn i Whirlpool fra en multisig-lommebok som bruker `P2WSH`-skript, er det en liten sjanse for at du vil bli blandet med andre brukere som opprinnelig har samme type lommebok. Hvis du tar ut postmixene dine i den samme multisig-lommeboken, vil personvernet til de blandede bitcoinsene dine bli sterkt redusert. I tillegg til skript finnes det mange andre lommebokfingeravtrykk som kan lure deg.

Som med alle Bitcoin-transaksjoner er det også viktig å ikke gjenbruke mottaksadresser. Hver nye transaksjon bør mottas på en ny, tom adresse.

Den enkleste og tryggeste løsningen er å la de blandede UTXO-ene hvile på **postmix**-kontoen, slik at de kan remixes og kun brukes når de skal brukes. Samourai- og Sparrow-porteføljene har ekstra beskyttelse mot alle disse risikoene ved kjedeanalyse. Denne beskyttelsen hjelper deg med å unngå å gjøre feil.

### Hvordan håndtere giftige endringer på riktig måte?

Deretter må du være forsiktig når du håndterer de giftige vekslepengene dine, vekslepengene som ikke kunne inngå i coinjoin-poolen. Disse giftige UTXO-ene, som stammer fra Whirlpool-bruk, utgjør en risiko for personvernet ditt fordi de etablerer en kobling mellom deg og bruken av coinjoin. Derfor er det viktig å håndtere dem med forsiktighet og ikke kombinere dem med andre UTXO-er, spesielt ikke blandede UTXO-er.

Her er flere strategier du kan vurdere for å bruke dem:


- Bland dem i mindre bassenger:** Hvis den giftige UTXO-en din er stor nok til å få plass alene i et mindre basseng, bør du vurdere å blande den. Dette er ofte det beste alternativet. Det anbefales imidlertid ikke å blande flere giftige UTXO-er sammen for å få tilgang til et basseng, da dette kan koble sammen de ulike inngangene.
- Merk dem som "ikke brukbare":** En annen måte å gjøre det på er å slutte å bruke dem, merke dem som "ikke brukbare" på den dedikerte kontoen deres og rett og slett hodle dem. Dette sikrer at du ikke bruker dem ved et uhell. Hvis verdien av bitcoin øker, kan det dukke opp nye bassenger som passer bedre for dine giftige UTXO-er;
- Donasjoner:** Vurder å gi donasjoner, selv beskjedne, til utviklere som jobber med Bitcoin og tilhørende programvare. Du kan også donere til organisasjoner som aksepterer BTC. Hvis det virker for komplisert å administrere giftige UTXO-er, kan du ganske enkelt kvitte deg med dem ved å gi en donasjon.
- Kjøp gavekort:** Plattformer som [Bitrefill] (https://www.bitrefill.com/) lar deg veksle bitcoins til gavekort som kan brukes hos ulike forhandlere. Dette kan være en måte å kvitte seg med giftige UTXO-er på uten å miste den tilhørende verdien.
- Konsolider dem til Monero:** Samourai Wallet tilbyr en atombyttetjeneste mellom BTC og XMR. Dette er ideelt for å håndtere giftige UTXO-er ved å konsolidere dem på Monero, uten å kompromittere personvernet ditt via KYC, før du sender dem tilbake til Bitcoin. Dette alternativet kan imidlertid være dyrt når det gjelder gruveavgifter og premier på grunn av likviditetsbegrensninger.
- Send dem til Lightning Network:** Det er et attraktivt alternativ å overføre disse UTXO-ene til Lightning Network for å dra nytte av reduserte transaksjonsgebyrer. Denne metoden kan imidlertid avsløre en del informasjon avhengig av hvordan du bruker Lightning, og bør derfor brukes med forsiktighet.

### Hvordan bruke Whirlpool?

Etter arrestasjonen av grunnleggerne av Samourai Wallet og beslagleggelsen av serverne deres 24. april 2024, fungerer ikke Whirlpool-verktøyet lenger, selv ikke for de som har sin egen Dojo. Tidligere var det tilgjengelig på Samourai Wallet og Sparrow Wallet.

![BTC204](assets/fr/149.webp)

Det er imidlertid fortsatt mulig at dette instrumentet kan bli tatt i bruk igjen i løpet av de kommende ukene, avhengig av utfallet av forsøkene, eller relanseres på en annen måte. I alle fall tror jeg at coinjoin-markedet på Bitcoin ikke vil forbli uten tilbud lenge, ettersom det er en klar etterspørsel. Dessuten vil Whirlpool-modellen, som er den mest avanserte når det gjelder personvern, helt sikkert bli brukt til andre implementeringer i fremtiden.

Vi følger nøye med på utviklingen i denne saken og utviklingen når det gjelder tilhørende verktøy. Du kan være trygg på at vi vil oppdatere denne opplæringen etter hvert som ny informasjon blir tilgjengelig.

I neste kapittel skal vi finne ut hva "anonsets" er, hvordan disse indikatorene beregnes, og hvordan de kan hjelpe oss med å estimere effektiviteten av coinjoin-sykluser.

https://planb.network/tutorials/privacy/on-chain/coinjoin-sparrow-wallet-84def86d-faf5-4589-807a-83be60720c8b
https://planb.network/tutorials/privacy/on-chain/coinjoin-samourai-wallet-e566803d-ab3f-4d98-9136-5462009262ef
https://planb.network/tutorials/privacy/on-chain/coinjoin-dojo-c4b20263-5b30-4c74-ae59-dc8d0f8715c2
## Anonymitetssett

<chapterId>be1093dc-1a74-40e5-9545-2b97a7d7d431</chapterId>

Etter å ha studert hvordan coinjoins fungerer og utfordringene knyttet til effektiv blanding, skal vi nå lære hvordan vi kan måle denne effektiviteten. Hvordan kan man avgjøre om en coinjoin-prosess var effektiv, og hvilken grad av anonymitet en mynt oppnådde? Det er dette vi skal utforske i dette kapittelet med anonymitetssett, eller "anonsett" på engelsk.

### Påminnelse om nytten av Coinjoin

Nytten av CoinJoin ligger i dens evne til å skape plausibel fornektelse ved å dyppe mynten din i en gruppe av mynter som ikke kan skilles fra hverandre. Målet med denne handlingen er å bryte sporbarhetskoblinger, både fra fortid til nåtid og fra nåtid til fortid.

Med andre ord, en analytiker som kjenner din opprinnelige transaksjon (`Tx0`) ved inngangen til CoinJoin-sykluser, bør ikke være i stand til å identifisere UTXO med sikkerhet ved utgangen av remix-sykluser (analyse fra inngang til syklus til utgang fra syklus).

![BTC204](assets/it/55/01.webp)

En analytiker som kjenner UTXO-en din ved utgangen av CoinJoin-syklusene, vil derimot ikke kunne fastslå den opprinnelige transaksjonen ved inngangen av syklusene (analyse fra syklusutgang til syklusinngang).

![BTC204](assets/it/55/02.webp)

For å vurdere hvor vanskelig det er for en analytiker å knytte fortiden til nåtiden og omvendt, er det nødvendig å kvantifisere størrelsen på de homogene myntgruppene som mynten din er skjult innenfor. Dette målet forteller oss hvor mange analyser som har identisk sannsynlighet. Hvis den riktige analysen drukner blant tre andre analyser med lik sannsynlighet, er skjulingsgraden svært lav. Men hvis den riktige analysen befinner seg i et sett med 20 000 analyser som alle er like sannsynlige, er mynten din svært godt skjult. Og nettopp størrelsen på disse settene representerer indikatorer som kalles anonsett.

### Forstå Anonsets

Anonsett fungerer som indikatorer for å vurdere graden av personvern for en bestemt UTXO. Mer spesifikt måler de antallet UTXOer som ikke kan skilles fra hverandre i settet som inkluderer mynten som studeres. Kravet om et homogent UTXO-sett betyr at anonsets vanligvis beregnes på CoinJoin-sykluser. Bruken av disse indikatorene er spesielt relevant for Whirlpool CoinJoins på grunn av deres ensartethet.

Anonsets gjør det mulig å bedømme kvaliteten på CoinJoins når det er hensiktsmessig. En stor anonset-størrelse betyr en høy grad av anonymitet, ettersom det blir vanskelig å skille ut en bestemt UTXO i det homogene settet.

Det finnes to typer anonsett:


- Den potensielle anonset;**
- Den retrospektive anonset.**

### Det potensielle anonset

Den fremtidsrettede anonset indikerer størrelsen på gruppen som den studerte UTXO-en er skjult i ved syklusutgangen, når man kjenner UTXO-en ved inngangen, det vil si antallet mynter som ikke kan skilles fra hverandre i denne gruppen. På engelsk er navnet på denne indikatoren "forward anonset" eller "forward-looking metrics"

Denne indikatoren gir et mål på valutaens motstand mot personvern i en fortid-til-nåtid-analyse (input til output).

![BTC204](assets/it/55/03.webp)

Denne beregningen anslår i hvilken grad UTXO-en er beskyttet mot forsøk på å rekonstruere historikken fra inngangspunktet til utgangspunktet i coinjoin-prosessen.

Hvis transaksjonen din for eksempel deltok i den første coinjoin-syklusen og ytterligere to synkende sykluser ble fullført, vil den potensielle anonset for mynten din være `13`:

![BTC204](assets/fr/153.webp)

La oss for eksempel tenke oss at mynten vår ved inngangen til coinjoin-syklusen drar nytte av en potensiell anonset på `86 871`. I praksis betyr dette at den er skjult blant `86 871` mynter som ikke kan skilles fra hverandre. For en utenforstående observatør som er klar over denne mynten i begynnelsen av møntsyklusen og forsøker å spore dens utgang, vil han stå overfor `86 871` mulige UTXO-er, hver med identisk sannsynlighet for å være den mynten vi leter etter.

![BTC204](assets/it/55/05.webp)

### Den retrospektive anonset

Retrospektiv anonset indikerer antall mulige kilder for en gitt mynt, med kjennskap til UTXO ved syklusavslutning. Denne indikatoren måler myntens personvernmotstand mot en nåtid-til-fortid-analyse (exit to entry), det vil si hvor vanskelig det er for en analytiker å spore opprinnelsen til mynten din, før myntsykluser. På engelsk heter denne indikatoren "backward anonset", eller "retrospective metrics"

Ved å kjenne UTXO ved utgangen av syklusene, bestemmer den retrospektive anonset antallet potensielle Tx0-transaksjoner som kunne ha utgjort din inngang i coinjoin-syklusene. I diagrammet nedenfor tilsvarer dette summen av alle de oransje boblene.

La oss for eksempel tenke oss at mynten vår ved utgangen av coinjoin-syklusen drar nytte av en retrospektiv anonset på `42,185`. I praksis betyr dette at det finnes `42 185` mulige kilder til denne UTXO-en. Hvis en utenforstående observatør identifiserer denne mynten ved slutten av syklusene og prøver å spore dens opprinnelse, vil han stå overfor `42 185` mulige kilder, alle med like stor sannsynlighet for å være opprinnelsen som søkes.

### Hvordan beregne anonsets konkret?

Du kan beregne anonsettene manuelt ved hjelp av en blokkutforsker for små sett. For større anonsett er det imidlertid nødvendig å bruke et spesialisert verktøy. Så vidt jeg vet, er den eneste programvaren som kan utføre denne oppgaven _Whirlpool Stats Tool_, et Python-verktøy utviklet av Samourai- og OXT-teamene. Dessverre er dette verktøyet for øyeblikket ute av drift etter arrestasjonen av grunnleggerne av Samourai og oppsigelsen av OXT, som ble brukt til å hente ut data fra blokkjeden.

Som vi har sett i dette kapittelet, kan anonsets bare beregnes hvis det er en viss homogenitet i coinjoin-strukturen. I neste kapittel skal vi finne ut hvordan vi kan kvantifisere denne homogeniteten i en Bitcoin-transaksjon, enten det er en coinjoin eller en mer tradisjonell transaksjon.

https://planb.network/tutorials/privacy/analysis/wst-anonsets-0354b793-c301-48af-af75-f87569756375
## Entropi

<chapterId>e4fe289d-618b-49a2-84c9-68c562e708b4</chapterId>

Som vi har sett i denne delen om coinjoins, spiller homogeniteten til UTXO-er i inn- og utganger en viktig rolle i å forbedre konfidensialiteten til en Bitcoin-transaksjon. Denne parameteren gjør det mulig å nekte plausibelt mot kjedeanalyse. Flere metoder kan måle denne homogeniteten, men en av de mest effektive, etter min mening, er bruken av indikatorer levert av _Boltzmann_-verktøyet, utviklet av OXT- og Samourai Wallet-teamene, spesielt transaksjonsentropi. Det er dette vi vil studere i detalj i dette kapittelet.

I motsetning til anonsets, som beregnes på et sett med transaksjoner, fokuserer indikatorene vi presenterer her utelukkende på én enkelt transaksjon, enten det er en coinjoin eller en mer tradisjonell transaksjon.

### Antall tolkninger

Den første indikatoren som kan observeres i en Bitcoin-transaksjon, er det totale antallet mulige tolkninger sett med øynene til en utenforstående observatør som analyserer transaksjonen. Ved å ta hensyn til verdiene til UTXO-ene som er involvert i transaksjonen, indikerer denne indikatoren antall måter innganger kan knyttes til utganger på. Med andre ord bestemmer den antallet mulige tolkninger som en transaksjon kan generere i bitcoin-strømmen sett fra perspektivet til en utenforstående observatør som analyserer den.

For eksempel vil en enkel betalingstransaksjon med 1 inngang og 2 utganger bare ha én tolkning, nemlig at inngang #0 finansierte utgang #0 og utgang #1. Det finnes ingen andre mulige tolkninger:

![BTC204](assets/fr/159.webp)

En coinjoin strukturert i henhold til Whirlpool 5x5-modellen har derimot 1496 mulige kombinasjoner:

![BTC204](assets/fr/160.webp)

En Whirlpool Surge Cycle 8x8 coinjoin kommer opp med $ 9 934 563 mulige tolkninger:

![BTC204](assets/fr/161.webp)

### Entropi

Ut fra antall tolkninger av en Bitcoin-transaksjon kan vi beregne dens entropi.

I en generell sammenheng med kryptografi og informasjon er entropi et kvantitativt mål på usikkerheten eller uforutsigbarheten knyttet til en datakilde eller tilfeldig prosess. Med andre ord er entropi en måte å måle hvor vanskelig det er å forutsi eller gjette informasjon på.

I kjedeanalysesammenheng er entropi også navnet på en indikator, avledet fra Shannons entropi og [oppfunnet av LaurentMT] (https://gist.github.com/LaurentMT/e758767ca4038ac40aaf), som kan beregnes på en Bitcoin-transaksjon.

Når en transaksjon har et høyt antall mulige tolkninger, er det ofte mer relevant å referere til dens entropi. Denne indikatoren gir et mål på analytikernes mangel på kunnskap om den nøyaktige konfigurasjonen av transaksjonen. Med andre ord, jo høyere entropi, desto vanskeligere blir det for analytikere å identifisere bitcoinstrømmer mellom inn- og utganger.

I praksis avslører entropien om en transaksjon, sett fra en utenforstående observatørs perspektiv, har flere mulige tolkninger, utelukkende basert på inn- og utdatastørrelser, uten å ta hensyn til andre eksterne eller interne mønstre og heuristikker. Høy entropi er dermed ensbetydende med høyere konfidensialitet for transaksjonen.

Entropi defineres som den binære logaritmen av antall mulige kombinasjoner. Her er formelen som brukes, der $E$ representerer entropien til transaksjonen og $C$ antall mulige tolkninger:

$$
E = \log_2(C)
$$

I matematikken tilsvarer den binære logaritmen (logaritmen til base 2) den inverse operasjonen av å opphøye 2 til en bestemt potens. Med andre ord er den binære logaritmen til $x$ eksponenten som $2$ må heves til for å oppnå $x$. Denne indikatoren uttrykkes altså i bits.

Ta eksempelet med entropiberegningen for en coinjoin-transaksjon strukturert i henhold til 5x5 Whirlpool-modellen, som, som nevnt i forrige avsnitt, har et antall mulige tolkninger på 1 496 dollar:

$$
\begin{align*}
C &= 1.496 \\
E &= \log_2(1.496) \\
E &= 10.5469 \text{ bit}
\end{align*}
$$

Denne coinjoin-transaksjonen har dermed en entropi på $10,5469$ bits, noe som anses som svært tilfredsstillende. Jo høyere denne verdien er, desto flere ulike tolkninger kan transaksjonen tillate, noe som forbedrer personvernet.

For en 8x8 coinjoin-transaksjon som har tolkninger på 9 934 563 dollar, vil entropien være

$$
\begin{align*}
C &= 9.934.563 \\
E &= \log_2(9.934.563) \\
E &= 23,244 \text{ bit}
\end{align*}
$$

La oss ta et annet eksempel med en standard betalingstransaksjon, med 1 inngang og 2 utganger: [1b1b0c3f0883a99f1161c64da19471841ed12a1f78e77fab128c69a5f578ccce](https://mempool.space/tx/1b1b0c3f0883a99f1161c64da19471841ed12a1f78e77fab128c69a5f578ccce)

![BTC204](assets/fr/162.webp)

I tilfellet med denne transaksjonen er den eneste mulige tolkningen: `(In.0) > (Out.0 ; Out.1)`. Følgelig er entropien satt til $0$:

$$
\begin{align*}
C &= 1 \\
E &= \log_2(1) \\
E &= 0 \text{ bit}
\end{align*}
$$

### Effektivitet

Ut fra entropien til transaksjonen kan vi også beregne dens personverneffektivitet. Denne indikatoren evaluerer effektiviteten til transaksjonen ved å sammenligne den med den optimale transaksjonen som kan tenkes i en identisk konfigurasjon.

Dette leder oss til å diskutere begrepet maksimal entropi, som tilsvarer den høyeste entropien som en bestemt transaksjonsstruktur teoretisk sett kan oppnå. Transaksjonens effektivitet beregnes deretter ved å sammenligne denne maksimale entropien med den faktiske entropien til den analyserte transaksjonen.

Formelen som brukes er som følger med:


- $E_R$: transaksjonens faktiske entropi uttrykt i bits;
- $E_M$: den maksimale mulige entropien for en transaksjonsstruktur, også uttrykt i bits;
- $Ef$: effektiviteten til transaksjonen i bits:

$$
Ef = E_R - E_M
$$

For eksempel er den maksimale entropien for en coinjoin-struktur av typen Whirlpool 5x5 $10,5469$:

$$
\begin{align*}
E_R &= 10,5469 \\
E_M &= 10,5469 \\
Ef &= E_R - E_M \\
Ef &= 10,5469 - 10,5469 \\
Ef &= 0 \text{ bit}
\end{align*}
$$

Denne indikatoren uttrykkes også i prosent. Formelen som brukes er som følger med:


- $C_R$: antall mulige reelle tolkninger;
- $C_M$: det maksimale antallet mulige tolkninger med samme struktur;
- $Ef$: effektivitet uttrykt i prosent:

$$
\begin{align*}
E_f &= \frac{C_R}{C_M} \\
E_f &= \frac{1.496}{1.496} \\
E_f &= 100\%
\end{align*}
$$

En effektivitet på $100\%$ indikerer dermed at transaksjonen maksimerer potensialet for personvern basert på dens struktur.

### Entropitetthet

Entropi er en god indikator for å måle personvernet i en transaksjon, men den avhenger delvis av antall innganger og utganger i transaksjonen. For å sammenligne entropien til to ulike transaksjoner som ikke har samme antall inn- og utdata, kan man beregne entropitettheten. Denne indikatoren gir et perspektiv på entropien i forhold til hver inngang eller utgang i transaksjonen. Tettheten er nyttig når man skal evaluere og sammenligne effektiviteten til transaksjoner av ulik størrelse.

For å beregne den, dividerer du ganske enkelt transaksjonens totale entropi med det totale antallet inn- og utganger som er involvert i transaksjonen:


- $E_D$: entropitettheten uttrykt i bits;
- $E$: entropien til transaksjonen uttrykt i bits;
- $T$: det totale antallet innganger og utganger i transaksjonen:

$$
E_D = \frac{E}{T}
$$

Ta eksemplet med en 5x5 Whirlpool coinjoin:

$$
\begin{align*}
T &= 5 + 5 = 10 \\
E &= 10.5469 \\
E_D &= \frac{E}{T} \\
E_D &= \frac{10.5469}{10} \\
E_D &= 1.054 \text{ bit}
\end{align*}
$$

Vi beregner også entropitettheten til en 8x8 Whirlpool coinjoin:

$$
\begin{align*}
T &= 8 + 8 = 16 \\
E &= 23.244 \\
E_D &= \frac{E}{T} \\
E_D &= \frac{23.244}{16} \\
E_D &= 1.453 \text{ bit}
\end{align*}
$$

Ved å analysere entropitettheten til disse to typene sammenføyninger blir det tydelig at selv når entropien normaliseres for antall elementer, genererer "Surge Cycle 8x8"-samføyningen mer usikkerhet for analysen.

### Boltzmann-poengsummen

En annen del av informasjonen som analyseres i en transaksjon, er Boltzmann-poengsummen for hvert element i forhold til et annet. Dette er en tabell over sannsynligheten for samsvar mellom inndata og utdata. Gjennom Boltzmann-poengsummen angir denne tabellen den betingede sannsynligheten for at en bestemt input er relatert til en gitt output. Det er altså et kvantitativt mål på den betingede sannsynligheten for at en sammenheng mellom en inngang og en utgang i en transaksjon vil inntreffe, bestemt ut fra forholdet mellom antall gunstige forekomster av denne hendelsen og det totale antallet mulige forekomster i et sett med tolkninger.

Hvis vi tar eksemplet med en Whirlpool coinjoin, vil den betingede sannsynlighetstabellen fremheve mulighetene for en kobling mellom hver inngang og utgang, noe som gir et kvantitativt mål på tvetydigheten i assosiasjonene i transaksjonen:



| ------- | -------- | -------- | -------- | -------- | -------- |

Her er det tydelig at hver input har samme sannsynlighet for å bli assosiert med en hvilken som helst output, noe som øker transaksjonens konfidensialitet.

Boltzmann-poengsummen beregnes ved å dividere antallet tolkninger der en bestemt hendelse forekommer, med det totale antallet tilgjengelige tolkninger. For å bestemme poengsummen ved å knytte inndata #0 til utdata #3 (en hendelse som forekommer i 512$ tolkninger), er prosessen som følger:

$$
\begin{align*}
\text{Interpretazioni (IN.0 > OUT.3)} &= 512 \\
\text{Interpretazioni Totali} &= 1496 \\
\text{Punteggio} &= \frac{512}{1496} \\
\text{Punteggio} &= 34\%
\end{align*}
$$

Hvis vi ser på eksemplet med en Surge 8x8 Whirlpool coinjoin-syklus, vil Boltzmann-tabellen se slik ut:

| UT.0 | UT.1 | UT.2 | UT.3 | UT.4 | UT.5 | UT.6 | UT.7 | UT.7 | | UT.6 | UT.7

| ---- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |

| IN.0 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| IN.1 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| IN.2 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| IN.3 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| IN.4 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| IN.5 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| IN.6 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| IN.7 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

Når det gjelder en enkel transaksjon med én inngang og to utganger, er situasjonen imidlertid en annen:



| ------- | -------- | -------- |

| Input 0 | 100 % | 100 % | 100 % | 100

Her ser vi at sannsynligheten for at hver utgang kommer fra inngang nr. 0 er 100 %. En lavere sannsynlighet gir dermed større personvern ved at de direkte koblingene mellom inndata og utdata utvannes.

### Deterministiske koblinger

Det er også mulig å beregne antall deterministiske koblinger i en transaksjon. Denne indikatoren viser hvor mange koblinger mellom inn- og utdata i den analyserte transaksjonen som med 100 % sannsynlighet er ubestridelige. Denne indikatoren kan deretter kompletteres ved å beregne forholdet mellom deterministiske koblinger. Forholdstallet gir et perspektiv på vekten av disse deterministiske koblingene i forhold til alle koblingene i transaksjonen.

For eksempel viser en Whirlpool coinjoin-transaksjon ingen deterministiske koblinger mellom inn- og utdata, og indikatoren viser dermed 0 koblinger og et forholdstall på 0 %. I den andre enkle betalingstransaksjonen vi har undersøkt (med én inngang og to utganger), viser indikatoren derimot at det er to deterministiske koblinger, og forholdstallet når 100 %. En nullindikator signaliserer altså utmerket personvern på grunn av fraværet av direkte og udiskutable forbindelser mellom inn- og utdata.

### Hvordan beregner man disse indikatorene?

Det er relativt enkelt å beregne disse indikatorene manuelt ved hjelp av ligningene jeg har oppgitt. Hovedproblemet ligger i å bestemme antall mulige tolkninger av en transaksjon. For en standardtransaksjon kan denne beregningen gjøres for hånd. For en coinjoin er oppgaven imidlertid betydelig mer kompleks.

Tidligere fantes det et Python-verktøy kalt _Boltzmann Calculator_, utviklet av teamene hos OXT og Samourai, som gjorde det mulig å beregne alle disse indikatorene automatisk for en Bitcoin-transaksjon:

![BTC204](assets/fr/163.webp)

Det var også mulig å bruke nettstedet KYCP.org til disse analysene:

![BTC204](assets/fr/164.webp)

Etter at Samourais grunnleggere ble arrestert, er disse verktøyene dessverre ikke operative for øyeblikket.

Nå som vi har diskutert coinjoins i detalj, vil vi utforske andre personvernteknikker som er tilgjengelige på Bitcoin i den siste delen av opplæringen vår. Vi skal se nærmere på payjoin-transaksjoner, spesifikke pseudocoinjoin-transaksjonstyper, statiske adresseprotokoller, samt tiltak for å forbedre personvernet ikke på transaksjonsnivå, men på nettverksnivå for noder.

https://planb.network/tutorials/privacy/analysis/boltzmann-entropy-738e45af-18a6-4ce6-af1a-1bf58e15f1fe
# Forstå hva som står på spill med andre avanserte personvernteknikker

<partId>19989ae6-d608-4acf-b698-2cf1e7e5e6ae</partId>

## Payjoin-transaksjoner

<chapterId>c1e90b95-f709-4574-837b-2ec26b11286f</chapterId>

For øyeblikket er coinjoin den mest effektive metoden for å innføre usikkerhet i myntsporing under en kjedeanalyse. Som vi har sett i tidligere kapitler, må inn- og utdataene være så homogene som mulig for å oppnå effektiv miksing. I tillegg er det avgjørende at coinjoins integreres i en så stor gruppe som mulig for å maksimere anonsets. For at coinjoins skal være effektive, må de derfor involvere et stort antall ensartede mynter. Dette mangfoldet av krav betyr at coinjoin-transaksjoner har en svært rigid struktur: Beløpene er forhåndsbestemt, og alle deltakerne må holde seg til dem for å sikre en enhetlig prosess. I tillegg krever coinjoins synkronisering mellom alle deltakerne og koordinatoren under oppbyggingen av transaksjonen.

Disse kravene gjør coinjoin uegnet for direkte betalinger. Hvis du for eksempel eier en 1 million sats i en coinjoin-pool, vil det være komplisert å bruke den direkte som betaling. Det ville kreve synkronisering med andre deltakere og koordinatoren for å bygge samarbeidstransaksjonen akkurat på det tidspunktet du trenger å foreta en betaling, og kjøpsbeløpet ville måtte samsvare nøyaktig med verdien på brikken din, noe som er praktisk umulig. Derfor er en coinjoin-transaksjon av natur en samarbeidende oppryddingstransaksjon, noe som betyr at det generelt er de samme eierne av inndataene som er i utdataene.

Det ville imidlertid være interessant å ha transaksjonsstrukturer som muliggjør praktiske betalinger ved å introdusere tvil i kjedeanalysen. Det er nettopp dette vi skal utforske i dette og neste kapittel.

### Hva er en payjoin-transaksjon?

Payjoin er en spesifikk Bitcoin-transaksjonsstruktur som forbedrer brukerens personvern under en betaling ved å samarbeide med betalingsmottakeren.

I 2015 nevnte LaurentMT først denne metoden under navnet "steganografiske transaksjoner", ifølge et tilgjengelig papir [her] (https://gist.githubusercontent.com/LaurentMT/e758767ca4038ac40aaf/raw/c8125f6a3c3d0e90246dc96d3b603690ab6f1dcc/gistfile1.txt). Denne teknikken ble senere tatt i bruk av Samourai Wallet, som i 2018 var den første klienten som implementerte den med Stowaway-verktøyet. Konseptet payjoin finnes også i [BIP79](https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki) og [BIP78](https://github.com/bitcoin/bips/blob/master/bip-0078.mediawiki). Det brukes altså flere begreper for å betegne en payjoin:


- Payjoin;
- Blindpassasjer;
- P2EP (_Pay-to-End-Point_);
- Steganografisk transaksjon.

Det unike med payjoin er at den kan generere en transaksjon som ved første øyekast ser helt vanlig ut, men som i virkeligheten er en mini Coinjoin mellom to personer. Transaksjonen er strukturert slik at mottakeren av betalingen inngår i inndataene sammen med den faktiske avsenderen. Mottakeren inkluderer deretter en betaling til seg selv midt i transaksjonen som gjør at han kan få betalt.

La oss ta et eksempel for å forstå denne prosessen bedre. Alice kjøper en baguette for 4 000 satser ved hjelp av en UTXO på 10 000 satser og velger en payjoin. Bakeren hennes, Bob, legger til en UTXO på 15 000 sats i input, som han får tilbake i sin helhet i output, i tillegg til Alices 4 000 sats.

I eksempelet går Bob, bakeren, inn med 15 000 sats og kommer ut med 19 000 sats, og differansen er nøyaktig 4 000 sats, som er prisen på baguetten. Alice på sin side går inn med 10 000 sats og ender opp med 6 000 sats, noe som gir en saldo på -4 000 sats, som er prisen på baguetten. For å forenkle eksemplet har jeg bevisst utelatt gruveavgiftene i denne transaksjonen.

### Hva er hensikten med payjoin?

Payjoin-transaksjonen oppfyller to mål som gjør det mulig for brukerne å forbedre personvernet i forbindelse med betalingen.

For det første har payjoin som mål å lure en utenforstående observatør ved å skape en avledning i kjedeanalysen. Dette gjøres mulig gjennom _Common Input Ownership Heuristic_ (CIOH). Som vi så i del 3, antas det vanligvis at når en transaksjon i blokkjeden har flere innganger, tilhører alle disse inngangene samme enhet eller bruker.

Når en analytiker undersøker en payjoin-transaksjon, forledes han eller hun til å tro at alle inndataene kommer fra samme person. Denne oppfatningen er imidlertid feil, siden betalingsmottakeren også bidrar med input sammen med den faktiske betaleren. Kjedeanalysen blir dermed vridd i retning av en tolkning som viser seg å være feil.

La oss gå tilbake til eksempelet med en payjoin-transaksjon for å betale for en baguette:

En utenforstående observatør som ser denne transaksjonen i blokkjeden og følger de vanlige heuristikkene for kjedeanalyse, vil tolke den slik: "Alice ble med på 2 UTXO-er i transaksjonsinput for å betale 19 000 sats til Bob."

Denne tolkningen er åpenbart feil; som du allerede vet, tilhører de to UTXO-ene i input ikke samme person. Den ene er fra Alice, baguettekjøperen, og den andre er fra Bob, bakeren.

Dermed blir den eksterne observatørens analyse rettet mot en feilaktig konklusjon, noe som sikrer at interessentenes konfidensialitet bevares.

### Den steganografiske transaksjonen

Det andre målet med payjoin er å villede en utenforstående observatør om det faktiske beløpet som er betalt. Ved å undersøke strukturen i transaksjonen kan analytikeren tro at betalingen tilsvarer beløpet på en av utbetalingene.

Hvis vi tar eksemplet med kjøp av en baguette, vil analytikeren tro at betalingsbeløpet tilsvarer enten UTXO-en på 6 000 sats eller UTXO-en på 19 000 sats. I dette tilfellet er det mer sannsynlig at analytikeren tror at betalingsbeløpet er 19 000 sats fordi det er to UTXO-er i utdataene, hvorav minst én er større enn 6 000 sats (det er ingen logisk grunn til å bruke to UTXO-er for å betale 6 000 sats når én enkelt UTXO ville ha vært tilstrekkelig for denne betalingen).

Men i virkeligheten er denne analysen feil. Betalingsbeløpet samsvarer ikke med noen av utbetalingene. Det er faktisk differansen mellom UTXO for utgangsmottakeren og UTXO for inngangsmottakeren.

Payjoin-transaksjonen faller dermed inn under steganografi. Den gjør det mulig å skjule det virkelige transaksjonsbeløpet i en falsk transaksjon som fungerer som en avledningsmanøver.

Steganografi er en teknikk for å skjule informasjon i andre data eller objekter, slik at den skjulte informasjonen ikke er synlig. En hemmelig melding kan for eksempel skjules i et punkt i en urelatert tekst, slik at den ikke kan oppdages med det blotte øye (dette er [micropoint]-teknikken (https://fr.wikipedia.org/wiki/Micropoint)).

I motsetning til kryptering, som gjør informasjonen uforståelig uten dekrypteringsnøkkelen, endrer ikke steganografi informasjonen. De forblir synlige. Målet er snarere å skjule selve eksistensen av det hemmelige budskapet, mens kryptografi tydelig avslører tilstedeværelsen av skjult informasjon, selv om den er utilgjengelig uten nøkkelen. Dette er grunnen til at payjoin opprinnelig ble kalt "steganografiske transaksjoner"

Man kan trekke en analogi mellom kryptografi og coinjoin, og mellom steganografi og payjoin. Coinjoin har egenskaper som ligner på kryptografiens: Metoden er gjenkjennelig, men informasjonen er ikke mulig å tyde. Payjoin er derimot beslektet med steganografi: informasjonen er teoretisk sett tilgjengelig, men fordi metoden for å skjule den ikke er gjenkjennelig, blir den utilgjengelig.

### Hvordan bruker jeg payjoin?

Kjente programvarer som støtter payjoin inkluderer Sparrow Wallet, Wasabi Wallet, Mutiny, BitMask, BlueWallet og JoinMarket, samt BTCPay betalingsprosessor.

Den mest avanserte implementeringen av payjoin var bare Stowaway på Samourai Wallet. Men siden nedleggelsen av programvaregrunnleggerne fungerer dette verktøyet nå bare delvis. Fordelen med Stowaway er at det er en komplett og veldig brukervennlig protokoll som støtter både mottak og sending av payjoins. Delvis signerte transaksjoner kan utveksles manuelt ved å skanne flere QR-koder eller automatisk gjennom Tor via Soroban. Det er sistnevnte kommunikasjonsalternativ som for øyeblikket ikke er i bruk.

Vanskeligheten med å bruke payjoin ligger i at det er avhengig av at forhandleren deltar. Som kunde er det umulig å bruke payjoin hvis forhandleren ikke støtter det. Dette gjør det ekstra vanskelig å gjennomføre et kjøp: Ikke bare er det komplisert å finne forhandlere som godtar bitcoin, men hvis du i tillegg leter etter forhandlere som støtter payjoin, blir det enda mer komplisert.

En løsning kan være å bruke transaksjonsstrukturer som introduserer tvetydighet i kjedeanalysen uten å kreve samarbeid fra mottakeren. På denne måten kan vi forbedre personvernet ved betalingene våre uten å være avhengig av aktiv medvirkning fra forhandlerne. Det er nettopp dette vi skal se nærmere på i neste kapittel.

https://planb.network/tutorials/privacy/on-chain/payjoin-sparrow-wallet-087a0e49-61cd-41f5-8440-ac7b157bdd62
https://planb.network/tutorials/privacy/on-chain/payjoin-samourai-wallet-48a5c711-ee3d-44db-b812-c55913080eab
## Mini-coinjoin-betaling

<chapterId>300777ee-30ae-43d7-ab00-479dac3522c1</chapterId>

Når man ønsker å gjennomføre en betalingstransaksjon og samtidig bevare en viss grad av personvern, er payjoin et godt alternativ. Men som vi har sett, krever payjoin at mottakeren er involvert. Så hva gjør man hvis mottakeren nekter å delta i en payjoin, eller hvis man rett og slett foretrekker å ikke involvere ham? Et alternativ er å bruke en Stonewall- eller Stonewall x2-transaksjon. La oss se nærmere på disse to transaksjonstypene.

### Stonewall-transaksjonen

Stonewall er en spesifikk form for Bitcoin-transaksjon som tar sikte på å øke brukernes personvern under en shoppingtur ved å etterligne en pseudocoinjoin mellom to personer, men uten å faktisk være en. Faktisk er denne transaksjonen ikke samarbeidende. En bruker kan bygge den selv, med bare UTXO-er han eier som input. Du kan deretter opprette en Stonewall-transaksjon for en hvilken som helst anledning, uten å måtte synkronisere med en annen bruker eller mottaker.

Stonewall-transaksjonen fungerer på følgende måte: I transaksjonens input bruker avsenderen 2 UTXO-er som tilhører ham selv. I utgangen produserer transaksjonen 4 UTXO-er, hvorav 2 vil være nøyaktig det samme beløpet. De andre 2 UTXO-ene vil utgjøre resten. Av de to UTXOene med samme beløp er det bare én som faktisk går til mottakeren av betalingen.

Det er bare to roller i en Stonewall-transaksjon:


- Avsenderen, som foretar betalingen;
- Mottakeren, som kanskje ikke er klar over transaksjonens spesifikke natur og bare venter på betaling fra avsenderen.

La oss ta et eksempel for å forstå denne transaksjonsstrukturen. Alice er hos baker Bob for å kjøpe baguetten sin, som koster 4000 sats. Hun ønsker å betale i bitcoin, samtidig som hun ønsker å opprettholde et visst nivå av personvern rundt betalingen. Derfor bestemmer hun seg for å konstruere en Stonewall-transaksjon for betalingen.

Når vi analyserer denne transaksjonen, ser vi at bakeren Bob faktisk mottok 4 000 sats som betaling for baguetten. Alice brukte to UTXO-er som inndata: én på 10 000 sats og én på 15 000 sats. Som output mottok hun 3 UTXOer: én på 4 000 sats, én på 6 000 sats og én på 11 000 sats. Alice har dermed en nettosaldo på -4 000 sats på denne transaksjonen, noe som er nøyaktig det samme som prisen på baguetten.

I dette eksempelet har jeg med vilje utelatt utvinningsgebyrer for å gjøre det lettere å forstå. I virkeligheten er det avsenderen som står for hele transaksjonsgebyret.

### Hva er målene med en Stonewall-transaksjon?

Stonewall-strukturen tilfører mye entropi til transaksjonen og forvirrer sporene i kjedeanalysen. Fra utsiden kan en slik transaksjon tolkes som en mini-coinjoin mellom to personer. Men i virkeligheten er det en betaling. Dermed skaper denne metoden usikkerhet i kjedeanalysen, eller fører til og med til falske spor.

La oss gå tilbake til eksemplet med Alice hos bakeren Bob. Transaksjonen på blokkjeden ville sett slik ut:

![BTC204](assets/fr/174.webp)

En utenforstående observatør som baserer seg på de vanlige heuristikkene for kjedeanalyse, kan feilaktig konkludere med at "_to personer foretok en liten coinjoin, med én UTXO hver i input og to UTXO hver i output_" En analyse av denne transaksjonen fra utsiden fører ikke til anvendelse av Common Ownership Heuristics of Input (CIOH), fordi tilstedeværelsen av to utganger på samme beløp tyder på et coinjoin-mønster. Fra et eksternt perspektiv kan CIOH derfor ikke anvendes i dette tilfellet.

![BTC204](assets/fr/175.webp)

Denne tolkningen er unøyaktig, for som du vet, ble én UTXO sendt til Bob the Baker, de to UTXO-ene i input kom fra Alice, og hun hentet de tre resterende outputene.

![BTC204](assets/fr/176.webp)

Og det som er spesielt interessant med strukturen i Stonewall-transaksjonen, er at den, sett fra en utenforstående observatørs perspektiv, ser nøyaktig ut som en Stonewall x2-transaksjon.

### Stonewall-transaksjonen x2

Stonewall x2 er en annen spesifikk form for Bitcoin-transaksjon som også har som mål å øke brukerens personvern under et forbruk, men denne gangen ved å samarbeide med en tredjepart som ikke er involvert i forbruket. Denne metoden fungerer som en pseudocoinjoin mellom to deltakere mens de foretar en betaling til en tredjepart.

Stonewall x2-transaksjonen fungerer relativt enkelt: Man bruker en UTXO man selv har til å utføre betalingen, og får hjelp av en tredjepart som også bidrar med en UTXO. Transaksjonen ender med fire utganger: to av dem er like store, og den ene går til adressen til betalingsmottakeren, den andre til en adresse som tilhører bidragsyteren. En tredje UTXO sendes til en annen adresse som tilhører bidragsyteren, slik at de kan få tilbake det opprinnelige beløpet (en nøytral handling for dem, minus gruveavgifter), og en siste UTXO returnerer til en adresse som tilhører oss, som utgjør resten av betalingen.

Det er altså tre ulike roller som defineres i Stonewall x2-transaksjoner:


- Avsenderen, som foretar selve betalingen;
- Mottakeren, som kanskje ikke er klar over hva transaksjonen går ut på, og som bare venter på betaling fra avsenderen;
- Samarbeidspartneren, som gir bitcoin for å så tvil i transaksjonsanalysen, får tilbake pengene sine på slutten (en nøytral handling for dem, netto etter gruveavgifter).

La oss gå tilbake til eksempelet med Alice som er hos Bob bakeren for å kjøpe baguetten sin som koster 4000 sats. Hun ønsker å betale i bitcoin og samtidig opprettholde en viss grad av personvern rundt betalingen. Hun ringer derfor sin venn Charles, som skal hjelpe henne i denne prosessen.

![BTC204](assets/fr/177.webp)

Når vi analyserer denne transaksjonen, ser vi at Bob, bakeren, faktisk mottok 4 000 sats som betaling for baguetten. Alice brukte 10 000 sats i input og fikk tilbake 6 000 sats i output, noe som resulterte i en nettobalanse på -4 000 sats, som tilsvarer prisen på baguetten. Charles leverte 15 000 sats i input og mottok to outputs: en på 4 000 sats og en på 11 000 sats, noe som resulterte i en balanse på 0.

I dette eksempelet har jeg med vilje utelatt provisjoner for å gjøre det lettere å forstå. I virkeligheten deles utvinningsgebyrene vanligvis likt mellom utstederen av betalingen og bidragsyteren.

### Hva er målet med en Stonewall x2-transaksjon?

I likhet med Stonewall-strukturen tilfører Stonewall x2-strukturen en betydelig mengde entropi til transaksjonen og tilslører sporene etter kjedeanalysen. Fra et eksternt synspunkt kan en slik transaksjon tolkes som en liten myntveksling mellom to personer. Men i virkeligheten er det en betaling. Denne metoden skaper derfor usikkerhet i kjedeanalysen, noe som også fører til falske spor.

La oss se på eksemplet med Alice, Bob the Baker og Charles. Transaksjonen på blokkjeden vil se slik ut:

![BTC204](assets/fr/178.webp)

En utenforstående observatør som baserer seg på de vanlige heuristikkene for kjedeanalyse, kan feilaktig konkludere med at "_Alice og Charles gjennomførte en liten coinjoin, med én UTXO hver i input og to UTXO hver i output_" Igjen, hvis man analyserer denne transaksjonen utenfra, kan man ikke bruke Common Ownership Heuristics of Input (CIOH), fordi tilstedeværelsen av to utganger på samme beløp tyder på et coinjoin-mønster. Fra et eksternt perspektiv kan CIOH derfor ikke anvendes i dette tilfellet.

![BTC204](assets/fr/179.webp)

Denne tolkningen er unøyaktig, for som du vet, ble det sendt én UTXO til Bob the Baker, Alice har bare én restutgang, og Charles har to.

![BTC204](assets/fr/180.webp)

Og igjen, det som er spesielt interessant med Stonewall x2-transaksjonsstrukturen, er at den fra en utenforstående observatørs perspektiv ser nøyaktig ut som en Stonewall-transaksjon.

### Hva er forskjellen mellom Stonewall og Stonewall x2?

En Stonewall X2-transaksjon fungerer akkurat som en Stonewall-transaksjon, bortsett fra at førstnevnte er kollaborativ, mens sistnevnte ikke er det. Som vi har sett, involverer en Stonewall X2-transaksjon deltakelse fra en tredjepart (Charles), som er ekstern i forhold til betalingen, og som gir sine bitcoins for å øke konfidensialiteten til transaksjonen. I en klassisk Stonewall-transaksjon er det avsenderen som tar rollen som bidragsyter.

![BTC204](assets/fr/181.webp)

Fra et eksternt synspunkt er transaksjonsmodellen derfor nøyaktig den samme.

Det faktum at disse to transaksjonsstrukturene har nøyaktig samme mønster, innebærer at selv om en utenforstående observatør kan identifisere et "Stonewall(x2)"-mønster, vil han ikke ha all informasjon. Han vil ikke kunne avgjøre hvilken av de to UTXOene med samme beløp som tilsvarer betalingen. Han vil heller ikke kunne avgjøre om de to UTXO-ene kom fra to forskjellige personer (Stonewall x2) eller om de tilhørte én og samme person som slo dem sammen (Stonewall).

Dette siste poenget skyldes at Stonewall x2-transaksjoner følger nøyaktig samme mønster som Stonewall-transaksjoner. Utenfra og uten ytterligere kontekstinformasjon er det umulig å skille en Stonewall-transaksjon fra en Stonewall x2-transaksjon. De førstnevnte er imidlertid ikke samarbeidstransaksjoner, mens de sistnevnte er det. Dette gjør analysen av en slik transaksjon enda mer tvilsom.

### Når skal man bruke Stonewall og Stonewall x2-transaksjoner?

Logikken bør være som følger når du ønsker å bruke et personvernverktøy for en transaksjon:


- Du kan velge å prioritere en payjoin;
- Hvis forhandleren ikke støtter payjoins, kan en samarbeidstransaksjon gjøres med en annen person utenfor betaling ved hjelp av Stonewall x2-strukturen;
- Hvis du ikke finner noen å gjøre en Stonewall x2-transaksjon med, kan du gjøre en Stonewall-transaksjon på egen hånd, som vil etterligne oppførselen til en Stonewall x2-transaksjon.

### Hvordan bruker jeg Stonewall og Stonewall x2-transaksjoner?

Stonewall- og Stonewall x2-transaksjoner er tilgjengelige både i Samourai Wallet-appen og Sparrow Wallet-programvaren.

Men akkurat som med payjoins, etter arrestasjonen av Samourais grunnleggere, fungerer Stonewall x2-transaksjoner nå bare ved å utveksle PSBT-er manuelt mellom de involverte partene. Automatisk utveksling via Soroban er dessverre ikke tilgjengelig for øyeblikket.

Du kan også utføre denne typen transaksjoner manuelt fra hvilken som helst Bitcoin-lommebokprogramvare.

I neste kapittel skal vi se nærmere på en annen relativt ukjent, men svært nyttig personvernteknikk i tillegg til det vi allerede har studert.

https://planb.network/tutorials/privacy/on-chain/stonewall-033daa45-d42c-40e1-9511-cea89751c3d4
https://planb.network/tutorials/privacy/on-chain/stonewall-x2-05120280-f6f9-4e14-9fb8-c9e603f73e5b
## Rebounds

<chapterId>db9a20ac-a149-443d-884b-ea6c03f28499</chapterId>

Bruken av Bitcoin-transaksjonsstrukturer som skaper tvetydighet i kjedeanalysen, slik som coinjoin, er spesielt gunstig for personvern. Men som vi diskuterte i kapittelet om payjoins, er coinjoin-transaksjoner naturlig nok identifiserbare i kjeden. Husk analogien vi etablerte mellom kryptografi og coinjoins: Når man krypterer en fil, kan en tredjepart som oppdager den krypterte filen, ikke få tilgang til innholdet, men kan tydelig identifisere at det har blitt gjort en endring av filen for å skjule innholdet. Det samme gjelder for coinjoins: Når en analytiker undersøker en coinjoin-transaksjon, kan han eller hun, selv om han eller hun ikke kan etablere direkte koblinger mellom inndata og utdata (og vice versa), likevel gjenkjenne at den observerte transaksjonen er en coinjoin.

Avhengig av hva mynten din skal brukes til etter å ha gjennomgått en coinjoin-syklus, kan det faktum at den har gjennomgått denne prosessen være problematisk. Hvis du for eksempel planlegger å selge mynten din på en regulert børsplattform, men den nylig har gjennomgått en coinjoin, vil plattformens kjedeanalyseverktøy oppdage dette. Plattformen kan da nekte å akseptere UTXO-en din som har gjennomgått en coinjoin, eller til og med kreve forklaringer fra deg, med risiko for at kontoen din blir suspendert eller pengene dine frosset. I noen tilfeller kan plattformen også rapportere oppførselen din til statlige myndigheter (dette er for eksempel det TRACFIN krever av leverandører av digitale aktivatjenester (PSAN) i Frankrike).

For å unngå dette trenger vi et verktøy som kan viske ut sporene etter en Bitcoin-mynts fortid for å gjenopprette en form for fungibilitet. Dette er nettopp målet med rikosjett.

### Hva er en rikosjett?

Ricochet er en teknikk som går ut på å utføre flere dummy-transaksjoner til seg selv (sweeping) for å simulere en overføring av bitcoin-eierskap. Dette verktøyet skiller seg fra andre transaksjonsstrukturer vi har diskutert, fordi det ikke gir mulighet for prospektiv anonymitet, men snarere en form for retrospektiv anonymitet. Faktisk gjør rikosjettering det mulig å utviske særtrekk som kan kompromittere fungibiliteten til en bitcoin-mynt på grunn av dens fortid.

For å skjule avtrykket som en tidligere hendelse har etterlatt på en mynt, som for eksempel coinjoin-sykluser, utfører ricochet fire påfølgende transaksjoner der brukeren overfører penger til seg selv på forskjellige adresser.

Etter denne transaksjonssekvensen sender rikosjettverktøyet til slutt bitcoinsene til deres endelige destinasjon som en utvekslingsplattform.

Målet er å skape en avstand som påvirker myntens fungibilitet, for eksempel en coinjoin-transaksjon, og den endelige forbrukshandlingen som kan avvise denne mynten på grunn av dens fortid. Dermed kan verktøy for kjedeanalyse konkludere med at det sannsynligvis har vært et eierskifte etter hendelsen, og vurdere at denne mynten er fungibel. I tilfelle av en coinjoin kan verktøyene for kjedeanalyse anta at det ikke er den samme personen som sendte bitcoins og utførte coinjoin, og at det dermed er nytteløst å iverksette tiltak mot avsenderen.

### Hvorfor fungerer det?

Med denne rikosjettmetoden kunne man tenke seg at programvaren for kjedeanalyse ville gå dypere enn fire hopp. Disse plattformene står imidlertid overfor et dilemma når de skal optimalisere deteksjonsterskelen. De må sette en grense for hvor mange hopp som skal til før de innrømmer at det sannsynligvis har skjedd et eierskifte, og at koblingen til en tidligere hendelse (for eksempel en coinjoin) bør ignoreres.

Det er imidlertid risikabelt å fastsette denne terskelen: Hver gang det observerte antallet overhoppinger økes, øker antallet falske positiver eksponentielt, det vil si personer som feilaktig blir markert som deltakere i en hendelse når transaksjonen ble utført av noen andre. Dette scenariet utgjør en større risiko for disse selskapene, ettersom falske positiver fører til misnøye, noe som kan føre til at berørte kunder går til konkurrentene. I det lange løp kan en for høy deteksjonsterskel føre til at en plattform mister flere kunder enn konkurrentene, noe som kan true dens overlevelse. Derfor er det komplisert for disse plattformene å øke antallet observerte hopp, og 4 er ofte et tilstrekkelig antall for å motvirke analysen deres.

Fenomenet som observeres her, er noe analogt med teorien om seks graders separasjon.

Teorien om seks graders atskillelse antyder at enhver person på jorden er forbundet med enhver annen gjennom en kunnskapskjede som ikke omfatter mer enn seks mellomledd. Det ville være nok å gå gjennom en serie på seks personer, som hver kjenner den neste personlig, for å nå et hvilket som helst individ i verden.

For Bitcoin-transaksjoner finner man et lignende fenomen. Ved å spore et tilstrekkelig antall Bitcoin-transaksjoner, ender man uunngåelig opp med å støte på en coinjoin. Rikosjettmetoden utnytter dette prinsippet ved å bruke flere hopp enn det er rimelig at utvekslingsplattformene kan følge. Hvis plattformene bestemmer seg for å følge flere transaksjoner, er det da mulig å legge til et ekstra hopp for å omgå dette tiltaket.

### Når og hvordan bruke rikosjett?

Det vanligste bruksområdet for rikosjettering oppstår når det er nødvendig å skjule tidligere deltakelse i en coinjoin på en UTXO som du eier. Ideelt sett er det best å unngå å overføre bitcoins som har gjennomgått en coinjoin til regulerte enheter. Men i tilfelle man står uten andre alternativer, spesielt når det haster med å likvidere bitcoin til fiat-valuta, tilbyr ricochet en effektiv løsning.

Denne metoden er ikke bare effektiv for myntfuger, men også for alle andre merker som kan kompromittere en mynts fungibilitet.

Ideen til denne ricochet-metoden kom opprinnelig fra Samourai Wallet-teamene, som integrerte den i applikasjonen sin for å automatisere prosessen. Tjenesten koster penger på Samourai, ettersom en ricochet medfører en serviceavgift på 100 000 sats, i tillegg til gruveavgifter. Derfor anbefales det heller å bruke den for overføringer av betydelige beløp.

Samourai-applikasjonen tilbyr to varianter av rikosjetteringen:


- Avansert rikosjettering, eller "forskjøvet levering", som har den fordelen at Samourais serviceavgifter spres over fem påfølgende transaksjoner. Dette alternativet sikrer også at hver transaksjon overføres på et separat tidspunkt og registreres i en annen blokk, noe som gjør det mulig å etterligne oppførselen til et eierskifte så tett som mulig. Selv om denne metoden er langsommere, er den å foretrekke for dem som ikke har det travelt, ettersom den maksimerer effektiviteten til rikosjetten ved å styrke dens motstand mot kjedeanalyse;
- Den klassiske rikosjettmetoden, som er utformet for å utføre operasjonen raskt ved å overføre alle transaksjoner på kort tid. Denne metoden gir derfor mindre personvern og mindre motstand mot analyse enn den avanserte metoden. Den bør kun brukes ved hasteinnleveringer.

Recochet består ganske enkelt av å sende bitcoin til seg selv. Det er fullt mulig å utføre en ricochet manuelt på hvilken som helst lommebokprogramvare, uten å bruke et spesialisert verktøy. Du overfører ganske enkelt den samme mynten til deg selv senere, ved å bruke en ny, tom adresse hver gang.

I det følgende kapittelet skal vi se nærmere på flere teknikker for hemmelig eiendomsoverføring. Disse metodene skiller seg radikalt fra dem vi har undersøkt så langt, både når det gjelder hvordan de fungerer og resultatene de gir.

https://planb.network/tutorials/privacy/on-chain/ricochet-e0bb1afe-becd-44a6-a940-88a463756589
## Hemmelige eiendomsoverdragelser

<chapterId>a2067036-849c-4d6b-87d2-44235cfae7a1</chapterId>

Blant personvernteknikkene på bitcoin er hemmelig overføring av eierskap. Denne metoden tar sikte på å overføre eierskap av bitcoins fra en person til en annen, og omvendt, uten at denne transaksjonen er eksplisitt synlig på blokkjeden. La oss sammen se nærmere på de ulike teknikkene som er tilgjengelige, samt fordelene og ulempene ved dem.

### The CoinSwap

CoinSwap er basert på et relativt enkelt konsept: Det bruker smartkontrakter for å legge til rette for en overføring av bitcoin-eierskap mellom to brukere, uten behov for tillit og uten at denne overføringen er eksplisitt synlig i blokkjeden.

La oss tenke oss et forenklet eksempel med Alice og Bob. Alice har 1 BTC sikret med den private nøkkelen $A$, og Bob har også 1 BTC sikret med den private nøkkelen $B$. Teoretisk sett kan de utveksle sine private nøkler via en ekstern kommunikasjonskanal for å utføre en hemmelig overføring.

Denne naive metoden innebærer imidlertid en høy risiko når det gjelder tillit. Ingenting hindrer Alice i å beholde en kopi av den private $A$-nøkkelen etter utvekslingen og bruke den senere til å stjele bitcoins når Bob er i besittelse av nøkkelen.

Dessuten finnes det ingen garanti som hindrer Alice i å motta Bobs private nøkkel $B$ og aldri sende sin private nøkkel $A$ i retur. Denne utvekslingen er derfor avhengig av overdreven tillit mellom partene, og viser seg å være ineffektiv når det gjelder å sikre en hemmelig overføring av eierskap på en sikker måte.

For å løse disse problemene og muliggjøre utveksling mellom parter som ikke stoler på hverandre, kan vi i stedet bruke smartkontraktsystemer. En smartkontrakt er et program som kjører automatisk når forhåndsdefinerte betingelser er oppfylt, noe som i vårt tilfelle sørger for at eiendomsbytte skjer automatisk uten at det kreves gjensidig tillit.

For å gjøre dette kan vi bruke HTLC (_Hash Time-Locked Contracts_) eller PTLC (_Point Time-Locked Contracts_). Disse to protokollene fungerer på samme måte ved hjelp av et tidslåst system som sikrer at utvekslingen fullføres eller kanselleres helt, og dermed beskytter integriteten til begge parters midler. Hovedforskjellen mellom HTLC og PTLC er at HTLC bruker hashes og preimages for å sikre transaksjonen, mens PTLC bruker adaptive signaturer.

I et CoinSwap-scenario med en HTLC eller en PTLC mellom Alice og Bob foregår utvekslingen på en sikker måte: enten lykkes den, og begge mottar den andres BTC, eller så mislykkes den, og begge beholder sin egen BTC. Det er derfor umulig for noen av partene å jukse eller stjele den andres BTC.

> hTLCene er også mekanismen som brukes til å rute betalinger sikkert gjennom Lightning-nettverkets toveiskanaler
> Bruken av adaptive signaturer er spesielt interessant i denne sammenhengen, ettersom den gjør det mulig å omgå tradisjonelle skript (dette er en mekanisme som noen ganger omtales som "_skriptløse skript"). Denne funksjonen bidrar til å redusere avgiftene forbundet med utvekslingen. En annen stor fordel med adaptive signaturer er at de ikke krever bruk av en felles hash for begge sider av transaksjonen, slik at man unngår å avsløre en direkte kobling mellom dem i visse typer utvekslinger.
### Adaptive signaturer

Adaptive signaturer er en kryptografisk metode som integrerer en gyldig signatur med en tilleggssignatur, kalt en "_adaptiv signatur_", for å avsløre en hemmelig del av dataene. Denne mekanismen er utformet på en slik måte at hvis man kjenner til to av følgende tre elementer: den gyldige signaturen, den adaptive signaturen og hemmeligheten, kan det tredje manglende elementet utledes. En interessant egenskap ved denne metoden er at hvis vi kjenner den adaptive signaturen til motparten vår og det spesifikke punktet på den elliptiske kurven som er knyttet til hemmeligheten som ble brukt til å beregne denne adaptive signaturen, kan vi utlede vår egen adaptive signatur som vil være kompatibel med den samme hemmeligheten, uten å ha direkte tilgang til selve hemmeligheten.

I myntbørser gjør bruken av adaptive signaturer det mulig å utlevere to sensitive opplysninger mellom deltakerne samtidig, slik at man unngår behovet for gjensidig tillit. La oss ta et eksempel for å illustrere denne prosessen med Alice og Bob, som ønsker å bytte eierskapet til 1 BTC hver, men som ikke stoler på hverandre. De bruker Adaptive Signatures for å eliminere behovet for tillit i denne utvekslingen. Slik går de frem:


- Alice starter utvekslingen ved å opprette en transaksjon $m_A$ som sender 1 BTC til Bob. Hun genererer en signatur $s_A$, som validerer denne transaksjonen, ved hjelp av sin private nøkkel $p_A$ ($P_A = p_A \cdot G$), et nonce $n_A$ ($N_A = n_A \cdot G$) og en hemmelighet $t$ ($T = t \cdot G$):

$$s_A = n_A + t + H(N_A + T \parallell P_A \parallell m_A) \cdot p_A$$$


- Alice beregner den adaptive signaturen $s_A'$ ved å trekke den hemmelige $t$ fra sin sanne signatur $s_A$:

$$s_A' = s_A - t$$$$


- Alice sender Bob sin adaptive signatur $s'_A$, sin usignerte transaksjon $m_A$, punktet som tilsvarer hemmeligheten ($T$), og punktet som tilsvarer nonce ($N_A$). Disse elementene utgjør det som kalles en "_adapter_" Det er viktig å merke seg at Bob ikke kan hente ut Alices BTC med bare denne informasjonen.
- Bob har imidlertid muligheten til å verifisere at Alice ikke prøver å stjele fra ham. For å gjøre dette sjekker han om Alices adaptive signatur $s_A'$ faktisk samsvarer med den foreslåtte transaksjonen $m_A$. Hvis følgende ligning er korrekt, kan han være sikker på at Alices adaptive signatur er gyldig:

$$s_A' \cdot G = N_A + H(N_A + T \parallell P_A \parallell m_A) \cdot P_A$$$


- Denne verifiseringen gir Bob tilstrekkelig sikkerhet til å fortsette med utvekslingen på en trygg måte. Deretter oppretter han sin egen transaksjon $m_B$, som har til hensikt å sende 1 BTC til Alice, og genererer sin adaptive signatur $s_B'$, som også vil være knyttet til den samme hemmeligheten $t$. På dette tidspunktet er det bare Alice som kjenner verdien av $t$; Bob kjenner bare det tilsvarende punktet $T$ som Alice overførte til ham:

$$s_B' = n_B + H(N_B + T \parallell P_B \parallell m_B) \cdot p_B$$$


- Bob overfører sin adaptive signatur $s_B'$, sin usignerte transaksjon $m_B$, samt punktet som tilsvarer hemmeligheten ($T$) og punktet som tilsvarer nonce ($N_B$) til Alice. Alice, som kjenner hemmeligheten $t$, kan nå kombinere Bobs adaptive signatur $s_B'$ med denne hemmeligheten for å generere en gyldig signatur $s_B$ for transaksjonen $m_B$ som vil overføre Bobs BTC til henne:

$$s_B = s_B' + t$$$$

$$$(s_B' + t) \cdot G = N_B + T + H(N_B + T \parallell P_B \parallell m_B) \cdot P_B$$$


- Alice overfører denne signerte transaksjonen $m_B$ på Bitcoin-blokkjeden for å hente BTC som Bob har lovet. Når Bob ser denne transaksjonen på blokkjeden, kan han trekke ut signaturen $s_B = s_B' + t$. Med denne informasjonen kan Bob isolere den berømte hemmeligheten $t$ som han trengte:

$$t = (s_B' + t) - s_B' = s_B - s_B'$$$$


- Og faktisk var denne hemmeligheten $t$ det eneste elementet som manglet for at Bob kunne generere den gyldige signaturen $s_A$ fra Alices adapter-signatur $s_A'$. Denne signaturen gjør det mulig å validere transaksjonen $m_A$ som sender en BTC fra Alice til Bob. Bob beregner deretter $s_A$ og overfører i sin tur $m_A$-transaksjonen på blokkjeden:

$$s_A = s_A' + t$$$$

$$$(s_A' + t) \cdot G = N_A + T + H(N_A + T \parallell P_A \parallell m_A) \cdot P_A$$$

La oss oppsummere hvordan en signaturadapter fungerer i en myntutveksling. Til å begynne med sender Alice en usignert transaksjon til Bob sammen med en adapter, slik at Bob kan verifisere at hemmeligheten som avsløres senere, vil gi ham tilgang til bitcoins. Til gjengjeld sender Bob sin usignerte transaksjon og adapter til Alice. Alice kan deretter fullføre Bobs transaksjon og få tilbake bitcoinsene ved å sende en gyldig transaksjon med hemmeligheten. Når denne transaksjonen publiseres på blokkjeden, kan Bob trekke ut hemmeligheten og dermed låse opp Alices transaksjon. Hvis Alice initierer en overføring av Bobs bitcoins, kan Bob i sin tur få tilgang til Alices bitcoins uten at det kreves gjensidig tillit.

Det er viktig å merke seg at myntbørser først ble foreslått av [Gregory Maxwell i oktober 2013 på BitcoinTalk] (https://bitcointalk.org/index.php?topic=321228.0).

### Atomutvekslingen

I likhet med myntutvekslingen og ved hjelp av de samme typene smartkontrakter er det også mulig å utføre atomutvekslinger. En atomisk veksling tillater direkte veksling av ulike kryptovalutaer, for eksempel BTC og XMR, mellom to brukere uten å kreve tillit eller innblanding fra en mellommann. Slike bytter kalles "atomiske" bytter fordi de bare har to mulige utfall: enten lykkes byttet, og begge parter er fornøyde, eller så mislykkes det, og begge beholder sine opprinnelige kryptovalutaer, noe som eliminerer behovet for å stole på den andre parten.

![BTC204](assets/fr/197.webp)

Atomutveksling og myntutveksling deler en lignende driftsmetode og tilbyr de samme fordelene og ulempene når det gjelder personvern. Fra Bitcoins perspektiv er faktisk en atomutveksling sammenlignbar med en myntutveksling utført i to trinn. Først bytter vi vår BTC mot en annen kryptovaluta, og deretter kan denne kryptovalutaen byttes mot andre BTC. Til slutt henter vi en annen brukers BTC. Dette er grunnen til at jeg i analysen av personvernproblemer grupperer disse to protokollene under kategorien hemmelig utveksling av eiendom.

![BTC204](assets/fr/198.webp)

I motsetning til myntbørser kan imidlertid atombørser ha ubalanse når det gjelder tilgjengelig likviditet, spesielt i BTC/XMR-børser. Generelt er det lettere å veksle bitcoin til altcoin fordi det er stor etterspørsel etter bitcoin, noe som holder premiene for denne konverteringsretningen lave. Det kan imidlertid være mer komplisert å bytte altcoin mot BTC på grunn av lavere etterspørsel, noe som ofte resulterer i svært høye premier.

Når en atomutveksling involverer bitcoin i kjeden og bitcoin i Lightning-nettverket, kaller vi det en "_submersible exchange_"

### Er det virkelig nyttig?

Hemmelige eierskapsoverføringer, som myntbytter og atombytter, har den fordelen at de kan lure kjedeanalysens heuristikk. Disse metodene kan gi inntrykk av at transaksjonene involverer samme bruker, selv om det faktiske eierskapet har skiftet hender. Den største ulempen med disse metodene er imidlertid at de er svært risikable uten bruk av en ekstra teknikk for å forstyrre mynthistorikken.

Når Alice foretar et myntbytte eller atombytte med Bob, bytter hun eierskapet til sine bitcoins mot Bobs bitcoins. I tilfellet med et atombytte inkluderer utvekslingen en altcoin, men prinsippet forblir det samme. Dermed ender Alice opp med mynten $B$ og Bob med mynten $A$. Dette skaper tvil i kjedeanalysen, men myntenes historie forblir sporbar. Hvis en analytiker undersøker mynt $A$, kan han eller hun spore Alices tidligere aktiviteter, og vice versa for mynt $B$.

Sett fra Alices synspunkt er risikoen at historikken til $B$-mynten kan bli ansett som mistenkelig av visse enheter. Hvis Bob for eksempel hadde skaffet seg $B$-mynten gjennom en kriminell handling som hacking, ville denne mynten forbli knyttet til hans ulovlige aktiviteter. Alice kan da komme i besittelse av en mynt som hun ikke kan overføre til regulerte handelsplattformer uten å risikere å få pengene sine frosset, eller til og med bli anklaget for Bobs forbrytelser, selv om hun ikke hadde noe med dem å gjøre.

Og selvfølgelig er personvernmetoder som myntbytte eller atombytte foretrukket av kriminelle hvis midler overvåkes av myndighetene. Disse protokollene gir dem muligheten til å kvitte seg med sine overvåkede bitcoins i bytte mot helt fungible bitcoins. Dette gjør det også mulig for dem å avlede oppmerksomheten ved å henvise myndighetene til andre brukere. Det er dermed en dobbel nytteverdi for disse menneskene.

Med coinjoin blir mynten din ødelagt selv om den blandes med overvåkede bitcoins, noe som gir en form for plausibel benektelse som ikke finnes i protokoller for hemmelig eiendomsoverføring, for eksempel myntbytte eller atombytte.

Hvis Alice ønsker å unngå enhver risiko, må hun nødvendigvis bruke en metode for å forstyrre historien til $B$-mynten, for eksempel ved å kjøre den gjennom coinjoins. Dette reiser et spørsmål om nytten av å kombinere hemmelig overføring av eierskap og coinjoin. Coinjoin, ved å avbryte historikken til en mynt, gir allerede et tilstrekkelig nivå av personvern for Alice. Derfor mener jeg at hvis Alice ønsker å beskytte personvernet sitt, vil det være mer fornuftig å gå direkte til en coinjoin enn å foreta en myntutveksling etterfulgt av en coinjoin.

For at metoder for hemmelig overføring av eierskap virkelig skal være effektive og unngå risikoen for å knytte historien til en $A$-bruker til en $B$-bruker, vil det paradoksalt nok være nødvendig at bruken av dem er allment kjent. Hvis myntutveksling brukes massivt og myndighetene er klar over denne vanlige praksisen, kan det etableres en plausibel form for benektbarhet. Så lenge bruken av disse overføringene forblir marginal, tror jeg imidlertid at disse metodene vil forbli for risikable for brukerne.

Så langt har vi hovedsakelig studert personvernmetoder på selve transaksjonsnivået. I neste kapittel skal vi se nærmere på problemstillinger på nettverksnivå og transaksjonsspredning.

## Personvern i P2P-nettverket

<chapterId>04a2467b-db84-4076-a9ff-919be5135106</chapterId>

I del 4 diskuterte vi viktigheten av å bruke en full node for å beskytte personvernet i forbindelse med transaksjonene dine. Det er imidlertid viktig å forstå at noden i seg selv kan bli utsatt for angrep som forsøker å hente ut informasjon om aktivitetene dine. I dette kapittelet skal vi derfor se på ulike tiltak for å beskytte personvernet, ikke på transaksjonsnivå eller i selve bitcoinstrømmene, men på nettverksnivå.

### Løvetann

En måte å unngå ulike deanonymiseringsangrep på, er å bruke den foreslåtte Dandelion. Denne overføringsprotokollen ble formalisert i BIP156, men har aldri blitt implementert på Bitcoin. Tanken med Dandelion er å forbedre personvernet ved transaksjonsruting i Bitcoin-nettverket for å motvirke ulike former for angrep. Hovedmålet er å skjule kildenoden som opprinnelig overfører en transaksjon i nettverket. Avsløring av denne noden kan koble en Bitcoin-transaksjon til en spesifikk IP-adresse (hvis noden opererer på det ukrypterte nettverket), og dermed gi et inngangspunkt for kjedeanalyse.

Denne koblingen mellom en aktivitet på Bitcoin og en IP-adresse utgjør en betydelig risiko for brukernes personvern. Faktisk er det mange enheter som enkelt kan koble en IP-adresse til en personlig identitet. Dette inkluderer myndigheter og internettleverandører. I tillegg kan denne informasjonen bli offentlig tilgjengelig, for eksempel hvis IP-adressen og personopplysningene dine blir eksponert på grunn av en datalekkasje i forbindelse med hacking av en nettstedsdatabase.

I standard Bitcoin-drift overføres transaksjoner som er opprettet av en bruker i programvarelommeboken, til den personlige noden. Denne noden overfører umiddelbart den nye transaksjonen til alle andre noder som den er koblet til.

Disse peerene verifiserer deretter transaksjonen for å sikre at den oppfyller konsensusreglene og de lokale standardiseringsreglene. Når transaksjonen er validert, videresender hver peer transaksjonen til sine peers, og så videre.

Fordelingen av transaksjoner som venter på å bli integrert i en blokk, skjer på en ganske balansert og statistisk forutsigbar måte. Denne sårbarheten kan utnyttes av spionnoder, som samarbeider om å overvåke og analysere nettverket for å identifisere den første noden som overfører en transaksjon. Hvis en observatør kan lokalisere kildenoden, kan vedkommende anta at transaksjonen kom fra operatøren av denne noden. Denne typen observasjon kan knytte transaksjoner, som normalt er anonyme, til spesifikke IP-adresser.

Målet med BIP156 er å løse dette problemet. For å gjøre dette innfører den et ekstra trinn i overføringen av en ny transaksjon for å bevare anonymiteten før storskala offentlig spredning. Dandelion bruker først en "stamfase" der transaksjonen sendes gjennom en tilfeldig sti av noder.

Transaksjonen overføres deretter til hele nettverket i "fluff"-fasen (blowhole).

Stilken og løvetannen er referanser til oppførselen til forplantningen av transaksjonen gjennom nettverket, som ligner formen til en løvetann.

Spionnoder kan dermed potensielt spore transaksjonen tilbake til noden som initierte blowing-fasen (den massive overføringen), men denne noden er ikke den som først overførte transaksjonen, siden den mottok den fra den siste noden i stammen. Hvis spionnodene ikke kan spore stammen, kan de heller ikke identifisere kildenoden.

Selv om det finnes spionnoder i stamfasen, vil det alltid være tvil, for så snart de støter på en ærlig node i diffusjonsgrafen, kan ikke spionene avgjøre om denne noden er den opprinnelige kilden eller bare et mellomledd.

Denne rutingsmetoden gjør det vanskeligere å spore tilbake til kildenoden, noe som gjør det komplisert å spore en transaksjon gjennom nettverket til dens opprinnelse. Dandelion forbedrer dermed personvernet ved å begrense motstandernes mulighet til å avanonymisere nettverket. Denne metoden er enda mer effektiv når transaksjonen, i "stammefasen", går gjennom en node som krypterer nettverkskommunikasjonen, som med Tor eller P2P Transport V2.

BIP156 har ikke blitt integrert i Bitcoin Core og er for øyeblikket klassifisert med statusen "avvist" Et stort problem med denne protokollen er at transaksjonene i stamfasen må videresendes av mellomliggende noder før de blir verifisert. Som vi har sett, verifiserer hver node i den normale Bitcoin-modellen først transaksjonen før den videresendes til de andre nodene. Hvis en transaksjon ikke oppfyller nodens konsensusregler eller lokale standardiseringsregler, blir den ignorert og ikke videresendt. Denne prosessen er viktig for å motvirke DoS-angrep, siden bare gyldige transaksjoner sendes til hele nettverket. Ugyldige transaksjoner, som potensielt kan genereres i massevis for å overbelaste nettverket, stoppes ved den første noden og spres ikke videre. Den største risikoen med Dandelion er at denne nye protokollen kan introdusere nye vektorer for DoS-angrep ved å tillate at ugyldige transaksjoner sendes gjennom deler av nettverket.

### P2P-transport V2

P2P Transport V2 er en annen nettverksprotokoll som ble presentert i BIP324. Det er en ny versjon av Bitcoins P2P-transportprotokoll som inneholder opportunistisk kryptografi for å forbedre konfidensialiteten og sikkerheten i kommunikasjonen mellom noder.

Denne forbedringen tar sikte på å løse flere problemer med den grunnleggende versjonen av P2P-protokollen. For det første gjør den utvekslede data umulig å skille fra andre typer data som sirkulerer på Internett for en passiv observatør. Hovedmålet er å forhindre at myndigheter, Internett-leverandører eller VPN-leverandører massivt overvåker Bitcoin-brukere. Dette gjør det også vanskeligere for disse aktørene å avgjøre om en Internett-bruker også er en Bitcoin-bruker, det vil si om de driver en full node.

P2P V2 bidrar også til å redusere risikoen for sensur og angrep ved å oppdage spesifikke mønstre i datapakkene. Det kompliserer og gjør det mer kostbart å utføre ulike typer Sybil-angrep på nettverksnivå. Et Sybil-angrep oppstår når en aktør oppretter flere falske identiteter for å oppnå urettmessige fordeler. I forbindelse med Bitcoin-nettverket kommer dette ofte til uttrykk ved at en aktør kontrollerer et stort antall komplette noder og bruker dem aggressivt til å multiplisere tilkoblinger. Sybil-angrep kan være passive, med mål om å samle informasjon og kompromittere brukernes konfidensialitet, eller aktive, i form av Eclipse-angrep. Sistnevnte isolerer en spesifikk node fra resten av nettverket, slik at den kan sensurere brukeren eller endre dataene den mottar. Til slutt gjør P2P V2 _Man-In-The-Middle_-angrep (MITM) dyrere og lettere å oppdage.

Krypteringen som implementeres av P2P V2, omfatter ikke autentisering for å unngå unødvendig kompleksitet og for ikke å kompromittere nettverkstilkoblingens tillatelsesløse natur. Denne nye P2P-transportprotokollen gir imidlertid bedre sikkerhet mot passive angrep og gjør aktive angrep betydelig mer kostbare og vanskeligere å oppdage. Innføringen av en pseudotilfeldig datastrøm i nettverksmeldinger gjør det vanskeligere for angripere som ønsker å sensurere eller manipulere kommunikasjonen.

P2P V2-transport ble inkludert som et alternativ (deaktivert som standard) i versjon 26.0 av Bitcoin Core, som ble distribuert i desember 2023. Den ble deretter aktivert som standard i versjon 27.0 i april 2024. Det kan endres med `v2transport=`-alternativet i konfigurasjonsfilen.

### Tor

En relativt enkel løsning for å unngå risikoen for tap av konfidensialitet for en node på nettverksnivå er å kjøre den helt og holdent under Tor. Tor er et nettverk av relay-servere (noder) som anonymiserer opprinnelsen til TCP-tilkoblinger over Internett. Det fungerer ved at data kapsles inn i flere lag med kryptering. Hver relénode fjerner ett lag for å avsløre adressen til den neste noden, helt til den endelige destinasjonen er nådd. Tor-nettverket sikrer anonymitet ved å forhindre at mellomliggende noder kjenner både opprinnelsen og destinasjonen til dataene, noe som gjør det svært vanskelig for en observatør å spore brukeraktivitet.

Tor krypterer derfor ikke bare dataene som kommuniseres, men gjør det også mulig å maskere kommunikasjonens opprinnelse og destinasjon. Ved å bruke Tor for personlig nodekommunikasjon forbedrer vi personvernet til transaksjonene våre: Internettleverandøren (ISP) kan ikke dekryptere kommunikasjonen, og andre noder i Bitcoin-nettverket kan ikke identifisere IP-adressen til kildenoden. I tillegg skjuler Tor også bruken av Bitcoin for ISP-en.

Den største risikoen forbundet med denne metoden er at Tor er en Bitcoin-uavhengig protokoll. Hvis du har en Bitcoin-node under Tor og Tor slutter å fungere, vil Bitcoin-noden din ikke lenger kunne kommunisere.

Det er også viktig å merke seg at kommunikasjonen på Tor er tregere. Denne forsinkelsen er spesielt plagsom under den første lanseringen av en node, ettersom Initial Block Download (IBD) krever mye kommunikasjon. Som et resultat av dette kan den første synkroniseringen med Bitcoin-nettverket ta betydelig lengre tid ved bruk av Tor. Det er også mulig å utføre IBD på det åpne nettverket og deretter aktivere Tor senere. Selv om denne metoden avslører eksistensen av Bitcoin-noden din til Internett-leverandøren din, beskytter den din personlige transaksjonsinformasjon når du bytter til Tor.

Etter å ha utforsket de ulike personvernmetodene på nettverksnivå, vil jeg i de neste kapitlene også presentere to elegante løsninger for å unngå gjenbruk av adresser: BIP47 og Silent Payments.

## BIP47 og gjenbrukbare betalingskoder

<chapterId>ad88e076-a04b-4aec-b3b2-7b4760175504</chapterId>

Som vi så i del 3, er gjenbruk av adresser et alvorlig hinder for brukernes personvern i Bitcoin-protokollen. For å redusere denne risikoen anbefales det på det sterkeste å generere en ny mottakeradresse for hver nye betaling som mottas i en lommebok. Selv om det i dag er enklere å generere en ny adresse ved bruk av moderne programvare og hierarkiske, deterministiske lommebøker, kan denne praksisen virke kontraintuitiv.

I det tradisjonelle banksystemet er vi for eksempel vant til å dele IBAN-nummeret vårt, som alltid forblir det samme. Når vi har fortalt det til noen, kan de sende oss flere betalinger uten å måtte samhandle med oss igjen. Nybankene tilbyr også mer moderne muligheter, som bruk av unike e-postadresser på PayPal eller RevTags på Revolut. Selv utenfor finansverdenen er våre daglige identifikatorer som postadresse, telefonnummer og e-postadresse unike og permanente. Vi trenger ikke å fornye dem ved hver nye interaksjon.

Bitcoin fungerer imidlertid annerledes: Det er helt nødvendig å generere en ny mottakeradresse for hver innkommende transaksjon. Denne avveiningen mellom brukervennlighet og personvern går helt tilbake til opprinnelsen til Bitcoins hvitbok. Allerede da Satoshi Nakamoto publiserte den første versjonen av dokumentet sitt i slutten av 2008, advarte han oss om denne risikoen:

**"Som en ekstra brannmur kan man bruke et nytt nøkkelpar for hver transaksjon, slik at de ikke knyttes til en felles eier."

Det finnes mange metoder for å motta flere betalinger på én og samme identifikator uten at det fører til gjenbruk av adresser. Hver av disse metodene har sine egne avveininger og ulemper. Blant disse metodene er BIP47, et forslag utviklet av Justus Ranvier og publisert i 2015. Dette forslaget tar sikte på å skape gjenbrukbare betalingskoder som tillater flere transaksjoner til samme person, samtidig som man unngår gjenbruk av adresser. BIP47 har som mål å tilby et intuitivt betalingssystem som en unik identifikator, samtidig som personvernet ved transaksjoner ivaretas.

![BTC204](assets/fr/212.webp)

BIP47 forbedrer ikke brukernes personvern direkte, siden en BIP47-betaling gir samme grad av personvern som en klassisk Bitcoin-transaksjon med nye adresser. Det gjør imidlertid bruken av Bitcoin mer praktisk og intuitiv, noe som normalt ville ha gått på bekostning av personvernet. Takket være BIP47 oppnår denne brukervennligheten samme nivå av personvern som en klassisk transaksjon. Derfor er BIP47 et verdifullt verktøy for å bevare personvernet.

Opprinnelig var BIP47 et forslag som skulle integreres i Bitcoin Core, men det ble aldri vedtatt. Noen programvarer valgte imidlertid å implementere det uavhengig på applikasjonsnivå. Samourai Wallet-teamene utviklet derfor sin egen implementering av BIP47, kalt "PayNym"

### Generelt prinsipp for BIP47 og PayNym

Målet med BIP47 er å gjøre det mulig å motta mange betalinger uten at det fører til gjenbruk av adresser. Det er basert på bruk av en gjenbrukbar betalingskode, som gjør det mulig for ulike avsendere å sende flere betalinger til en enkelt kode som tilhører en annen bruker. Mottakeren trenger dermed ikke å oppgi en ny adresse for hver transaksjon, noe som forenkler utvekslingen av data samtidig som personvernet ivaretas.

![BTC204](assets/it/66/4.webp)

En bruker kan da fritt dele betalingskoden sin, enten på sosiale nettverk eller på sin egen nettside, uten å risikere tap av personvern, i motsetning til hva som ville skjedd med en klassisk mottaksadresse eller offentlig nøkkel.

For å gjennomføre en transaksjon må begge parter ha en Bitcoin-lommebok med en implementering av BIP47, for eksempel PayNym på Samourai Wallet eller Sparrow Wallet. Den felles bruken av betalingskodene deres skaper en hemmelig kanal mellom dem. For å etablere denne kanalen effektivt må avsenderen utføre en spesifikk transaksjon på Bitcoin-blokkjeden, kjent som en "varslingstransaksjon" (jeg vil gi flere detaljer om dette senere).

Kombinasjonen av begge brukernes betalingskoder genererer delte hemmeligheter, som i sin tur gjør det mulig å opprette et stort antall unike Bitcoin-mottakeradresser (nøyaktig 2^32, eller omtrent 4 milliarder). Dermed er betalinger som gjøres gjennom BIP47 faktisk ikke adressert til selve betalingskoden, men heller til klassiske mottakeradresser avledet fra betalingskodene til de involverte brukerne.

Betalingskoden fungerer da som en virtuell identifikator som er avledet fra seed i lommeboken. I porteføljens hierarkiske avledningsstruktur er betalingskoden plassert på nivå 3, det vil si på kontonivå.

![BTC204](assets/it/66/5.webp)

Avledningsmålet for BIP47 er identifisert med indeksen `47` (`0x8000002F`), som refererer til BIP47. Et eksempel på en avledningssti for en gjenbrukbar betalingskode kan være som følger:

```plaintext
m/47'/0'/0'/
```

Her er min betalingskode, for å gi deg et inntrykk av hvordan den ser ut:

```plaintext
M8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5
```

Denne koden kan også kodes inn i en QR-kode for enkel kommunikasjon, akkurat som en klassisk mottaksadresse.

Når det gjelder PayNym Bots, er disse robotene som noen ganger sees på Twitter visuelle representasjoner av betalingskode, opprettet av Samourai Wallet. De genereres gjennom en hashing-funksjon, noe som gir dem nesten unikhet. De vises som en liten streng med tegn som begynner med `+`:

```plaintext
+throbbingpond8B1
+twilightresonance487
+billowingfire340
```

Disse avatarene kan også representeres som bilder:

![BTC204](assets/fr/215.webp)

Selv om disse robotene ikke har en spesifikk teknisk funksjonalitet innenfor BIP47-rammeverket, bidrar de til å lette interaksjonen mellom brukerne ved å tilby en lett gjenkjennelig visuell identitet.

---
*I de følgende avsnittene i dette kapittelet, som er viet BIP47, vil vi se nærmere på hvordan det fungerer, med særlig fokus på de kryptografiske metodene som brukes. For å forstå disse ganske tekniske forklaringene fullt ut, er det først viktig å forstå strukturen til HD-lommebøker, nøkkelderivasjonsprosesser og de grunnleggende prinsippene for elliptisk kurvebasert kryptografi. Hvis du ønsker å lære mer om disse konseptene, er et annet gratis kurs tilgjengelig fra Plan ₿ Network:*

https://planb.network/courses/46b0ced2-9028-4a61-8fbc-3b005ee8d70f
*Jeg anbefaler på det sterkeste at du følger den, for hvis du forstår hvordan BIP47 fungerer rent teknisk, blir det mye lettere å forstå andre lignende forslag som vi kommer til å diskutere i de kommende kapitlene*

---
### Gjenbrukbar betalingskode

Som nevnt tidligere er den gjenbrukbare betalingskoden plassert på nivå 3 i HD-lommeboken, noe som gjør den sammenlignbar med en `xpub`, både når det gjelder dens posisjon i lommebokstrukturen og dens rolle.

Betalingskoden på 80 byte er delt inn på følgende måte:


- Byte `0`: Versjon**. For den første versjonen av BIP47 er denne byten satt til `0x01`;
- Byte `1`: Bit-feltet**. Denne plassen er reservert for å innlemme ytterligere indikasjoner under spesifikke bruksområder. For standard bruk med PayNym er denne byten definert som `0x00`;
- Byte `2`: Pariteten til `y`**. Denne byten er `0x02` eller `0x03`, som angir om ordinaten til den offentlige nøkkelen er partall eller oddetall, siden det brukes en komprimert offentlig nøkkel;
- Fra byte `3` til byte `34`: Verdien av `x`**. Disse bytene representerer abscissen til den offentlige nøkkelen. Sammenkjedningen av `x` og pariteten til `y` danner den komplette komprimerte offentlige nøkkelen;
- Fra byte `35` til byte `66`: Kjedekode**. Dette området inneholder kjedekoden som er knyttet til den offentlige nøkkelen;
- Fra byte `67` til byte `79`: Utfylling**. Denne plassen er ment for mulig fremtidig utvikling. I den nåværende versjonen er nuller ganske enkelt plassert her for å oppnå den 80 byte-størrelsen som kreves for en `OP_RETURN`-utgang.

Her er den heksadesimale representasjonen av den gjenbrukbare betalingskoden min som allerede ble presentert i forrige avsnitt:

```plaintext
0x010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000
```

![BTC204](assets/it/66/7.webp)

Først og fremst er det nødvendig å legge til prefiksbyten `P` i begynnelsen for å tydelig indikere at det er en betalingskode. Denne byten er representert med `0x47`:

```plaintext
0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000
```

For å sikre betalingskodens integritet utføres det til slutt en kontrollsumberegning ved hjelp av `HASH256`, som består av dobbel hashing med `SHA256`-funksjonen. De fire første byte som er resultatet av denne hashen, kobles deretter sammen på slutten av betalingskoden:

```plaintext
0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000567080c4
```

Når disse trinnene er fullført, er betalingskoden klar. Det eneste som gjenstår, er å konvertere den til base 58 for å få den endelige versjonen:

```plaintext
PM8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5
```

Under denne prosessen med å opprette betalingskoden bruker vi en komprimert offentlig nøkkel og en kjedekode. Begge avledes ved hjelp av deterministisk og hierarkisk avledning fra lommebokfrøet. Avledningsveien som brukes for å oppnå dette, er

```plaintext
m/47'/0'/0'/
```

For å generere den komprimerte offentlige nøkkelen og den tilhørende kjedekoden for den gjenbrukbare betalingskoden, begynner vi med å beregne den private hovednøkkelen fra lommebokfrøet. Deretter utleder vi et datternøkkelpar ved hjelp av indeksen `47 + 2^31` (forsterket utledning). Dette trinnet etterfølges av to påfølgende utledninger av datternøkkelpar, hver med indeksen `2^31` (forsterket utledning).

### Elliptisk kurve Diffie-Hellman-nøkkelutveksling (ECDH)

Den kryptografiske protokollen som ligger til grunn for BIP47, kalles ECDH, som står for _Elliptic-Curve Diffie-Hellman_. Denne metoden er en variant av den opprinnelige Diffie-Hellman-nøkkelutvekslingen.

Diffie-Hellman ble introdusert i 1976 og er en nøkkelavtaleprotokoll som gjør det mulig for to parter, som hver er utstyrt med et nøkkelpar (offentlig og privat), å bli enige om en felles hemmelighet, selv om de kommuniserer utelukkende gjennom en offentlig, usikker kanal.

![BTC204](assets/it/66/10.webp)

Denne delte hemmeligheten (her den blå nøkkelen) kan deretter brukes til andre operasjoner. Vanligvis kan denne delte hemmeligheten brukes til å kryptere og dekryptere kommunikasjon over et usikkert nettverk:

![BTC204](assets/fr/220.webp)

For å gjennomføre denne utvekslingen bruker Diffie-Hellman modulær aritmetikk til å beregne den delte hemmeligheten. Her er en forenklet forklaring på hvordan det fungerer:


- Alice og Bob blir enige om en felles farge, her gul, som utgjør offentlige data (angriperne kjenner denne fargen);
- Alice velger en hemmelig farge, her rød, og blander de to for å få oransje;
- Bob velger også en hemmelig farge, her blå, og blander den med gul for å få grønn;
- Deretter utveksler de de oppnådde fargene, oransje og grønn. Denne utvekslingen kan finne sted på et usikkert, observert nettverk;
- Ved å blande Bobs grønne farge med hans hemmelige farge, får Alice frem en brun farge;
- Bob, som gjør det samme med Alices oransje og hennes hemmelige blå, blir også brun.

![BTC204](assets/it/66/12.webp)

I denne forenklingen representerer fargen brun hemmeligheten som deles mellom Alice og Bob. Det er viktig å forstå at det i virkeligheten er umulig for angriperen å skille fargene oransje og grønn for å oppdage de hemmelige fargene til Alice eller Bob.

La oss nå undersøke hvordan denne protokollen faktisk fungerer, ikke med fargeanalogier, men ved hjelp av reelle tall og modulær aritmetikk!

Før jeg går nærmere inn på Diffie-Hellman-mekanismene, vil jeg kort minne deg på to viktige matematiske begreper vi trenger:


- Et **primtall** er et naturlig tall som bare har to divisorer: $1$ og seg selv. For eksempel er $7$ et primtall fordi det bare kan deles med $1$ og $7$. På den annen side er $8$ ikke et primtall, siden det er delelig med $1$, $2$, $4$ og $8$. Derfor har det fire positive heltall som divisorer i stedet for to;
- **mod** (betegnet $mod$ eller $\%$) er en matematisk operasjon som, mellom to heltall, returnerer resten av den euklidske delingen av førstnevnte med sistnevnte. For eksempel $16 \bmod 5 = 1$.

**Diffie-Hellman-nøkkelutvekslingen mellom Alice og Bob foregår på følgende måte:**


- Alice og Bob er enige om to felles tall: $p$ og $g$. $p$ er et primtall, og jo større dette tallet er, desto sikrere vil Diffie-Hellman være. $g$ er en primitiv rot av $p$. Disse to tallene kan kommuniseres åpent over et usikret nettverk. De tilsvarer den **gule fargen** i forenklingen ovenfor. Det er derfor viktig at Alice og Bob bruker nøyaktig de samme verdiene for $p$ og $g$.

Når disse parameterne er definert, velger Alice og Bob et tilfeldig hemmelig tall hver. Alice kaller sitt tilfeldige hemmelige tall $a$ (tilsvarer **fargen rød**), og Bob kaller sitt $b$ (tilsvarer **fargen blå**). Disse tallene må forbli strengt konfidensielle.

I stedet for å utveksle tallene $a$ og $b$ direkte, beregner hver side $A$ og $B$ på følgende måte:

$A$ er lik $g$ opphøyd i potensen av $a$ modulo $p$:

$$
A = g^a \bmod p
$$

$B$ er lik $g$ opphøyd i potensen av $b$ modulo $p$:

$$
B = g^b \bmod p
$$

Verdiene $A$ (tilsvarende **fargen oransje**) og $B$ (tilsvarende **fargen grønn**) utveksles mellom de to partene. Denne utvekslingen kan skje åpent over et usikret nettverk;

Alice, som har mottatt $B$, beregner verdien av $z$ på følgende måte:

$z$ er lik $B$ opphøyd i potensen av $a$ modulo $p$:

$$
z = B^a \bmod p
$$

Tilbakekalling:

$$
B = g^b \bmod p
$$

Dermed får vi

$$
z = B^a \bmod p
$$

$$
z = (g^b)^a \bmod p
$$

Bruke reglene for eksponenter:

$$
(x^n)^m = x^{nm}
$$

Vi får dermed

$$
z = g^{ba} \bmod p
$$


- På sin side beregner Bob, etter å ha mottatt $A$, også verdien av $z$ på følgende måte:

$z$ er lik $A$ opphøyd i potensen av $b$ modulo $p$:

$$
z = A^b \bmod p
$$

Dermed får vi

$$
z = (g^a)^b \bmod p
$$

$$
z = g^{ab} \bmod p
$$

$$
z = g^{ba} \bmod p
$$

På grunn av distributiviteten til modulooperatoren får Alice og Bob nøyaktig den samme $z$-verdien. Dette tallet representerer deres felles hemmelighet, tilsvarende **fargen brun** i den forrige forenklingen med malingspotter. De kan nå bruke denne felles hemmeligheten til å kryptere kommunikasjonen sin symmetrisk over et usikret nettverk.

Selv om en angriper er i besittelse av $p$, $g$, $A$ og $B$ (de offentlige verdiene), vil han ikke være i stand til å beregne $a$, $b$ eller $z$ (de private verdiene). For å gjøre dette må man invertere eksponentialen, noe som er umulig uten å prøve alle mulighetene én etter én, siden det tilsvarer å beregne den diskrete logaritmen, dvs. den inverse av eksponentialen i en endelig syklisk gruppe.

Så lenge verdiene $a$, $b$ og $p$ er tilstrekkelig store, er Diffie-Hellman-protokollen derfor trygg. Med 2048-biters parametere (et tall med 600 desimaltall) vil det vanligvis være upraktisk å teste alle muligheter for $a$ og $b$. Til dags dato anses denne algoritmen som sikker med slike tall.

Det er nettopp her den største ulempen med Diffie-Hellman-protokollen ligger. For å være sikker må algoritmen bruke store tall. Derfor foretrekker man i dag ECDH-algoritmen (_Elliptic Curve Diffie-Hellman_), en variant av Diffie-Hellman som er basert på en algebraisk kurve, nærmere bestemt en elliptisk kurve. Denne tilnærmingen gjør det mulig å arbeide med mye mindre tall samtidig som man opprettholder tilsvarende sikkerhet, noe som reduserer ressursene som kreves for beregning og lagring.

Det generelle prinsippet for algoritmen forblir det samme. Men i stedet for å bruke et tilfeldig tall $a$ og et tall $A$ beregnet fra $a$ ved hjelp av modulær eksponentiering, bruker vi et nøkkelpar som er etablert på en elliptisk kurve. I stedet for å stole på distributiviteten til modulooperatoren, bruker vi gruppeloven på elliptiske kurver, og mer spesifikt assosiativiteten til denne loven.

For å forklare prinsippet om elliptisk kurvekryptografi kort, er en privat nøkkel representert ved et tilfeldig tall mellom $1$ og $n-1$, der $n$ representerer kurvens orden. Den offentlige nøkkelen er derimot et spesifikt punkt på denne kurven, som er hentet fra den private nøkkelen ved hjelp av addisjon og dobling av punkter som starter fra det genererende punktet, i henhold til ligningen:

$$
K = k \cdot G
$$

I denne formelen betegner $K$ den offentlige nøkkelen, $k$ den private nøkkelen og $G$ det genererende punktet.

En av de viktigste egenskapene ved disse nøklene er at det er enkelt å beregne $K$ fra $k$ og $G$, mens det er praktisk talt umulig å finne $k$ fra $K$ og $G$. Denne asymmetrien skaper en enveisfunksjon. Med andre ord er det enkelt å beregne den offentlige nøkkelen hvis man kjenner den private nøkkelen, men det er umulig å finne den private nøkkelen ut fra den offentlige nøkkelen. Denne sikkerheten er fortsatt avhengig av den diskrete logaritmens beregningsvansker.

Vi vil bruke denne egenskapen til å tilpasse Diffie-Hellman-algoritmen vår. **Prinsippet for ECDH er som følger


- Alice og Bob blir enige om en kryptografisk sikker elliptisk kurve og dens parametere. Denne informasjonen er offentlig;
- Alice genererer et tilfeldig tall $ka$ som blir hennes private nøkkel. Denne private nøkkelen må forbli hemmelig. Hun bestemmer sin offentlige nøkkel $Ka$ ved å addere og doble punkter på den valgte elliptiske kurven:

$$
K_a = k_a \cdot G
$$


- Bob genererer også et tilfeldig tall $kb$ som blir hans private nøkkel. Han beregner den tilhørende offentlige nøkkelen $kb$:

$$
K_b = k_b \cdot G
$$


- Alice og Bob utveksler sine offentlige nøkler $Ka$ og $Kb$ på et usikret, offentlig nettverk.
- Alice beregner et punkt $(x,y)$ på kurven ved å bruke sin private nøkkel $ka$ på Bobs offentlige nøkkel $Kb$:

$$
(x,y) = k_a \cdot K_b
$$


- Bob beregner et punkt $(x,y)$ på kurven ved å bruke sin private nøkkel $kb$ på Alices offentlige nøkkel $Ka$:

$$
(x,y) = k_b \cdot K_a
$$


- Alice og Bob får det samme punktet på den elliptiske kurven. Den delte hemmeligheten vil være $x$-koordinaten til dette punktet.

Faktisk får de den samme delte hemmeligheten fordi:

(x,y) = k_a \cdot K_b = k_a \cdot (k_b \cdot G) = (k_a \cdot k_b) \cdot G = (k_b \cdot k_a) \cdot G = k_b \cdot (k_a \cdot G) = k_b \cdot K_a

$$
Un attaccante che osserva la rete pubblica non protetta può ottenere solo le chiavi pubbliche di ciascuna parte e i parametri della curva ellittica scelta. Come precedentemente spiegato, queste informazioni da sole non sono sufficienti per determinare le chiavi private. Pertanto, l'attaccante non può trovare il segreto condiviso tra Alice e Bob.
ECDH è quindi un algoritmo che consente lo scambio di chiavi. È spesso utilizzato in combinazione con altri metodi crittografici per stabilire un protocollo completo. Ad esempio, ECDH è integrato nel nucleo di TLS (_Transport Layer Security_), un protocollo di crittografia e autenticazione utilizzato per il livello di trasporto di Internet. TLS utilizza ECDHE per lo scambio di chiavi, una variante di ECDH dove le chiavi sono effimere, per garantire la confidenzialità persistente. Inoltre, TLS utilizza algoritmi di autenticazione come ECDSA, algoritmi di crittografia come AES e funzioni hash come SHA256.
TLS è notevolmente responsabile della `s` in `https` così come del lucchetto visibile nella barra degli indirizzi del tuo browser, simboli delle comunicazioni criptate. Seguendo questo corso, stai quindi utilizzando ECDH, ed è molto probabile che lo usi quotidianamente senza nemmeno saperlo.
### La Transazione di Notifica
Come abbiamo visto nella sezione precedente, ECDH è una variante dello scambio Diffie-Hellman che utilizza coppie di chiavi stabilite su una curva ellittica. Convenientemente, possediamo già molte coppie di chiavi aderenti a questo standard nei nostri portafogli Bitcoin! L'idea di BIP47 è di utilizzare le coppie di chiavi dei portafogli Bitcoin gerarchici deterministici di entrambe le parti per stabilire segreti condivisi ed effimeri tra di loro. Nel contesto di BIP47, viene utilizzato ECDHE (_Elliptic Curve Diffie-Hellman Ephemeral_).
ECDHE viene utilizzato per la prima volta in BIP47 per trasmettere il codice di pagamento dal mittente al destinatario. Questo è il famoso **notification transaction**. Questo passaggio è essenziale perché affinché BIP47 funzioni efficacemente, entrambe le parti coinvolte (il mittente e il destinatario) devono conoscere il codice di pagamento dell'altro. Questa conoscenza consente la derivazione di chiavi pubbliche effimere e, di conseguenza, indirizzi di ricezione vuoti associati.
Prima di questo scambio, il mittente è logicamente già a conoscenza del codice di pagamento del destinatario poiché lo ha recuperato off-chain, ad esempio, dal loro sito web, una fattura o i loro social media. Tuttavia, il destinatario potrebbe non conoscere necessariamente il codice di pagamento del mittente. Eppure, questo codice deve essere trasmesso a loro; altrimenti, non saranno in grado di derivare le chiavi effimere necessarie per identificare gli indirizzi dove sono conservati i loro bitcoin, né accedere ai loro fondi. Sebbene questa trasmissione del codice del mittente possa tecnicamente essere effettuata off-chain attraverso altri mezzi di comunicazione, ciò pone un problema se il portafoglio deve essere recuperato solo dal seme.
Infatti, a differenza degli indirizzi convenzionali, gli indirizzi BIP47 non sono derivati direttamente dal seed del destinatario—utilizzare un `xpub` sarebbe più semplice in questo caso—ma risultano da un calcolo che combina i codici di pagamento di entrambi: quello del mittente e quello del destinatario. Pertanto, se il destinatario perde il proprio portafoglio e tenta di ripristinarlo dal proprio seed, recupererà il proprio codice di pagamento, che è derivato direttamente dal loro seed. Tuttavia, per trovare gli indirizzi effimeri, sarà essenziale per loro avere anche i codici di pagamento di tutti coloro che hanno inviato loro bitcoin tramite BIP47. Da qui l'importanza della transazione di notifica, che consente di salvare queste informazioni sulla blockchain di Bitcoin, pur essendo in grado di trovarle molto facilmente senza dover cercare tra il miliardo di transazioni eseguite dal suo lancio nel 2009.
![BTC204](assets/it/66/15.webp)
Pertanto, sarebbe possibile implementare BIP47 senza ricorrere alla transazione di notifica, a condizione che ogni utente conservi un backup dei codici di pagamento dei propri pari. Tuttavia, questo metodo si rivela complesso da gestire finché non viene sviluppata una soluzione semplice, robusta ed efficiente per creare, conservare e aggiornare questi backup. Nello stato attuale delle cose, la transazione di notifica diventa quasi indispensabile.
Nei capitoli seguenti, studieremo altri protocolli con obiettivi simili a quelli di BIP47, ma che non richiedono una transazione di notifica. Queste alternative, tuttavia, introducono i propri compromessi.
Oltre al suo ruolo nel backup dei codici di pagamento, la transazione di notifica serve anche una funzione di notifica per il destinatario, come suggerisce il suo nome. Segnala al client del destinatario che è stato stabilito un nuovo canale di pagamento e suggerisce quindi di monitorare gli indirizzi effimeri risultanti.
### Il Modello di Privacy di BIP47
Prima di dettagliare il funzionamento tecnico della transazione di notifica, è importante discutere il modello di privacy associato a BIP47, che giustifica alcune misure prese durante la creazione di questa transazione iniziale.
Il codice di pagamento, di per sé, non rappresenta un rischio diretto per la privacy. A differenza del modello Bitcoin tradizionale, che mira a rompere il collegamento tra l'identità di un utente e le sue transazioni (che sono pubbliche) preservando l'anonimato di chiavi e indirizzi, il codice di pagamento può essere apertamente associato a un'identità senza rappresentare una minaccia.
Infatti, il codice di pagamento non è utilizzato per derivare direttamente gli indirizzi che ricevono pagamenti BIP47. Questi indirizzi sono invece generati attraverso l'applicazione di ECDH tra le chiavi derivate dai codici di pagamento delle due parti coinvolte.
Così, un codice di pagamento di per sé non porta direttamente a una perdita di privacy, poiché solo l'indirizzo di notifica è derivato da esso. Sebbene questo indirizzo possa rivelare alcune informazioni, normalmente non consente di scoprire le parti con cui si stanno conducendo transazioni, a meno che non si effettui un'analisi approfondita della catena. Infatti, se il mittente utilizza UTXO che possono essere collegati alla loro identità per eseguire la transazione di notifica, allora diventa possibile dedurre che la loro identità è probabilmente collegata ai pagamenti BIP47 al tuo codice di pagamento. Questo non rivelerà le transazioni sottostanti, ma indicherà la loro probabile esistenza.
Pertanto, è essenziale mantenere questa stretta separazione tra i codici di pagamento degli utenti. Verso questo obiettivo, il passo iniziale di comunicazione del codice è un momento critico per la privacy del pagamento, ma obbligatorio per il corretto funzionamento del protocollo. Se uno dei codici di pagamento può essere ottenuto pubblicamente (come su un sito web), il secondo codice, quello del mittente, non deve essere collegato al primo in nessun caso.
Prendiamo un esempio concreto: voglio fare una donazione a un movimento politico tramite BIP47:
- L'organizzazione ha reso pubblico il suo codice di pagamento sul suo sito web o tramite i suoi social network;
- Questo codice è quindi collegato al movimento politico;
- Recupero questo codice di pagamento;
- Prima di procedere con un invio, devo assicurarmi che conoscano il mio codice di pagamento, che è anche collegato alla mia identità poiché lo uso per ricevere transazioni sui miei social network.
Come trasmettere il mio codice senza rischi? L'uso di mezzi di comunicazione convenzionali potrebbe portare a una fuga di informazioni e, di conseguenza, associarmi a questo movimento politico. La transazione di notifica offre una soluzione grazie a uno strato di crittografia che impedisce precisamente questa associazione tra due codici. Sebbene questo non sia l'unico metodo per trasmettere segretamente il codice di pagamento del mittente, si dimostra molto efficace.
Nel diagramma sottostante, le linee arancioni indicano i punti in cui il flusso di informazioni deve essere interrotto, e le frecce nere mostrano le connessioni che potrebbero potenzialmente essere osservate da terze parti:
![BTC204](assets/it/66/16.webp)
In realtà, all'interno del modello tradizionale di privacy di Bitcoin, è spesso complesso dissociare completamente il flusso di informazioni tra la coppia di chiavi e l'utente, specialmente durante le transazioni a distanza. Ad esempio, nel contesto di una campagna di donazione, il destinatario deve inevitabilmente divulgare un indirizzo o una chiave pubblica tramite il loro sito web o social network. L'uso corretto di BIP47, in particolare con la transazione di notifica, permette di aggirare questo problema grazie a ECDHE e allo strato di crittografia che studieremo ulteriormente.
Ovviamente, il modello classico di privacy di Bitcoin si applica ancora alle chiavi pubbliche effimere, che sono derivate dalla combinazione dei due codici di pagamento. I due modelli sono in realtà complementari. Quello che voglio evidenziare qui è che, contrariamente all'uso abituale di una chiave pubblica per ricevere bitcoin, il codice di pagamento può essere collegato a una specifica identità, perché l'informazione "_Alice effettua una transazione con Bob_" viene interrotta in un'altra fase. Il codice di pagamento viene utilizzato per generare indirizzi di pagamento, ma basandosi unicamente sull'osservazione della blockchain, è impossibile collegare una transazione di pagamento BIP47 ai codici di pagamento utilizzati per eseguirla, a meno che gli UTXO coinvolti non fossero già collegati a un'identità precedentemente e gli utenti non abbiano associato i loro codici di pagamento alle rispettive identità.
Per riassumere, il modello di privacy offerto dai pagamenti BIP47 potrebbe essere considerato superiore a quello della base di Bitcoin, anche se non è magico in alcun modo.
### Costruzione della Transazione di Notifica
Ora, vediamo come funziona questa transazione di notifica. Immaginiamo che Alice voglia inviare fondi a Bob con BIP47. Nel mio esempio, Alice agisce come mittente e Bob come destinatario. Quest'ultimo ha pubblicato il suo codice di pagamento sul suo sito web. Pertanto, Alice è già a conoscenza del codice di pagamento di Bob.
**1- Alice calcola un segreto condiviso con ECDH:**
- Seleziona una coppia di chiavi dal suo portafoglio HD situato su un ramo diverso dal suo codice di pagamento. Nota, questa coppia non dovrebbe essere facilmente associata all'indirizzo di notifica di Alice, né all'identità di Alice (vedi sezione precedente);
- Alice seleziona la chiave privata da questa coppia. La chiamiamo $a$ (minuscolo);
$$

a

$$
```text
- Alice recupera la chiave pubblica associata all'indirizzo di notifica di Bob. Questa chiave è la prima figlia derivata dal codice di pagamento di Bob (indice $/0$). Chiamiamo questa chiave pubblica $B$ (maiuscolo). La chiave privata associata a questa chiave pubblica è chiamata $b$ (minuscolo). $B$ è determinata dall'addizione e dal raddoppio dei punti sulla curva ellittica da $G$ (il punto generatore) con $b$ (la chiave privata):
$$ B = b \cdot G $$
- Alice calcola un punto segreto $S$ (maiuscolo) sulla curva ellittica tramite l'addizione e il raddoppio dei punti applicando la sua chiave privata $a$ dalla chiave pubblica di Bob $B$.
$$ S = a \cdot B $$
- Alice calcola il fattore di oscuramento $f$ che le permetterà di criptare il suo codice di pagamento. Per fare ciò, determinerà un numero pseudo-casuale con la funzione HMAC-SHA512. Nel secondo input di questa funzione, utilizza un valore che solo Bob potrà recuperare: $x$ che è l'ascissa del punto segreto precedentemente calcolato. Il primo input è $o$ che è l'UTXO consumato in input di questa transazione (outpoint).
$$ f = \text{HMAC-SHA512}(o, x) $$
**2- Alice converte il suo codice di pagamento personale in base 2 (binario).**
**3- Utilizza questo fattore di oscuramento come chiave per eseguire la crittografia simmetrica sul payload del suo codice di pagamento.** L'algoritmo di crittografia utilizzato è semplicemente un `XOR`. L'operazione eseguita è paragonabile alla cifratura di Vernam, anche denominata "One-Time Pad".
- Alice prima divide il suo fattore di oscuramento in due: i primi 32 byte sono denominati $f1$ e gli ultimi 32 byte sono denominati $f2$. Quindi, abbiamo:
$$ f = f1 || f2 $$
- Alice calcola l'$x'$ criptato dell'ascissa della chiave pubblica $x$ del suo codice di pagamento, e il $c'$ criptato del suo codice catena $c$ separatamente. $f1$ e $f2$ agiscono rispettivamente come chiavi di crittografia. L'operazione utilizzata è il `XOR` (o esclusivo).
$$ x' = x \oplus f1 $$
$$ c' = c \oplus f2 $$
- Alice sostituisce i valori reali dell'ascissa della chiave pubblica $x$ e del codice catena $c$ nel suo codice di pagamento con i valori criptati $x'$ e $c'$.
**4-** Alice ora ha il suo codice di pagamento con un payload criptato. Costruirà e trasmetterà una transazione che coinvolge la sua chiave pubblica $A$ come input, un output all'indirizzo di notifica di Bob, e un output `OP_RETURN` contenente il suo codice di pagamento con il payload criptato. **Questa transazione è la transazione di notifica**.
Un `OP_RETURN` è un opcode che segna un output di una transazione Bitcoin come non valido. Oggi, è utilizzato per trasmettere o ancorare informazioni sulla blockchain di Bitcoin. Fino a 80 byte di dati possono essere memorizzati, che sono scritti sulla catena e quindi visibili a tutti gli altri utenti.
Come abbiamo visto nelle sezioni precedenti, ECDH è utilizzato per generare un segreto condiviso tra due utenti che comunicano su una rete non sicura, potenzialmente osservata da attaccanti. In BIP47, ECDH è utilizzato per la comunicazione sulla rete Bitcoin, che per sua natura è una rete di comunicazione trasparente osservata da molti attaccanti. Il segreto condiviso calcolato tramite lo scambio di chiavi ECDH è poi utilizzato per criptare le informazioni segrete da trasmettere: il codice di pagamento del mittente (di Alice).
Ricapitoliamo i passaggi che abbiamo appena esaminato insieme per eseguire una transazione di notifica:
- Alice recupera il codice di pagamento e l'indirizzo di notifica di Bob;
- Alice seleziona un UTXO che possiede nel suo portafoglio HD con la corrispondente coppia di chiavi;
- Calcola un punto segreto sulla curva ellittica utilizzando ECDH;
- Utilizza questo punto segreto per calcolare un HMAC, che è il fattore di oscuramento;
- Utilizza questo fattore di oscuramento per criptare il payload del suo codice di pagamento personale.
- Lei utilizza un output di transazione `OP_RETURN` per comunicare il codice di pagamento mascherato a Bob.
![BTC204](assets/it/66/17.webp)
### Transazione di Notifica: Studio Concreto
Per comprendere meglio il suo funzionamento, in particolare l'uso di `OP_RETURN`, esaminiamo insieme una vera transazione di notifica. Ho eseguito tale transazione sulla testnet, che potete trovare [cliccando qui](https://mempool.space/fr/testnet/tx/0e2e4695a3c49272ef631426a9fd2dae6ec3a469e3a39a3db51aa476cd09de2e).
![BTC204](assets/fr/227.webp)
Osservando questa transazione, possiamo vedere che ha un singolo input e 4 output:
- Il primo output è l'`OP_RETURN` che contiene il mio codice di pagamento mascherato;
- Il secondo output di 546 sats punta all'indirizzo di notifica del mio destinatario;
- Il terzo output di 15.000 sats rappresenta le commissioni di servizio, poiché ho utilizzato Samourai Wallet per costruire questa transazione;
- Il quarto output di 2 milioni di sats rappresenta il resto, ovvero la differenza rimanente dal mio input che ritorna a un altro indirizzo che mi appartiene.
Il più interessante da studiare è ovviamente l'output 0 che utilizza l'`OP_RETURN`. Vediamo più da vicino cosa contiene. Ecco lo `scriptPubKey` in esadecimale:
6a4c50010002b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d800000000000000000000000000
```

```text
In questo script, possiamo sezionare diverse parti. Prima di tutto, gli opcode:
6a4c
```

```text
Tra gli opcode, possiamo riconoscere `0x6a` che designa l'`OP_RETURN` e `0x4c` che designa l'`OP_PUSHDATA1`.
Il byte seguente questo ultimo opcode indica la dimensione del payload che segue. Indica `0x50`, ovvero 80 byte:
6a4c50
```

```text
Poi, abbiamo i metadati del mio codice di pagamento in chiaro:
010002
```

```text
La coordinata x criptata della chiave pubblica del mio codice di pagamento:
b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164
```

```text
Il codice catena criptato del mio codice di pagamento:
927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d8
```

```text
E infine, il padding per raggiungere 80 byte, la dimensione standard di un `OP_RETURN`:
00000000000000000000000000
```

```
Per capire meglio, ecco il mio codice di pagamento in chiaro in base 58:
````text
PM8TJQCyt6ovbozreUCBrfKqmSVmTzJ5vjqse58LnBzKFFZTwny3KfCDdwTqAEYVasn11tTMPc2FJsFygFd3YzsHvwNXLEQNADgxeGnMK8Ugmin62TZU
Quando si confronta il mio codice di pagamento in chiaro con l'`OP_RETURN`, è evidente che l'HRP (`0x47`) e il checksum (`0x8604e4db`) non vengono trasmessi. Questo è previsto, poiché queste informazioni sono destinate agli esseri umani.
Successivamente, possiamo identificare la versione (`0x01`), il campo di bit (`0x00`) e la parità della chiave pubblica (`0x02`). E, alla fine del codice di pagamento, i byte vuoti (`0x00000000000000000000000000`) sono utilizzati per riempire il codice fino a un totale di 80 byte. Tutti questi metadati vengono trasmessi in chiaro (non criptati).
Infine, si può osservare che la coordinata x della chiave pubblica (`0x77507c9c17a89cfca2d3af554745d6c2db0e7f6b2721a3941a504933103cc42a`) e il codice catena (`0xdd94881210d6e752a9abc8a9fa0070e85184993c4f643f1121dd807dd556d1dc`) sono stati criptati. Questo costituisce il payload del codice di pagamento.
### Cos'è XOR?
Nelle sezioni precedenti, abbiamo visto che il codice di pagamento è stato trasmesso criptato utilizzando l'operazione XOR. Prendiamoci un momento per capire come funziona questo operatore, poiché è ampiamente utilizzato nella crittografia.
XOR è un operatore logico bit a bit basato sull'algebra booleana. Con due operandi bit, restituisce `1` se i bit dello stesso rango sono diversi, e restituisce `0` se i bit dello stesso rango sono uguali. Ecco la tabella di verità di XOR basata sui valori degli operandi `D` e `E`:
| D   | E   | D XOR E |
| --- | --- | ------- |
| 0   | 0   | 0       |
| 0   | 1   | 1       |
| 1   | 0   | 1       |
| 1   | 1   | 0       |
Per esempio:
$$

$$
0110 \oplus 1110 = 1000
Oppure:
$$

$$
010011 \oplus 110110 = 100101
Con ECDH, l'uso di XOR come strato di crittografia è particolarmente adatto. Innanzitutto, a causa di questo operatore, la crittografia è simmetrica. Questo consente al destinatario di decifrare il codice di pagamento con la stessa chiave utilizzata per la crittografia. La chiave di crittografia e decrittografia viene calcolata dal segreto condiviso grazie a ECDH. Questa simmetria è resa possibile dalle proprietà commutativa e associativa dell'operatore XOR:
- Altre proprietà:
$$

$$
D \oplus D = 0
D ⊕ 0 = D
- Commutatività:
$$

$$
D \oplus E = E \oplus D
- Associatività:
$$

$$
D \oplus (E \oplus Z) = (D \oplus E) \oplus Z = D \oplus E \oplus Z
Se:
$$

$$
D \oplus E = L
Allora:
$$

$$
D \oplus L = D \oplus (D \oplus E) = D \oplus D \oplus E = 0 \oplus E = E \\
\therefore D \oplus L = E
Successivamente, questo metodo di cifratura assomiglia molto al cifrario di Vernam (One-Time Pad), l'unico algoritmo di cifratura conosciuto fino ad oggi che possiede sicurezza incondizionata (o assoluta). Affinché il cifrario di Vernam abbia questa caratteristica, la chiave di cifratura deve essere perfettamente casuale, deve essere della stessa dimensione del messaggio e deve essere utilizzata una sola volta. Nel metodo di cifratura utilizzato qui per BIP47, la chiave è effettivamente della stessa dimensione del messaggio, il fattore di offuscamento è esattamente della stessa dimensione della concatenazione della coordinata x della chiave pubblica con il codice catena del codice di pagamento. Questa chiave di cifratura è effettivamente utilizzata una sola volta. Tuttavia, questa chiave non è il risultato di una casualità perfetta poiché è un HMAC. È piuttosto pseudo-casuale. Pertanto, non si tratta di un cifrario di Vernam, ma il metodo è simile.
### Ricezione della Transazione di Notifica
Ora che Alice ha inviato la transazione di notifica a Bob, vediamo come lui la interpreta. Come promemoria, Bob deve essere in grado di accedere al codice di pagamento di Alice. Senza queste informazioni, come vedremo nella sezione seguente, non sarà in grado di derivare le coppie di chiavi create da Alice e, quindi, non sarà in grado di accedere ai suoi bitcoin ricevuti tramite BIP47. Per ora, il payload del codice di pagamento di Alice è criptato. Vediamo come Bob lo decifra.
**1-** Bob monitora le transazioni che creano output con il suo indirizzo di notifica.
**2-** Quando una transazione ha un output sul suo indirizzo di notifica, Bob la analizza per vedere se contiene un output OP_RETURN che segue lo standard BIP47.
**3-** Se il primo byte del payload OP_RETURN è `0x01`, Bob inizia la sua ricerca di un possibile segreto condiviso con ECDH:
- Bob seleziona la chiave pubblica nell'input della transazione. Ovvero, la chiave pubblica di Alice denominata $A$ con:
$$ A = a \cdot G $$
- Bob seleziona la chiave privata $b$ associata al suo indirizzo di notifica personale:
$$ b $$
- Bob calcola il punto segreto $S$ (segreto condiviso ECDH) sulla curva ellittica sommando e raddoppiando i punti, applicando la sua chiave privata $b$ alla chiave pubblica di Alice $A$:
$$ S = b \cdot A $$
- Bob determina il fattore di offuscamento $f$ che gli permetterà di decifrare il payload del codice di pagamento di Alice. Nello stesso modo in cui Alice aveva precedentemente calcolato, Bob troverà $f$ applicando HMAC-SHA512 su $x$ la coordinata x del punto segreto $S$, e su $o$ l'UTXO consumato come input in questa transazione di notifica:
$$ f = \text{HMAC-SHA512}(o, x) $$
**4-** Bob interpreta i dati nell'OP_RETURN della transazione di notifica come un codice di pagamento. Egli semplicemente decifra il payload di questo potenziale codice di pagamento usando il fattore di offuscamento $f$:
- Bob divide il fattore di offuscamento $f$ in 2 parti: i primi 32 byte di $f$ saranno $f1$ e gli ultimi 32 byte saranno $f2$;
- Bob decifra la coordinata x cifrata $x'$ della chiave pubblica dal codice di pagamento di Alice:
$$ x = x' \oplus f1 $$
- Bob decifra il valore del codice catena cifrato $c'$ dal codice di pagamento di Alice:
$$ c = c' \oplus f2 $$
**5-** Bob verifica se il valore della chiave pubblica dal codice di pagamento di Alice è effettivamente parte del gruppo secp256k1. Se è così, lo interpreta come un codice di pagamento valido. Altrimenti, ignora questa transazione.
Ora che Bob è a conoscenza del codice di pagamento di Alice, lei può inviargli fino a `2^32` pagamenti, senza mai dover effettuare un'altra transazione di notifica di questo tipo.
Perché funziona? Come fa Bob a determinare lo stesso fattore di offuscamento di Alice, e quindi a decifrare il suo codice di pagamento? Esaminiamo più da vicino il ruolo di ECDH in quello che abbiamo appena descritto.
Prima di tutto, stiamo trattando con la crittografia simmetrica. Questo significa che la chiave di cifratura e la chiave di decifratura sono lo stesso valore. Questa chiave nella transazione di notifica è il fattore di offuscamento:
$$ f = f1 || f2 $$
Pertanto, Alice e Bob devono ottenere lo stesso valore per $f$, senza trasmetterlo direttamente poiché un attaccante potrebbe rubarlo e decifrare le informazioni segrete. Questo fattore di offuscamento si ottiene applicando HMAC-SHA512 su 2 valori:
- la coordinata x di un punto segreto;
- e l'UTXO consumato come input nella transazione.
Bob, quindi, ha bisogno di queste due informazioni per decifrare il payload del codice di pagamento di Alice. Per l'UTXO come input, Bob può semplicemente recuperarlo osservando la transazione di notifica. Per il punto segreto, Bob dovrà usare ECDH. Come visto nella sezione precedente su Diffie-Hellman, semplicemente scambiando le rispettive chiavi pubbliche e applicando segretamente le proprie chiavi private alla chiave pubblica dell'altro, Alice e Bob possono trovare un punto specifico e segreto sulla curva ellittica. La transazione di notifica si basa su questo meccanismo:
- Coppia di chiavi di Bob:
$$ B = b \cdot G $$
- Coppia di chiavi di Alice:
$$ A = a \cdot G $$
- Per un segreto $S (x, y)$:
$$ S = a \cdot B = a \cdot (b \cdot G) = (b \cdot a) \cdot G = b \cdot A $$
Ora che Bob conosce il codice di pagamento di Alice, sarà in grado di rilevare i suoi pagamenti BIP47, e può derivare le chiavi private che bloccano i bitcoin ricevuti.
Ricapitoliamo i passaggi che abbiamo appena esaminato per ricevere e interpretare una transazione di notifica:
- Bob monitora gli output delle transazioni al suo indirizzo di notifica;
- Quando ne rileva uno, recupera le informazioni contenute nell'OP_RETURN;
- Bob seleziona la chiave pubblica in input e calcola un punto segreto usando ECDH;
- Usa questo punto segreto per calcolare un HMAC che è il fattore di offuscamento;
- Usa questo fattore di offuscamento per decifrare il payload del codice di pagamento di Alice contenuto nell'OP_RETURN.
### La Transazione di Pagamento BIP47
Studiamo ora insieme il processo di pagamento con BIP47. Per ricordarvi lo stato attuale delle cose:
- Alice conosce il codice di pagamento di Bob, che ha semplicemente recuperato dal suo sito web;
- Bob conosce il codice di pagamento di Alice grazie alla transazione di notifica;
- Alice effettuerà un primo pagamento a Bob. Potrà effettuarne molti altri allo stesso modo.
Prima di spiegare questo processo, penso sia importante ricordare gli indici su cui stiamo attualmente lavorando. Il percorso di derivazione di un codice di pagamento è descritto come segue: `m/47'/0'/0'`. La profondità successiva distribuisce gli indici in questo modo:
- La prima coppia di chiavi figlio normali (non rinforzate) è quella utilizzata per generare l'indirizzo di notifica di cui abbiamo parlato nella parte precedente: `m/47'/0'/0'/0`;
- Le coppie di chiavi figlio normali sono utilizzate all'interno di ECDH per generare indirizzi di ricezione dei pagamenti BIP47 come vedremo in questa sezione: da `m/47'/0'/0'/0` a `m/47'/0'/0'/2 147 483 647`;
- Le coppie di chiavi figlio rinforzate sono codici di pagamento effimeri: da `m/47'/0'/0'/0'` a `m/47'/0'/0'/2 147 483 647'`.
Ogni volta che Alice desidera inviare un pagamento a Bob, deriva un nuovo indirizzo vergine unico, grazie ancora al protocollo ECDH:
- Alice seleziona la prima chiave privata derivata dal suo codice di pagamento personale riutilizzabile:
$$ a $$
- Alice seleziona la prima chiave pubblica inutilizzata derivata dal codice di pagamento di Bob. Questa chiave pubblica, la chiameremo $B$. È associata alla chiave privata $b$ che solo Bob conosce:
$$ B = b \cdot G $$
- Alice calcola un punto segreto $S$ sulla curva ellittica tramite addizione e raddoppio di punti applicando la sua chiave privata $a$ alla chiave pubblica $B$ di Bob:
$$ S = a \cdot B $$
- Da questo punto segreto, Alice calcolerà il segreto condiviso $s$ (minuscolo). Per fare ciò, seleziona la coordinata x del punto segreto $S$ denominata $Sx$, e passa questo valore attraverso la funzione hash SHA256:
$$ S = (Sx, Sy) $$
$$ s = \text{SHA256}(Sx) $$
- Alice utilizza questo segreto condiviso $s$ per calcolare un indirizzo Bitcoin di ricezione dei pagamenti. Inizialmente, verifica che $s$ sia contenuto nell'ordine della curva secp256k1. In caso contrario, incrementa l'indice della chiave pubblica di Bob per derivare un altro segreto condiviso;
- In secondo luogo, calcola una chiave pubblica $K0$ aggiungendo sulla curva ellittica i punti $B$ e $s·G$. In altre parole, Alice aggiunge la chiave pubblica derivata dal codice di pagamento di Bob $B$ con un altro punto calcolato sulla curva ellittica tramite addizione e raddoppio con il segreto condiviso $s$ dal punto generatore della curva secp256k1 $G$. Questo nuovo punto rappresenta una chiave pubblica, e lo chiamiamo $K0$:
$$ K0 = B + s \cdot G $$
- Con questa chiave pubblica $K0$, Alice può derivare un indirizzo vergine standard di ricezione (per esempio, SegWit V0 in bech32).
Una volta che Alice ha ottenuto l'indirizzo di ricezione di Bob $K0$, può eseguire una transazione Bitcoin in modo standard. Per fare ciò, seleziona un UTXO di sua proprietà, assicurato da una coppia di chiavi di un ramo diverso del suo portafoglio HD, e lo spende per soddisfare un output all'indirizzo di Bob $K0$. È importante notare che questo pagamento, una volta derivato l'indirizzo, segue un processo convenzionale e non dipende più dalle chiavi associate a BIP47.
Ricapitoliamo i passaggi che abbiamo appena eseguito insieme per inviare un pagamento BIP47:
- Alice seleziona la prima chiave privata derivata dal suo codice di pagamento personale;
- Calcola un punto segreto sulla curva ellittica utilizzando ECDH dalla prima chiave pubblica derivata non utilizzata dal codice di pagamento di Bob;
- Utilizza questo punto segreto per calcolare un segreto condiviso con SHA256;
- Utilizza questo segreto condiviso per calcolare un nuovo punto segreto sulla curva ellittica;
- Aggiunge questo nuovo punto segreto alla chiave pubblica di Bob;
- Ottiene una nuova chiave pubblica effimera per la quale solo Bob ha la chiave privata associata;
- Alice può effettuare una transazione standard a Bob con l'indirizzo di ricezione effimero derivato.
![BTC204](assets/it/66/21.webp)
Se Alice desidera effettuare un secondo pagamento, seguirà gli stessi passaggi di prima, eccetto che questa volta selezionerà la seconda chiave pubblica derivata dal codice di pagamento di Bob. Specificamente, utilizzerà la prossima chiave non utilizzata. Otterrà così un nuovo indirizzo di ricezione appartenente a Bob, designato $K1$:
![BTC204](assets/it/66/22.webp)
Può continuare in questo modo e derivare fino a `2^32` indirizzi non utilizzati appartenenti a Bob.
Da un punto di vista esterno, osservando la blockchain, è teoricamente impossibile differenziare un pagamento BIP47 da un pagamento standard. Ecco un esempio di transazione di pagamento BIP47 sul Testnet:
```

94b2e59510f2e1fa78411634c98a77bbb638e28fb2da00c9f359cd5fc8f87254
````
Questo sembra una transazione standard con un input consumato, un output di pagamento e un resto:
![BTC204](assets/fr/232.webp)
### Ricevere il Pagamento BIP47 e Derivare la Chiave Privata
Alice ha appena effettuato il suo primo pagamento a un nuovo indirizzo BIP47 appartenente a Bob. Ora vediamo come Bob riceve questo pagamento. Vedremo anche perché Alice non ha accesso alla chiave privata dell'indirizzo che ha appena generato da sola, e come Bob recupera questa chiave per spendere i bitcoin che ha appena ricevuto.
Non appena Bob riceve la transazione di notifica da Alice, deriva la chiave pubblica BIP47 $K0$ anche prima che lei abbia inviato qualsiasi pagamento. Poi monitora qualsiasi pagamento all'indirizzo associato. Infatti, deriva immediatamente diversi indirizzi che monitorerà ($K0$, $K1$, $K2$, $K3$...). Ecco come deriva questa chiave pubblica $K0$:
- Bob seleziona la prima chiave privata derivata dal suo codice di pagamento. Questa chiave privata è denominata $b$. È associata alla chiave pubblica $B$ con cui Alice aveva fatto i suoi calcoli nel passaggio precedente:
$$ b $$
- Bob seleziona la prima chiave pubblica di Alice derivata dal suo codice di pagamento. Questa chiave è denominata $A$. È associata alla chiave privata $a$ con cui Alice aveva fatto i suoi calcoli, e di cui solo Alice è a conoscenza. Bob può eseguire questo processo poiché è a conoscenza del codice di pagamento di Alice che le è stato trasmesso con la transazione di notifica:
$$ A = a \cdot G $$
- Bob calcola il punto segreto $S$, mediante addizione e raddoppio di punti sulla curva ellittica, applicando la sua chiave privata $b$ alla chiave pubblica di Alice $A$. Qui troviamo l'uso di ECDH che garantisce che questo punto $S$ sarà lo stesso sia per Bob che per Alice:
$$ S = b \cdot A $$
- Proprio come ha fatto Alice, Bob isola la coordinata x di questo punto $S$. Abbiamo chiamato questo valore $Sx$. Egli passa questo valore attraverso la funzione SHA256 per trovare il segreto condiviso $s$ (minuscolo):
$$ s = \text{SHA256}(Sx) $$
- Proprio come Alice, Bob calcola il punto $s·G$ sulla curva ellittica. Poi, aggiunge questo punto segreto alla sua chiave pubblica $B$. Ottiene così un nuovo punto sulla curva ellittica che interpreta come una chiave pubblica $K0$:
$$ K0 = B + s \cdot G $$
Una volta che Bob ha questa chiave pubblica $K0$, può derivare la chiave privata associata per essere in grado di spendere i suoi bitcoin. È l'unico che può generare questa chiave privata:
- Bob aggiunge la sua chiave privata figlio $b$ derivata dal suo codice di pagamento personale. È l'unico che può ottenere il valore di $b$. Poi, aggiunge $b$ con il segreto condiviso $s$ per ottenere $k0$, la chiave privata di $K0$:
$$ k0 = b + s $$
Grazie alla legge di gruppo della curva ellittica, Bob ottiene esattamente la chiave privata corrispondente alla chiave pubblica usata da Alice. Abbiamo quindi:
$$ K0 = k0 \cdot G $$
Riassumerò i passaggi che abbiamo appena esaminato insieme per ricevere un pagamento BIP47 e calcolare la chiave privata corrispondente:
- Bob seleziona la prima chiave privata figlio derivata dal suo codice di pagamento personale;
- Calcola un punto segreto sulla curva ellittica usando ECDH dalla prima chiave pubblica figlio derivata dal codice catena di Alice;
- Usa questo punto segreto per calcolare un segreto condiviso con SHA256;
- Usa questo segreto condiviso per calcolare un nuovo punto segreto sulla curva ellittica;
- Aggiunge questo nuovo punto segreto alla sua chiave pubblica personale;
- Ottiene una nuova chiave pubblica effimera, alla quale Alice invierà il suo primo pagamento;
- Bob calcola la chiave privata associata a questa chiave pubblica effimera aggiungendo la sua chiave privata figlio derivata dal suo codice di pagamento e il segreto condiviso.
![BTC204](assets/it/66/24.webp)
Poiché Alice non può ottenere $b$ (la chiave privata di Bob), lei non è in grado di determinare $k0$ (la chiave privata associata all'indirizzo di ricezione BIP47 di Bob). Schematicamente, possiamo rappresentare il calcolo del segreto condiviso $S$ così:
![BTC204](assets/it/66/19.webp)
Una volta trovato il segreto condiviso con ECDH, Alice e Bob calcolano la chiave pubblica di pagamento BIP47 $K0$, e Bob calcola anche la chiave privata associata $k0$:
![BTC204](assets/it/66/25.webp)
### Rimborsare il Pagamento BIP47
Poiché Bob è a conoscenza del codice di pagamento riutilizzabile di Alice, ha già tutte le informazioni necessarie per inviarle un rimborso. Non avrà bisogno di contattare nuovamente Alice per chiedere informazioni. Dovrà semplicemente notificarla con una transazione di notifica, specialmente affinché lei possa recuperare i suoi indirizzi BIP47 con il suo seed, e poi potrà anche inviarle fino a `2^32` pagamenti.
La funzionalità di rimborso è specifica per BIP47 ed è uno dei suoi vantaggi rispetto ad altri metodi che studieremo nei prossimi capitoli, come i Pagamenti Silenziosi.
Bob può quindi rimborsare Alice nello stesso modo in cui lei gli ha inviato i pagamenti. I ruoli si invertono:
![BTC204](assets/it/66/26.webp)
_Un grande ringraziamento a [Fanis Michalakis](https://x.com/FanisMichalakis) per la sua revisione e preziosi consigli esperti sull'articolo che ha ispirato la scrittura di questo capitolo!_
https://planb.network/tutorials/privacy/on-chain/paynym-bip47-a492a70b-50eb-4f95-a766-bae2c5535093
## Pagamenti Silenziosi
<chapterId>2871d594-414e-4598-a830-91c9eb84dfb8</chapterId>
Il BIP47 è stato criticato per la sua inefficienza sulla blockchain. Come spiegato nel capitolo precedente, richiede una transazione di notifica per ogni nuovo destinatario. Questo vincolo diventa trascurabile se si prevede di stabilire un canale di pagamento duraturo con questo destinatario. Infatti, una singola transazione di notifica apre la strada a un numero quasi infinito di pagamenti BIP47 successivi.
Tuttavia, in determinate situazioni, la transazione di notifica può rappresentare un ostacolo per l'utente. Prendiamo l'esempio di una donazione una tantum a un destinatario: con un indirizzo Bitcoin classico, una singola transazione è sufficiente per effettuare la donazione. Ma con il BIP47, sono necessarie due transazioni: una per la notifica e un'altra per il pagamento effettivo. Quando la domanda di spazio nel blocco è bassa e le commissioni di transazione sono minime, questo passaggio aggiuntivo generalmente non rappresenta un problema. Tuttavia, durante i periodi di congestione, le commissioni di transazione possono diventare esorbitanti per un singolo pagamento, potenzialmente raddoppiando il costo per l'utente rispetto a una transazione Bitcoin standard, il che può essere inaccettabile per l'utente.
Per situazioni in cui l'utente prevede di effettuare solo pochi pagamenti a un identificatore statico, sono state sviluppate altre soluzioni. Tra queste ci sono i Pagamenti Silenziosi, descritti nel [BIP352](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki). Questo protocollo consente l'uso di un identificatore statico per ricevere pagamenti senza generare riutilizzo dell'indirizzo e senza richiedere l'uso di transazioni di notifica. Esaminiamo come funziona questo protocollo.
---
_Per comprendere appieno questo capitolo, è essenziale essere familiari con il funzionamento di ECDH (Elliptic Curve Diffie-Hellman) e la derivazione delle chiavi crittografiche in un portafoglio HD. Questi concetti sono stati dettagliati nel capitolo precedente sul BIP47. Non li ripeterò qui. Se non sei ancora familiare con queste nozioni, ti consiglio di consultare il capitolo precedente prima di continuare con questo. Non riprenderò nemmeno i rischi associati al riutilizzo degli indirizzi di ricezione, né l'importanza di avere un identificatore unico per ricevere pagamenti._
---
### Perché non spostare la notifica?
Come discusso nel capitolo sul BIP47, la transazione di notifica svolge principalmente due funzioni:
- Notifica il destinatario;
- Trasmette il codice di pagamento del mittente.
Si potrebbe ingenuamente pensare che questo processo di notifica potrebbe essere effettuato off-chain. In teoria, ciò è completamente fattibile: sarebbe sufficiente per il destinatario indicare un mezzo di comunicazione per ricevere i codici di pagamento BIP47 dai mittenti. Tuttavia, questo approccio presenta due problemi principali:
- Primo, ciò sposterebbe il processo di trasmissione del codice su un altro protocollo di comunicazione. Le questioni relative ai costi e alla privacy dello scambio rimarrebbero, ma sarebbero semplicemente trasferite a questo nuovo protocollo. In termini di privacy, ciò potrebbe anche creare un collegamento tra l'identità di un utente e l'attività sulla blockchain, cosa che cerchiamo di evitare eseguendo la notifica direttamente sulla blockchain. Inoltre, effettuare la notifica fuori dalla blockchain introdurrebbe rischi di censura (come il blocco dei fondi) che non esistono su Bitcoin;
Successivamente, ciò porrebbe un problema di recupero. Con BIP47, il destinatario deve assolutamente conoscere i codici di pagamento dei mittenti per accedere ai fondi. Questo è vero al momento della ricezione, ma anche in caso di recupero dei fondi tramite il seed in caso di perdita del portafoglio. Con le notifiche onchain, questo rischio viene evitato, poiché l'utente può trovare e decifrare le transazioni di notifica semplicemente conoscendo il proprio seed. Tuttavia, se la notifica viene eseguita fuori dalla blockchain, l'utente dovrebbe mantenere un backup dinamico di tutti i codici di pagamento ricevuti, il che è impraticabile per l'utente medio.
Tutti questi vincoli rendono l'uso della notifica onchain indispensabile nel contesto di BIP47. Eppure, i Pagamenti Silenziosi cercano specificamente di evitare questo passaggio di notifica onchain a causa del suo costo. Pertanto, la soluzione adottata non è spostare la notifica, ma eliminarla completamente. Per raggiungere questo obiettivo, deve essere accettato un compromesso: quello della scansione. A differenza di BIP47, dove l'utente sa esattamente dove trovare i propri fondi grazie alle transazioni di notifica, nel contesto dei Pagamenti Silenziosi, l'utente deve esaminare tutte le transazioni Bitcoin esistenti per rilevare eventuali pagamenti che potrebbero essere destinati a loro. Per ridurre questo onere operativo, la ricerca di Pagamenti Silenziosi è limitata solo alle transazioni che probabilmente contengono tali pagamenti, ovvero quelle che includono almeno un output Taproot P2TR. La scansione si concentra esclusivamente anche sulle transazioni dalla data di creazione del portafoglio (non c'è bisogno di scandire transazioni risalenti al 2009 se il portafoglio è stato creato nel 2024).
Pertanto, potete vedere perché BIP47 e Pagamenti Silenziosi, sebbene mirino a un obiettivo simile, comportano compromessi diversi e **quindi si rivolgono effettivamente a casi d'uso distinti**. Per i pagamenti una tantum, come le donazioni occasionali, i Pagamenti Silenziosi sono più appropriati a causa del loro costo inferiore. Al contrario, per le transazioni regolari allo stesso destinatario, come nel caso delle piattaforme di scambio o dei pool di mining, BIP47 potrebbe essere preferito.
Esploriamo insieme il funzionamento tecnico dei Pagamenti Silenziosi per capirne meglio le implicazioni. Per fare ciò, suggerisco di adottare lo stesso approccio del documento esplicativo di BIP352. Scomporremo gradualmente i calcoli da eseguire, elemento per elemento, giustificando ogni nuova aggiunta.
### Alcuni concetti da comprendere
Prima di iniziare, è importante chiarire che i Pagamenti Silenziosi si basano esclusivamente sull'uso di tipi di script P2TR (_Pay to Taproot_). A differenza di BIP47, non è necessario derivare gli indirizzi di ricezione dalle chiavi pubbliche figlie tramite hashing. Infatti, nello standard P2TR, la chiave pubblica modificata viene utilizzata direttamente e apertamente nell'indirizzo. Così, un indirizzo di ricezione Taproot è essenzialmente una chiave pubblica accompagnata da alcuni metadati. Questa chiave pubblica modificata è l'aggregazione di altre due chiavi pubbliche: una che consente la spesa diretta e tradizionale tramite una semplice firma, e l'altra che rappresenta la radice di Merkle del MAST, che autorizza la spesa soggetta alla soddisfazione di una delle condizioni potenzialmente iscritte nell'albero di Merkle.
![BTC204](assets/it/67/01.webp)
La decisione di limitare i Pagamenti Silenziosi esclusivamente a Taproot è motivata da due ragioni principali:
- Primo, facilita significativamente l'implementazione e gli aggiornamenti futuri nel software del portafoglio, poiché è necessario aderire a un solo standard;
- In secondo luogo, questo approccio aiuta a migliorare l'insieme di anonimato degli utenti incoraggiandoli a non disperdersi tra diversi tipi di script, che generano impronte di portafoglio distinte nell'analisi della catena (per maggiori informazioni su questo concetto, vi invito a consultare il capitolo 4 della parte 2).
### Derivazione naive di una chiave pubblica di Pagamenti Silenziosi
Iniziamo con un semplice esempio che ti aiuterà a comprendere il funzionamento di base dei Pagamenti Silenziosi (SP, Silent Payments). Prendiamo Alice e Bob, due utenti Bitcoin. Alice vuole inviare bitcoin a Bob su un nuovo indirizzo di ricezione. Tre obiettivi devono essere raggiunti in questo processo:
- Alice deve essere in grado di generare un nuovo indirizzo;
- Bob deve essere in grado di identificare un pagamento inviato a questo specifico indirizzo;
- Bob deve essere in grado di ottenere la chiave privata associata a questo indirizzo per poter spendere i suoi fondi.
Alice ha un UTXO nel suo portafoglio Bitcoin protetto con la seguente coppia di chiavi:
- $a$: la chiave privata;
- $A$: la chiave pubblica ($A = a \cdot G$)
Bob ha un indirizzo SP che ha pubblicato su internet con:
- $b$: la chiave privata;
- $B$: la chiave pubblica ($B = b \cdot G$)
Recuperando l'indirizzo di Bob, Alice è in grado di calcolare un nuovo indirizzo vuoto che appartiene a Bob usando ECDH. Chiamiamo questo indirizzo $P$:
$$ P = B + \text{hash}(a \cdot B) \cdot G $$
In questa equazione, Alice ha semplicemente calcolato il prodotto scalare della sua chiave privata $a$ e della chiave pubblica di Bob $B$. Ha passato questo risultato attraverso una funzione hash conosciuta da tutti. Il valore di output è poi moltiplicato scalarmente per il punto generatore $G$ della curva ellittica `secp256k1`. Infine, Alice aggiunge il punto ottenuto alla chiave pubblica di Bob $B$. Una volta che Alice ha questo indirizzo $P$, lo usa come output in una transazione, il che significa che invia bitcoin ad esso.
> _Nel contesto dei Pagamenti Silenziosi, la funzione "hash" corrisponde a una funzione hash SHA256 etichettata specificamente con `BIP0352/SharedSecret`, assicurando che gli hash generati siano unici per questo protocollo e non possano essere riutilizzati in altri contesti, fornendo anche una protezione aggiuntiva contro il riutilizzo di nonce nelle firme. Questo standard corrisponde a quello [specificato nel BIP340 per le firme Schnorr](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) su `secp256k1`._
Grazie alle proprietà della curva ellittica su cui si basa ECDH, sappiamo che:
$$ a \cdot B = b \cdot A $$
Bob sarà quindi in grado di calcolare l'indirizzo di ricezione su cui Alice ha inviato i bitcoin. Per fare ciò, monitora tutte le transazioni Bitcoin che soddisfano i criteri dei Pagamenti Silenziosi e applica il seguente calcolo a ciascuna di esse per vedere se il pagamento è indirizzato a lui (_scanning_):
$$ P' = B + \text{hash}(b \cdot A) \cdot G $$
Quando esamina la transazione di Alice, si rende conto che $P'$ è uguale a $P$. Sa quindi che questo pagamento è indirizzato a lui:
$$ P' = B + \text{hash}(b \cdot A) \cdot G = B + \text{hash}(a \cdot B) \cdot G = P $$
Da qui, Bob sarà in grado di calcolare la chiave privata $p$ che consente di spendere l'indirizzo $P$:
$$ p = (b + \text{hash}(b \cdot A)) \bmod n $$
Come puoi vedere, per calcolare questa chiave privata $p$, è necessario avere la chiave privata $b$. Solo Bob ha questa chiave privata $b$. Sarà quindi effettivamente l'unico in grado di spendere i bitcoin inviati al suo indirizzo di Pagamenti Silenziosi.
![BTC204](assets/fr/236.webp)
_Didascalia:_
- $B$: La chiave pubblica / indirizzo statico pubblicato da Bob
- $b$: La chiave privata di Bob
- $A$: La chiave pubblica dell'UTXO di Alice usata come input per la transazione
- $a$: La chiave privata di Alice
- $G$: Il punto generatore della curva ellittica `secp256k1`
- $\text{SHA256}$: La funzione di hashing SHA256 etichettata con `BIP0352/SharedSecret`
- $s$: Il segreto comune ECDH
- $P$: La chiave pubblica / indirizzo unico per il pagamento a Bob
Ecco un approccio inizialmente piuttosto ingenuo nell'uso dell'indirizzo statico di Bob, denotato $B$, per derivare un indirizzo unico $P$ per inviare bitcoin. Tuttavia, questo metodo è troppo semplicistico e presenta diversi difetti che necessitano di correzione. Il primo problema è che, in questo schema, Alice non può creare molteplici output per Bob all'interno della stessa transazione.
### Come creare molteplici output?
Nell'esempio della sezione precedente, Alice crea un singolo output che andrà a Bob al suo indirizzo unico $P$. Con lo stesso input selezionato, è impossibile per Alice creare due indirizzi vergini distinti per Bob, poiché il metodo utilizzato porterebbe sempre allo stesso risultato per $P$, quindi allo stesso indirizzo. Tuttavia, ci possono essere molte situazioni in cui Alice desidera dividere il suo pagamento a Bob in diverse piccole somme, creando così molteplici UTXO. È quindi necessario trovare un metodo che permetta di farlo.
Per raggiungere questo obiettivo, modificheremo leggermente il calcolo che Alice esegue per derivare $P$, in modo che possa generare due indirizzi distinti per Bob, ovvero $P_0$ e $P_1$.
Per modificare il calcolo e ottenere 2 indirizzi diversi, è sufficiente aggiungere un intero che modifica il risultato. Così, Alice aggiungerà $0$ nel suo calcolo per ottenere l'indirizzo $P_0$ e $1$ per ottenere l'indirizzo $P_1$. Chiamiamo questo intero $i$:
$$ P_i = B + \text{hash}(a \cdot B \text{ ‖ } i) \cdot G $$
Il processo di calcolo rimane invariato rispetto al metodo precedente, eccetto che questa volta Alice concatenerà $a \cdot B$ con $i$ prima di procedere al hash. È quindi sufficiente cambiare $i$ per avere un nuovo indirizzo appartenente a Bob. Ad esempio:
$$ P_0 = B + \text{hash}(a \cdot B \text{ ‖ } 0) \cdot G $$
$$ P_1 = B + \text{hash}(a \cdot B \text{ ‖ } 1) \cdot G $$
Quando Bob esamina la blockchain per i Pagamenti Silenziosi destinati a lui, inizia utilizzando $i = 0$ per l'indirizzo $P_0$. Se non trova nessun pagamento su $P_0$, conclude che questa transazione non contiene nessun Pagamento Silenzioso per lui e smette di analizzarla. Tuttavia, se $P_0$ è valido e contiene un pagamento per lui, procede con $P_1$ nella stessa transazione per verificare se Alice ha effettuato un secondo pagamento. Se $P_1$ risulta essere invalido, interrompe la sua ricerca per questa transazione; altrimenti, continua a testare valori successivi di $i$.
$$ P_1 = B + \text{hash}(b \cdot A \text{ ‖ } 1) \cdot G $$
Poiché Bob si ferma immediatamente a $i = 0$ se $P_0$ non produce risultati, l'uso di questo intero aggiunge quasi nessun onere operativo aggiuntivo a Bob per la fase di scansione delle transazioni.
Bob può quindi calcolare le chiavi private nello stesso modo:
$$

p_0 = (b + \text{hash}(b \cdot A \text{ ‖ } 0)) \bmod n

$$
p_1 = (b + \text{hash}(b \cdot A \text{ ‖ } 1)) \bmod n
$$

_Didascalia:_


- $B$: La chiave pubblica / indirizzo statico pubblicato da Bob
- $b$: La chiave privata di Bob
- $A$: La chiave pubblica dell'UTXO di Alice usata come input per la transazione
- $a$: La chiave privata di Alice
- $G$: Il punto generatore della curva ellittica `secp256k1`
- $\tekst{SHA256}$: Funksjonen for hash SHA256 er opprettet med `BIP0352/SharedSecret`
- $s_0$: Il primo segreto condiviso ECDH
- $s_1$: Il secondo segreto condiviso ECDH
- $P_0$: La prima chiave pubblica / indirizzo unico per il pagamento a Bob
- $P_1$: La seconda chiave pubblica / indirizzo unico per il pagamento a Bob

Med denne metoden har vi begynt å lage en god protokoll, men det er også noen utfordringer som må overvinnes, særlig når det gjelder å hindre at vi utnytter indirizzi.

### Hvordan unngå at noen bruker indirizzi?

Som vi har sett i de foregående avsnittene, bruker Alice en gruppe chiavi som beskytter hennes UTXO, som hun bruker til å beregne segmentet ECDH med Bob. Dette segmentet gjør det mulig å avlede det eneste indekset $P_0$. Men Alice kan beskytte flere UTXO hvis hun har brukt dette indekset flere ganger. Hvis Alice utfører to betalinger til Bobs statiske kode $B$ ved å bruke to UTXO beskyttet av samme kode $A$, vil dette innebære at Bob bruker denne koden flere ganger.

> _Il riutilizzo degli indirizzi è una pratica molto negativa per la privacy degli utenti. For å forstå hvorfor, anbefaler vi at du leser de første delene av denne veiledningen
Infatti, poiché l'indirizzo unico $P_0$ è derivato da $A$ e $B$, se Alice deriva un secondo indirizzo per un secondo pagamento a $B$, con la stessa chiave $A$, finirà per ottenere lo stesso indirizzo $P_0$. For å unngå denne risikoen og forhindre at du bruker indeksene på innsiden av de stille betalingene, må vi endre våre beregninger.

Det vi ønsker er at alle UTXO som Alice bruker som input til en betaling, skal ha en unik indirizzo fra Bob, selv om flere UTXOer er beskyttet av den samme kopien av chiavi. Det er derfor tilstrekkelig å legge til en henvisning til UTXO i beregningen av det eneste indekset $P_0$. Denne referansen er ganske enkelt hashverdien til UTXO som brukes som input:

$$ \text{inputHash} = \text{hash}(\text{outpoint} \text{ ‖ } A) $$$

E questo riferimento di input, Alice lo aggiungerà nel suo calcolo dell'indirizzo unico $P_0$:

I løpet av sin skanning kan Bob også legge til $\text{inputHash}$, siden alt som må gjøres er å osservare transaksjonen for å dedurere $\text{outpoint}$:

$$ P_0 = B + \text{hash}(\text{inputHash} \cdot b \cdot A \text{ ‖ } 0) \cdot G $$$

Når du finner en gyldig $P_0$, kan du beregne den tilsvarende private chiave $p_0$:

$$
p_0 = (b + \text{hash}(\text{inputHash} \cdot b \cdot A \text{ ‖ } 0)) \bmod n
$$

```text
_Legenda:_
- $B$: La chiave pubblica / indirizzo statico pubblicato da Bob
- $b$: La chiave privata di Bob
- $A$: La chiave pubblica dell'UTXO di Alice usata come input per la transazione
- $a$: La chiave privata di Alice
- $H$: L'hash dell'UTXO usato come input
- $G$: Il punto generatore della curva ellittica `secp256k1`
- $\text{SHA256}$: La funzione di hash SHA256 etichettata con `BIP0352/SharedSecret`
- $s_0$: Il primo segreto condiviso ECDH
- $P_0$: La prima chiave pubblica / indirizzo unico per il pagamento a Bob
Al momento, i nostri calcoli presuppongono che Alice utilizzi un singolo input per la sua transazione. Tuttavia, dovrebbe essere in grado di utilizzare più input. Di conseguenza, da parte di Bob, per ogni transazione contenente più input, teoricamente avrebbe bisogno di calcolare l'ECDH per ogni input per determinare se un pagamento è destinato a lui. Questo metodo non è soddisfacente, quindi abbiamo bisogno di trovare una soluzione per ridurre il carico di lavoro!
### Modificare le chiavi pubbliche negli input
Per risolvere questo problema, invece di utilizzare la coppia di chiavi che protegge un input specifico da parte di Alice, useremo la somma di tutte le coppie di chiavi utilizzate negli input della transazione. Questa somma sarà quindi considerata come una nuova coppia di chiavi. Questa tecnica è nota come "tweak".
Per esempio, immagina che la transazione di Alice abbia 3 input, ognuno protetto con una coppia di chiavi diversa:
- $a_0$ protegge l'input #0;
- $a_1$ protegge l'input #1;
- $a_2$ protegge l'input #2.
Seguendo il metodo descritto sopra, Alice dovrebbe scegliere una singola coppia di chiavi tra $a_0$, $a_1$ e $a_2$ per calcolare il segreto ECDH e generare l'indirizzo di pagamento unico $P$ dall'indirizzo statico $B$ di Bob. Tuttavia, questo approccio richiede a Bob di testare ogni possibilità sequenzialmente, partendo da $a_0$, poi $a_1$, e così via, fino all'identificazione di una coppia che genera un indirizzo valido $P$. Questo processo richiede che Bob esegua il calcolo ECDH su tutti gli input di tutte le transazioni, aumentando significativamente il carico di lavoro operativo di scansione.
Per evitare ciò, chiederemo ad Alice di eseguire il suo calcolo di $P$ utilizzando la somma di tutte le chiavi in input. Prendendo il nostro esempio, la chiave privata modificata $a$ sarebbe calcolata come segue:
$$ a = a_0 + a_1 + a_2 $$
Allo stesso modo, Alice e Bob saranno in grado di calcolare la chiave pubblica modificata:
$$ A = A_0 + A_1 + A_2 $$
Grazie a questo metodo, a Bob basta calcolare la somma delle chiavi pubbliche della transazione, poi calcolare il segreto ECDH da $A$ soltanto, il che riduce notevolmente il numero di calcoli da fare per la fase di scansione. Tuttavia, ricorda dalla sezione precedente. Avevamo incluso nel nostro calcolo l'hash $\text{inputHash}$ che viene usato come nonce per prevenire il riutilizzo degli indirizzi:
$$ \text{inputHash} = \text{hash}(\text{outpoint} \text{ ‖ } A) $$
Ma se ci sono più input in una transazione, è necessario determinare quale $\text{outpoint}$ viene scelto in questo calcolo. Secondo il BIP352, il criterio di selezione per $\text{outpoint}$ da usare è scegliere il più piccolo lessicograficamente, il che significa selezionare l'UTXO che appare per primo in ordine alfabetico. Questo metodo standardizza l'UTXO da scegliere in ogni transazione. Ad esempio, se questo $\text{outpoint}$ più piccolo lessicograficamente è $\text{outpoint}_L$, il calcolo di $\text{inputHash}$ sarà:
$$ \text{inputHash} = \text{hash}(\text{outpoint}\_L \text{ ‖ } A) $$
I calcoli rimangono quindi identici a quelli presentati nella sezione precedente, eccetto che la chiave privata $a$ e la sua corrispondente chiave pubblica $A$ non rappresentano più una coppia che protegge un singolo input, ma ora rappresentano la modifica di tutte le coppie di chiavi negli input.
### Separare le Chiavi di Spesa e di Scansione
Finora, abbiamo discusso dell'indirizzo statico di Pagamento Silenzioso $B$ come di una chiave pubblica unica. Ricorda, è questa chiave pubblica $B$ che viene usata da Alice per creare il segreto condiviso ECDH, che a sua volta viene usato per calcolare l'indirizzo di pagamento unico $P$. Bob usa questa chiave pubblica $B$ e la corrispondente chiave privata $b$ per la fase di scansione. Ma userà anche la chiave privata $b$ per calcolare la chiave privata $p$ che consente di spendere dall'indirizzo $P$.
Lo svantaggio di questo metodo è che la chiave privata $b$, che viene usata per calcolare tutte le chiavi private per gli indirizzi che ricevono Pagamenti Silenziosi, viene anche usata da Bob per scansionare le transazioni. Questo passaggio richiede che la chiave $b$ sia disponibile su un software di portafoglio connesso a Internet, il che la espone a un rischio maggiore di furto rispetto al mantenerla su un portafoglio freddo. Idealmente, sarebbe vantaggioso poter approfittare dei Pagamenti Silenziosi mantenendo la chiave privata $b$, che controlla l'accesso a tutte le altre chiavi private, al sicuro su un portafoglio hardware. Fortunatamente, il protocollo è stato adattato per permettere esattamente questo.
Per raggiungere questo obiettivo, il BIP352 specifica che il ricevente usa 2 diverse coppie di chiavi:
- $B_{\text{spend}}$: per calcolare le chiavi private degli indirizzi di pagamento unici;
- $B_{\text{scan}}$: per trovare indirizzi di pagamento unici.
In questo modo, Bob può mantenere la chiave privata $b_{\text{spend}}$ su un portafoglio hardware e usare la chiave privata $b_{\text{scan}}$ su software online per trovare i suoi Pagamenti Silenziosi, senza rivelare $b_{\text{spend}}$. Tuttavia, le chiavi pubbliche $B_{\text{scan}}$ e $B_{\text{spend}}$ sono entrambe pubblicamente rivelate, poiché si trovano nell'indirizzo statico di Bob $B$:
Per calcolare un indirizzo di pagamento unico $P_0$ appartenente a Bob, Alice eseguirà il seguente calcolo:
$$ P*0 = B*{\text{spend}} + \text{hash}(\text{inputHash} \cdot a \cdot B\_{\text{scan}} \text{ ‖ } 0) \cdot G $$
Per trovare i pagamenti indirizzati a lui, Bob eseguirà il seguente calcolo:
$$ P*0 = B*{\text{spend}} + \text{hash}(\text{inputHash} \cdot b\_{\text{scan}} \cdot A \text{ ‖ } 0) \cdot G $$
Come puoi vedere, fino a questo momento, Bob non ha avuto bisogno di usare $b_{\text{spend}}$ che si trova sul suo portafoglio hardware. Quando desidera spendere $P_0$, può quindi eseguire il seguente calcolo per trovare la chiave privata $p_0$:
$$ p*0 = (b*{\text{spend}} + \text{hash}(\text{inputHash} \cdot b\_{\text{scan}} \cdot A \text{ ‖ } 0)) \bmod n $$
_Didascalia:_
- $B_{\text{scan}}$: Chiave pubblica di scansione di Bob (indirizzo statico)
- $b_{\text{scan}}$: Chiave privata di scansione di Bob
- $B_{\text{spend}}$: Chiave pubblica di spesa di Bob (indirizzo statico)
- $b_{\text{spend}}$: Chiave privata di spesa di Bob
- $A$: La somma delle chiavi pubbliche in input (tweak)
- $a$: La chiave privata corrispondente alla chiave pubblica modificata
- $H$: L'hash dell'UTXO più piccolo (lessicograficamente) usato in input
- $G$: Il punto generatore della curva ellittica `secp256k1`
- $\text{SHA256}$: La funzione di hashing SHA256 etichettata con `BIP0352/SharedSecret`
- $s_0$: Il primo segreto condiviso ECDH
- $P_0$: La prima chiave pubblica / indirizzo di pagamento unico per Bob
### Utilizzando indirizzi SP con un'etichetta
Bob ha quindi un indirizzo statico $B$ per i Pagamenti Silenziosi come segue:
$$ B = B*{\text{scan}} \text{ ‖ } B*{\text{spend}} $$
Il problema con questo metodo è che non permette di segregare i diversi pagamenti inviati a questo indirizzo. Ad esempio, se Bob ha 2 clienti diversi per la sua attività e vuole differenziare chiaramente i pagamenti da ciascuno, avrebbe bisogno di 2 indirizzi statici diversi. Una soluzione ingenua, con l'approccio attuale, sarebbe che Bob crei due portafogli separati, ognuno con il proprio indirizzo statico, o addirittura stabilisca due indirizzi statici diversi all'interno dello stesso portafoglio. Tuttavia, questa soluzione richiede la scansione dell'intera blockchain due volte (una per ciascun indirizzo) per rilevare rispettivamente i pagamenti destinati a ciascun indirizzo. Questa doppia scansione aumenta in modo irragionevole l'onere operativo per Bob.
Per risolvere questo problema, BIP352 utilizza un sistema di etichettatura che consente di avere diversi indirizzi statici senza aumentare in modo irragionevole il carico di lavoro per trovare Pagamenti Silenziosi sulla blockchain. Per fare ciò, viene aggiunto un intero $m$ alla chiave pubblica di spesa $B_{\text{spend}}$. Questo intero può assumere il valore di $1$ per il primo indirizzo statico, poi $2$ per il secondo, e così via. Le chiavi di spesa $B_{\text{spend}}$ saranno d'ora in poi chiamate $B_m$ e saranno costruite in questo modo:
$$ B*m = B*{\text{spend}} + \text{hash}(b\_{\text{scan}} \text{ ‖ } m) \cdot G $$
Per esempio, per la prima chiave di spesa con l'etichetta $1$:
$$ B*1 = B*{\text{spend}} + \text{hash}(b\_{\text{scan}} \text{ ‖ } 1) \cdot G $$
L'indirizzo statico pubblicato da Bob consisterà ora di $B_{\text{scan}}$ e $B_m$. Per esempio, il primo indirizzo statico con l'etichetta $1$ sarà:
$$ B = B\_{\text{scan}} \text{ ‖ } B_1 $$
> _Iniziamo solo dall'etichetta 1 perché l'etichetta 0 è riservata per il resto._
Alice, da parte sua, deriverà l'indirizzo di pagamento unico $P$ nello stesso modo di prima, ma utilizzando il nuovo $B_1$ invece di $B_{\text{spend}}$.
$$ P*0 = B_1 + \text{hash}(\text{inputHash} \cdot a \cdot B*{\text{scan}} \text{ ‖ } 0) \cdot G $$
In realtà, Alice potrebbe non sapere nemmeno che Bob ha un indirizzo etichettato, poiché lei semplicemente utilizza la seconda parte dell'indirizzo statico che lui le ha fornito, che in questo caso, è il valore $B_1$ piuttosto che $B_{\text{spend}}$.
Per scansionare i pagamenti, Bob utilizzerà sempre il valore del suo indirizzo statico iniziale con $B_{\text{spend}}$ in questo modo:
$$ P*0 = B*{\text{spend}} + \text{hash}(\text{inputHash} \cdot b\_{\text{scan}} \cdot A \text{ ‖ } 0) \cdot G $$
Poi, semplicemente sottrae il valore che trova per $P_0$ da ogni output uno per uno. Poi controlla se uno dei risultati di queste sottrazioni corrisponde al valore di una delle etichette che usa nel suo portafoglio. Se corrisponde, per esempio, per l'output #4 con l'etichetta $1$, ciò significa che questo output è un Pagamento Silenzioso associato al suo indirizzo statico etichettato $B_1$:
$$ Out*4 - P_0 = \text{hash}(b*{\text{scan}} \text{ ‖ } 1) \cdot G $$
Questo funziona perché:
$$ B*1 = B*{\text{spend}} + \text{hash}(b*{\text{scan}} \text{ ‖ } 1) \cdot G $$
Grazie a questo metodo, Bob può utilizzare una moltitudine di indirizzi statici ($B_1$, $B_2$, $B_3$...), tutti derivati dal suo indirizzo statico base ($B = B*{\text{scan}} \text{ ‖ } B*{\text{spend}}$), al fine di separare correttamente gli usi.
Tuttavia, questa separazione degli indirizzi statici è valida solo da una prospettiva di gestione personale del portafoglio e non consente la separazione delle identità. Poiché tutti hanno lo stesso $B*{\text{scan}}$, è molto facile associare tutti gli indirizzi statici insieme e dedurre che appartengono a una singola entità.
_Didascalia:_
- $B_{\text{scan}}$: chiave pubblica di scansione di Bob (indirizzo statico)
- $b_{\text{scan}}$: chiave privata di scansione di Bob
- $B_{\text{spend}}$: chiave pubblica di spesa di Bob (indirizzo iniziale)
- $B_m$: chiave pubblica di spesa etichettata di Bob (indirizzo statico)
- $b_m$: chiave privata di spesa etichettata di Bob
- $A$: La somma delle chiavi pubbliche in input (tweak)
- $a$: La chiave privata corrispondente alla chiave pubblica modificata
- $H$: L'hash del più piccolo UTXO (lessicograficamente) utilizzato come input
- $G$: Il punto generatore della curva ellittica `secp256k1`
- $\text{SHA256}$: La funzione di hashing SHA256 etichettata con `BIP0352/SharedSecret`
- $s_0$: Il primo segreto condiviso ECDH
- $P_0$: La prima chiave pubblica / indirizzo unico per il pagamento a Bob
- $p_0$: La chiave privata del primo indirizzo di pagamento unico a Bob
- $X$: L'hash della chiave privata di scansione con l'etichetta
### Come Costruire un Indirizzo per Pagamenti Silenziosi?
Per costruire un indirizzo dedicato ai Pagamenti Silenziosi, è necessario prima derivare 2 coppie di chiavi nel proprio portafoglio Bitcoin HD:
- La coppia $b_{\text{scan}}$, $B_{\text{scan}}$ per cercare i pagamenti indirizzati a noi;
- La coppia $b_{\text{spend}}$, $B_{\text{spend}}$ per spendere i bitcoin che abbiamo ricevuto.
Queste coppie sono derivate seguendo questi percorsi (_Bitcoin Mainnet_):
scan: m / 352' / 0' / 0' / 1' / 0
spend: m / 352' / 0' / 0' / 0' / 0
```

```text
Una volta disponibili queste 2 coppie di chiavi, si concatenano semplicemente (una di seguito all'altra) per creare il payload dell'indirizzo statico:
$$ B = B*{\text{scan}} \text{ ‖ } B*{\text{spend}} $$
Se si desidera utilizzare etichette, $B_{\text{spend}}$ viene sostituito con $B_m$:
$$ B = B\_{\text{scan}} \text{ ‖ } B_m $$
Con l'etichetta $m$:
$$ B*m = B*{\text{spend}} + \text{hash}(b\_{\text{scan}} \text{ ‖ } m) \cdot G $$
Una volta disponibile questo payload, si aggiunge la HRP (_Human-Readable Part_) `sp` e la versione `q` (= versione 0). Viene anche aggiunto un checksum, e l'indirizzo è formattato in bech32m.
Ad esempio, ecco il mio indirizzo statico per i Pagamenti Silenziosi:
sp1qqvhjvsq2vz8zwrw372vuzle7472zup2ql3pz64yn5cpkw5ngv2n6jq4nl8cgm6zmu48yk3eq33ryc7aam6jrvrg0d0uuyzecfhx2wgsumcurv77e
```