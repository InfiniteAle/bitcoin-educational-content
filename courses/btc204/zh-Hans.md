---
name: 比特币隐私
goal: 了解并掌握使用比特币时的隐私保护原则
objectives: 

  - 定义理解隐私保护利害关系所需的理论概念
  - 了解如何识别和降低与比特币用户隐私泄露相关的风险
  - 在比特币上使用保护隐私的方法和工具
  - 了解连锁分析方法并制定防御策略

---
# 保护比特币隐私

在金融交易隐私逐渐成为奢侈品的今天，了解和掌握比特币使用中的隐私保护原则至关重要。本培训从理论和实践两方面为您提供了实现这一目标的全部关键。

如今，在比特币上，有一些公司专门从事链分析。他们的核心业务正是侵犯你的隐私，以破坏你交易的保密性。事实上，比特币上的 "隐私权 "并不存在。因此，用户应该维护自己的自然权利，保护自己交易的机密性，因为没有人会替你这么做。

本培训是一门综合性的通识课程。每个技术概念都很详细，并配有解释性图表。目的是让每个人都能获得知识。因此，BTC204 适合初级和中级用户。本培训还为更有经验的比特币使用者提供了附加值，因为我们深入探讨了一些通常不熟悉的技术概念。

加入我们，改变你对比特币的使用，成为一个知情的用户，能够理解与保密有关的问题并保护你的隐私。

+++
# 导言

<partId>e17474a8-8899-4bdb-a7f8-bc52ddb01440</partId>

## 培训简介

<chapterId>08ba1933-f393-4fb5-8279-777d874caedb</chapterId>

在金融交易隐私逐渐成为奢侈品的今天，了解和掌握比特币使用中的隐私保护原则至关重要。本培训从理论和实践两方面为您提供了实现这一目标的全部关键。

如今，在比特币生态系统中，有一些公司专门从事区块链分析。他们的核心业务正是侵犯你的隐私，损害你交易的保密性。事实上，比特币上的 "隐私权 "并不存在。因此，用户应该维护自己的自然权利，保护自己交易的机密性，因为没有人会替你这么做。

比特币的存在不仅仅是为了 "数字上涨 "和储蓄保值。由于其独特的功能和历史，它主要是另类经济的工具。有了这项非凡的发明，你可以自由地管理你的钱，花掉它，积累它，没有任何人可以阻止你。

比特币提供了一种摆脱国家束缚的和平方式，使你能够充分享受你的自然权利，而这些权利是既定法律所无法挑战的。多亏了中本聪的发明，你才有权力行使自己的私有财产权，重获契约自由。

然而，比特币默认情况下不是匿名的，这可能会给从事替代经济的个人带来风险，尤其是在专制政权统治的地区。但这并不是唯一的危险。因为比特币是一种有价值的、不受审查的资产，它可能会引起小偷的注意。因此，保护个人隐私也是一个安全问题：它可以帮助你防止网络攻击和人身攻击。

正如我们将看到的，尽管比特币协议提供了某些固有的隐私保护，但使用其他工具来优化和保护这种隐私也是至关重要的。本课程旨在为理解比特币隐私问题提供一个全面、通俗的途径。每个技术概念都有详细的讨论，并附有解释性图表。目的是让每个人，包括初级和中级用户，都能了解这些知识。对于更有经验的比特币使用者，我们也会在课程中介绍一些非常技术性的，有时是鲜为人知的概念，以加深对每个主题的理解。

本课程的目的不是让您在使用比特币时完全匿名，而是为您提供必要的工具，让您知道如何根据个人目标保护自己的隐私。您可以根据自己的具体目标和需求，自由选择所介绍的概念和工具，制定自己的策略。

### 第 1 部分：定义和关键概念

首先，我们将一起了解比特币运行的基本原理，然后冷静地探讨与隐私相关的概念。掌握一些基本概念，如UTXOs、接收地址或脚本等，对我们完全理解下文中的概念至关重要。我们还将介绍中本聪所设想的比特币一般隐私模式，这将使我们能够掌握相关问题和风险。

![BTC204](assets/it/11/1.webp)

### 第 2 部分：了解连锁分析和如何保护自己

在第二部分，我们将研究区块链分析公司用来追踪你在比特币上的活动的技术。了解这些方法对于改善您的隐私保护至关重要。这一部分旨在研究攻击者的策略，以便更好地了解风险，并为我们在后续章节中研究的技术打下基础。我们将分析交易模式、内部和外部启发式方法以及对这些模式的合理解释。除了理论部分，我们还将通过实际案例和练习，学习如何使用区块资源管理器进行链分析。

![BTC204](assets/fr/002.webp)

### 第 3 部分：掌握保护隐私的最佳做法

在课程的第三部分，我们将进入问题的核心：实践！我们的目标是掌握所有基本的最佳实践，这应该成为任何比特币用户的自然反应。我们将介绍新地址的使用、标签、合并、全节点的使用以及 KYC 和获取方法。我们的目标是为你提供一个全面的概述，让你了解在寻求隐私保护的过程中应该避免的陷阱，从而为我们的隐私保护打下坚实的基础。对于其中的一些做法，我们将为您提供具体的实施教程。

![BTC204](assets/it/11/3.webp)

### 第 4 节：了解 Coinjoin 交易

说到比特币隐私，怎么能不讨论 coinjoin 呢？在第 4 节中，你将了解到关于这种混合方法的所有信息。你将了解到什么是 "币合"、"币合 "的历史和目标，以及不同类型的 "币合"。最后，对于更有经验的用户，我们将了解什么是anonsets和熵，以及如何计算这些指标。

![BTC204](assets/it/11/4.webp)

### 第 5 部分：了解其他高级隐私技术的问题

在第五部分，我们将概述除了 Coinjoin 之外，比特币上保护隐私的所有其他现有技术。多年来，开发者们在设计隐私保护工具方面表现出了极大的创造力。我们将研究所有这些方法，如 payjoin、协同交易、币币交换和原子交换，详细介绍它们的工作原理、目标和潜在弱点。

我们还将讨论节点网络层面的隐私和交易扩散问题。我们还将讨论多年来为改善比特币用户隐私而提出的各种协议，包括静态地址协议。

![BTC204](assets/fr/005.webp)

# 定义和关键概念

<partId>b9bbbde3-34c0-4851-83e8-e2ffb029cf31</partId>

## 比特币的UTXO模式

<chapterId>8d6b50c5-bf74-44f4-922b-25204991cb75</chapterId>

比特币主要是一种货币，但你知道 BTC 在协议中是如何具体体现的吗？

### 比特币的UTXO：它们是什么？

在比特币协议中，货币单位的管理基于UTXO模式，即 "未用交易输出"。

这种模式与传统的银行系统大相径庭，后者依靠账户和余额机制来跟踪资金流动。事实上，在银行系统中，个人余额保存在与身份相关联的账户中。例如，当你从面包师那里买了一根法棍，你的银行只需从你的账户中扣除购买金额，从而减少你的余额，而面包师的账户则贷记同样的金额，增加其余额。在这个系统中，除了交易记录之外，你的账户中的资金流入和流出之间没有任何联系。

在比特币上，情况有所不同。账户的概念并不存在，货币单位的管理不是通过余额，而是通过UTXO。一个UTXO代表一个尚未花费的特定数量的比特币，从而形成一个 "比特币碎片"，可大可小。例如，一个UTXO的价值可能是 "500 BTC"，也可能只有 "700 SATS"。

**> 提醒：** Satoshi（通常简称为 sat）是比特币的最小单位，相当于法定货币中的一便士。

```plaintext
1 BTC = 100,000,000 SATS
```

理论上，UTXO 可以代表比特币的任何价值，从一个 sat 到约 2 100 万 BTC 的理论最高值。然而，从逻辑上讲，拥有全部 2 100 万枚比特币是不可能的，而且还有一个被称为 "尘埃 "的较低经济阈值，低于这个阈值，UTXO 在经济上就被认为是不合算的。

**>你知道吗？**比特币有史以来最大的UTXO价值为`500,000 BTC`。它是 MtGox 平台在 2011 年 11 月的一次整合行动中创建的：[29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf](https://mempool.space/fr/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)

### UTXO和支出条件

UTXOs是比特币的交换工具。每笔交易都会消耗作为输入的UTXOs，并产生作为输出的新UTXOs。交易完成后，作为输入的UTXOs 被视为 "已消耗"，新的UTXOs 被生成并分配给交易输出中指定的接收者。因此，UTXO 只代表未用完的交易输出，也就是在特定时间属于用户的比特币数量。

![BTC204](assets/it/21/2.webp)

所有UTXO都受脚本保护，脚本规定了使用UTXO的条件。要使用UTXO，用户必须向网络证明他或她符合保护该UTXO的脚本规定的条件。一般来说，UTXO 由一个公开密钥（或代表该公开密钥的接收地址）保护。要使用与该公开密钥相关的UTXO，用户必须提供用该密钥制作的数字签名，以证明自己持有相应的私人密钥。这就是为什么说你的比特币钱包实际上并不包含比特币，而是保存着你的私钥，而私钥又能让你访问你的UTXO，进而访问它们所代表的比特币。

![BTC204](assets/it/21/3.webp)

由于比特币中没有账户的概念，钱包的余额就是它可以使用的所有 UTXO 的价值总和。例如，如果你的比特币钱包可以使用以下 4 个UTXOs：

```plaintext
- 2 BTC
- 8 BTC
- 5 BTC
- 2 BTC
```

您钱包的总余额将是 `17 BTC`。

![BTC204](assets/it/21/4.webp)

## 比特币交易的结构

<chapterId>29d3aaab-de2e-4746-ab40-c9748898850c</chapterId>

### 交易的输入和输出

比特币交易是记录在区块链上的交易，它使比特币的所有权从一个人转移到另一个人。更具体地说，由于我们采用的是UTXO模式，不存在账户，因此交易满足了保护一个或多个UTXO的消费条件，消耗了这些UTXO，并等同于创建了具备新消费条件的新UTXO。简而言之，交易将比特币从一个已满足条件的脚本转移到一个旨在保护比特币的新脚本。

![BTC204](assets/it/22/1.webp)

因此，每个比特币交易由一个或多个输入和一个或多个输出组成。输入是交易产生输出所消耗的UTXO。输出是新的UTXO，可作为未来交易的输入。

![BTC204](assets/it/22/2.webp)

**> 你知道吗？** 理论上，比特币交易可以有无限多的输入和输出。只有最大区块大小限制了这个数量。比特币交易中的每一个输入都是指之前的一个未花费的UTXO（未花费的交易输出）。要将 UTXO 用作输入，其持有者必须通过验证与之相关的脚本（即满足规定的支出条件）来证明自己是合法所有者。一般来说，这需要提供一个数字签名，该数字签名是用私钥制作的，而私钥对应的公钥是该UTXO的初始担保。然后，脚本会验证该签名是否与接收资金时使用的公钥相符。

另一方面，每次输出都会指定要转移的比特币数量以及接收者。后者由一个新脚本定义，一般会用接收地址或新的公钥锁定新创建的 UTXO。

根据共识规则，交易要被视为有效，总输出必须小于或等于总输入。换句话说，交易产生的新 UTXOs 总和不得超过作为输入消耗的 UTXOs 总和。这一原则是合乎逻辑的：如果你只有`500,000 SATS`，你就不能购买`700,000 SATS`。

### 比特币交易中的交换与合并

因此，比特币交易对UTXO的作用可以比作金币的熔化。事实上，UTXO 不能分割，只能统一。这意味着，用户不能简单地将一个代表一定数量比特币的UTXO分割成几个较小的UTXO。他必须在交易中将其全部消耗掉，以在输出中创建一个或多个任意值的新的UTXO，而这些新的UTXO必须小于或等于初始值。

这种机制与金币类似。假设你拥有一枚 2 盎司的金币，但想支付 1 盎司的货款，假定卖方不能找零。您必须熔化您的金币，然后铸造 2 枚每枚 1 盎司的新金币。

比特币的操作与此类似。假设爱丽丝有一个价值 `10,000 SATS` 的UTXO，她想买一个价值 `4,000 SATS` 的法棍。爱丽丝将执行一笔交易，输入 1 个价值 `10,000 SATS` 的UTXO，她将完全消耗掉这个UTXO，在输出中，她将创建 2 个价值 `4,000 SATS` 和 `6,000 SATS` 的UTXO。4,000 SATS` 的UTXO 将被送到面包师那里，作为购买法棍的付款，而 6,000 SATS` 的UTXO 将作为零钱返回爱丽丝。在比特币行话中，返回给交易初始发送者的UTXO被称为 "零钱"。

现在设想一下，爱丽丝没有一个UTXO`10,000 SATS`，而是有两个UTXO，每个UTXO`3,000 SATS`。在这种情况下，任何一个UTXO都不足以支付长棍面包的`4,000 SATS`。因此，爱丽丝必须同时使用两个UTXO`3,000 SATS`作为交易输入。这样，总投入将达到 `6,000 SATS` ，使她能够支付面包师 `4,000 SATS` 的费用。这种将多个 UTXO 合并为交易投入的方法通常被称为 "合并"。

### 交易费用

直觉上，人们可能会认为交易费也是交易的一种产出。但实际上并非如此。交易费代表的是总投入与总产出之间的差额。这意味着，在交易中使用部分投入的价值来支付所需的产出后，仍有一定数量的投入没有使用。这部分余额就是交易费。

```plaintext
Commissioni = input totali - output totali
```

让我们回到爱丽丝的例子，她的UTXO为`10,000 SATS`，她想用`4,000 SATS`买一根法棍。爱丽丝以她的UTXO`10,000 SATS`为输入创建了一个交易。然后，她会产生一笔 4,000 SATS` 的输出，用于支付面包师购买长棍面包的费用。为了鼓励矿工将她的交易纳入一个区块，爱丽丝分配了 `200 SATS` 作为佣金。这样，她又产生了第二个产出，即剩余部分，将返还给她，共计 `5,800SATS`。

根据佣金计算公式，我们实际上看到矿工们还剩下`200 SATS`：

```plaintext
Commissioni = input totali - output totali
Spese = 10.000 - (4.000 + 5.800)
Spese = 10.000 - 9.800
Spese = 200
```

当矿工成功验证一个区块时，他们有权通过所谓的 "coinbase "交易，为其区块中包含的所有交易收取这些费用。

### UTXO在比特币上的诞生

如果你仔细阅读了前面的段落，你就会知道，UTXO 只能通过消耗其他现有的 UTXO 来产生。因此，比特币上的币形成了一个连续的链。不过，你可能会问，第一批UTXOs 是如何出现在这条链上的？这就产生了一个类似于鸡和蛋的问题：这些最初的UTXO从何而来？

答案就在 **coinbase 交易中。

Coinbase 是一种特殊的比特币交易类型，在每个区块中都是独一无二的，而且总是第一个区块。它允许找到有效工作证明的矿工获得区块奖励。这种奖励由两个元素组成： **区块奖励**和**交易费用**。

Coinbase 交易的独特之处在于，它是唯一一种可以凭空创造比特币的交易，无需消耗输入来产生输出。这些新创建的比特币构成了所谓的 "原始UTXOs"。

区块授权中的比特币是按照共识规则中预定的发行时间表凭空产生的新 BTC。区块补助每 21 万个区块减半一次，大约每四年一次，这个过程被称为 "减半"。最初，每次补贴会产生 50 个比特币，但这一数量逐渐减少；目前，每个区块补贴 3 125 个比特币。

至于交易费用部分，虽然它代表了新创建的 BTC，但不得超过一个区块中所有交易的总投入和总产出之间的差额。我们在前面已经看到，这些费用代表的是没有用于交易输出的那部分输入。从技术上讲，这部分价值在交易过程中 "损失 "了，矿工有权以一个或多个新的 UTXO 的形式重新创造这部分价值。因此，这是交易发送者向矿工的价值转移，矿工将其添加到区块链中。

**> 您知道吗？** 通过 coinbase 交易产生的比特币有 100 个区块的成熟期，在此期间，矿工不能使用这些比特币。这一规则旨在避免在链上使用新创建的比特币所带来的复杂性，因为这些新创建的比特币日后可能会被淘汰。

### UTXO模型的影响

首先，UTXO 模式直接影响比特币的交易费用。由于每个区块的容量是有限的，矿工们倾向于那些相对于其在区块中所占空间而言费用最高的交易。事实上，一个交易的输入和输出所包含的UTXO越多，它就越重，因此需要的费用也就越高。这也是我们经常努力减少UTXO数量的原因之一，这也会影响隐私，我们将在本培训的第三部分详细探讨这个话题。

其次，如前文所述，比特币上的币本质上是一条UTXO 链。因此，每一笔交易都会在过去的UTXO和未来的UTXO之间建立一个链接。因此，UTXO 可以明确追踪比特币从产生到当前消费的过程。这种透明度是积极的，因为它允许每个用户确保收到的比特币的真实性。然而，链分析也正是基于这种可追溯性和可审计性原则，这种做法会损害你的隐私。我们将在培训的第二部分深入研究这种做法。

## 比特币的隐私模式

<chapterId>769d8963-3ed5-4094-b21d-9203c7d9e465</chapterId>

### 货币：真实性、完整性和双重消费

货币的功能之一是解决双重需求重合的问题。在以物易物的体系中，进行交换不仅需要找到一个提供满足我的需求的物品的人，还需要为他们提供满足他们的需求的等值物品。事实证明，找到这种平衡点是很复杂的。

这就是为什么要使用货币，因为货币可以在空间和时间上进行价值转移。

货币要想解决这个问题，就必须让提供商品或服务的一方相信自己日后有能力花掉这笔钱。因此，任何希望接受某种形式货币（无论是数字货币还是实物货币）的理性个体，都会确保这种货币符合两个基本标准：


- 硬币必须完好无损、货真价实；**- **不得重复使用。

在使用实物货币时，第一个特征是最复杂的。在不同的历史时期，金属硬币的完整性往往会受到切割或打孔等做法的损害。例如，在古罗马时期，市民们通常会刮掉金币的边缘，以收集部分贵金属，同时保留金币以备将来交易之用。这样，金币的内在价值就降低了，但其面值却保持不变。这就是后来在硬币边缘铸上条纹的原因。

真伪也是很难通过实物货币手段验证的一个特征。如今，打假技术日益复杂，迫使商家投资昂贵的验证系统。

另一方面，由于实物货币的性质，重复支付对它们来说不是问题。如果我给你一张 10 欧元的纸币，它就不可逆转地离开了我，进入了你的手中，当然也就排除了多次使用相同货币单位的可能性。简而言之，我将无法再次使用这张 10 欧元纸币。

数字货币的难度则不同。确保一个币的真实性和完整性通常比较容易。正如我们在上一节中看到的，比特币的UTXO模式允许追溯一个币的来源，从而验证它确实是由矿工按照共识规则创建的。

然而，要确保没有重复支付则更为复杂，因为任何数字商品本质上都是信息。与实物商品不同，信息在交换过程中不会分裂，而是通过倍增的方式传播。例如，如果我通过电子邮件发送给你一份文件，它就会被复制。就你而言，你无法确定我是否删除了原始文件。

### 防止比特币重复支付

避免数字资产重复的唯一方法就是了解系统内的所有交换。这样，你就能知道谁拥有什么，并根据所进行的交易更新每个人的所有权。例如，银行系统中的经文货币就是这样做的。当您用信用卡向商家支付 10 欧元时，银行会记录这笔交易并更新分类账。

在比特币上，防止双重支付也是通过同样的方式实现的。我们的目标是确认不存在已经使用过相关硬币的交易。如果这些币从未被使用过，那么我们就可以确定不会发生重复支付。中本聪在白皮书中用这句著名的话描述了这一原则：

**"_确认没有交易的唯一办法是了解所有交易。

然而，与银行模式不同的是，人们并不希望在比特币上信任一个中央实体。所有用户都有必要在不依赖第三方的情况下确认没有双重支付。因此，每个人都需要了解所有比特币交易。这就是比特币交易在网络所有节点上公开广播并以纯文本记录在区块链上的原因。

正是这种信息的公开传播使比特币的隐私保护变得更加复杂。在传统的银行系统中，理论上只有金融机构知道所进行的交易。而在比特币上，所有用户都可以通过各自的节点获知所有交易。

### 隐私模式：银行系统与比特币

在传统系统中，银行账户与个人身份相关联。银行家能够知道哪个客户属于哪个银行账户，以及与之相关的交易。然而，这种信息流在银行和公共领域之间是中断的。换句话说，你不可能知道属于他人的银行账户的余额和交易情况。只有银行才能获得这些信息。

例如，你的银行家知道你每天早上在附近的面包店买法棍，但你的邻居却不知道这笔交易。因此，有关各方，尤其是银行，都可以获得信息流，但外人却无法获得。

由于我们在上一部分看到的交易公开传播的限制，比特币的隐私模式不能沿用银行系统的模式。在比特币中，由于交易和公共领域之间的信息流不能中断，**隐私模式的基础是用户身份和交易**本身的分离。

例如，如果您用 BTC 支付从面包师那里买了一条法棍，您的邻居（他拥有自己的完整节点）可以看到您的交易发生，就像他可以看到系统中的所有其他交易一样。但是，如果尊重隐私原则，他们应该无法将这一特定交易与您的身份联系起来。

但是，由于比特币交易是公开的，因此还是有可能在它们之间建立联系，从而推断出相关方的信息。这种活动本身甚至构成了一门专业，叫做 "链分析"。在课程的下一部分，我邀请你探索链分析的基本原理，以了解你的比特币是如何被追踪的，并知道如何更好地保护自己。

# 了解连锁分析和如何保护自己

<partId>4739371e-9fef-45b0-bcaa-b7a4df6b4470</partId>

## 什么是比特币的链式分析？

<chapterId>7d198ba6-4af2-4f24-86cb-3c79cb25627e</chapterId>

### 定义和操作

链分析是一种实践，包括用于跟踪区块链上比特币流动的所有方法。一般来说，链分析是基于对之前交易样本特征的观察。然后，在想要分析的交易中找出这些相同的特征，并推断出合理的解释。这种从实际出发寻找足够好的解决方案的方法被称为 "启发式"。

为简化起见，连锁分析主要分三步进行：

1. **观察区块链；**

2. **确定已知特征；**

3. **教育假设。

任何人都可以进行区块链分析。只需通过一个完整节点访问区块链的公共信息，即可观察交易动向并做出假设。也有一些免费工具为这种分析提供便利，如网站 [OXT.me](https://oxt.me/)，我们将在本部分最后两章详细探讨。不过，主要的隐私风险来自专门从事链分析的公司。这些公司已将链分析发展到工业规模，并向金融机构或政府出售服务。在这些公司中，Chainalysis 可能是最知名的。

### 产业链分析的目标

链分析的目标之一是将比特币上的各种活动归类，以确定进行这些活动的用户的唯一性。接下来，就可以尝试将这组活动与实际身份联系起来。

回顾前一章。我解释过为什么比特币的隐私模型最初是基于将用户身份与其交易分离。因此，人们很容易认为链上分析是无用的，因为即使你能对链上活动进行分组，它们也不能与实际身份相关联。

从理论上讲，这种说法是准确的。在本培训的第一部分，我们看到加密密钥对用于建立UTXO的条件。从本质上讲，这些密钥对不会泄露其持有者的任何身份信息。因此，即使我们能够对与不同密钥对相关的活动进行分组，也无法了解这些活动背后的实体。

然而，实际情况要复杂得多。有许多行为都有可能将真实身份与链上活动联系起来。在分析中，这被称为切入点，而切入点有很多。

最常见的当然是 KYC（了解你的客户）。如果你把比特币从一个受监管的平台提现到你的一个个人接收地址，那么有些人就能把你的身份和这个地址联系起来。更广泛地说，切入点可以是你的现实生活和比特币交易之间的任何形式的互动。例如，如果你在社交网络上发布了一个收款地址，这就可以成为分析的切入点。如果你向你的面包师傅支付了比特币，他们就可以把你的脸（这是你身份的一部分）和比特币地址联系起来。

在使用比特币的过程中，这些切入点几乎是不可避免的。虽然您可以尝试限制它们的范围，但它们依然存在。因此，将保护个人隐私的方法结合起来至关重要。尽管将真实身份和交易分开是一种有吸引力的方法，但在今天仍然不够。事实上，如果您的所有链上活动都可以归为一组，那么最微小的切入点都有可能破坏您已建立的一层隐私。

### 防御链分析

因此，我们在使用比特币时，也有必要进行区块链分析。通过这种方式，我们可以最大限度地减少我们活动的聚集，并限制切入点对我们隐私的影响。

事实上，要想更好地对抗区块链分析，还有什么比熟悉区块链分析的方法更好的呢？如果你想知道如何提高比特币的隐私性，你就需要了解这些方法。这将使你更好地理解 coinjoin 或 payjoin 等技术（我们将在培训的后半部分学习这些技术），并减少你可能犯的错误。

在这方面，我们可以用密码学和密码分析进行类比。一名优秀的密码学家首先是一名优秀的密码分析师。要想设计出一种新的加密算法，你需要知道它将面临哪些攻击，还要研究以前的算法被黑客攻击的原因。同样的原则也适用于比特币的隐私保护。了解分析区块链的方法是防范区块链攻击的关键。这就是为什么我在这次培训中提出了一整节的区块链分析。

https://planb.network/tutorials/privacy/on-chain/coinjoin-samourai-wallet-e566803d-ab3f-4d98-9136-5462009262ef
https://planb.network/fr/tutorials/privacy/on-chain/payjoin-848b6a23-deb2-4c5f-a27e-93e2f842140f
### 区块链分析方法

重要的是要明白，区块链分析不是一门精确的科学。它依赖于从以前的观察或逻辑解释中得出的启发式方法。这些规则可以得出相当可靠的结果，但绝不会绝对精确。换句话说，**区块链分析得出的结论总是涉及概率维度**。例如，人们可以或多或少地确定两个地址属于同一个实体，但总是无法完全确定。

区块链分析的主要目标正是在于汇总各种启发式方法，以最大限度地降低出错风险。从某种意义上说，这是一种证据积累，让我们更接近现实。

这些著名的启发式方法可分为几类，我们将一并详述：


- 交易模式（或交易模型）；**
- 交易的内部启发式；**
- 交易之外的启发式**

### 中本聪与区块链分析

值得注意的是，链分析的前两个启发式方法是中本聪自己发现的。他在《比特币白皮书》第 10 部分中讨论了这两个方法。它们是


- 通用输入属性启发式（CIOH）；
- 以及地址的重复使用。

![BTC204](assets/fr/031.webp)

资料来源S. Nakamoto，"比特币：点对点电子现金系统"，https://bitcoin.org/bitcoin.pdf，2009 年。

在接下来的章节中，我们将探讨这究竟是怎么回事，但值得注意的是，这两种启发式方法至今仍在链式分析中占据重要地位。

## 交易模板

<chapterId>d365a101-2d37-46a5-bfb9-3c51e37bf96b</chapterId>

交易模式只是区块链上可以找到的典型交易的一般模式或结构，其解释大概是已知的。在研究模式时，我们将重点关注单笔交易，并对其进行高层次分析。

换句话说，我们将只关注输入中的UTXOs 数量和输出中的UTXOs 数量，而不会纠缠于交易的更具体细节或环境。从观察到的模式中，我们可以解读出交易的性质。然后，我们将寻找其结构中的特征，并推断出一种解释。

![BTC204](assets/it/32/01.webp)

在这一部分中，我们将一起发现链分析中可能遇到的主要交易模式，对于每一种模式，我都会给出这种结构的可能解释，并举出一个具体的例子。

### 简单发送（或简单支付）

让我们从一个非常流行的模型开始，因为它是大多数比特币支付中出现的模型。简单支付模式的特点是，输入消耗一个或多个UTXOs，输出产生 2 个UTXOs。因此，这种模式是这样的

![BTC204](assets/it/32/02.webp)

当我们在区块链上识别出这种交易结构时，我们已经可以得出一种解释。顾名思义，这种模式表明我们正在处理的是发送或支付交易。用户在输入时消耗了自己的UTXO，在输出时满足了支付UTXO和变更UTXO（资金返回给同一用户）。

因此，我们知道被观察的用户可能不再拥有两个输出 UTXO 中的一个（付款 UTXO），但仍然拥有另一个 UTXO（变更 UTXO）。

目前，我们不可能明确指出哪个输出代表哪个UTXO，因为这不是研究模型的目的。我们将依靠启发式方法来实现这一目标，我们将在下文中对启发式方法进行研究。在现阶段，我们的目标仅限于确定有关交易的性质，在本例中，交易的性质就是简单的发送。

例如，下面是一个采用简单发送模式的比特币交易：

```plaintext
b6cc79f45fd2d7669ff94db5cb14c45f1f879ea0ba4c6e3d16ad53a18c34b769
```

![BTC204](assets/it/32/03.webp)

Fonte: [Mempool.space](https://mempool.space/fr/tx/b6cc79f45fd2d7669ff94db5cb14c45f1f879ea0ba4c6e3d16ad53a18c34b769)

看完第一个例子，你应该能更好地理解研究 "事务模型 "的含义了。我们研究交易时只关注其结构，而不考虑其环境或特定交易的细节。在第一步中，我们只对它进行全局考察。

既然你已经了解了什么是模型，那我们就来谈谈其他现有的模型。

### 清扫

第二种模式的特点是消耗单个 UTXO 作为输入，产生单个 UTXO 作为输出。

![BTC204](assets/it/32/04.webp)

对这种模式的解释是，我们正在处理的是自动转账。用户把他的比特币转到了他自己的另一个地址。由于交易中没有剩余，因此我们不太可能在处理付款。事实上，在付款时，付款人的UTXO几乎不可能与卖方要求的金额完全一致，还要加上交易费用。因此，付款人一般被迫产生余款输出。

因此，我们知道被观察的用户很可能仍持有该UTXO。在链式分析中，如果我们知道交易中作为输入的UTXO属于爱丽丝，我们就可以假设输出的UTXO也属于她。稍后有趣的是找到交易内部的启发式方法来加强这一假设（我们将在第 3.3 节中研究这些启发式方法）。

例如，下面是一个采用扫码模式的比特币交易：

```plaintext
35f1072a0fda5ae106efb4fda871ab40e1f8023c6c47f396441ad4b995ea693d
```

![BTC204](assets/it/32/05.webp)

来源：[Mempool.space](https://mempool.space/fr/tx/35f1072a0fda5ae106efb4fda871ab40e1f8023c6c47f396441ad4b995ea693d) 不过，这类模式也可能揭示了向加密货币交易所平台账户的自我转账。通过对已知地址和交易背景的研究，我们可以知道这是向自存钱包的合并还是向平台的提现。事实上，交易所平台的地址通常很容易识别。

让我们回到 Alice 的例子：如果合并指向一个已知的平台地址（例如 Binance），这可能意味着比特币被转移出 Alice 直接拥有的财产，其目的可能是将其出售或存储在该平台上。另一方面，如果目标地址未知，则可以合理地认为这只是另一个仍属于 Alice 的钱包。但这类研究更多属于启发式研究，而非模式研究。

### 合并

该模型的特点是消耗多个UTXO 作为输入，产生一个UTXO 作为输出。

![BTC204](assets/it/32/06.webp)

对这种模式的解释是，我们正处于合并阶段。这是比特币用户在预期交易费用可能增加的情况下合并多个UTXO的常见做法。在费用较低的时期进行这种操作，可以节省未来的费用。我们将在第 4.3 章详细讨论这种做法。

我们可以推断，这个事务模型背后的用户很可能拥有所有输入的 UTXO，并且仍然拥有输出的 UTXO。这无疑是一次自动转移。

与合并一样，这种模式也可能揭示了向交易所平台账户的自我转账。通过对已知地址和交易背景的研究，我们可以知道这是合并到自我保管的钱包，还是提取到平台。

例如，下面是一个采用合并方案的比特币交易：

```plaintext
77c16914211e237a9bd51a7ce0b1a7368631caed515fe51b081d220590589e94
```

![BTC204](assets/it/32/07.webp)

Fonte: [Mempool.space](https://mempool.space/fr/tx/77c16914211e237a9bd51a7ce0b1a7368631caed515fe51b081d220590589e94)

在链式分析中，这个模型可以揭示很多信息。例如，如果我们知道其中一个输入属于爱丽丝，那么我们就可以假设该交易的所有其他输入和输出都属于她。根据这一假设，我们可以追溯之前的交易链，发现并分析可能与爱丽丝有关的其他交易。

![BTC204](assets/it/32/08.webp)

### 分组支出

这种模式的特点是消耗少量UTXO 作为输入（通常只有一个），生产大量UTXO 作为输出。

![BTC204](assets/it/32/09.webp)

对这种模式的解释是，我们正在处理捆绑式消费。这种做法很可能揭示了重要的经济活动，如交换平台。捆绑消费使这些实体可以将其支出合并到单笔交易中，从而节省费用。

我们可以从这个模型中推断出，UTXO 的输入来自一家有重大经济活动的公司，而 UTXO 的输出将是分散的。其中许多将属于从平台上提取比特币的公司客户。其他的可能会流向合作公司。最后，肯定会有一个或多个交易所返回发行公司。

例如，这里有一笔采用分组消费模式的比特币交易（可能是 Bybit 平台发布的交易）：

```plaintext
8a7288758b6e5d550897beedd13c70bcbaba8709af01a7dbcc1f574b89176b43
```

![BTC204](assets/it/32/10.webp)

Fonte: [Mempool.space](https://mempool.space/fr/tx/8a7288758b6e5d550897beedd13c70bcbaba8709af01a7dbcc1f574b89176b43)

### 协议特定交易

在交易模式中，我们还可以识别出揭示特定协议使用情况的模式。例如，漩涡币合并（我们将在第 5 部分讨论）将有一个易于识别的结构，可以将其与其他更传统的交易区分开来。

![BTC204](assets/it/32/11.webp)

对这一模式的分析表明，我们可能正在处理一笔合作交易。我们也有可能观察到了一次联合行动。如果后一种假设被证明是准确的，那么输出的数量就能让我们大致估算出共同连接参与者的数量。

例如，下面是一个采用 coinjoin 协作交易类型模式的比特币交易：

```plaintext
00601af905bede31086d9b1b79ee8399bd60c97e9c5bba197bdebeee028b9bea
```

![BTC204](assets/it/32/12.webp)

Fonte: [Mempool.space](https://mempool.space/fr/tx/00601af905bede31086d9b1b79ee8399bd60c97e9c5bba197bdebeee028b9bea)

还有许多其他协议都有自己的特定结构。因此，我们可以区分 Wabisabi、Stamps 或 Runes 等类型的交易。

有了这些交易模型，我们已经可以解读特定交易的一定信息量。但是，交易结构并不是唯一的分析信息来源。我们还可以研究它的细节。我喜欢把这些交易内部的细节称为 "内部启发式"，我们将在下一章研究它们。

## 内部启发式方法

<chapterId>c54b5abe-872f-40f4-a0d0-c59faff228ba</chapterId>

内部启发式是在交易本身内部识别出的特定特征，无需检查其环境，就能让我们做出推断。内部启发式与关注交易整体结构的高层次模型不同，内部启发式以可提取的数据集为基础。这包括


- 不同UTXO的进出数量；
- 有关脚本的一切：接收地址、版本、锁定时间等。

一般来说，这种启发式方法可以让我们识别特定交易中的剩余部分。这样，我们就可以在多个交易中继续跟踪一个实体。事实上，如果我们确定一个UTXO 属于我们希望跟踪的用户，那么当他们进行交易时，确定哪些输出已转移给另一个用户，哪些输出代表剩余部分，从而由他们继续拥有，这一点至关重要。

![BTC204](assets/it/33/01.webp)

我再次提醒大家，这些启发式方法绝不准确。单独来看，它们只能让我们确定似是而非的情况。不同启发式方法的积累有助于减少不确定性，但绝不会完全消除不确定性。

### 内部相似性

这种启发式方法是研究同一笔交易的输入和输出之间的相似性。如果我们在输入端观察到相同的特征，而在交易的输出端中只有一个，那么其余的很可能就是这个输出端。

最明显的特征是在同一交易中重复使用接收地址。

![BTC204](assets/it/33/02.webp)

这种启发式方法几乎没有可疑之处。除非某人的私钥被黑客窃取，否则同一个接收地址不可避免地会暴露出单个用户的活动。由此得出的解释是，交易的其余部分是与输入地址相同的输出。这样就可以根据剩余部分对个人进行持续追踪。

例如，以下交易就可以合理地采用这种启发式：

```plaintext
54364146665bfc453a55eae4bfb8fdf7c721d02cb96aadc480c8b16bdeb8d6d0
```

![BTC204](assets/fr/046.webp)

Fonte: [Mempool.space](https://mempool.space/tx/54364146665bfc453a55eae4bfb8fdf7c721d02cb96aadc480c8b16bdeb8d6d0)

输入和输出之间的这些相似性并不仅限于地址重用。脚本使用中的任何相似之处都可以应用启发式方法。例如，有时可以在输入和其中一个事务输出之间观察到相同的版本。

![BTC204](assets/it/33/04.webp)

在该图中，我们可以看到 0 号输入解锁了一个 P2WPKH 脚本（以 `bc1q` 开头的 SegWit V0）。0 号输出使用相同类型的脚本。但是，1 号输出使用的是 P2TR 脚本（以 `bc1p` 开头的 SegWit V1）。对这一特征的解释是，与输入具有相同版本的地址很可能就是其余部分的地址。因此，它仍属于同一个用户。

下面是一个可以合理应用这一启发式方法的交易：

```plaintext
db07516288771ce5d0a06b275962ec4af1b74500739f168e5800cbcb0e9dd578
```

![BTC204](assets/fr/048.webp)

Fonte: [Mempool.space](https://mempool.space/tx/db07516288771ce5d0a06b275962ec4af1b74500739f168e5800cbcb0e9dd578)

在这种情况下，我们可以看到 0 号输入和 1 号输出使用的是 P2WPKH 脚本（SegWit V0），而 0 号输出使用的是另一种类型的脚本，即 P2PKH（Legacy）。在 2010 年代初，由于可用脚本类型的限制，这种基于脚本版本的启发式方法相对来说并不实用。然而，随着时间的推移和比特币的不断更新，脚本类型也越来越多样化。这种启发式变得越来越重要，因为随着脚本类型的增多，用户被分成了更小的群体，从而增加了应用这种内部版本重用启发式的机会。因此，仅从隐私角度来看，建议选择最常见的脚本类型。例如，在我写下这些行文时，Taproot 脚本（`bc1p`）的使用率低于 SegWit V0 脚本（`bc1q`）。虽然前者在某些特定情况下具有经济和隐私优势，但对于更传统的单一签名用途，出于隐私考虑，在新标准被更广泛采用之前，坚持使用旧标准可能是明智之举。

### 用四舍五入数字付款

另一个可以帮助我们识别余数的内部启发式方法是四舍五入法。一般来说，面对一个简单的支付方案（1 个输入和 2 个输出），如果其中一个输出的支出是四舍五入数，那么它就代表支付。

![BTC204](assets/it/33/06.webp)

根据排除法，如果一个输出代表付款，另一个则代表零钱。因此可以推断，输入交易的用户很可能仍然拥有被识别为零钱的输出。

需要注意的是，这种启发式方法并不总是适用，因为大多数支付仍然是以法定货币单位进行的。事实上，当法国的商家接受比特币时，他一般不会显示以萨特为单位的稳定价格。他更愿意选择在欧元价格和比特币支付金额之间进行换算。因此，交易输出中不应该出现四舍五入的数字。

不过，分析人员可以考虑到交易通过网络传输时的汇率，尝试进行这种换算。以一笔输入为 "97,552 萨特"、输出为 "31,085 萨特 "和 "64,152 萨特 "的交易为例。乍一看，这笔交易似乎不涉及四舍五入的金额。但是，如果采用交易时的汇率 64.339，我们就可以得到换算成欧元的结果如下：


- 投入 62.76 欧元；
- 产出为 20 欧元；
- 产出为 41.27 欧元。

一旦兑换成法定货币，这笔交易就可以采用四舍五入的启发式支付方法。20 欧元的输出可能是给一个商人的，或以其他方式改变了所有者。由此推断，41.27 欧元的输出可能仍由原用户持有。

![BTC204](assets/it/33/07.webp)

如果有一天，比特币成为我们交易中的首选记账单位，那么这种启发式分析就会变得更加有用。

例如，下面的交易可能就可以采用这种启发式：

```plaintext
2bcb42fab7fba17ac1b176060e7d7d7730a7b807d470815f5034d52e96d2828a
```

![BTC204](assets/fr/051.webp)

Fonte: [Mempool.space](https://mempool.space/tx/2bcb42fab7fba17ac1b176060e7d7d7730a7b807d470815f5034d52e96d2828a)

### 最大产出

在简单支付模型中，当交易的两个输出之间存在明显的巨大差异时，可以估计较大的输出很可能是剩余部分。

![BTC204](assets/it/33/09.webp)

这种最大输出启发式可能是最不准确的。当单独识别时，它是相当薄弱的。不过，这一特征可以与其他启发式相结合，以减少我们解释的不确定性。

例如，如果我们对一项交易进行研究，其中一项产出的金额为整数，而另一项产出的金额较大，那么我们就可以联合应用整数支付启发式方法和与较大产出相关的启发式方法，从而降低不确定性水平。

例如，下面的交易可能就可以采用这种启发式：

```plaintext
b79d8f8e4756d34bbb26c659ab88314c220834c7a8b781c047a3916b56d14dcf
```

![BTC204](assets/fr/053.webp)

Fonte: [Mempool.space](https://mempool.space/tx/b79d8f8e4756d34bbb26c659ab88314c220834c7a8b781c047a3916b56d14dcf)

## 外部启发式方法

<chapterId>4a170e3b-200d-431a-8285-18a23ff617ba</chapterId>

外部启发法的研究涉及分析某些非交易本身固有元素的相似性、模式和特征。换句话说，如果我们以前仅限于通过内部启发式来利用交易的内在要素，那么现在我们则通过外部启发式将分析领域扩展到交易环境。

### 地址的重复使用

这是比特币爱好者最熟悉的启发式方法之一。地址重用允许在不同的交易和不同的UTXO之间建立连接。当一个比特币接收地址被多次使用时，就会出现这种情况。

因此，可以利用同一事务中的地址重用作为内部启发式来识别剩余部分（如上一章所述）。不过，地址重用也可以作为一种外部启发式，用于识别多个事务背后的实体的唯一性。

对地址重用的解释是，锁定在该地址上的所有UTXO都属于（或曾经属于）同一个实体。这种启发式方法几乎不存在不确定性。当可以确定时，接下来的解释最有可能符合实际情况。因此，它允许对不同的链上活动进行聚类。

![BTC204](assets/it/34/01.webp)

正如本第 3 部分导言中所解释的，这种启发式是中本聪自己发现的。在《白皮书》中，他特别提到了用户避免这种情况的解决方案，即每次新交易都使用一个新地址：

"_作为额外的保护措施，可以为每笔交易使用新的密钥对，以防止它们被链接到一个共同的所有者。

![BTC204](assets/fr/055.webp)

资料来源S. Nakamoto，"比特币：点对点电子现金系统"，https://bitcoin.org/bitcoin.pdf，2009 年。

例如，下面是一个在多个交易中重复使用的地址：

```plaintext
bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0
```

来源：[Mempool.space](https://mempool.space/address/bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0)

### 脚本和钱包指纹的相似性

除地址重用外，还有一些其他启发式方法，可将共享链接到相同的组合或地址群。

首先，分析人员可以利用脚本使用的相似性。例如，某些少数脚本（如 multisig）比 SegWit V0 脚本更容易识别。我们隐藏的群体越大，就越难被识别。这就是为什么在优秀的 Coinjoin 协议中，所有参与者都使用完全相同类型的脚本。

更广泛地说，分析师还可以关注投资组合的指纹特征。这些都是与使用有关的特定过程，人们可以尝试识别这些过程，以便利用它们作为追踪启发式方法。换句话说，如果观察到归属于被跟踪实体的交易中积累了相同的内部特征，就可以尝试在其他交易中识别这些相同的特征。

例如，可以发现被跟踪的用户系统地将其剩余部分发送到 P2TR 地址（"bc1p..."）。如果这一过程重复出现，我们就可以将其作为继续分析的启发式方法。还可以使用其他指纹，如 UTXO 的顺序、余数在输出中的位置、RBF（Replace-by-Fee）信令，甚至版本号、"nSequence "字段和 "nLockTime "字段。

正如[@LaurentMT](https://twitter.com/LaurentMT)在[Space Kek #19](https://podcasters.spotify.com/pod/show/decouvrebitcoin/episodes/SpaceKek-19---Analyse-de-chane--anonsets-et-entropie-e1vfuji)（法语播客）中所述，随着时间的推移，钱包指纹在链分析中的效用会显著增加。事实上，脚本类型的不断增加和钱包软件对这些新功能的逐步部署都加剧了这种差异。我们甚至可以准确识别被追踪实体所使用的软件。因此，重要的是要明白，对钱包数字足迹的研究对近期交易尤其重要，比 2010 年代初启动的交易更有意义。

总而言之，指纹可以是钱包自动执行或用户手动执行的任何特定操作，可以在其他交易中找到，以帮助我们进行分析。

### 共同拥有投入的启发式方法（CIOH）

CIOH 的英文全称是 "Common Input Ownership Heuristic"（共同输入所有权启发式），是一种启发式，它认为当一项交易包含多个输入时，这些输入很可能来自一个实体。因此，它们的所有权是共同的。

要应用输入共同所有权启发法（CIOH），我们首先要观察一笔有多个输入的交易。这可以是最少 2 项投入，也可以是最多 30 项投入。一旦发现这一特征，我们就会检查该交易是否与已知的交易模型不符。例如，如果它有 5 个金额大致相同的输入和 5 个金额完全相同的输出，我们就知道这是一个硬币连接的结构。因此，我们不能应用 IOCH。

但是，如果交易不符合任何已知的协作交易模型，那么我们就可以推断所有输入可能来自同一个实体。这对于扩大已知群集或继续追踪非常有用。

中本聪发现了 CIOH。他在《白皮书》第 10 部分对此进行了讨论：

"_[......]多输入交易不可避免地会产生联系，因为这些交易必然会显示其输入是由同一个所有者拥有的。风险在于，如果密钥的所有者被揭露，关联可能会揭露属于同一所有者的其他交易。

中本聪甚至在比特币正式推出之前，就已经发现了用户的两大隐私漏洞，即 IOCH 和地址重用，这一点尤其引人入胜。这种预测非常了不起，因为这两种启发式方法至今仍是区块链分析中最有用的方法。

举个例子，我们可以在下面的交易中应用 IOCH：

```plaintext
20618e63b6eed056263fa52a2282c8897ab2ee71604c7faccfe748e1a202d712
```

Fonte: [Mempool.space](https://mempool.space/tx/20618e63b6eed056263fa52a2282c8897ab2ee71604c7faccfe748e1a202d712)

### 离链数据

当然，链上分析不仅限于链上数据。以前的分析数据或互联网上提供的数据也可用于完善分析。

例如，如果观察到被追踪的交易系统性地从同一个比特币节点传输，并且可以识别其 IP 地址，那么就有可能识别来自同一实体的其他交易，并确定发送者的部分身份。虽然这种做法不容易实现，因为它需要许多节点来运行，但一些专门从事链分析的公司有可能采用这种做法。

分析人员还可以选择依赖以前的开源分析或自己以前的分析。也许可以找到指向已经确定的地址集群的输出结果。有时，也可以依靠指向交换平台的输出，这些公司的地址一般都是众所周知的。

同样，我们也可以通过排除法进行分析。例如，在分析一个有两个输出的事务时，如果其中一个输出连接到一个已知但与被跟踪实体不同的地址集群，那么就可以解释为另一个输出可能代表其余的地址集群。

链式分析还包括 OSINT（开源情报）的一部分，它与互联网搜索更接近。这就是为什么不建议直接在社交媒体或网站上发布接收地址，无论是否使用化名。

![BTC204](assets/fr/063.webp)

### 时间模式

虽然不太常见，但某些人类行为在链上是可以识别的。最有用的分析可能是你的睡眠模式！是的，当你睡觉的时候，你可能没有在传输比特币交易。因为你通常在相同的时间睡觉，所以在链上分析中使用时间分析是很常见的。简单来说，就是把某个实体的交易传输到比特币网络的时间编成目录。通过分析这些时间模式，我们可以推断出很多信息。

首先，时间分析有时可以确定被跟踪实体的性质。如果观察到交易在 24 小时内持续传输，那么这将揭示强大的经济活动。这些交易背后的实体很可能是一家公司，有可能是国际性的，也许有内部自动化程序。

例如，[几个月前，我通过分析[错误分配 19 个比特币费用的交易](https://mempool.space/tx/d5392d474b4c436e1c9d1f4ff4be5f5f9bb0eb2e26b61d2781751474b7e870fd) 认识到了这种模式](https://twitter.com/Loic_Pandul/status/1701127409712452072)。通过简单的时间分析，我认为我们面对的是一项自动服务，因此很可能是一个大型实体，如交易所平台。

事实上，几天后，人们发现这些资金通过 Paxos 交易所平台属于 PayPal。

相反，如果我们看到时间模式相当分散，分布在 16 个非常具体的小时内，那么我们就可以估计，我们面对的是一个个人用户，或者根据交易量，可能是一个本地企业。

除了观察到的实体的性质外，时间模型还能通过时区为我们提供用户的大致位置。然后，我们可以将其他事务联系起来，并将这些事务的时间戳作为额外的启发式方法添加到我们的分析中。

例如，在我前面提到的重复使用的地址上，我们可以观察到交易，无论是输入还是输出，都集中在 13 小时的时间间隔内。

```plaintext
bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0
```

![BTC204](assets/fr/064.webp)

来源：OXT.me来源：OXT.me

这个范围可能与欧洲、非洲或中东相对应。因此，我们可以推断，这些交易背后的用户就住在那里。

在另一个注册表中，也正是这样的时间分析让人们提出了中本聪不是在日本而是在美国操作的假设：[中本聪的时区_](https://medium.com/@insearchofsatoshi/the-time-zones-of-satoshi-nakamoto-aa40f035178f)

## 区块资源管理器的实际应用

<chapterId>6493cf2f-225c-405f-9375-c4304f1087ed</chapterId>

在这最后一章中，我们将具体应用迄今为止所学到的概念。我将举出一些真实的比特币交易例子，而你必须提取我所要求的信息。

理想情况下，这些练习最好使用专业的链分析工具。然而，随着 Samourai Wallet 创建者的关闭，唯一的免费分析工具 OXT.me 也不再可用。因此，我们将选择经典的区块资源管理器来进行这些练习。我推荐使用[Mempool.space](https://mempool.space/)，因为它有很多功能和一系列链分析工具，但你也可以选择其他资源管理器，比如[Bitcoin Explorer](https://bitcoinexplorer.org/)。首先，我将介绍这些练习。请使用你的区块资源管理器完成这些练习，并将答案写在纸上。然后，在本章末尾，我将提供答案，以便你检查和更正你的结果。

为这些练习所选的交易完全是根据其特点随机选择的。本章仅用于教育和提供信息。我想明确指出，我并不提倡或鼓励恶意使用这些工具。我们的目的是教你如何保护自己免受链式分析的侵害，而不是进行分析以暴露他人的私人信息。

### 练习 1

待分析事务的 ID：

```plaintext
3769d3b124e47ef4ffb5b52d11df64b0a3f0b82bb10fd6b98c0fd5111789bef7
```

该交易的模型名称是什么？仅考察其模型，即交易结构，可以得出哪些可信的解释？

### 练习 2

待分析事务的 ID：

```plaintext
baa228f6859ca63e6b8eea24ffad7e871713749d693ebd85343859173b8d5c20
```

该交易的模型名称是什么？仅考察其模型，即交易结构，可以得出哪些可信的解释？

### 练习 3

待分析事务的 ID：

```plaintext
3a9eb9ccc3517cc25d1860924c66109262a4b68f4ed2d847f079b084da0cd32b
```

这笔交易的模式是什么？

在确定其模型后，利用交易的内部启发式方法，什么输出可能代表其余部分？

### 练习 4

待分析事务的 ID：

```plaintext
35f0b31c05503ebfdf7311df47f68a048e992e5cf4c97ec34aa2833cc0122a12
```

这笔交易的模式是什么？

在确定其模型后，利用交易的内部启发式方法，什么输出可能代表其余部分？

### 练习 5

想象一下，Loïc 在社交网络 Twitter 上发布了他的一个比特币地址来接收付款：

![BTC204](assets/fr/065.webp)

```plaintext
bc1qja0hycrv7g9ww00jcqanhfpqmzx7luqalum3vu
```

使用**地址重用启发式**，我们可以将哪些比特币交易与 Loïc 的身份联系起来？

显然，我不是这个接收地址的真正所有者，我也没有在社交媒体上发布这个地址。这是我从区块链中随机选择的一个地址。

### 练习 6

在练习 5 之后，使用地址重用启发法，您可以识别出 Loïc 似乎参与的几笔比特币交易。通常情况下，在已确定的交易中，您应该已经确定了这一交易：

这笔交易是向 Loïc 地址发送资金的第一笔交易。您认为 Loïc 通过这笔交易收到的比特币是从哪里来的？

### 练习 7

在练习 5 之后，使用地址重用启发法，您可以识别出 Loïc 似乎参与的几笔比特币交易。现在您想找出 Loïc 来自哪里。根据找到的交易，进行时间分析，找出 Loïc 可能使用的时区。根据这个时区，确定 Loïc 似乎居住的地点（国家、州/地区、城市......）。

### 练习 8

下面是要研究的比特币交易：

```plaintext
bb346dae645d09d32ed6eca1391d2ee97c57e11b4c31ae4325bcffdec40afd4f
```

仅从这笔交易来看，我们可以解读出哪些信息？

### 练习解答

**_练习 1:_**

这笔交易的模式就是简单的支付。如果我们只研究它的结构，就可以解释为一个输出代表变化，另一个输出代表实际支付。这样我们就知道，被观察到的用户很可能不再拥有输出中的两个UTXO之一（支付的那个），但仍然拥有另一个UTXO（变化的那个）。

**练习 2：_**

这种交易模式是批量消费。这种模式可能预示着一种重要的经济活动，如交换平台。我们可以推断，输入的 UTXO 来自一家有重大经济活动的公司，而输出的 UTXO 将会分散。其中一些属于该公司的客户，他们将比特币提取到自存钱包中。其他的可能会流向合作公司。最后，肯定会有剩余部分回到发行公司。

**_练习 3:_**

这笔交易的模式是简单付款。因此，我们可以对这笔交易采用内部启发式方法，尝试找出剩余部分。

就我个人而言，我发现至少有两种内部启发式方法支持同样的假设：


- 重复使用同一类型的脚本；
- 最大产出。

最明显的启发式方法是重复使用同一类型的脚本。事实上，输出`0`是一个`P2SH`，其接收地址以`3`开头，因此可以识别：

```plaintext
3Lcdauq6eqCWwQ3UzgNb4cu9bs88sz3mKD
```

而输出 `1` 是一个 `P2WPKH` ，可通过以 `bc1q` 开头的地址识别：

```plaintext
bc1qya6sw6sta0mfr698n9jpd3j3nrkltdtwvelywa
```

用作该事务输入的 UTXO 也使用了`P2WPKH`脚本：

```plaintext
bc1qyfuytw8pcvg5vx37kkgwjspg73rpt56l5mx89k
```

因此，我们可以假设输出`0`对应的是付款，输出`1`是交易的其余部分，这意味着输入用户仍然拥有输出`1`。

为了支持或反驳这一假设，我们可以寻找其他启发式方法来证实我们的想法或降低我们假设正确的概率。

我至少还发现了一个启发式。它是最大的输出。0 "输出测量 "123 689 sats"，而 "1 "输出测量 "505 839 sats"。因此，这两个输出之间存在显著差异。输出量较大的启发式方法表明，输出量较大的可能是剩余部分。因此，这一启发式进一步加强了我们最初的假设。

提供输入 UTXO 的用户很可能仍持有输出 `1`，它似乎代表了交易的其余部分。

**_练习 4:_**

这笔交易的模式是简单付款。因此，我们可以对这笔交易采用内部启发式方法，尝试找出剩余部分。

我个人发现，至少有两种内部启发式方法支持同样的假设：


- 重复使用同一类型的脚本；
- 整数的输出。

最明显的启发式方法是重复使用同一类型的脚本。事实上，输出`0`是一个`P2SH`，其接收地址以`3`开头，因此可以识别：

```plaintext
3FSH5Mnq6S5FyQoKR9Yjakk3X4KCGxeaD4
```

而输出 `1` 是一个 `P2WPKH` ，可通过以 `bc1q` 开头的地址识别：

```plaintext
bc1qvdywdcfsyavt4v8uxmmrdt6meu4vgeg439n7sg
```

用作该事务输入的 UTXO 也使用了`P2WPKH`脚本：

```plaintext
bc1qku3f2y294h3ks5eusv63dslcua2xnlzxx0k6kp
```

因此，我们可以假设输出`0`对应的是付款，输出`1`是交易的其余部分，这意味着输入用户仍然持有输出`1`。

为了支持或反驳这一假设，我们可以寻找其他启发式方法来证实我们的想法或降低我们假设正确的概率。

我至少还发现了一种启发式。它是一个整数的输出。0 "的输出量为 "70,000 萨特"，而 "1 "的输出量为 "22,962 萨特"。因此，我们处理的是以 BTC 为记账单位的完全整数输出。整数输出的启发式表明，有一个整数的 UTXO 可能是付款，通过排除，另一个代表剩余部分。因此，这一启发式进一步加强了我们最初的假设。

然而，在这个例子中，另一个启发式可能会挑战我们最初的假设。事实上，输出`0`大于输出`1`。如果我们的推理基于 "最大的输出通常是余数 "这一启发式，我们可能会推断输出`0`是余数。然而，这个反假设似乎是难以置信的，因为其他两个启发式似乎比最大输出启发式更有说服力。因此，尽管存在这种明显的矛盾，我们似乎仍有理由维持最初的假设。

因此，提供 UTXO 作为输入的用户很有可能仍持有 `1` 输出，它似乎代表了交易的其余部分。

**_练习 5:_**

我们可以看到，有 8 笔交易与 Loïc 的身份有关。其中有 4 笔涉及比特币的接收：

```plaintext
2d9575553c99578268ffba49a1b2adc3b85a29926728bd0280703a04d051eace
8b70bd322e6118b8a002dbdb731d16b59c4a729c2379af376ae230cf8cdde0dd
d5864ea93e7a8db9d3fb113651d2131567e284e868021e114a67c3f5fb616ac4
bc4dcf2200c88ac1f976b8c9018ce70f9007e949435841fc5681fd33308dd762
```

另外 4 个是关于发送比特币的：

```plaintext
8b52fe3c2cf8bef60828399d1c776c0e9e99e7aaeeff721fff70f4b68145d540
c12499e9a865b9e920012e39b4b9867ea821e44c047d022ebb5c9113f2910ed6
a6dbebebca119af3d05c0196b76f80fdbf78f20368ebef1b7fd3476d0814517d
3aeb7ce02c35eaecccc0a97a771d92c3e65e86bedff42a8185edd12ce89d89cc
```

**_ 练习 6:_**

如果我们研究一下这笔交易的模式，就会发现这是一笔分组支出。事实上，这笔交易有一个输入和 51 个输出，表明有大量的经济活动。因此，我们可以假设 Loïc 从一个交易所平台提取了比特币。

有几个因素加强了这一假设。首先，用于保护输入 UTXO 的脚本类型是 P2SH 多位 2/3 脚本，表明交易所平台具有典型的高级安全级别：

```plaintext
OP_PUSHNUM_2
OP_PUSHBYTES_33 03eae02975918af86577e1d8a257773118fd6ceaf43f1a543a4a04a410e9af4a59
OP_PUSHBYTES_33 03ba37b6c04aaf7099edc389e22eeb5eae643ce0ab89ac5afa4fb934f575f24b4e
OP_PUSHBYTES_33 03d95ef2dc0749859929f3ed4aa5668c7a95baa47133d3abec25896411321d2d2d
OP_PUSHNUM_3
OP_CHECKMULTISIG
```

此外，被分析的地址 "3PUv9tQMSDCEPSMsYSopA5wDW86pwRFbNF "在超过 220,000 次不同的交易中被重复使用，这通常是交易所平台的特征，它们通常并不关心自己的隐私。应用于该地址的时间启发法还显示，在 3 个月的时间里，几乎每天都有有规律的交易分布，时间超过 24 小时，表明交易所平台在持续活动。

最后，该实体处理的交易量巨大。事实上，在 2022 年 12 月至 2023 年 3 月期间的 222,262 次交易中，该地址接收和发送了 44 BTC。这些巨大的交易量进一步证实了交易所平台活动的可能性。

**_练习 7:_**

分析交易确认时间，可以看到以下 UTC 时间：

```plaintext
05:43
20:51
18:12
17:16
04:28
23:38
07:45
21:55
```

通过对这些时间的分析，UTC-7 和 UTC-8 时区显然与人类大多数时间的常见活动范围（上午 8 点到晚上 11 点之间）相一致：

```plaintext
05:43 UTC > 22:43 UTC-7
20:51 UTC > 13:51 UTC-7
18:12 UTC > 11:12 UTC-7
17:16 UTC > 10:16 UTC-7
04:28 UTC > 21:28 UTC-7
23:38 UTC > 16:38 UTC-7
07:45 UTC > 00:45 UTC-7
21:55 UTC > 14:55 UTC-7
05:43 UTC > 21:43 UTC-8
20:51 UTC > 12:51 UTC-8
18:12 UTC > 10:12 UTC-8
17:16 UTC > 09:16 UTC-8
04:28 UTC > 20:28 UTC-8
23:38 UTC > 15:38 UTC-8
07:45 UTC > 23:45 UTC-8
21:55 UTC > 13:55 UTC-8
```

UTC-7时区在夏季尤为重要，因为它包括以下州和地区：


- 加利福尼亚州（包括洛杉矶、旧金山和圣地亚哥等城市）；
- 内华达州（含拉斯维加斯）；
- 俄勒冈州（含波特兰）；
- 华盛顿（含西雅图）；
- 加拿大不列颠哥伦比亚地区（包括温哥华和维多利亚等城市）。

这些信息表明，Loïc 有可能居住在美国西海岸或加拿大。

**_练习 8:_**

对该交易的分析表明，有 5 个输入和一个输出，这似乎表明是合并交易。应用 CIOH 启发式表明，输入中的所有UTXO 都由一个实体持有，输出中的UTXO 也属于这个实体。看来，用户选择将自己拥有的几个UTXO合并为输出中的一个UTXO，目的是合并自己的硬币。这种做法的动机可能是想利用当前的低交易费来减少未来的费用。

---
在撰写关于链分析的第 3 部分时，我参考了以下资源：_


- _由 Samourai Wallet 于 2021 年制作的题为：[用 OXT 理解比特币隐私](https://medium.com/oxt-research/understanding-bitcoin-privacy-with-oxt-part-1-4-8177a40a5923) 的四篇系列文章；_
- _[OXT研究](https://medium.com/oxt-research)的各种报告，以及他们的免费链分析工具（在Samourai钱包创始人被捕后，目前已无法使用）；__
- _更广泛地说，我的知识来自[@LaurentMT](https://twitter.com/LaurentMT)和[@ErgoBTC](https://twitter.com/ErgoBTC)的各种推文和内容；__
- \我与[@louneskmt](https://twitter.com/louneskmt)、[@TheoPantamis](https://twitter.com/TheoPantamis)、[@Sosthene\_\_](https://twitter.com/Sosthene___)和[@LaurentMT](https://twitter.com/LaurentMT)一起参与的[Space Kek #19](https://podcasters.spotify.com/pod/show/decouvrebitcoin/episodes/SpaceKek-19---Analyse-de-chane--anonsets-et-entropie-e1vfuji)。

_我要感谢它们的作者、开发者和制作者。


- _[Gilles Cadignan](https://twitter.com/gillesCadignan)；_
- _[路德维克-拉尔斯](https://viresinnumeris.fr/)._

# 掌握保护隐私的最佳做法

<partId>9bd04b63-f1af-4e50-9061-6bc90009df68</partId>

## 地址的重复使用

<chapterId>f3e97645-3df3-41bc-a4ed-d2c740113d96</chapterId>

在研究了比特币上可能泄露个人隐私的技术后，我们将在第三部分探讨保护个人隐私的最佳方法。这一部分的目的不是探讨改善隐私的方法，这个话题将在后面讨论，而是了解如何正确地与比特币互动，以维护它自然提供的隐私，而不诉诸其他技术。

当然，在第三部分的开头，我们要谈谈地址重复使用的问题。这种现象是对用户隐私的主要威胁。因此，本章可能是整个课程中最重要的一章。

### 什么是接收地址？

比特币接收地址是一个字符串或标识符，用于将比特币接收到钱包中。

从技术上讲，比特币接收地址并不是字面意义上的 "接收 "比特币，而是定义了比特币的使用条件。具体来说，当一笔付款发送给你时，发送方的交易会在输出端从输入端消耗的 UTXO 中创建一个新的 UTXO。在这个输出中，会应用一个脚本来定义以后如何使用这个UTXO。该脚本称为"_ScriptPubKey_"或"_Locking Script_"。您的接收地址，更确切地说是其有效载荷，被嵌入到这个脚本中。简单地说，这个脚本主要是：

> "_要使用这一新的 UTXO，必须使用与这一接收地址相关联的私人密钥提供数字签名。
![BTC204](assets/fr/067.webp)

比特币地址有不同的类型，取决于所使用的脚本模型。第一种称为"_Legacy_"，包括 "P2PKH"（_Pay-to-PubKey-Hash_）和 "P2SH"（_Pay-to-Script-Hash_）地址。P2PKH 地址总是以 "1 "开头，P2SH 以 "3 "开头。尽管这些格式仍然安全，但现在已经过时，因为与新标准相比，它们的交易费用更高，隐私性更差。

SegWit V0（`P2WPKH`和`P2WSH`）和 Taproot / SegWit V1（`P2TR`）地址代表现代格式。SegWit 地址以 `bc1q` 开头，2021 年推出的 Taproot 地址以 `bc1p` 开头。

例如，这是一个 Taproot 接收地址：

```text
bc1ps5gd2ys8kllz9alpmcwxqegn7kl3elrpnnlegwkm3xpq2h8da07spxwtf5
```

构建 ScriptPubKey 的方式取决于您使用的标准：

| 脚本模板 | 脚本出版键 | | ---------------- | ----------------------------------------------------------- | ----------------------------------------------------------- |

| P2PKH | OP_DUP OP_HASH160 `<pubKeyHash>` OP_EQUALVERIFY OP_CHECKSIG | OP_EQUALVERIFY OP_CHECKSIG

P2SH | OP_HASH160 `<scriptHash>` OP_EQUAL | P2SH | OP_HASH160 `<scriptHash>` OP_EQUAL

| P2WPKH | 0 `<pubKeyHash>` | P2WPKH

P2WSH | 0 `<witnessScriptHash>` | P2WSH | 0 `<witnessScriptHash>` | P2WSH | 0

P2SH - P2WPKH | OP_HASH160 `<redeemScriptHash>` OP_EQUAL | P2SH - P2WPKH | OP_HASH160 `<redeemScriptHash>` OP_EQUAL | P2WPKH

| P2SH - P2WSH | OP_HASH160 `<redeemScriptHash>` OP_EQUAL | P2WSH

| P2TR | 1 `<pubKey>` | P2TR

至于接收地址的结构，也取决于所选择的脚本模板：


- 对于 "P2PKH "和 "P2WPKH "地址，有效载荷或地址的核心部分代表公钥的哈希值；
- 对于 `P2SH` 和 `P2WSH` 地址，有效载荷代表脚本的哈希值；
- 至于 `P2TR` 地址，其有效载荷是修改后的公钥。P2TR "输出结合了_Pay-to-PubKey_和_Pay-to-Script_的各个方面。修改后的公钥是在经典消费公钥的基础上进行 "修改 "的结果，而经典消费公钥是从一组脚本的 Merkle 根中衍生出来的，这些脚本也可以用来消费比特币。

![BTC204](assets/it/67/01.webp)

钱包软件上显示的地址还包括一个 HRP（_Human-Readable Part_），通常是后 SegWit 地址的 `bc`、分隔符 `1`、版本号 `q` （SegWit V0）和 `p` （Taproot/SegWit V1）。此外，还添加了校验和，以确保地址在传输过程中的完整性和有效性。

最后，将地址输入标准格式：


- Base58check 用于旧的传统地址；
- Bech32 用于 SegWit 地址；
- 用于 Taproot 地址的 Bech32m。

下面是以 10 为基数的 bech32 和 bech32m 格式（SegWit 和 Taproot）的加法矩阵：

| + | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |

| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

| 0 | q | p | z | r | y | 9 | x | 8 | 8

| 8 | g | f | 2 | t | v | d | w | 0 |

| 16 | s | 3 | j | n | 5 | 4 | k | h | | 24 | c | e | 6 | m | u | a | 7 | l | l

### 什么是地址重用？

地址重用是指使用相同的接收地址来阻塞多个不同的 UTXO。

正如我们在上一节中看到的，每个UTXO 都有自己的 ScriptPubKey，它锁定了UTXO，必须满足这个条件，UTXO 才能作为新事务的输入被使用。接收地址（有效载荷）就是嵌入在这个 ScriptPubKey 中的。

当多个 ScriptPubKeys 包含相同的接收地址时，这就是所谓的地址重复使用。实际上，这意味着用户多次向发送者提供相同的地址，通过多次支付来接收比特币。实际上，这种做法对你的隐私是灾难性的。

### 为什么地址重复使用是个问题？

由于区块链是公开的，因此很容易看到哪些地址拦截了哪些UTXO，拦截了多少比特币。如果同一地址被用于多项交易，就有可能推断出与该地址相关的所有比特币都属于同一个人。这种做法允许在不同交易之间建立确定性链接，并在区块链上追踪比特币，从而损害了用户隐私。中本聪本人也在《比特币白皮书》中强调了这个问题：

> 作为额外的防火墙，可以为每笔交易使用新的密钥对，以防止它们被链接到共同的所有者。
![BTC204](assets/fr/055.webp)

资料来源S. Nakamoto，"比特币：点对点电子现金系统"，https://bitcoin.org/bitcoin.pdf，2009 年。

中本聪的这一声明旨在为用户身份与比特币上的密钥对之间的关联创建一个额外的防火墙，以避免他们的所有活动都与他们的身份公开关联。如今，随着区块链分析公司和 KYC 法规的激增，使用唯一地址已不再是 "额外的防火墙"，而是任何希望最低限度保护自己隐私的人的必要做法。

当您重复使用一个地址时，您就在与该地址相关的所有交易之间建立了几乎无可争议的联系。虽然这不会直接危及你的资金，因为椭圆曲线加密确保了你私钥的安全，但却使你的活动更容易被监控。事实上，任何拥有节点的人都可以观察到你的交易和地址余额，从而完全破坏了你的匿名性。

![BTC204](assets/it/34/01.webp)

为了说明这一点，让我们以鲍勃为例，他经常通过美元平均成本法（DCA）少量购买比特币，并总是将它们发送到同一个地址。两年后，这个地址就有了大量的比特币。如果鲍勃使用这个地址向本地商家付款，商家可能会看到所有相关资金，并扣除鲍勃的财富。这可能会导致个人安全风险，包括盗窃或勒索企图。如果鲍勃使用一个新的地址来接收每次定期购买的比特币，他向商家透露的信息就会大大减少。

在链分析中，我们将地址重用分为两种类型：


- 外部再利用；
- 交易内部重复使用。

第一种情况是，一个地址在多个不同的比特币交易中被重复使用。这就是我们之前讨论过的：通过这种启发式，我们可以推断出通过该地址的所有UTXO都属于一个实体。

内部地址的重复使用不是发生在多个事务中，而是发生在同一事务中。事实上，如果用于锁定输入的相同地址在交易中被用作输出，那么我们就可以推断出该输出仍属于同一个用户（剩余部分），并且第二个输出代表实际付款。另一种启发式方法允许在多个交易中追踪资金。

![BTC204](assets/it/33/02.webp)

地址重复使用是比特币的真正祸害。根据网站 OXT.me（目前无法访问）的数据，2022 年比特币地址重复使用的总体比率约为 52%：

![BTC204](assets/fr/069.webp)

这一比例虽然巨大，但绝大多数来自交换平台，而非个人用户。

### 如何避免地址重复使用？

避免地址重复使用非常简单： **只需为钱包中的每笔新付款使用一个新地址**。

得益于 BIP32，现代投资组合现在是确定的、分层的。这意味着用户可以从单一的初始信息（种子）中生成大量地址。通过保存这一条信息，就可以恢复钱包中的所有私钥，从而获得相应地址所担保的资金。

![BTC204](assets/fr/070.webp)

这就是为什么当你按下钱包软件中的"_receive_"按钮时，每次都会向你提供一个未使用的接收地址。在这个地址上接收比特币后，软件会自动推荐一个新地址。

> _PS：最近，一些钱包软件宣布打算停止生成空白地址，因为它们担心这可能会被当局视为一种洗钱形式。如果您的软件也在其中，我强烈建议您立即更换，因为用户不会接受这种做法。
如果你需要一个静态标识符来接收付款，比如接收捐款，不建议使用经典比特币地址，因为有重复使用的风险。您更愿意使用闪电地址，或使用静态链上支付标识符，您可以选择 BIP47 或静默支付。本培训的第 6 部分将详细介绍这些协议的工作原理。

## 硬币标签和控制

<chapterId>fbdb07cd-c025-48f2-97b0-bd1bc21c68a8</chapterId>

正如我们在 "链分析 "一节中发现的，有许多启发式方法和模式可用于推断交易信息。作为用户，必须了解这些技术，以便更好地保护自己。

这在很大程度上涉及对个人保管的钱包的严格管理，包括了解自己的UTXO的来源，以及在支付过程中深思熟虑地选择要消耗的UTXO。这种有效的钱包管理依赖于优秀比特币钱包的两个重要特征：标签和硬币控制。

在本章中，我们将研究这些功能，并了解如何在不增加太多工作量的情况下智能地使用它们，从而大大优化比特币上的隐私。

### 什么是标签？

标记是一种为比特币钱包中的特定UTXO分配注释或标签的做法。这些注释由钱包软件本地存储，绝不会通过比特币网络传输。因此，标签是一种个人管理工具。

例如，如果我通过 Charles 在 Bisq 上以 P2P 方式购买了一个 UTXO，我可能会给它贴上"`Non-KYC Bisq Charles`"的标签。

标记是一种良好的做法，有助于记住UTXO的来源或预定目的地，从而便于管理资金和优化隐私。事实上，您的比特币钱包很可能包含多个UTXO。如果这些UTXO的来源不同，您可能不想在将来合并这些UTXO，否则就会暴露它们的共同所有权。通过正确标记您的所有币，您可以确保在需要时记住它们的来源，即使是几年后。

### 什么是硬币控制？

如果与钱包软件上的硬币控制选项相结合，积极使用标记功能就更具吸引力。

币控是优秀比特币钱包软件中的一项功能，可以手动选择特定的UTXO作为交易输入。事实上，要完成一笔支付，您必须消耗一个输入的UTXO作为回报。出于一些原因（我们稍后会看到），您可能希望精确地选择消耗哪些硬币作为输入，以满足给定的付款要求。这正是硬币控制所允许的。打个比方，这种功能类似于您在支付法棍面包时在钱包中选择特定硬币的操作。

使用硬币控制的钱包软件，再加上UTXO 的标签，用户可以准确区分和选择用于交易的 UTXO。

### 如何正确标注UTXO？

UTXO的标签没有适合所有人的通用方法。您需要确定一个标签系统，以便轻松浏览您的投资组合。无论如何，请记住，好的标签是你在需要时能够理解的。如果您的比特币钱包主要用于储蓄，那么这些标签可能在几十年后才会对您有用。因此，一定要确保标签清晰、准确，并具有包容性。

重要的是，如果有一天您的亲人需要查阅您的投资组合，他们可以很容易地确定资金的来源。这不仅有助于保护他们的隐私，也有助于他们在法律面前证明资金的来源。

标签最重要的一点是注明UTXO 的来源。您只需说明这枚硬币是如何进入您的钱包的。它是通过交易所平台购买的吗？客户付款？点对点交易所？还是购买的剩余部分？因此，您可以说明


- Pickup Exchange.com"；
- 付款客户 David`；
- 购买 P2P 查尔斯；
- 购买沙发的收益

为了完善您对UTXOs的管理，并坚持在投资组合中隔离基金的策略，您可以在标签中加入额外的标记，以反映这些分离。如果您的投资组合包含两类UTXO，而您又不希望将它们混在一起，您可以在标签中加入一个标记，以明确区分这两类UTXO。这些分离标记将取决于您的标准，例如区分来自涉及 KYC 的收购过程的 UTXOs，或区分专业基金和个人基金。以前面提到的标签为例，这可以转化为：


- KYC - Exchange.com 取款"；
- KYC - Customer Payment David"；
- 无 KYC - 购买 P2P Charles`；
- 无 KYC - 购买沙发的剩余部分

在交易过程中，还建议永久保留硬币的标签。例如，在没有 KYC 的情况下合并 UTXO 时，确保不仅将生成的 UTXO 标记为 "合并"，而且特别标记为 "无 KYC 合并"，以保持钱币来源的清晰痕迹。

最后，在标签上标注日期不是必须的。大多数钱包软件已经显示了交易日期，在区块资源管理器上使用 TXID 也可以检索到该信息。

### 如何正确选择硬币？

当您进行交易时，金币控制允许您具体选择消耗哪些UTXO 作为输入来满足支付输出。在选择时应考虑两个方面：


- 收款人能将您的部分身份与作为输入的 UTXOs 联系起来；
- 外部观察者在所有作为输入消耗的UTXO之间建立联系的能力。

为了说明第一点，让我们举一个具体的例子。假设你用比特币从当地面包师那里买了一根法棍。你用自己的一个或多个 UTXO 作为输入，至少可以支付法棍的输出价格，外加交易费用。面包师可能会将你的脸或他所知道的你身份的任何其他部分与作为输入的比特币联系起来。知道了这种联系的存在，您在付款时可能会更愿意选择一种特定的 UTXO 而不是另一种。

例如，如果您的UTXO之一来自一个交易所平台，而您不希望面包师知道您在这个平台上的账户，您就会避免使用这个UTXO付款。如果你有一个高价值的UTXO，显示了大量的比特币，你也可以选择不使用它，以防止面包师知道你的 BTC 财富。

因此，选择用于第一点的 UTXOs 是基于个人的决定，受您是否愿意披露信息的影响。您在收到UTXO时为其指定的标签将帮助您选择那些在使用时只显示您愿意向接收者透露的信息的UTXO。

除了可能向接收者透露的信息外，您对输入的选择也会影响您向所有区块链观察者透露的信息。事实上，根据输入的共同所有权启发法（CIOH），如果将多个UTXO作为交易输入，就会暴露出它们为同一实体所有。

因此，当您选择您的币种时，您应该意识到您将要传输的交易将在所有使用的 UTXO 之间创建一个链接。这种链接可能会影响您的个人隐私，尤其是当UTXO来自不同来源时。

回到我在 Bisq 上购买的不带 KYC 的 UTXO 的例子；我想避免将它与来自比如说知道我身份的受监管交易所平台的 UTXO 结合起来。事实上，如果我在同一笔交易中使用这两个 UTXO 作为输入，受监管平台就能将我的身份与我在 Bisq 上购买的 UTXO 联系起来，而在此之前，它与我的身份是没有联系的。

最后，要正确选择使用哪些UTXO 作为交易输入，最重要的是避免使用多个UTXO。在可能的情况下，选择一个足够大的币来支付。这样做可以完全避免 COINJOIN 带来的风险。但是，如果单个 UTXO 不足以支付您的款项，而您需要使用多个 UTXO，请确保它们的来源相似，以尽量减少不必要的连接风险。此外，请记住，收款人可能会将他们所掌握的关于您的信息与作为输入的硬币的历史记录联系起来。

### 了解自动硬币选择

在前面的章节中，我们讨论了交易中手动选择UTXO 的问题。但如果钱包软件自动选择UTXO，会发生什么情况呢？有几种方法可以决定消耗哪些硬币，而选择UTXOs是比特币的一个真正研究领域。这种自动过程的主要目的通常是尽量减少用户的交易费用。

FIFO（先进先出）和LIFO（后进先出）等UTXO选择方法是最简单的方法，但也是效率最低的方法。采用先进先出法时，首先使用投资组合中最老的硬币。除了使用相对时间锁且必须定期更新的情况外，这种方法在最大限度降低交易费用和保护隐私方面通常效率较低。相比之下，后进先出法优先使用最近的UTXO。这两种方法虽然简单，但效率往往不高。

更高级的方法是_Knapsack Solver_。在 0.17 版之前，比特币核心钱包一直使用这种方法。它包括从钱包中随机迭代选择UTXO，将它们汇总成子组，并保留尽可能降低交易权重的解决方案，以减少用户费用。

从 0.17 版本开始，比特币核心中的 _Branch-and-Bound 算法（BNB）取代了 _Knapsack Solver 算法（Knapsack Solver）。这种更先进的方法旨在找到一组UTXO，与满足交易输出所需的金额完全匹配。BNB 的目标是通过减少所谓的 "浪费标准"（该标准考虑到了剩余部分的即时成本和预期未来成本）来最小化剩余部分的数量和费用。该方法源于艾尔莎-兰德和艾莉森-哈考特于 1960 年设计的 "分支与边界"（Branch-and-Bound）原始概念，比 "纳帕克求解器"（Knapsack Solver）提供了更精确的佣金优化。

所有这些自动UTXO选择方法都能有效降低交易费用，但在保护用户隐私方面往往效率低下。事实上，这些算法可能会将多个UTXO合并到输入中，从而揭示出这些UTXO因COH而具有共同所有权。显然，这些方法无法考虑附加在UTXO上的标签，而这些标签对于有意识地选择向交易接收者披露哪些硬币至关重要。目前，优化硬币选择隐私的唯一解决方案就是手动选择。

### UTXO标签教程

如果您想了解如何标记您的UTXOs，我们在现有的主要比特币钱包软件上编写了一个全面的教程：

https://planb.network/tutorials/privacy/on-chain/utxo-labelling-d997f80f-8a96-45b5-8a4e-a3e1b7788c52
## KYC 和关键识别

<chapterId>cec6b9d9-0eed-4f85-bc4e-1e9aa59ca605</chapterId>

KYC 是 "了解你的客户 "的缩写，是一些从事比特币行业的公司实施的监管程序。该程序旨在核实和记录客户的身份，其既定目标是打击洗钱和恐怖主义融资。

具体来说，KYC 涉及收集客户的各种个人信息，这些信息可能因司法管辖区而异，但一般包括身份证、照片和居住证明。然后对这些信息进行核实和存储，以备将来使用。

在大多数西方国家，所有受监管的兑换平台都必须履行这一程序。这意味着，任何希望通过这些平台用法定货币兑换比特币的人都必须遵守 KYC 要求。

这一程序对用户隐私和安全并非没有风险。在本章中，我们将详细研究这些风险，并分析 KYC 和身份识别程序对比特币用户隐私的具体影响。

### 促进链上跟踪

与 KYC 相关的第一个风险是，它为区块链分析提供了一个首选切入点。正如我们在上一节中看到的，分析师可以利用交易模式和启发式方法对区块链上的活动进行分组和跟踪。一旦他们设法对用户的链上活动进行分组，在其所有交易和密钥中只需找到一个切入点，就足以完全泄露其隐私。

![BTC204](assets/fr/078.webp)

当你提交 KYC 时，你就为链分析提供了一个非常高质量的切入点，因为你将从交易所平台提取比特币时使用的接收地址与你经过验证的完整身份联系起来。理论上，只有您提供信息的公司才知道这些信息，但正如我们稍后将看到的，数据丢失的风险是真实存在的。此外，即使公司不共享这些信息，仅仅是公司掌握这些信息这一事实也会带来问题。

因此，除非采取其他措施限制一个人在区块链上的活动汇集，否则任何知道 KYC 这个切入点的人都有可能将他们在比特币上的所有活动与他们的身份联系起来。从这家公司的角度来看，比特币的使用因此失去了所有的保密性。

![BTC204](assets/fr/079.webp)

打个比方来说明这一点，就好比一个人在_X_银行的银行家不仅能看到他与_X_银行的所有交易，还能看到他与_Y_银行的交易以及他自己的所有现金交易。

回顾本培训的第一部分：中本聪设计的比特币隐私模式是基于用户身份和密钥对之间的分离。尽管这层隐私在今天已不再足够，但尽可能限制其退化仍是明智之举。

### 接受国家监督

KYC 的第二个主要问题是，它向国家透露了一个人曾经拥有比特币的信息。当你通过受监管的行为者购买比特币时，国家就有可能知道你拥有比特币。目前，这似乎微不足道，但重要的是要记住，一个人国家的政治和经济未来并不掌握在自己手中。

首先，国家可以迅速采取专制立场。历史上，政策突然改变的例子比比皆是。今天，在欧洲，比特币爱好者可以撰写关于比特币的文章，参加会议，管理自己的自存钱包。但谁能说得准明天会发生什么呢？如果比特币突然成了头号公敌，那么在国家登记处与比特币联系在一起就会成为问题。

以后，面对严重的经济危机，国家可能会考虑没收公民持有的比特币。也许明天，比特币持有者就会被视为趁人之危，在法定货币贬值的情况下因资本利得而被征收过多的税款。

你可能会认为这不是问题，因为你的比特币是洗过的，因此无法追踪。然而，可追踪性并不是问题所在。真正的问题是国家知道你拥有比特币。这个简单的信息就足以指控你或要求你交代。你可以说你花掉了你的比特币，但这必须反映在你的纳税申报单上，你会被发现的。你也可以说你在一次划船事故中丢了钥匙，但除了 Twitter 上的笑话之外，你真的认为这足以为你开脱罪责吗？

因此，重要的是要考虑与国家可能知道您拥有 BTC 这一简单事实相关的风险，尽管这种风险在今天看来可能还很遥远。

在国家监督方面，KYC 带来的另一个问题是受监管平台的强制报告。虽然我不熟悉其他司法管辖区的法规，但在法国，数字资产服务提供商（PSANs）必须向金融监管部门报告他们认为可疑的任何资金流动。

因此，在 2023 年的法国，PSAN 报告了 1 449 起可疑行为。目前，这些行为大多与犯罪有关。不过，当局也要求受监管的平台报告任何仅基于其结构的可疑比特币交易。如果你进行了一笔合作交易，甚至只是一笔模式有点反常的交易，而这笔交易又发生在你从这些平台提取比特币的附近，那么你可能会发现自己被报告给了当局。即使您没有不法行为，也是在合法行使自己的权利，这种举报也可能导致审查和监控的增加，而如果没有 KYC，您本可以避免这些不便。

### 丢失个人数据的风险

KYC 的另一个问题在于，它要求将您的所有个人数据存储在私人公司的服务器上。最近发生的事件提醒我们，无论是金融还是信息技术相关的故障，没有人能够幸免。2022 年，Celsius 的客户就遭受了这样的后果。由于该公司破产，美国司法系统在行政程序中公开了债权人的姓名及其资产数额。

就在两年多前，加密货币领域一家领先的网络安全实体遭遇了客户个人数据被盗事件。虽然这一事件与购买比特币并无直接关系，但交易所平台同样存在这一风险。因此，这些个人数据存在一定的风险。

诚然，我们已经将许多个人数据委托给了私人公司。然而，这里的风险是双重的，因为这些数据不仅可以识别你的身份，还与比特币的活动相关联。事实上，当黑客能够访问交易所平台客户的数据时，他们可以合理地认为这些客户拥有比特币。因此，比特币和其他任何有价值的资产一样，会吸引盗贼的兴趣，从而加剧了这种风险。

如果发生数据泄露，往好了说，您可能会成为有针对性的网络钓鱼企图的目标。最坏的情况是，您可能会发现自己的家庭受到物理威胁。

除了与比特币相关的具体风险外，还有必要考虑与传输身份证件相关的危险。事实上，一旦数据泄露，就有可能成为身份盗窃的受害者。因此，利害攸关的问题不仅限于保护交易的机密性，还影响到每个人的人身安全。

### 关于 KYC 的常见误解

我们有必要消除一些关于 KYC 的常见误解，这些误解经常出现在 Twitter 上或比特币玩家的讨论中。

首先，认为通过 KYC（"了解你的客户"）获得的比特币的隐私保护毫无用处的想法是错误的。保护比特币隐私的工具和方法多种多样，目的也各不相同。例如，在 KYC 中使用 coinjoin 交易比特币并不是一个坏主意。当然，你需要谨慎使用受监管的交易所平台，以避免账户被冻结或封禁，但从严格的技术角度来看，这些做法并不冲突。Coinjoin 可以破坏一个币的历史，这有助于抵御与 KYC 相关的链分析风险。虽然这并不能消除所有风险，但已经是一个很大的好处了。

比特币的隐私不应被二元对立地看待，不应被视为 "匿名 "比特币和其他非匿名比特币之间的区别。拥有通过 KYC 获取的比特币并不意味着一切都失去了意义；相反，使用隐私工具可能会带来更多好处。

相反，通过非 "KYC "方式获取比特币并不能保证完美的隐私，也不能免除你采取其他保护措施的需要。如果你持有非 KYC 比特币，但多次重复使用接收地址，你的交易就会被跟踪和分组。与比特币之外的世界的一丁点联系，都可能危及你仅有的一层隐私。因此，重要的是将所有改善比特币隐私的工具和方法视为互补。每种技术都能解决特定的风险，并能增加一层额外的保护。因此，拥有非 KYC 比特币绝对不能免除你采取其他预防措施。

### KYC 可以取消吗？

有时有人问我，完成 KYC 后是否可以 "回头"，从前面的段落中可以想象，答案是微妙的。要避免 KYC 带来的风险，最简单的方法就是在获取比特币时不要使用它。我们将在下一章详细阐述这个话题。但是，如果已经进行了 KYC 并购买了比特币，是否有办法降低所产生的风险呢？

至于追踪交易的风险，使用 Coinjoin 是一种解决方案。我们将在稍后的培训中详细讨论这种方法，但要知道，coinjoin 会破坏一个币的历史，并阻止其过去-现在和现在-过去的可追溯性。即使是通过受监管平台获得的 BTC，这种技术也会阻止其可追溯性。

然而，coinjoin 并不能消除与 KYC 相关的第二种风险：国家被告知你持有的比特币。事实上，即使你的比特币不再可追踪，国家（取决于司法管辖区）也有可能获得你的加密活动转让声明。由于这种风险不是技术性的，而是行政性的，因此，除了最初避免接触 KYC 外，没有专门针对比特币的解决方案来消除这种风险。降低这种风险的唯一合法方法是在受监管的平台上出售通过受监管平台获得的比特币，然后通过不需要 KYC 的方式买回。通过出售和申报处置，管理部门应注意到您已不再拥有这些比特币。

至于个人数据和身份证件被泄露的风险，这是比特币的外部危险，没有技术手段可以避免。一旦你的数据被泄露，很难逆转。你可以尝试关闭平台上的账户，但这并不能保证消除你的 KYC 数据，尤其是在身份验证外包的情况下。验证您的信息是否完全消除是不可能的。因此，没有任何解决方案可以完全防止这种风险并确保其不复存在。

### KYC 与关键识别的区别

有时，一些比特币玩家倾向于将 "KYC "一词扩展到任何涉及转账或信用卡支付的 BTC 交易所，因为这些手段也可以像 KYC 一样揭示支付的来源。不过，重要的是不要混淆 KYC 和密钥识别。就我个人而言，我必须承认，随着时间的推移，我对这个话题的认识也在不断发展。

KYC 特指一些公司为核实和记录客户身份而实施的监管程序。这是一个二元问题：当你获得比特币时，要么提交 KYC，要么不提交。然而，关键识别是将用户身份的某个方面与链上活动联系起来，并不是二元对立的，而是一个连续的过程。事实上，在买卖比特币的过程中，这种身份识别总是在不同程度上是可能的。

例如，如果您在瑞士的监管平台上购买比特币，则不需要 KYC（了解您的客户）。但是，由于购买是通过银行账户进行的，因此可能会对你的密钥进行识别。这就是与 KYC 相关的前两个风险出现的地方--促进链上跟踪和暴露于政府监控--这也可能在非 KYC 交易所中表现出来。如果瑞士实体向您所在国家的当局报告可疑交易，他们只需检查用于购买的银行账户，就能发现您的身份。因此，在受监管的平台上不进行 KYC 的购买在关键识别的风险等级上是相当高的。

不过，避开受监管的平台，选择 P2P（点对点）收购方式并不能完全消除密钥识别的风险，而只是降低了风险。以在 Bisq 或其他 P2P 平台上购物为例。与交易对手结算时，您可能会使用银行账户。如果当局询问与您交易的人并询问您的姓名，我们就会遇到上述风险 1 和 2。当然，这些风险比在平台上进行非 KYC 购买的风险要低得多，甚至比使用 KYC 购买的风险更低，但它们在一定程度上仍然存在。

最后，即使你通过实体现金交易所购买比特币，你也不是完全匿名的。与你交易的人看到了你的脸，这是你身份的一部分。虽然在这个例子中这种可能性微乎其微，但识别钥匙的可能性仍然存在。

总之，在用比特币兑换其他资产的过程中，无论是购买法定货币还是出售实物资产，总会有一种形式的密钥识别。根据所选择的兑换方式，这种识别的强度会有所不同。重要的是，不要将这种识别与 KYC 混为一谈，后者是一个定义明确的监管过程。不过，KYC 与识别范围之间有联系，因为 KYC 是识别范围的高端，因为它系统地促进了当局对用户密钥的识别。

## 销售和采购方法

<chapterId>756598af-95aa-4c77-ac48-243c7ad89530</chapterId>

读完上一章后，你可能会想知道如何在不进行身份验证的情况下买卖比特币，以避免与 KYC 相关的风险。有几种方法可以进行交换。

### P2P 现金交易

正如我们所看到的，就隐私而言，最好的方法仍然是采用现金结算的点对点（P2P）交换。无论您是买方还是卖方，这种方法都能最大限度地减少留下的痕迹，并大大降低关键识别的可能性。

然而，这种做法存在个人安全风险。主要的危险在于，在交换过程中，对方会知道你持有大量现金或比特币。这些信息可能会引起恶意分子的注意。事实上，一般建议对持有比特币保持谨慎。这一建议也适用于现金。然而，在当面交换的过程中，不可避免地要透露自己拥有比特币，这可能会引起贪婪。

为了限制这种风险，我建议你优先与可信赖的人进行现金交易，比如家庭成员或亲密朋友。或者，你也可以考虑在[当地比特币会议](https://btcmap.org/communities/map)上进行交换，在参加几次之后。这样可以让你更好地了解其他参与者，在实物交换时也不会感到孤单。然而，重要的是要认识到，P2P 现金兑换本身会给您的个人安全带来风险，而通过受监管的平台和您的银行账户进行购买则不存在这种风险。

此外，根据你居住的地方，无论是比特币还是现金，运输和存储大笔资金都可能带来风险。

在警察或其他人员检查时，兑换现金也会带来法律风险。虽然大多数国家对您携带的现金数额没有限制，但数额过大可能会引起怀疑。因此，要谨慎行事，尤其是在您必须长途旅行的情况下，避免一次性进行过大金额的交易，这样您就不必为持有大额现金进行辩解。

最后，P2P 购买的另一个缺点是价格往往高于受监管平台的价格。卖家通常会收取 1%至 10%以上的附加费。造成这种价格差异的原因有几个。首先，这是 P2P 卖家长期以来形成的普遍做法。此外，卖家在向买家发送资金时会产生交易费用。与平台交易相比，P2P 销售的失窃风险也更高，因此有理由收取一定的风险费用。最后，溢价可能与需求和交易所在隐私方面的质量有关。作为买方，卖方收取的附加费中已经包含了隐私收益。一些比特币玩家还认为，在 P2P 平台上购买的 BTC 价格上涨反映了它们的真实价值，并认为受监管平台上较低的价格是对个人信息隐私权进行权衡的结果。

### 通过匹配平台进行 P2P 交换

就个人安全而言，风险较低的另一种选择是通过 PayPal、银行转账或 Revolut 等电子支付方式，完全在网上进行 P2P 交换。

这种方法有助于避免与现金交易相关的许多风险。不过，在网上交易中，交易方不履行承诺的风险更大。事实上，在实物交换中，如果你把钱交给卖方，而卖方没有给你比特币作为回报，你可以立即把他叫出来，因为他就站在你面前。而在网上，往往不可能找到偷你钱的人。

为了降低这种风险，可以使用专门的匹配平台进行 P2P 交换。这些平台使用冲突解决机制来保护受害用户。一般来说，它们提供一个托管系统，在卖方确认以法定货币付款之前，比特币将被托管在该系统中。

就个人安全而言，这种购买方式要比实物现金交易安全得多。不过，如前所述，在线 P2P 交易所留下的痕迹比实体交易所更多，这可能会对比特币的隐私造成损害。通过使用银行等在线法币支付方式，你会暴露更多的信息，从而便于关键识别。

我再次建议不要在这些平台上进行单笔大额交易。通过拆分交易，您可以分散与交易对手潜在盗窃相关的风险。

P2P 购买的另一个缺点是价格往往高于受监管平台的价格。卖家通常会收取 1%至 10%以上的附加费。造成这种价格差异的原因有几个。首先，这是 P2P 卖家长期以来形成的普遍做法。此外，卖家在向买家发送资金时会产生交易费用。与平台交易相比，P2P 销售的失窃风险也更高，因此有理由收取一定的风险费用。最后，溢价可能与需求和交易所在隐私方面的质量有关。作为买方，卖方收取的附加费中已经包含了隐私收益。一些比特币玩家还认为，P2P 购买的 BTC 价格较高，反映了其真实价值，并认为受监管平台的价格较低，是个人信息隐私权权衡的结果。

至于解决方案，我个人一直使用 [Bisq](https://bisq.network/)，对他们非常满意。他们的系统成熟可靠。不过，Bisq 只能在 PC 上使用，其界面对于初学者来说可能过于复杂。另一个缺点是，Bisq 完全使用链上交易，这在比特币交易费用高昂的时期可能会变得昂贵。

-> 了解我们的 Bisq 教程。

https://planb.network/tutorials/exchange/peer-to-peer/bisq-fe244bfa-dcc4-4522-8ec7-92223373ed04
如果想选择更简单的方法，您可以试试 [Peach](https://peachbitcoin.com/)，这是一款移动应用程序，通过集成的争议解决系统促进买卖双方之间的联系。该程序比 Bisq 更直观。

-> 了解我们的桃子教程。

另一个在线选择是 [HodlHodl](https://hodlhodl.com/)，这是一个历史悠久的平台，提供良好的流动性，不过我个人没有测试过。

-> 了解我们的 HodlHodl 教程。

https://planb.network/tutorials/exchange/peer-to-peer/peach-wallet-db64fe42-17ca-4b24-abb8-e7d4c03b2028
https://planb.network/tutorials/exchange/peer-to-peer/hodlhodl-d7344cd5-6b18-40f5-8e78-2574a93a3879
关于基于闪电网络的解决方案，您可以试试 [RoboSats](https://learn.robosats.com/) 和 [LNP2PBot](https://lnp2pbot.com/)。RoboSats 可通过网站访问，使用相对简单。LNP2PBot 则比较特殊，它是通过信息应用 Telegram 上的交换系统运行的。

-> 查看我们的机器人卫星教程。

-> 查看我们的 LNP2PBot 教程。

https://planb.network/tutorials/exchange/peer-to-peer/robosats-b60e4f7c-533a-4295-9f6d-5368152e8c06
https://planb.network/tutorials/exchange/peer-to-peer/lnp2pbot-v2-e6bcb210-610b-487d-970c-7cce85273e3c
### 无 KYC 的受监管平台

根据你所居住的国家，你可以使用不需要 KYC 程序的受监管平台来买卖比特币。例如，在瑞士，您可以使用 [Relai](https://relai.app/) 和 [MtPelerin](https://www.mtpelerin.com/) 等平台。

-> 了解我们的 Relai 教程。

正如我们在上一章中看到的，这类平台可以避免与 KYC 程序相关的风险，但它们的密钥识别风险较高。因此，在比特币的隐私保护方面，这些平台比 KYC 购买方式提供更好的保护，但不如 P2P 交易所吸引人。

不过，就个人安全而言，使用这些平台的风险要比 P2P 交易所小得多。这些平台通常也比促进 P2P 交流的平台更容易使用。

https://planb.network/tutorials/exchange/centralized/relai-v2-30a9671d-e407-459d-9203-4c3eae15b30e
### 自动取款机

另一种无需 KYC 就能买卖比特币的方法是加密货币自动取款机（ATM）。就我个人而言，我从来没有机会测试这种解决方案，因为在我的国家还没有。但这种方法可能非常有趣，这取决于你住在哪里。

自动取款机的问题在于，有些国家禁止使用自动取款机，有些国家则对其进行严格监管。如果自动取款机需要进行身份验证，那么它面临的风险与受监管的 KYC 平台所固有的风险相同。但是，如果自动取款机允许小额交易而无需身份验证，那么使用自动取款机可以提供与基于现金的 P2P 交易所相当的隐私水平，避免与这类交易所相关的大部分风险。

自动取款机的主要缺点在于其外汇兑换费用通常很高，从兑换金额的百分之几到百分之十五不等。

### 礼品卡

最后，我还想为那些希望每天使用比特币购物而不是将比特币出售换取法定货币的人介绍一种行之有效的解决方案。

使用比特币的最佳方式显然是直接使用比特币或闪电网络购买商品或服务。然而，在许多国家，接受比特币的商家数量仍然有限。因此，一个实用的替代方法就是使用礼品卡。

一些不需要 KYC 程序的平台提供将比特币兑换成礼品卡的功能，这些礼品卡可以在各大商店使用。这些平台包括[CoinsBee](https://www.coinsbee.com/)、[The Bitcoin Company](https://thebitcoincompany.com/)和[Bitrefill](https://www.bitrefill.com/)。这些平台极大地方便了比特币的日常使用，让你无需转换法定货币就能获得各种产品和服务。

https://planb.network/tutorials/exchange/centralized/bitrefill-8c588412-1bfc-465b-9bca-e647a647fbc1
### 其他获取方式

当然，在保护个人隐私的同时获取比特币的其他方法还有挖矿。要开始挖矿，你不需要透露自己的身份；只需找到一份有效的工作证明并提交给网络即可。如果你选择矿池挖矿，有些矿池要求提供身份证明，如 KYC，有些则不需要。

另一种方法是以工作换取比特币。这种获取方式可能很有吸引力，但所需的身份验证程度因情况不同而大相径庭。

\为了写这一章，我使用了[@pivi\_\_](https://x.com/pivi___)在 Plan ₿网络上创建的 BTC205 课程（目前只有法语版本）。

## 合并、UTXO 和 CIOH 管理

<chapterId>d0486c8f-332d-402b-ae2e-949416752b9c</chapterId>

当你拥有自己的自助存储组合时，最复杂的管理问题之一无疑是合并。是否应该合并？目的是什么？您应该寻求实现多大的 UTXO 规模？隐私权如何权衡？这就是我们本节要探讨的问题。

### 什么是合并？

比特币的运作类似于拍卖市场，矿工们会优先考虑提供最优惠费用的交易。不过，每个区块都有一个最大权重，限制了可包含的交易数量。由于平均每 10 分钟产生一个区块，因此每个区块的可用空间都是稀缺资源。

矿工的业务涉及电力、资本和维护等方面的大量成本，自然会寻求利润最大化。他们倾向于选择相对于其权重能提供最高费用的交易。

事实上，并非所有比特币交易的重量都一样。输入和输出越多的交易，其权重就越大。例如，考虑 2 笔交易：


- 交易 A 包括 1 个输入和 1 个输出。它分配了 1 994 sats 的费用，权重为 141 vB；
- 更复杂的交易 B 有 2 个输入和 2 个输出，分配了 2 640 sats 的佣金，权重为 220 vB。

在这个例子中，虽然交易 B 提出的佣金总额更高，但矿工们会倾向于交易 A，因为它提供了更好的佣金与权重比。以下是每笔交易的计算结果，以每个虚拟字节（sat/vB）表示：

```text
TXA: 1994 / 141 = 14 sat/vB
TXB: 2640 / 220 = 12 sat / vB
```

这意味着，对于每个权重单位，交易 A 提供的费用比交易 B 多，尽管后者提供的费用绝对值更大。

因此，对用户来说，在交易中消耗尽可能少的输入量越来越有吸引力。然而，为了满足产出支付的需要，必须消费足够的数量。因此，在管理自己的投资组合时，有必要拥有足够大的 UTXO。

合并的原则正是利用比特币费用较低的时期，将自己的小型UTXO合并成一个较大的UTXO。这样，当比特币手续费上涨时，就可以用最少的投入进行交易，从而减少绝对手续费的支出。这样做的目的是在高手续费时期计划强制交易。

除了节省交易费用外，合并UTXOs 还有助于避免产生 "灰尘"。灰尘 "指的是UTXO在萨特中的价值很低，不足以支付使用这些UTXO所需的交易费用。因此，只要交易费居高不下，使用这些UTXO在经济上就是不合理的。通过主动将UTXO分组，可以防止它们变成灰尘，确保所有资金仍然可用。

### UTXO的最小尺寸是多少？

有时有人问我，UTXO 的最低推荐值是多少。遗憾的是，这并没有一个通用的答案，因为这取决于您的偏好和佣金的市场条件。不过，这里有一个公式可以帮助您确定一个适合您需要的阈值：

$$
\frac {P \times F}T = M
$$

在哪里？


- P$ 是交易的权重；
- $F$ 代表您愿意支付的最高费率，单位为每 vbyte（sats/vB）；
- $T$ 是您愿意支付的交易费占 UTXO 总价值的百分比；
- $M$ 是每个 UTXO 的最低聪币金额。

假设您想支付标准 SegWit 交易的佣金，1 个输入和 2 个输出，重量为 141 vB。如果您最多支付 800 个 sats/vB，并且您最多愿意花费 UTXO 价值的 12% 作为佣金，那么计算结果将是

$$
\frac{141 \times 800}{0.12} = 940\ 000
$$

在这个例子中，明智的做法是在投资组合中将UTXOs 的最低值保持在 940,000 sat。

### 合并与 COIH

区块链分析中最广泛使用的启发式之一是 COIH（_共同输入所有权启发式_），它允许我们假设比特币交易的所有输入都属于同一个实体。准确地说，合并的原理是消耗多个UTXO作为输入，创建一个UTXO作为输出。因此，合并可以应用 COIH。

![BTC204](assets/fr/097.webp)

实际上，这意味着外部观察者可以推断，所有合并的 UTXO 很可能属于同一个人，而且生成的唯一输出也属于他们。这种情况会将不同的交易历史联系起来，从而损害您的隐私。例如，我合并了通过 P2P 获得的 3 个 UTXO 和通过需要 KYC 的平台获得的 1 个 UTXO：

![BTC204](assets/fr/098.webp)

通过这种方式，任何可以访问交易所平台数据的实体（可能包括政府机构）都可以识别出我持有其他数额的 BTC。以前，这些 UTXOs 与我的身份没有直接联系；现在有了。此外，这也向所有消息来源透露了我持有一定数量的比特币。

在管理 UTXOs 时，经济方面的考虑会推动合并以降低费用，而良好的隐私保护措施则建议永远不要合并 UTXOs。因此，在经济性和隐私性之间做出选择取决于每个用户的优先级。

如果既能避免合并，又能保持相当规模的UTXO，那就再好不过了。为此，请优化您的购买方法。如果你在 DCA 中购买比特币，尽量拉大一次性购买的距离，将价值集中到更少的 UTXO 中。每两个月一次性购买 1000 欧元比每周购买 120 欧元更容易管理。这样可以最大限度地减少产生的 UTXOs 数量，简化投资组合的管理，同时保护您的隐私。

如果您发现自己需要合并比特币，请优先合并同一来源的UTXOs。例如，合并来自单一平台的 10 个UTXOs 对您隐私的影响要小于将来自平台 A 的 5 个UTXOs 与来自平台 B 的 5 个UTXOs 混合在一起的影响。例如，将通过 KYC 获取的UTXO 合并为一项交易，将通过 P2P 获取的UTXO 合并为另一项交易。

无论如何，请记住，任何合并都不可避免地会导致隐私权的丧失。因此，在考虑到风险的情况下，要仔细评估这样做的必要性以及对您隐私的潜在影响。

## 其他良好做法

<chapterId>b5216965-7d13-4ea1-9b7c-e292966a487b</chapterId>

让我们一起来探讨其他一些可以帮助你优化比特币隐私的最佳做法。

### 完整的绳结

个人保管比特币是好事，但使用自己的完整节点更好！这就是为什么拥有自己的节点对完全主权使用比特币至关重要：


- 抵制审查**：任何人都无法阻止您的交易；
- 独立于第三方**：您不再依赖任何外部服务来验证区块链数据；
- 积极参与**：您可以设置自己的验证规则，并直接参与达成共识；
- 对网络的贡献**：通过运行一个节点，你可以帮助加强和传播比特币网络；
- 技术教育**：运行一个完整节点是加深你对比特币技术知识了解的好方法。

除了这些好处，使用全节点还能提高您传输交易时的隐私性。当你发出一笔交易时，它首先是通过你的钱包创建和签名的。要在比特币网络上传输，必须至少有一个节点知道它。通过使用自己的节点，您可以直接控制传输，从而提高您的隐私性并限制数据丢失的风险。

![BTC204](assets/fr/099.webp)

如果您没有自己的比特币节点，您将不得不使用第三方的节点，如钱包软件供应商提供的节点。除了交易传输，您的钱包还需要访问各种信息，如待处理交易、与您的地址相关的余额或交易确认的数量。要访问所有这些数据，您需要查询一个节点。

![BTC204](assets/fr/100.webp)

不使用自己的比特币节点的主要风险是，第三方节点运营商可能会观察到你在区块链上的活动，甚至与其他实体共享这些信息。为了限制这种风险，一个中间解决方案是使用允许您通过 Tor 隐藏连接的钱包软件。这样可以减少数据的暴露。然而，最佳的解决方案仍然是拥有自己的比特币节点，并用它来传输您的交易。当然，你还必须确保没有任何信息从你的节点泄露出去，但这是我们将在下文中探讨的另一个话题。

除了对您的隐私有明显好处外，拥有自己的完整节点还能确保区块链上数据的真实性，防止审查，并让您积极参与比特币治理。通过使用自己的节点，您可以向自己选择的区块链贡献自己的经济权重，这在社区内部发生冲突时非常重要，例如在 2015 年至 2017 年的区块大小战争期间。在发生分叉的情况下，使用第三方节点可能会导致你支持一条你不希望支持的链，因为节点运营商会替你做出选择。正如你所理解的，从隐私和更普遍的个人主权角度来看，运行和使用自己的完整节点至关重要！

### 欺骗性分析启发法

一般来说，了解我们在上一节中讨论的启发式方法非常重要，这样才能更好地避免或欺骗它们。采用一些最佳实践可以证明是有益的，即使它们不是必需的。它们提供了一个额外的保护层，对于在使用比特币时保持良好的隐私非常重要。

我给出的第一个建议是融入最密集的人群。在比特币上，这意味着使用最广泛采用的脚本模板。例如，P2WSH 脚本通常用于多重签名 SegWit V0 配置，但非常罕见。它们无法让你隐藏在一大套匿名中。P2PKH 或 P2SH 等旧模式也是如此。虽然它们广泛存在于 UTXO 中，但在新交易中使用得越来越少。

一般来说，只要最新的脚本标准被广泛采用，那么采用最新的脚本标准会更安全。因此，在 2022 年，我会建议不要使用 P2TR（Taproot），因为它的采用率很低，但到了 2024 年，我会建议选择这种脚本，如果不行，也可以选择 SegWit V0 脚本，因为使用 P2TR 的交易数量已经开始占到相当大的比例。

来源：[txstats.com](https://txstats.com/d/000000054/utxo-set-repartition-by-output-type)

另一个保护隐私的小窍门是尽量规避内部交易启发式。例如，当您付款时，您可以尽量避免创建一个整数输出，因为这可能意味着其他输出代表了变化。如果你必须向朋友发送 10 万个聪，可以考虑转账一个稍高的金额，以规避这种启发式。同样，尽量不要创建与支付金额相比高得不成比例的剩余输出，因为这也会暴露哪个输出代表剩余。

最后，如果你经常进行比特币交易，请确保不要总是在相同的时间传输。通过在一天和一周内分散传输交易，可以避免让外部观察者发现基于时区的时间模式，从而改进他们的分析。

除了这些日常采用的最佳做法，还有更有效的方法可以彻底破坏比特币的可追溯性。这些方法当然包括币合交易，我们将在下一节深入研究。

# 了解 Coinjoin 交易

<partId>6d0bbf16-3714-4db1-9897-2d45019f6bdc</partId>

## 什么是 Coinjoin 交易？

<chapterId>0862bc6b-1c48-4aa4-b76d-4f547b469008</chapterId>

在学习了隐私保护的基础知识后，我们现在将讨论更复杂的技术，旨在积极保护你的隐私，特别是通过析出你的比特币历史记录。在下一部分，我们将探讨许多小技巧，但首先我想告诉大家 coinjoin。

Coinjoin 通常被认为是保护比特币用户隐私的最有效方法。但究竟什么是 Coinjoin 交易呢？让我们一起来了解一下。

### Coinjoin 的基本原则

Coinjoin 是一种破坏区块链上比特币追踪的技术。它基于同名特定结构的协作交易：Coinjoin 交易。

正如我们在本培训的第一部分所看到的，比特币上的交易通过节点为所有用户所知。因此，很容易验证每个币的电子签名链并观察其历史。这意味着所有用户都可以尝试分析其他用户的交易。因此，交易层面的匿名是不可能的。但在个人身份识别层面，匿名性却得以保留。与传统银行的每个账户都与个人身份相关联不同，在比特币上，资金与加密密钥对（或脚本）相关联，从而在加密标识符背后为用户提供了一种假名形式。

![BTC204](assets/it/51/01.webp)

因此，当外部观察者能够将特定的 UTXO 与已识别的用户联系起来时，比特币的保密性就会受到损害。一旦这种关联建立起来，就有可能追踪他们的交易，分析他们的比特币历史。Coinjoin 正是为了破坏对UTXOs 的追踪而开发的一种技术，目的是在交易层面为比特币用户提供一定程度的保密性。

Coinjoins 通过使外部观察者的链分析复杂化来提高比特币用户的保密性。它们的结构允许将来自不同用户的多个硬币合并成一笔交易，从而混淆了交易痕迹，难以确定输入和输出地址之间的联系。

重要的是要明白，"接币 "交易的目的是打乱比特币的历史。这种技术不会赋予比特币永久的匿名性，也不会永久停止比特币的可追溯性，这与人们可能的想法恰恰相反。Coinjoin 的目的只是在进行 Coinjoin 交易时中断历史。然而，在这次交易之前和之后，比特币仍然面临同样的隐私风险。

![BTC204](assets/fr/104.webp)

### 共同连接是如何工作的？

Coinjoin 的原理基于一种协作方法：几个希望混合比特币的用户将相同金额的比特币存入同一交易的输入端。然后，这些金额会以等值输出的方式重新分配给每个用户。

![BTC204](assets/fr/105.webp)

在交易结束时，无法将特定的输出与已知的用户输入相关联。输入和输出之间没有直接联系，这就打破了用户和他们的UTXO之间的关联，也打破了每个硬币的历史。

![BTC204](assets/fr/106.webp)

让我们以爱丽丝为例。她想给妹妹伊芙发送大约 100,000 个比特币作为生日礼物。但是，爱丽丝不希望伊芙能够追踪到她的交易历史，因为她不想暴露自己拥有多少比特币或如何获得这些比特币。为此，爱丽丝决定用一次 Coinjoin 交易来打乱她的 UTXO 历史记录。她安排鲍勃、查尔斯、大卫和弗兰克进行一次合作交易：爱丽丝、鲍勃、查尔斯、大卫和弗兰克各自承诺 105,000 萨特的UTXO（其中 5,000 萨特为挖矿费用）作为交易输入：

![BTC204](assets/fr/107.webp)


- 作为使用这些输入的回报，每个人都会生成一个新地址，以创建五个相同的输出，每个输出为 100,000 sats。每个参与者检索一个输出：

![BTC204](assets/fr/108.webp)


- 爱丽丝最终得到了一个由 100 000 个卫星组成的UTXO，它的历史是混合的。她在新的交易中使用这个UTXO，将这笔钱寄给夏娃作为生日礼物：

![BTC204](assets/fr/109.webp)


- 如果夏娃试图分析这笔交易以提取信息，她会遇到涉及爱丽丝、鲍勃、查尔斯、大卫和弗兰克的 coinjoin 交易。由于金额的统一性，夏娃无法区分每笔输入属于谁，因此她无法追踪爱丽丝的UTXO历史，也无法确定她的妹妹拥有多少比特币或她是如何获得这些比特币的：

![BTC204](assets/fr/110.webp)

在这种情况下，爱丽丝使用了硬币连接技术来提高其隐私性，以防止后向分析。事实上，爱丽丝可以保护自己免受夏娃可能进行的分析，即从特定交易开始向后追溯UTXO 的历史。这种防止从现在到过去的分析的保护措施就是我们所说的回溯性不可见性（retrospective anonset）。我们将在本部分的最后几章详细探讨这一概念。

不过，coinjoin 也提供了改善隐私的可能性，以防止从过去到现在的分析，即所谓的前瞻性匿名。让我们回到爱丽丝在夏娃生日那天向她发送了 98,000 条信息的例子，但将角色颠倒一下。现在让我们想象一下，关心自己隐私的是夏娃。事实上，爱丽丝可能会受到诱惑，跟踪她发送给夏娃的硬币来收集信息。伊芙可能会将这个新收到的 UTXO 与她所有其他的 UTXO 合并，这可能会向爱丽丝透露她钱包中持有的比特币数量。为了避免这种情况，Eve 还可以破坏新收到的硬币的历史记录。


- 夏娃、格蕾丝、马洛里、奥斯卡和维克多各自将 98,000 sats 的UTXO 作为比特币交易的输入：

![BTC204](assets/fr/111.webp)


- 作为使用这些输入的交换，每个用户提供一个新地址，以创建 5 个输出，每个输出有 97 500 个卫星，完全相等。每个用户获取一个输出：

![BTC204](assets/fr/112.webp)


- 伊芙现在拥有 97 500 sats 的UTXO，而且历史记录已被破坏。她可以放心地将其用于未来的交易。事实上，如果 Alice 试图追踪她发送给 Eve 的比特币，她就会遇到 Coinjoin 交易。她将无法确定 Eve 属于哪个 UTXO 输出。这样，分析就变得不可能了：

![BTC204](assets/fr/113.webp)

在第一个例子中，我们看到了 coinjoin 如何保护硬币过去的隐私，而在第二个例子中，我们看到了 coinjoin 如何保护硬币未来的历史。这就是为什么我提到，coinjoin 应被视为一个一次性事件，它可以在两个方向上分割硬币的历史：

![BTC204](assets/fr/104.webp)

### 混合、共同连接、混合器......有什么区别？

有时，"混合 "一词被用来描述币合，一些比特币爱好者拒绝接受这个词，因为他们担心与托管混合器相混淆。然而，我认为这种担心是没有根据的，因为在数学语境中，币合恰恰体现了混合的概念。

在数学的一般领域中，混合是指动态系统的一种特性，即经过一定时间后，初始空间的所有部分理论上都可以与任何其他部分混合。混合意味着粒子的位置或系统的状态以这样一种方式演化，即粒子的未来分布与其初始分布无关，从而达到初始状态的特征在系统空间中均匀分布的状态。这正是比特币的投币过程。因此，在我看来，coinjoin 实际上是一种硬币混合方法。

![BTC204](assets/fr/114.webp)

不过，必须将 "币合 "与 "混合器 "区分开来。混合器是一种用户发送比特币进行混合的服务。这些服务在 2010 年代很流行，但由于与币圈相比存在两大缺点，其使用率已经下降：


- 它们要求用户在混合过程中放弃对资金的保管，使用户面临被盗风险；
- 无法保证混合器不会记录交易细节，甚至不会将这些信息出售给区块链分析公司。

![BTC204](assets/fr/115.webp)

因此，如今用户更喜欢 Coinjoin，因为它允许他们在整个过程中保持对资金的完全控制。币合的参与者不会冒比特币被其他参与者盗取的风险。让我们在下一章一起探讨如何做到这一点。

## Zerolink 和 Chaumian Coinjoins

<chapterId>326c9654-b359-4906-b23d-d6518dd5dc3e</chapterId>

硬币拼接的隐私性取决于我们的棋子所隐藏的小组的规模。因此，必须找到尽可能多的参与者。完全可以通过独立找到的用户来手动运行 coinjoin，但这种方法比较复杂，而且无法实现大型匿名集。

这就是为什么在比特币上发展出了 Coojoin 协调员。他们的作用是连接不同的用户，并传递成功完成合作交易所需的信息。

![BTC204](assets/fr/116.webp)

但是，我们如何确保协调人永远不会控制用户的比特币？虽然协调人是构建 Coinjoin 交易的人，但我们如何确保协调人无法将用户的输入和输出联系起来，这可能会造成隐私的损失？

### 乔姆的盲人签名

现代 Coinjoin 实现使用戴维-乔姆（David Chaum）的盲签名来防止信息泄露。让我们一起快速研究一下这些盲签名是如何工作的。

Chaum 盲签名是一种数字签名形式，签名者不知道所签名的信息内容。然而，签名可以在以后与原始信息进行验证。这种技术由密码学家戴维-查姆于 1983 年提出。

例如，一家公司希望在不泄露合同等机密文件内容的情况下对其进行认证。该公司采用一种掩蔽程序，以可逆的方式对原始文件进行加密转换。修改后的文件被发送给认证机构，认证机构在不知道基本内容的情况下进行盲签名。收到签名文件后，公司会从签名中移除遮蔽。这样，一份原始文件就得到了认证机构签名的认证，而认证机构却从未见过原始文件的内容。

因此，Chaum 的盲签名可以在不知道文件内容的情况下认证文件的真实性，确保用户数据的保密性和签名文件的完整性。

### Chaumian Coinjoins

在 "Chaumian CoinJoins "中，Tor 的使用和 David Chaum 的盲签名相结合，确保协调者无法知道每个输出属于哪个用户。币合交易构建过程包括三个主要步骤：输入注册、输出注册和交易签名。让我们以联合交易所参与者之一爱丽丝为例，来看看这个过程。所有其他参与者都各自遵循与爱丽丝相同的步骤。

**第 1 步：注册输入**。


- 爱丽丝向协调者发送她希望作为交易输入的UTXO，以及她希望作为输出接收比特币的屏蔽接收地址。因此，协调者无法知道爱丽丝的地址。它只能看到她的屏蔽版本。
- 协调者验证输入的有效性，然后用爱丽丝的私钥对爱丽丝的屏蔽地址进行签名。然后他将盲签名发送给 Alice。

**第 2 步：记录输出**。


- 现在，爱丽丝可以从由协调人私钥签名的地址中移除伪装。她会以不同的 Tor 身份建立新的连接。协调者无法识别是爱丽丝在用这个新身份连接。
- 爱丽丝将未加掩饰的地址和签名发送给协调者（协调者仍不知道是爱丽丝）。

**第 3 步：签署交易**。


- 协调人同样会从所有参与者那里获取未加掩码的输出结果。有了相关的签名，他就可以验证匿名发送的每个输出实际上都是由他的私钥签名的，从而确保其合法性。然后，协调人就可以构建币合交易，并将其发送给参与者，让他们签署。
- 爱丽丝和其他参与者一样，要验证自己的输入和输出是否正确地包含在协调者构建的交易中。如果一切顺利，爱丽丝就会向协调者发送解锁其输入脚本的签名。
- 在收集了所有 Coinjoin 参与者的签名后，协调人就可以通过比特币网络传输交易，从而将其添加到一个区块中。

在这个系统中，协调人无法将输入与特定输出联系起来。此外，他也无法占有参与者的资金，因为他根本无法获取解锁 UTXO 所需的私人密钥。在整个过程中，直到第 3 步结束，他甚至无法获得签名。当爱丽丝和其他参与者在验证一切无误后签署全局交易时，协调人就不能再修改该交易，包括输出，而不会使其失效。这样就可以防止协调人盗取比特币。

最终，当他们在交易中登记自己的产出时，coinjoin 用户希望得到与公民投票类似的保证。这些行为的公开性和私密性具有双重性。一方面，是你想要保持的私密性：对于投票者来说，他们不希望自己的选票与自己的身份相关联；对于硬币拼接用户来说，他们不希望自己的输出与输入相关联。事实上，如果协调人或任何其他方设法在输入和输出之间建立联系，那么投币连接就失去了它的全部意义。如前所述，硬币接合必须作为硬币历史的一个中断。之所以会出现这种中断，正是因为在联币交易中无法将特定输入与特定输出联系起来（前瞻性中断），反之亦然（追溯性中断）。

另一方面，还有公共方面：投票人希望确保他们的选票包含在投票箱中；同样，币合用户希望确保他们的输出包含在币合交易中。事实上，币合参与者绝对有必要在签署交易之前验证其输出是否存在，否则协调人可能会窃取资金。

正是由于使用了戴维-恰姆的盲签名，这两个公共和私人方面才使得恰姆人的 Coinjoin 参与者确信他们的比特币不会被盗，他们的资金也不会被追踪。

### 谁发明了联接的概念？

很难确定是谁最先在比特币上提出了 "coinjoin "的概念，又是谁提出了在这种情况下使用大卫-查姆的盲签名的想法。人们通常认为是格雷戈里-麦克斯韦尔（Gregory Maxwell）在[2013 年 BitcoinTalk 上的一篇帖子](https://bitcointalk.org/index.php?topic=279249.0)中首次提到的：

使用乔姆的盲签名：用户连接并提供输入信息（和其他信息的地址），以及他们希望发送私人硬币的地址的加密模糊版本；服务器签署代币并将其返回给用户。用户以匿名方式重新连接，披露他们的输出地址，并将其发送回服务器。服务器可以看到所有输出都已由其签名，因此所有输出都来自有效的参与者。之后，人们重新连接并签名。

Maxwell, G. (2013, August 22)._CoinJoin：现实世界中的比特币隐私_.BitcoinTalk Forum. https://bitcointalk.org/index.php?topic=279249.0

然而，在混合和硬币接合的背景下，Chaum签名以前也被提到过。[2011年6月，邓肯-汤森（Duncan Townsend）在BitcoinTalk](https://bitcointalk.org/index.php?topic=12751.0)上介绍了一种混合器，它使用Chaum签名的方式与现代的Chaumians币币接合十分相似。

在同一个线程中，有[一条回复邓肯-汤森的哈希币信息](https://bitcointalk.org/index.php?topic=12751.msg315793#msg315793)来改进他的混频器。这条信息中描述的过程正是最接近币合的过程。Alex Mizrahi 在 2012 年的一条信息](https://gist.github.com/killerstorm/6f843e1d3ffc38191aebca67d483bd88#file-laundry) 中也提到了类似的系统，当时他正在为 Tenebrix 的创建者提供建议，Tenebrix 是最早的另类币之一，也是后来莱特币创建的基础。甚至连 "coinjoin "一词本身也不是格雷格-麦克斯韦尔发明的，而是来自彼得-托德的一个想法。

![BTC204](assets/fr/125.webp)

### Zerolink

Zerolink 是一种全面的混合协议，它整合了 Chaumiani 硬币接合和各种策略，以保护用户匿名性免受各种形式的链分析，从而大大减少了与钱包管理相关的错误。该协议[由 nopara73 和 TDevD 于 2017 年推出](https://github.com/nopara73/ZeroLink/blob/master/README.md)。

![BTC204](assets/fr/126.webp)

顾名思义，Zerolink 的原理是执行硬币连接交易，确保无法追踪输入和输出之间的联系。实现这一功能的方法是确保所有输出的金额完全相同。

![BTC204](assets/fr/127.webp)

Zerolink 的一项重要预防措施是使用不同的加密密钥，甚至是不同的钱包，将未混合的 UTXO 与混合的 UTXO 完全分开。这样，用于混合前硬币的 "混合前 "钱包与用于混合后硬币的 "混合后 "钱包就区分开了。

![BTC204](assets/fr/128.webp)

这种严格分离UTXO的做法主要是为了防止混合UTXO和未混合UTXO之间发生意外关联。事实上，如果出现这种关联，那么在用户不知情的情况下，coinjoin 在混合 UTXO 上的有效性就会失效，从而损害UTXO 的保密性，而用户认为UTXO 的历史记录已被破坏。如果用户将混合和未混合的UTXO作为同一交易的输入，那么这些链接可能会通过地址重用来确保混合UTXO与未混合UTXO的安全，或者通过应用共同输入所有权启发法（CIOH）而产生。通过分离混合前和混合后的组合，可以避免这些意外关联，保护用户免受无意错误的影响。

![BTC204](assets/fr/129.webp)

这种分离还提供了在组合软件层面对预混合和后混合组合应用不同规则的可能性。例如，在混合后投资组合中，软件可以禁止合并输入的UTXO，以防止应用 CIOH 影响用户ONSET。还可以对脚本和交易选项（例如 RBF 信号）的使用进行标准化，以防止钱包指纹识别。

目前，Whirlpool 是唯一一个严格执行 Zerolink 协议的联接实现。在下一章中，我们将探讨现有的各种 Coinjoin 实现及其优缺点。

## Coinjoin 实现

<chapterId>e37ed073-9498-4e4f-820b-30951e829596</chapterId>

在 2024 年，我们可以看到希望在比特币上运行 "接币 "的用户可以使用的工具发生了重大变化。我们目前正处于一个关键时期，币合市场正在经历一场重大的重组。因此，本章可能会随着时间的推移而更新。

目前，比特币上主要有三种不同的 Coinjoin 实现方式：


- 惠而浦；
- Wabisabi；
- JoinMarket.

这些实现方式都旨在通过联合交易打破UTXO 的历史。但是，它们的机制有很大不同。因此，有必要了解每种机制的工作原理，以便选择最适合您需求的方案。

### 加入市场

JoinMarket于2015年由亚当-吉布森（Adam Gibson）和克里斯-贝尔彻（Chris Belcher）创建，因其独特的用户匹配模式而不同于其他的币圈实现方式。该系统基于一个 P2P 交易所市场，其中一些用户（即 "制造者"）将他们的比特币用于混合，而另一些用户（即 "接受者"）则使用这些资金执行币币接合，以换取一定的费用。

![BTC204](assets/fr/130.webp)

在这种模式下，"制造者 "将自己的比特币提供给 "接受者"，并收取服务费。而 "入币者 "则付费使用 "制造者 "的比特币进行自己的入币交易。服务费因角色而异："制造者 "为其提供的流动性积累费用，而 "接受者 "则支付佣金。这个市场自由运作，没有使用条件。

JoinMarket 的一个主要缺点是使用复杂，需要对终端有一定的了解才能有效利用。虽然这种复杂性对有经验的用户不是障碍，但会限制一般公众的使用。不过，最近推出的名为 JAM 的网络界面在一定程度上方便了使用。

![BTC204](assets/fr/131.webp)

来源：[JAM]()[JAM](https://github.com/joinmarket-webui/jam/blob/devel/docs/assets/screenshot-dark.webp)

然而，技术壁垒仍然是一个主要障碍。在币币兑换生态系统中，参与人数越多，保密性就越高，任何降低可获取性的限制都会直接影响可用流动性，而流动性是混合效率的关键因素。比特币已经是金融交易中的一个利基，它将使用 Coinjoins 视为一个子利基，而 JoinMarket 则代表了一个更加专业的部分，因此限制了其增加用户匿名性的潜力。

尽管 JoinMarket 采用了创新的 P2P 比特币匹配模型，但它也有一些明显的缺点，特别是在交易结构方面。与 Whirlpool 等其他实现方式不同，JoinMarket 不能保证输出之间的完全平等，输入和输出之间可能存在确定性链接。它也缺乏防止已经混合的硬币再次混合的工具，这可能会损害用户寻求的保密性。最后，虽然 JoinMarket 的概念很有吸引力，特别是对那些对动态流动性市场感兴趣的人，但我认为，它的结构弱点和技术复杂性使它对新手和寻求硬币合并实施的专家都不那么有吸引力。

### Wabisabi

Wabisabi 是 Coinjoin 的另一种实现方式，采用的是集中协调交易的方法。该模式由 Ádám Ficsór (nopara73)、Yuval Kogman、Lucas Ontivero 和 István András Seres 于 2021 年设计，并于次年集成到 Wasabi 2.0 软件中。Wabisabi正是代表了2018年推出的Wasabi软件的coinjoin模式的演进。

2010 年代末，Wasabi 采用了与惠而浦截然不同的币圈交易结构。为了增加参与者的匿名性，Wasabi 采用了将数十名参与者组合在一起的超大型币合交易。相比之下，Whirlpool 则选择了多个小型交易，使得每个周期的匿名集数呈指数级增长。

处理余数的方法也是两种实现方法的不同之处。在 Whirlpool 中，余数被 TX0 排除在外，并在联接循环之前与UTXO 隔离，我将在下一章进一步解释这一概念。另一方面，在 Wasabi 中，余数构成了联接事务的输出之一，从而保持了某些输入和输出之间的确定性联系。

随着 Wabisabi 的推出，Wasabi 2.0 版本对其硬币连接方法进行了调整，以接近 Whirlpool 的方法。虽然硬币接合的交易量仍然很大，但现在可以连续进行几轮链式接合，从而效仿 Whirlpool 的模式。此外，Wabisabi 还在零钱管理方面做出了特别的努力：Wasabi 1.0 将零钱与用户输入直接挂钩，而 Wabisabi 则不同，它尝试将零钱分成若干小数目，并以相等的面额分配给所有参与者。

我们将通过一个只涉及 2 个用户的简化示例来说明这一点：爱丽丝想混合 115,000 萨特，鲍勃想混合 210,000 萨特。如果不考虑佣金，在 Wasabi 1.0 中，硬币合并交易会产生 3 个 100,000 sats 的输出，加上 Alice 的 1 个 15,000 sats 的剩余输出和 Bob 的 1 个 10,000 sats 的剩余输出。剩余的输出将始终与输入相连：

在 Wabisabi 模式下，同一笔交易会产生 3 个 100,000 sats 的输出和 5 个 5,000 sats 的输出，从而分散了剩余部分，使其无法直接追溯到特定的输入：

我个人认为，Wabisabi 的变革管理存在一些风险，可能会损害其在隐私方面的有效性：


- 当用户贡献的UTXO明显大于其他参与者的UTXO时，他最终不可避免地会产生与其输入相关的变化量。这就违背了协议的最初目标，即消除任何可识别的变化；
- 为了分割其余部分而增加名称，可能会自相矛盾地损害混合效率。这一过程可能会导致某些产出的不安全性降低，因为它们变得更容易识别；
- 这种方法还会产生低价值的 UTXO，给用户带来管理问题。如果这些小的 UTXO 相对于其价值而言花费过高，就会变成 "灰尘"。这种现象会促使用户在今后的交易中合并几个输入的 UTXO，或将其合并。无论哪种情况，由于 COH 的存在，这都会降低所获得的匿名性，或完全抵消从最初的硬币合并中获得的隐私利益。

惠而浦通过确保UTXO预混合和后混合之间的严格隔离来执行零链接协议，而Wasabi则不同，它没有保持这种严格的隔离。此外，Wasabi 的一些客户还存在地址重复使用的问题，这显然对用户非常有害。

在 Wasabi 2.0 版本中，实施了新的接币定价政策。现在，对于大于 0.01 比特币的UTXO，协调费定为 0.3%，而对于较小的UTXO，协调费则完全归零。此外，这些较小的 UTXOs 的重混合是免费的，但所有交易（包括重混合）仍需支付挖矿费。

这一政策与 Whirlpool 的政策形成鲜明对比，后者的佣金是固定的，与获得的 anonsets 大小无关。在 Wasabi 2.0 中，虽然小规模 UTXO 的协调员佣金被重置为零，但用户仍需为所有交易（包括混矿）支付挖矿佣金。

在撰写本报告时，由于最近发生的事件，Wabisabi 的使用已变得相当复杂。事实上，在 Samourai 钱包的创始人被捕后，负责资助和管理 Wasabi 开发的公司 zkSNACKs 宣布于 2024 年 6 月 1 日终止其 Coinjoin 协调服务。该协调器被默认设置为 Wasabi，拥有绝大多数的流动性。

随着这个主协调器的关闭，用户现在必须连接到新的独立协调器。这一变化引起了人们的担忧：一方面，新的协调者可能没有足够的流动性，从而降低了硬币接合在隐私方面的有效性。另一方面，还存在遭遇恶意协调者的风险。这种情况给想要使用 Wabisabi 的人增加了新的重大风险。

除了技术问题之外，Wasabi 背后的公司 zkSNACKs 决定使用区块链分析公司的服务来筛选币圈参与者，这也引发了严重的道德和战略问题。最初的想法是防止犯罪分子利用 Wasabi 上的接币，这一举措看似合法。然而，这却引发了一个悖论：向一个以提高用户隐私为主要任务的协调者支付费用，然后却资助一家以破坏用户隐私为目标的公司。

更令人担忧的是过滤原则，这与比特币提供一个开放的、不受审查的金融系统的理念形成鲜明对比。虽然排除犯罪活动似乎是合理的，但这种过滤也可能针对那些虽然在某些情况下被归类为非法，但在道德上是合理的或对社会有益的个人行为。爱德华-斯诺登（Edward Snowden）的例子就很好地说明了这种两分法：一些政府认为他的揭露行为是犯罪，而另一些政府则认为他是为公众利益而行动的举报人。这种复杂性凸显了过滤的潜在危险，虽然过滤的出发点是好的，但最终可能会损害合法用户的权利和安全。我还可以提到某些专制政权下受迫害的活动家和记者。正如你可能已经猜到的，我毫无疑问更倾向于在比特币上进行币合的漩涡模式。这个系统因其严谨性而脱颖而出，并在隐私方面提供了卓越的保障。它也是唯一一个提出在数学背景下被认为是完美的混合模型。在我看来，这种模式代表了比特币上币接合的未来。因此，我邀请大家在下一章更深入地探讨这个模型。

## 惠而浦的运作

<chapterId>bdbd7109-e36d-4b4f-a3c6-928df4e9bfda</chapterId>

漩涡有别于其他加入硬币的方法，它使用"_ZeroLink_"交易，确保所有输入和所有输出之间在技术上没有任何可能的联系。这种完美的混合是通过一种结构来实现的，在这种结构中，每个参与者的投入（挖矿费用除外）都是相同的，因此产生的产出完全相等。

这种对输入的限制性方法使惠而浦的联合交易具有一个独特的特点：输入和输出之间完全没有确定的联系。换句话说，相对于交易中的所有其他输出，每个输出归属于任何参与者的概率都是相等的。

![BTC204](assets/fr/136.webp)

### 惠而浦的一般运作

最初，每次漩涡币合并的参与者人数限制为 5 人，其中有 2 名新加入者和 3 名混币者（我们将在后面解释这些概念）。然而，2023 年观察到的链上交易费用的增加促使 Samourai 团队重新思考他们的模式，以提高隐私性，同时降低成本。因此，考虑到佣金市场的情况和参与者的数量，协调人现在可以组织包括 6、7 或 8 名参与者的币圈合并。这些增强型会话被命名为"_Surge Cycles_"。值得注意的是，无论采用哪种配置，惠而浦投币游戏中始终只有 2 个新参与者。

因此，惠而浦交易的特点是输入和输出的数量相同，可以是


- 5 个输入和 5 个输出；

![BTC204](assets/fr/137.webp)


- 6 个输入和 6 个输出；

![BTC204](assets/fr/138.webp)


- 7 个输入和 7 个输出；

![BTC204](assets/fr/139.webp)


- 8 个输入和 8 个输出。

![BTC204](assets/fr/140.webp)

因此，惠而浦提出的模式是基于小规模的硬币连接交易。与 Wabisabi 和 JoinMarket 不同，Whirlpool 依靠的是多个小循环的串联。在这种模式下，用户只有在首次进入池子时才会产生费用，这样他们就可以在不增加额外费用的情况下参与多种混音。新加入者承担了混矿者的开采成本。

每增加一次硬币加入，加上过去遇到的同行，onsets 就会呈指数增长。因此，我们的目标是利用这些免费的混搭，每次混搭都有助于加强与每个硬币混搭相关的匿名集的密度。

惠而浦在设计时考虑到了两个重要要求：


- 由于 Samourai 钱包主要是一个智能手机应用程序，因此可以在移动设备上方便地实施；
- 混音循环的速度会促使不可见性显著增加。

Samourai 钱包的开发人员在设计 Whirlpool 时，以这些必要条件为指导，限制了每个周期的参与者人数。参与人数太少会影响 Coinjoin 的效果，大大减少每个循环中产生的硬币，而参与人数太多又会给移动应用程序带来管理问题，阻碍循环的流动。

最终，在 Whirlpool 上进行联合不一定要有大量的参与者，因为ONSET 是通过几个联合循环的累积来实现的。这里最重要的原则是所有参与者的UTXO的同质性，因为这可以实现完美的混合，从而充分受益于混合和再混合循环。

### 联合泳池和费率

为使这些多重循环能有效提高混合硬币的安设率，必须建立某种框架来限制所使用的 UTXO 数量。因此，惠而浦定义了几个池。

一个币池代表一组希望混合在一起的用户，他们就UTXO的使用量达成一致，以便在保持币的完美同质性的同时优化加入币的过程。每个币池规定了一个固定的UTXO数额，用户必须达到该数额才能参与。因此，要使用 Whirlpool 进行硬币接合，必须选择一个池。目前可用的币池如下


- 0.5 比特币
- 0.05 比特币
- 0.01 比特币
- 0.001 比特币（= 100,000 萨特）。

加入比特币池后，这些比特币将被分割，生成与池中其他参与者完全相同的UTXO。每个比特币池都有一个最高限额；因此，如果比特币的数额超过了这个限额，你将被迫分两次进入同一个比特币池，或者转到另一个数额更大的比特币池：

| 币池（比特币） | 每个条目的最高金额（比特币） | | 每个条目的最高金额（比特币） | | 每个条目的最高金额（比特币

|----------------|----------------------------------------|

| 0,5 | 35 |

| 0,05 | 3,5 |

| 0,01 | 0,7 |

| 0,001 | 0,025 |

当一个UTXO准备好并入一个币池时，它就被视为属于该币池。但这并不意味着用户失去了对它的所有权。正如我们在本部分前几章所看到的，在不同的混合周期中，用户可以保留对密钥的完全控制权，因此也可以保留对比特币的完全控制权。这就是币合技术与其他集中式混合技术的不同之处。

要加入 Coinjoin 矿池，必须支付服务费和采矿费。每个矿池的服务费都是固定的，旨在补偿负责开发和维护 Whirlpool 的团队。

使用 Whirlpool 的服务费必须在进入泳池时一次性支付。完成此步骤后，您就可以无限次参加混音，无需支付额外费用。以下是每个池当前的固定费用：

Pool (bitcoin) | Input fee (bitcoin) | Pool (bitcoin) | Input fee (bitcoin)

| -------------- | --------------------------------- |

| 0.5 | 0.0175 |

| 0.05 | 0.00175 |

0.01 | 0.0005 (50,000 sats) | 0.01 | 0.0005 (50,000 sats) | 0.0005 (50,000 sats)

| 0.001 | 0.00005 (5,000 sats) | | 0.001 | 0.00005 (5,000 sats)

无论您在 coinjoin 中输入的金额是多少，这些费用本质上都是您所选矿池的入场券。因此，无论您是以 0.01 BTC 进入 0.01 BTC 池，还是以 0.5 BTC 进入 0.01 BTC 池，费用的绝对值都是相同的。

在进行惠而浦硬币连接之前，用户可以选择两种策略：


- 选择规模较小的资金池，以尽量减少服务费，因为他们知道自己将获得几个较小的 UTXO；
- 或者喜欢更大的资金池，同意支付更高的费用，最终获得少量价值更高的 UTXO。

一般来说，不建议在硬币连接循环后合并几个混合的UTXO，因为这可能会损害所获得的隐私，尤其是因为共同输入所有权启发式（CIOH：_Commun-Input-Ownership-Heuristic_）。因此，明智的做法是选择更大的数据池，即使这意味着要支付更多的费用，以避免有太多小价值的UTXO作为输出。用户必须对这些权衡进行评估，以选择自己喜欢的数据池。

除了服务费，还必须考虑任何比特币交易中固有的采矿费。作为 Whirlpool 用户，您需要为准备交易 (`Tx0`)以及首次加入比特币支付挖矿费用。由于 Whirlpool 采用向新加入者支付费用的模式，因此所有后续的混币都将是免费的。

事实上，在每次漩涡联合中，输入用户中有两个是新参与者。其他输入用户来自再混合者。因此，交易中所有参与者的挖矿费用都由这 2 个新参与者承担，他们也将从免费混音中受益：

![BTC204](assets/it/54/07.webp)

由于采用了这种收费系统，Whirlpool 真正区别于其他 Coinjoin 实现，因为 UTXO 的匿名性与用户支付的价格不成正比。因此，只需支付入池费和 2 笔交易（"Tx0 "和初始混合）的挖矿费，即可实现相当高的匿名性。

值得注意的是，用户还需要支付从矿池中提取UTXOs 的挖矿费用，除非他们选择了 "混合到 "选项，该选项允许他们提供一个外部地址，该地址将直接接收资金，作为硬币连接的输出，而无需任何额外的交易。

### 高清钱包账户

要通过 Whirlpool 进行币合，钱包必须生成多个独立账户。这就是 ZeroLink 协议的原理。在 HD（层次确定性）钱包中，一个账户构成一个与其他账户完全隔离的部分，这种隔离发生在钱包层次结构的第三级深度，即 "xpub "级。

![BTC204](assets/it/54/08.webp)

一个 HD 钱包理论上最多可以衍生出 `2^(32/2)` 个不同的账户。所有比特币钱包默认使用的初始账户对应于`0'`索引。

对于适用于惠而浦的投资组合，使用 4 个账户来满足 ZeroLink 流程的要求：


- 存款账户**，由索引 "0 "标识；
- 不良银行账户**（或 "有毒交易所"），以 "2 147 483 644 "为索引；
- 以 "2 147 483 645 "为索引的**预混账户**；
- 以 "2 147 483 646 "为索引的**混合后账户**。

这些账户在联接过程中各司其职，我们将在下文中探讨。

所有这些账户都与一个种子相关联，用户可以使用恢复短语，必要时还可以使用密码，恢复对所有比特币的访问。不过，在恢复操作过程中，有必要向软件指定所使用账户的不同索引。

现在让我们来看看这些账户中惠而浦硬币连接的不同阶段。

### TX0

任何惠而浦币合的起点都是**存款账户**。该账户是您创建新比特币钱包时自动使用的账户。该账户必须存入您想要混合的比特币。

Tx0 "是漩涡混合过程的第一步。其目的是准备和均衡UTXO，将其划分为与所选池数量相对应的单位，以确保混合的均匀性。然后，均衡后的UTXO 被发送到**预混合账户**。至于无法进入池中的差额，则会被分离到一个特定账户：**坏银行**（或 "有毒交易所"）。

最初的 "Tx0 "交易也是为了结清应支付给 Coinjoin 协调员的服务费。与后续步骤不同的是，这笔交易不是协作性的；因此，用户必须承担全部挖矿费用：

![BTC204](assets/it/54/09.webp)

在这个 "Tx0 "交易示例中，从我们的**存款账户**输入的 372 000 萨特被分成若干UTXOs 输出，分配如下：


- 分配给协调员的 5 000 萨特的服务费，相当于进入 100 000 萨特的资金池；
- 3 个准备混合的UTXO，转入我们的**预混合账户**，并在协调员处登记。这些UTXO的均价为每个 "108 000萨特"，以支付其未来初始混合的采矿费；
- 因数额太小而无法进入资金池的盈余被视为有毒交易所。它被发送到特定账户。在这里，这种交换的金额为 40 000 萨特；
- 最后，还有 "3 000 个卫星 "并不构成产出，而是确认 "Tx0 "所需的采矿费。

例如，这里有一个真正的 Tx0 惠而浦（不是我的）：[edef60744f539483d868caff49d4848e5cc6e805d6cdc8d0f9bdbbaedcb5fc46](https://mempool.space/fr/tx/edef60744f539483d868caff49d4848e5cc6e805d6cdc8d0f9bdbbaedcb5fc46)

![BTC204](assets/fr/145.webp)

### 有毒的变化

无法纳入资金池的多余部分（此处相当于 "40,000 萨特"）被转入**坏银行**账户，也称为 "有毒交换"，以确保与投资组合中的其他UTXO 严格分离。

这种UTXO对用户隐私是危险的，因为它不仅仍然与用户的过去相关联，从而可能与其所有者的身份相关联，而且它还被标记为属于一个参与过合币的用户。

![BTC204](assets/fr/146.webp)

如果将该UTXO 与洗牌输出合并，用户将失去在硬币连接循环中获得的所有隐私，这在很大程度上是由于 CIOH（_Commun-Input-Ownership-Heuristic_）造成的。如果与其他有毒变化合并，用户将面临失去隐私的风险，因为这将连接来自共线连接循环的不同输入。因此，应谨慎处理。我们将在本章最后一节详细讨论如何管理这些有毒的 UTXO。

### 初始混合

在 "Tx0 "完成后，均衡后的UTXO被发送到我们投资组合中的**premix**账户，准备进入它们的第一个币合周期，也称为 "初始混合"。如果在我们的例子中，"Tx0 "产生了多个用于混合的UTXO，那么每个UTXO都将被整合到一个单独的初始混合中。

在这些首次混合结束后，**premix**账户将清空，而我们的币在支付了首次加入的挖矿费用后，将按照所选矿池规定的数额进行结算。在我们的例子中，我们最初的UTXOs`108,000 sats`将正好减少到`100,000 sats`。

![BTC204](assets/fr/147.webp)

### 混音版

初始混音后，UTXO 被转入 **postmix** 账户。该账户收集已混合的UTXO和等待重新混合的UTXO。当 Whirlpool 客户端激活时，**postmix** 账户中的UTXO 将自动用于混音，并将被随机选中参与新一轮混音。

需要提醒的是，重新混合是完全免费的：不需要额外的服务费或挖矿费。因此，将UTXOs 保留在**后混合**账户中可保持其价值不变，同时提高其匿名性。这就是为什么必须允许这些币参与多个加入币周期的原因。这完全不花你一分钱，而且还能提高它们的匿名水平。

当您决定使用混合UTXO时，可直接从该**postmix**账户中使用。建议将混合UTXO保存在此账户中，以享受免费混音，并防止混合UTXO离开漩涡电路，因为这可能会降低混合UTXO的私密性。

### 如何正确管理您的 postmix 账户？

运行币合循环后，最好的策略是将UTXO保存在**后混合**账户中，以备将来使用。甚至建议无限期地让它们重新混合，直到你需要使用它们为止。

一些用户可能会考虑将混合比特币转移到受保护的硬件钱包中。这是有可能的，但必须严格遵守 Samourai 钱包的建议，以免影响所获得的保密性。

合并UTXO 是最常犯的错误。你需要避免在同一笔交易中将混合UTXO与非混合UTXO结合起来，以避免共同输入所有权（CIOH）启发式。这就需要谨慎管理投资组合中的UTXO，尤其是标签方面。

![BTC204](assets/fr/148.webp)

将混合 UTXO 合并在一起也必须谨慎。如果混合的UTXO具有显著的不对称，可以进行适度的合并，但这将不可避免地降低硬币的保密性。请确保合并的幅度不要太大，也不要在重新混合次数不足后进行合并，以免在硬币合并周期前后在您的UTXO之间建立推断的联系。如果对这些操作有疑问，最好的做法是不要在混合后合并UTXO，而是将它们逐个转移到硬件钱包中，每次都生成一个新的空地址。仍然要记得正确标注收到的每个 UTXO。

也不建议将您的 UTXO 后混合转移到使用不常用脚本的钱包。例如，如果您从使用 `P2WSH` 脚本的多位钱包进入漩涡，您将有小概率与其他拥有相同类型钱包的用户混合。如果您在同一个多字符钱包中提取您的后混合币，您混合比特币的隐私级别将大大降低。除了脚本之外，还有许多其他钱包指纹也能骗过你。

与任何比特币交易一样，重要的是不要重复使用接收地址。每笔新交易都应该用一个新的空地址接收。

最简单、最安全的解决方案是让您的混合 UTXO 在其**后混合**账户中休息，允许他们重新混合，只在花费时才接触他们。Samourai 和 Sparrow 投资组合对所有这些连锁分析风险提供额外保护。这些保护措施可以帮助您避免犯错。

### 如何正确管理有毒变化？

其次，您必须小心处理您的有毒零钱，即无法进入投币池的零钱。这些因使用惠而浦而产生的有毒 UTXO 会给您的隐私带来风险，因为它们会在您和投币器使用之间建立联系。因此，必须谨慎处理这些UTXO，不要将其与其他UTXO，尤其是混合UTXO结合在一起。

这里有几种使用策略可供参考：


- 在较小的水池中混合使用：** 如果有毒的UTXO足够大，可以单独放在一个较小的水池中，可以考虑混合使用。这通常是最佳选择。但不建议将多个有毒UTXO混合在一起进入一个水池，因为这可能会将不同的入口连接起来。
- 将其标记为 "不可消费"：** 另一种方法是停止使用，在专用账户中将其标记为 "不可消费"，然后直接删除。这样可以确保你不会不小心花掉它们。如果比特币价值上升，可能会出现更适合你的有毒 UTXOs 的新矿池；
- 捐款：** 考虑向开发比特币及其相关软件的开发者捐款，哪怕是微薄的捐款。您也可以向接受 BTC 的组织捐款。如果管理有毒的 UTXOs 显得过于复杂，您可以通过捐款将其清除。
- 购买礼品卡：** [Bitrefill](https://www.bitrefill.com/)等平台允许你用比特币兑换礼品卡，这些礼品卡可以在各种商家使用。这也是一种处理有毒 UTXOs 而不损失相关价值的方法。
- 将它们合并到莫奈罗：** Samourai 钱包提供 BTC 和 XMR 之间的原子交换服务。这非常适合管理有毒的UTXO，将它们整合到Monero上，而不会通过KYC泄露您的隐私，然后再将它们发送回比特币。不过，由于流动性的限制，这一方案在采矿费和溢价方面可能会比较昂贵。
- 将它们发送到闪电网络：** 将这些UTXO传输到闪电网络，以享受交易费用的降低，是一个很有吸引力的选择。不过，这种方法可能会泄露一些信息，具体取决于您对闪电的使用情况，因此应谨慎使用。

### 如何使用惠而浦？

2024 年 4 月 24 日，Samourai 钱包的创始人被捕，其服务器也被查封，此后，漩涡工具已无法使用，即使拥有自己 Dojo 的用户也无法使用。在此之前，Samourai 钱包和 Sparrow 钱包上可以使用该工具。

![BTC204](assets/fr/149.webp)

不过，根据试验结果，该工具仍有可能在未来几周内重新投入使用，或以其他方式重新推出。无论如何，我相信比特币上的接币市场不会长期没有供应，因为有明显的需求。此外，漩涡模式在隐私保护方面是最先进的，将来肯定会被用于其他实现方式。

我们正密切关注此案的进展以及相关工具的发展情况。请放心，一旦有新的信息，我们将及时更新培训内容。

在下一章中，我们将了解什么是 "anonsets"，这些指标是如何计算的，以及它们如何帮助我们估算联接循环的有效性。

https://planb.network/tutorials/privacy/on-chain/coinjoin-sparrow-wallet-84def86d-faf5-4589-807a-83be60720c8b
https://planb.network/tutorials/privacy/on-chain/coinjoin-samourai-wallet-e566803d-ab3f-4d98-9136-5462009262ef
https://planb.network/tutorials/privacy/on-chain/coinjoin-dojo-c4b20263-5b30-4c74-ae59-dc8d0f8715c2
## 匿名设置

<chapterId>be1093dc-1a74-40e5-9545-2b97a7d7d431</chapterId>

在研究了硬币拼接的工作原理以及与有效混合相关的挑战之后，我们现在将学习如何衡量这种有效性。如何确定硬币拼接过程是否有效，以及硬币的匿名程度如何？这就是我们在本章中要探讨的匿名集或英文中的 "anonsets"。

### 提醒您 Coinjoin 的实用性

CoinJoin 的实用性在于它能够通过将你的钱币沉浸在一组无法区分的钱币中来产生似是而非的可抵赖性。此举的目的是打破从过去到现在以及从现在到过去的可追溯性联系。

换句话说，如果分析师知道您在 CoinJoin 周期进入时的初始交易（"Tx0"），那么他就无法确定您在 remix 周期退出时的 UTXO（从进入周期到退出周期的分析）。

![BTC204](assets/it/55/01.webp)

相比之下，如果分析师知道您在 CoinJoin 循环输出时的 UTXO，就应该无法确定循环输入时的原始交易（从循环输出到循环输入的分析）。

![BTC204](assets/it/55/02.webp)

为了评估分析师将过去和现在联系起来的难度，有必要量化隐藏硬币的同质硬币组的大小。这一指标告诉我们具有相同概率的分析的数量。因此，如果正确的分析被淹没在其他 3 个概率相同的分析中，则您的隐藏水平非常低。但是，如果正确的分析是在一组 20000 个相同概率的分析中，那么你的硬币就隐藏得很好。准确地说，这些集合的大小代表了一种叫做 "无集合 "的指标。

### 了解 Anonsets

匿名集是评估特定 UTXO 隐私程度的指标。更具体地说，它们衡量的是包括所研究硬币在内的UTXO集合中无法区分的UTXO数量。对同质 UTXO 集的要求意味着匿名集通常是根据 CoinJoin 循环来计算的。由于漩涡式 CoinJoin 的一致性，这些指标的使用与漩涡式 CoinJoin 尤为相关。

在适当的时候，匿名集可以用来判断 CoinJoins 的质量。大的匿名集意味着高水平的匿名性，因为在同质集合中很难分辨出特定的UTXO。

有 2 种类型的不适用情况：


- 潜在的不发病者；**
- 追溯性的ONSET.**

### 前瞻性的不确定性

前瞻性湮没表示所研究的UTXO在周期退出时隐藏在其中的群体的大小，知道进入时的UTXO，即这一群体中存在的无法区分的硬币的数量。该指标的英文名称为 "forward anonset "或 "forward-looking metrics"。

该指标通过对过去到现在（投入到产出）的分析，衡量货币的隐私阻力。

![BTC204](assets/it/55/03.webp)

该指标可估算UTXO 受保护的程度，以防止有人试图重建其在联合进程中从进入点到退出点的历史。

例如，如果您的交易参与了第一个加入硬币的周期，并完成了另外两个递减周期，那么您的硬币的预期退市时间将是 `13`：

![BTC204](assets/fr/153.webp)

例如，让我们想象一下，我们的硬币在硬币连接周期的入口处，受益于`86 871`的预期取消。实际上，这意味着它隐藏在`86,871`枚无法区分的硬币中。对于一个在硬币连接周期开始时意识到这枚硬币并试图追踪其出口的外部观察者来说，他将面临`86,871`个可能的UTXO，每个都有相同的概率成为所寻找的硬币。

![BTC204](assets/it/55/05.webp)

### 回首往事

回溯性隐匿性（Retrospective anonset）是指在知道周期退出时的UTXO的情况下，特定硬币可能的来源数量。该指标衡量的是硬币在从现在到过去的分析（退出到进入）中的隐私阻力，即在硬币连接周期之前，分析师追踪硬币来源的难度。该指标的英文名称为 "backward anonset"，或 "retrospective metrics"。

通过了解您在周期退出时的UTXO，追溯反向确定了可能构成您在硬币连接周期中进入的潜在Tx0交易的数量。在下图中，这相当于所有橙色气泡的总和。

例如，让我们想象一下，我们的硬币在硬币连接周期的出口处受益于`42,185`的追溯性不对称。实际上，这意味着这枚 UTXO 有`42,185`个可能的来源。如果外部观察者在周期结束时识别出这枚硬币并试图追踪其来源，他将面临`42 185`个可能的来源，所有这些来源都有相同的概率成为所寻找的来源。

### 如何具体计算 anonsets？

对于小型数据集，您可以使用数据块资源管理器手动计算数据集。但是，对于较大的 anonsets，必须使用专门的工具。据我所知，唯一能完成这项任务的软件是_Whirlpool Stats Tool_，这是一款由 Samourai 和 OXT 团队开发的 Python 工具。不幸的是，在 Samourai 创始人被捕和 OXT 终止后，这个工具目前已停止使用，因为它被用来从区块链中提取数据。

正如我们在本章中所看到的，只有在币币结构存在某种同质性的情况下，才能计算出 "anonsets"。在下一章中，我们将了解如何量化比特币交易中的这种同质性，无论是币合还是更传统的交易。

https://planb.network/tutorials/privacy/analysis/wst-anonsets-0354b793-c301-48af-af75-f87569756375
## 熵

<chapterId>e4fe289d-618b-49a2-84c9-68c562e708b4</chapterId>

正如我们在 "币链 "部分所看到的，UTXO 在输入和输出中的同质性在提高比特币交易的保密性方面发挥着重要作用。这一参数允许在链分析中进行似是而非的推诿。有几种方法可以测量这种同质性，但在我看来，最有效的方法之一是使用 OXT 和 Samourai 钱包团队开发的_Boltzmann_工具提供的指标，特别是交易熵。这就是我们将在本章详细研究的内容。

与以一组交易为计算基础的 anonsets 不同，我们在此介绍的指标只关注单笔交易，无论是币合还是更传统的交易。

### 解释的数量

在比特币交易中可以观察到的第一个指标是外部观察者在分析交易时眼中可能的解释总数。考虑到交易中涉及的UTXO的值，该指标显示了输入与输出相关联的方式的数量。换句话说，它决定了从外部观察者分析的角度来看，一笔交易在比特币流中可能产生的解释数量。

例如，一个只有 1 个输入和 2 个输出的简单支付交易只有一种解释，即输入 #0 为输出 #0 和输出 #1 提供资金。没有其他可能的解释：

![BTC204](assets/fr/159.webp)

相比之下，按照惠而浦 5x5 模型构建的硬币连接有 1496 种可能的组合：

![BTC204](assets/fr/160.webp)

Whirlpool Surge Cycle 8x8 硬币连接得出 9,934,563 美元的可能解释：

![BTC204](assets/fr/161.webp)

### 熵

根据比特币交易的解释次数，我们可以计算出它的熵。

在密码学和信息的一般情况下，熵是对与数据源或随机过程相关的不确定性或不可预测性的定量测量。换句话说，熵是衡量预测或猜测信息难度的一种方法。

在链分析的具体语境中，熵也是一个指标的名称，它源于香农熵，[由 LaurentMT 发明](https://gist.github.com/LaurentMT/e758767ca4038ac40aaf)，可以计算比特币交易。

当一项交易有大量可能的解释时，参考其熵往往更有意义。这个指标可以衡量分析师对交易的确切配置缺乏了解的程度。换句话说，熵越高，分析师就越难识别输入和输出之间的比特币流动。

在实践中，熵揭示了从外部观察者的角度来看，交易是否有多种可能的解释，而这些解释仅仅基于输入和输出数量，而不考虑其他外部或内部模式和启发式方法。因此，高熵意味着交易具有更高的保密性。

熵的定义是可能组合数的二进制对数。下面是使用的公式，其中 $E$ 代表交易熵，$C$ 代表可能的解释数：

$$
E = \log_2(C)
$$

在数学中，二进制对数（以 2 为底的对数）对应于将 2 提升到一定幂的逆运算。换句话说，$x$ 的二进制对数就是为得到 $x$，必须将 2$ 提升到的指数。因此，这个指标用比特来表示。

以按照 5x5 惠而浦模型结构的联接交易的熵计算为例，如上一节所述，该交易的可能解释数为 1,496 美元：

$$
\begin{align*}
C &= 1.496 \\
E &= \log_2(1.496) \\
E &= 10.5469 \text{ bit}
\end{align*}
$$

因此，该硬币连接交易的熵值为 10.5469$ 比特，非常令人满意。该值越高，交易可接受的不同解释就越多，从而提高了其私密性。

对于有 9,934,563 美元解释的 8x8 硬币合并交易，熵为

$$
\begin{align*}
C &= 9.934.563 \\
E &= \log_2(9.934.563) \\
E &= 23,244 \text{ bit}
\end{align*}
$$

我们再举一个标准支付交易的例子，其中有 1 个输入和 2 个输出：[1b1b0c3f0883a99f1161c64da19471841ed12a1f78e77fab128c69a5f578ccce](https://mempool.space/tx/1b1b0c3f0883a99f1161c64da19471841ed12a1f78e77fab128c69a5f578ccce)

![BTC204](assets/fr/162.webp)

就该事务而言，唯一可能的解释是：`(In.0) > (Out.0 ; Out.1)`。因此，其熵设为 0$：

$$
\begin{align*}
C &= 1 \\
E &= \log_2(1) \\
E &= 0 \text{ bit}
\end{align*}
$$

### 效率

根据交易熵，我们还可以计算出其隐私效率。该指标通过与相同配置下的最优交易进行比较，来评估交易的效率。

这就引出了最大熵的概念，即特定事务结构理论上可以达到的最高熵。然后，通过比较最大熵和所分析事务的实际熵，计算出事务的效率。

所用公式如下


- E_R$：交易的实际熵，以比特为单位；
- E_M$：事务结构的最大可能熵，也以比特为单位；
- Ef$：以比特为单位的交易效率：

$$
Ef = E_R - E_M
$$

例如，对于 Whirlpool 5x5 类型的联接结构，最大熵为 10.5469$：

$$
\begin{align*}
E_R &= 10,5469 \\
E_M &= 10,5469 \\
Ef &= E_R - E_M \\
Ef &= 10,5469 - 10,5469 \\
Ef &= 0 \text{ bit}
\end{align*}
$$

该指标也用百分比表示。计算公式如下


- C_R$：可能的实数解释数；
- C_M$：具有相同结构的可能解释的最大数量；
- Ef$：以百分比表示的效率：

$$
\begin{align*}
E_f &= \frac{C_R}{C_M} \\
E_f &= \frac{1.496}{1.496} \\
E_f &= 100\%
\end{align*}
$$

因此，100%$ 的效率表明，根据交易结构，交易的隐私潜力最大。

### 熵密度

熵是衡量交易隐私的一个很好的指标，但它在一定程度上取决于交易中输入和输出的数量。要比较输入和输出数量不相同的两个不同交易的熵，可以计算熵密度。该指标提供了相对于交易中每个输入或输出的熵的视角。密度有助于评估和比较不同规模的事务的效率。

要计算它，只需用交易的总熵除以交易涉及的输入和输出总数即可：


- E_D$：以比特为单位的熵密度；
- E$：以比特为单位的交易熵；
- T$：交易中输入和输出的总数：

$$
E_D = \frac{E}{T}
$$

以 5x5 惠而浦硬币连接为例：

$$
\begin{align*}
T &= 5 + 5 = 10 \\
E &= 10.5469 \\
E_D &= \frac{E}{T} \\
E_D &= \frac{10.5469}{10} \\
E_D &= 1.054 \text{ bit}
\end{align*}
$$

我们还计算了 8x8 漩涡式拼接的熵密度：

$$
\begin{align*}
T &= 8 + 8 = 16 \\
E &= 23.244 \\
E_D &= \frac{E}{T} \\
E_D &= \frac{23.244}{16} \\
E_D &= 1.453 \text{ bit}
\end{align*}
$$

通过分析这两种硬币连接的熵密度，我们可以明显看出，即使对元素数量的熵进行归一化处理，"浪涌周期 8x8 "硬币连接产生的分析不确定性也更大。

### 波兹曼分数

交易中分析的另一项信息是每个元素相对于另一个元素的波尔兹曼分数。这是一张输入和输出之间对应概率的表格。该表通过波尔兹曼分数显示了特定输入与特定输出相关的条件概率。因此，它是交易中输入和输出之间发生关联的条件概率的定量测量，根据在一组解释中该事件的有利发生次数与可能发生的总次数之比来确定。

以惠而浦硬币连接为例，条件概率表将突出显示每个输入和输出之间存在联系的可能性，从而对交易中关联的模糊性进行量化衡量：

| % | 输出 0 | 输出 1 | 输出 2 | 输出 3 | 输出 4 |

| ------- | -------- | -------- | -------- | -------- | -------- |

显然，每项输入与任何输出相关联的概率都是相同的，这就提高了交易的保密性。

计算波尔兹曼分数的方法是用出现某一事件的解释数除以可用解释总数。因此，要通过将输入 #0 与输出 #3（在 512$ 种解释中出现的事件）相关联来确定得分，过程如下：

$$
\begin{align*}
\text{Interpretazioni (IN.0 > OUT.3)} &= 512 \\
\text{Interpretazioni Totali} &= 1496 \\
\text{Punteggio} &= \frac{512}{1496} \\
\text{Punteggio} &= 34\%
\end{align*}
$$

如果我们重新考虑一下浪涌 8x8 惠而浦硬币连接循环的例子，波尔兹曼表将如下所示：

| | out.0 | out.1 | out.2 | out.3 | out.4 | out.5 | out.6 | out.7 | out.7 | out.7

| ---- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |



| in.1 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23



| 英寸 3 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| 英寸 4 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23







但是，如果是涉及一个输入和两个输出的简单交易，情况就不同了：

| 输出 0 输出 1

| ------- | -------- | -------- |

| 输入 0 | 100% | 100% |

在这里，我们可以看到每个输出来自输入 0 的概率是 100%。因此，概率越低，输入和输出之间的直接联系就越少，隐私性也就越高。

### 确定性链接

还可以计算交易中确定性链接的数量。这一指标揭示了在分析的交易中，有多少输入和输出之间的链接是毫无疑问的，具有 100% 的可能性。然后，可以通过计算确定性链接的比率来完善这一指标。通过该比率可以了解这些确定性链接在交易所有链接中的权重。

例如，惠而浦的一个硬币合并交易显示输入和输出之间没有确定性联系，因此显示的指标为 0 个联系和 0% 的比率。与此相反，在我们研究的第二种简单支付交易（有一个输入和两个输出）中，指标告诉我们有两个确定性链接，比率达到 100%。因此，由于输入和输出之间不存在直接的、无可争议的联系，指标为空意味着隐私性极佳。

### 如何计算这些指标？

使用我提供的公式手动计算这些指标相对简单。主要困难在于确定交易的可能解释数量。对于标准交易，这种计算可以手工完成。但是，对于联合交易来说，这项工作要复杂得多。

在此之前，OXT 和 Samourai 团队开发了一个名为_Boltzmann Calculator_的 Python 工具，可以自动计算比特币交易的所有这些指标：

![BTC204](assets/fr/163.webp)

也可以使用 KYCP.org 网站进行这些分析：

![BTC204](assets/fr/164.webp)

遗憾的是，在 Samourai 创始人被捕后，这些工具目前无法使用。

既然我们已经详细讨论了 "硬币连接"，那么在培训的最后一部分，我们将探讨比特币上的其他隐私保护技术。我们将研究payjoin交易、特定的伪coinjoin交易类型、静态地址协议，以及不是在交易层面而是在节点网络层面改善隐私的措施。

https://planb.network/tutorials/privacy/analysis/boltzmann-entropy-738e45af-18a6-4ce6-af1a-1bf58e15f1fe
# 了解其他高级隐私技术的利害关系

<partId>19989ae6-d608-4acf-b698-2cf1e7e5e6ae</partId>

## Payjoin 交易

<chapterId>c1e90b95-f709-4574-837b-2ec26b11286f</chapterId>

目前，在链分析过程中，硬币连接是将不确定性引入硬币追踪的最有效方法。正如我们在前几章中所看到的，要实现有效的混合，输入和输出必须尽可能地相同。此外，至关重要的是，要将硬币连接整合到尽可能大的组中，以最大化不确定性。因此，要使硬币拼接有效，必须涉及大量统一的硬币。这些要求意味着币仓交易有一个非常严格的结构：金额是预先确定的，所有参与者都必须遵守，以确保过程的统一性。此外，硬币接合要求所有参与者和协调者在交易构建过程中保持同步。

这些要求使得 Coinjoin 不适合直接支付。例如，如果您在 Coinjoin 池中拥有一枚 100 万萨特的硬币，直接用它来支付将非常复杂。它需要与其他参与者和协调者同步，以便在您需要付款时准确建立合作交易，而且购买金额必须与您的币值完全匹配，这实际上是不可行的。因此，币合交易本质上是一种协作清理交易，这意味着一般情况下，输入的所有者都是输出的所有者。

然而，通过在链分析中引入疑问来实现实际支付的交易结构是非常有趣的。这正是我们将在本章和下一章探讨的问题。

### 什么是 payjoin 交易？

Payjoin 是一种特殊的比特币交易结构，它通过与收款人合作来增强用户在消费过程中的隐私。

2015 年，根据一篇可查阅的论文[此处](https://gist.githubusercontent.com/LaurentMT/e758767ca4038ac40aaf/raw/c8125f6a3c3d0e90246dc96d3b603690ab6f1dcc/gistfile1.txt)，LaurentMT 首次以 "隐写交易 "的名义提到了这种方法。后来，Samourai 钱包采用了这一技术，并于 2018 年成为第一个使用 Stowaway 工具实现这一技术的客户端。Payjoin 的概念也出现在 [BIP79](https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki) 和 [BIP78](https://github.com/bitcoin/bips/blob/master/bip-0078.mediawiki) 中。因此，有多个术语被用来指代 payjoin：


- Payjoin；
- 偷渡者
- P2EP（_Pay-to-End-Point_）；
- 加密交易。

payjoin 的独特之处在于它能够产生一种交易，这种交易乍一看很普通，但实际上是两个人之间的迷你 Coinjoin。为此，交易的结构是收款人与实际发款人一起参与输入。然后，收款人在交易中间向自己支付一笔款项，这样他就可以得到付款。

让我们举个例子来更好地理解这个过程。爱丽丝用 10,000 萨特的UTXO 购买了一个 4,000 萨特的法棍，并选择了付费加入。她的面包师鲍勃在输入中加入了自己的 15000 萨特UTXO，除了爱丽丝的 4000 萨特外，他还在输出中收回了全部UTXO。

在这个例子中，面包师鲍勃投入 15 000 沙特，产出 19 000 沙特，差额正好是 4 000 沙特，也就是长棍面包的价格。爱丽丝投入 10,000 沙特，最后产出 6,000 沙特，差额为-4,000 沙特，也就是法棍的价格。为了简化示例，我特意省略了交易中的采矿费。

### 付费连接的目的是什么？

payjoin 交易实现了两个目标，使用户能够提高支付的私密性。

首先，"付费连接 "的目的是通过在链分析中制造歧义来欺骗外部观察者。这是通过_共同输入所有权启发式_（CIOH）实现的。正如我们在第 3 部分中所看到的，当区块链上的交易有多个输入时，通常会假定所有这些输入都属于同一个实体或用户。

因此，分析人员在检查付款合并交易时，会认为所有输入都来自同一个人。然而，这种看法是不正确的，因为收款人也与实际付款人一起提供输入。因此，链式分析偏向于一种被证明是错误的解释。

让我们回到支付长棍面包的 payjoin 交易示例：

看到区块链上的这笔交易，外部观察者按照链分析的通常启发式方法会这样解释："爱丽丝在交易输入中加入了 2 个 UTXO，向鲍勃支付了 19000 萨特"。

这种解释显然是错误的；正如你已经知道的，输入中的两个 UTXO 并不属于同一个人。一个来自买法棍的爱丽丝，另一个来自面包师鲍勃。

这样，外部观察者的分析就会指向一个错误的结论，从而确保利益相关者的保密性。

### 加密交易

付款连接的第二个目的是在实际付款金额上欺骗外部观察者。通过研究交易结构，分析人员可能会认为支付的金额等同于其中一个输出的金额。

如果我们以购买长棍面包为例，分析师会认为付款金额对应的是 6000 沙特的UTXO 或 19000 沙特的UTXO。在这种情况下，分析师更有可能认为支付金额是 19000 沙特，因为输出中有 2 个UTXO，其中至少有一个大于 6000 沙特（使用 2 个UTXO 支付 6000 沙特在逻辑上是不合理的，因为单个UTXO 就足以支付这笔款项）。

但实际上，这种分析是不正确的。支付金额与任何产出都不匹配。它实际上是产出接收方的 UTXO 与输入接收方的 UTXO 之间的差额。

在这一点上，payjoin 交易属于隐写术的范畴。它可以将交易的真实金额隐藏在虚假交易中，起到声东击西的作用。

隐写术是一种将信息隐藏在其他数据或物体中，使人无法察觉隐藏信息存在的技术。例如，可以将秘密信息隐藏在无关文本的一个点中，使肉眼无法察觉（这就是 [微点](https://fr.wikipedia.org/wiki/Micropoint) 技术）。

加密技术使信息在没有解密密钥的情况下无法被理解，而隐写技术则不同，它不会改变信息。它们仍然在视野中。相反，隐写术的目的是隐藏秘密信息的存在，而加密术则是清楚地揭示隐藏信息的存在，尽管没有密钥是无法获取的。这就是为什么 payjoin 最初的名称是 "隐写交易"。

可以将密码学与硬币接合进行类比，也可以将隐写术与付费接合进行类比。事实上，coinjoin 具有与密码学类似的属性：方法可以识别，但信息无法破译。相比之下，payjoin 则类似于隐写术：理论上可以获取信息，但由于其隐藏方法无法识别，因此信息变得无法获取。

### 如何使用 payjoin？

支持 payjoin 的已知软件包括 Sparrow Wallet、Wasabi Wallet、Mutiny、BitMask、BlueWallet 和 JoinMarket，以及 BTCPay 支付处理器。

Payjoin 最先进的实现方式只有 Samourai 钱包上的 Stowaway。然而，自从软件创始人关闭后，这个工具现在只能部分运行。Stowaway 的优势在于它是一个完整且非常易于使用的协议，支持接收和发送 payjoin。部分签名交易可以通过扫描多个 QR 码手动交换，也可以通过 Soroban 在 Tor 上自动交换。后一种通信方式目前尚未投入使用。

使用 payjoin 的困难在于它依赖于商家的参与。作为客户，如果商家不支持 payjoin，就无法使用它。这就给购物增加了额外的困难：不仅寻找接受比特币的商家很复杂，如果还要寻找支持 payjoin 的商家，那就更复杂了。

一种解决方案是使用交易结构，在不要求收款人合作的情况下，将模糊性引入链分析。这样，我们就可以在不依赖商家积极参与的情况下提高支付的私密性。这正是我们将在下一章研究的内容。

https://planb.network/tutorials/privacy/on-chain/payjoin-sparrow-wallet-087a0e49-61cd-41f5-8440-ac7b157bdd62
https://planb.network/tutorials/privacy/on-chain/payjoin-samourai-wallet-48a5c711-ee3d-44db-b812-c55913080eab
## 迷你币兑换付款

<chapterId>300777ee-30ae-43d7-ab00-479dac3522c1</chapterId>

如果想在进行支付交易的同时保留一定程度的隐私，payjoin 是一个不错的选择。但正如我们所见，payjoin 需要收款人的参与。那么，如果收款人拒绝参与 payjoin，或者你根本不想让他参与，该怎么办呢？一种选择是使用石墙或石墙 x2 交易。让我们仔细看看这两种交易。

### 石墙交易

石墙 "是比特币交易的一种特殊形式，旨在通过模仿两个人之间的伪比特币连接（但实际上并不是一个人）来增加用户在购物时的隐私。事实上，这种交易并不是协作式的。用户可以自己创建，只需将自己拥有的UTXO作为输入。这样，你就可以在任何场合创建 "石墙 "交易，而无需与其他用户或收款人同步。

石墙交易的操作如下：在交易的输入端，发送方使用 2 个属于自己的UTXO。在输出端，交易产生 4 个UTXO，其中 2 个的金额完全相同。另外 2 个UTXO 构成剩余部分。在这 2 个金额相同的输出中，只有一个会实际支付给收款人。

石墙交易中只有两种角色：


- 付款的发件人；
- 收件人可能不知道交易的具体性质，只是在等待发件人付款。

让我们举个例子来理解这种交易结构。爱丽丝在面包师鲍勃的店里买了一条长棍面包，价格是 4000 萨特。她既想用比特币支付，又想在一定程度上保护自己的隐私。因此，她决定构建一个石墙交易来进行支付。

分析这笔交易，我们可以看到面包师鲍勃实际上收到了 4000 萨特的长棍面包付款。爱丽丝使用了 2 个UTXO 作为输入：一个是 10,000 萨特，一个是 15,000 萨特。在产出中，她收到了 3 个UTXO：一个 4000 萨特，一个 6000 萨特，一个 11000 萨特。因此，爱丽丝在这次交易中的净余额为 -4,000 沙特，与长棍面包的价格完全相同。

在这个例子中，为了便于理解，我故意忽略了挖矿费用。实际上，交易费用完全由发送者承担。

### 石墙交易的目标是什么？

石墙结构给交易增加了很多熵，并混淆了链式分析的痕迹。从外观上看，这种交易可以被解释为两个人之间的迷你币合并。但实际上，这是一种支付。因此，这种方法会在链分析中产生不确定性，甚至导致错误的痕迹。

让我们回到爱丽丝在面包师鲍勃家的例子。区块链上的交易是这样的

![BTC204](assets/fr/174.webp)

外部观察者根据链式分析的普通启发法，可能会错误地得出结论："_两个人进行了一次小规模的硬币合并，每个人输入一个UTXO，每个人输出两个UTXO_"。从外部对这笔交易进行分析，并不能得出 "输入共同所有权启发式"（CIOH）的应用结论，因为两笔相同金额的输出的存在表明了一种合拼模式。因此，从外部角度看，输入共同所有权启发法不适用于这一特定情况。

![BTC204](assets/fr/175.webp)

这种解释是不准确的，因为大家都知道，一个UTXO被发送给了面包师鲍勃，输入中的2个UTXO来自爱丽丝，她检索到了其余3个输出。

![BTC204](assets/fr/176.webp)

特别有趣的是，从外部观察者的角度来看，石墙公司的交易结构与石墙 x2 公司的交易结构一模一样。

### 石墙交易 x2

石墙 x2 是比特币交易的另一种特殊形式，其目的也是在消费过程中增加用户隐私，但这次是通过与不参与消费的第三方合作。这种方法的功能是在两个参与者之间进行伪比特币连接，同时向第三方付款。

石墙 x2 交易的操作相对简单：使用自己手中的UTXO 进行支付，并寻求第三方的帮助，后者也贡献出自己的一个UTXO。交易结束时有四次输出：其中两次金额相等，一次发送到收款人的地址，另一次发送到贡献者的地址。第三个UTXO 被发送到收款人的另一个地址，使他们能够收回初始金额（对他们来说是一个中性的行为，减去了挖矿费用），最后一个UTXO 返回到属于我们的地址，这构成了付款的剩余部分。

因此，在石墙 x2 交易中定义了三种不同的角色：


- 汇款人，实际付款人；
- 收件人可能不知道交易的具体性质，只是等待发件人付款；
- 合作者提供比特币，在交易分析中提出质疑，最后完全收回资金（扣除挖矿费用，对他们来说是中性行为）。

让我们回到爱丽丝的例子，她在面包师鲍勃的店里买了一条 4000 萨特的法棍。她想用比特币支付，同时又想保护自己的隐私。于是，她打电话给她的朋友 Charles，Charles 会在这个过程中帮助她。

![BTC204](assets/fr/177.webp)

分析这笔交易，我们可以看到面包师鲍勃实际上收到了 4000 萨特的长棍面包货款。爱丽丝投入了 10,000 萨特，产出了 6,000 萨特，净余额为-4,000 萨特，相当于长棍面包的价格。至于查尔斯，他投入了 15 000 萨特，得到了两笔产出：一笔是 4 000 萨特，另一笔是 11 000 萨特，余额为 0。

在这个例子中，我有意忽略了佣金，以便于理解。实际上，采矿费一般由付款发行方和捐款方平摊。

### 石墙 x2 交易的目标是什么？

与 "石墙 "结构一样，"石墙 x2 "结构也为交易增加了大量熵，并掩盖了链式分析的痕迹。从外部视角来看，这种交易可以被解释为两个人之间的小额硬币兑换。但实际上，这是一种支付。因此，这种方法会在链式分析中产生不确定性，也会导致虚假痕迹。

让我们回顾一下爱丽丝、面包师鲍勃和查尔斯的例子。区块链上的交易是这样的

![BTC204](assets/fr/178.webp)

外部观察者根据链式分析的普通启发法可能会错误地得出结论："_Alice 和 Charles 进行了一次小规模的联合交易，输入和输出各为一个 UTXO 和两个 UTXO"。同样，从外部分析这笔交易并不能应用输入的共同所有权启发式分析法（CIOH），因为两个相同金额的输出的存在表明了一种合纵连横模式。因此，从外部角度看，共同所有权启发式并不适用于这一特殊情况。

![BTC204](assets/fr/179.webp)

这种解释是不准确的，因为大家都知道，一个UTXO被发送给了面包师鲍勃，爱丽丝只有一个休息输出，而查尔斯有两个。

![BTC204](assets/fr/180.webp)

同样，"石墙 x2 "交易结构的特别之处在于，从外部观察者的角度来看，它与 "石墙 "交易结构一模一样。

### 石墙 "和 "石墙 x2 "有什么区别？

石墙 X2 交易的工作原理与石墙交易完全相同，只是前者是协作式的，而后者不是。正如我们所看到的，"石墙 X2 "交易有第三方（查尔斯）的参与，他不参与支付，并提供比特币来提高交易的保密性。在典型的 "石墙 "交易中，贡献者的角色由发送者承担。

![BTC204](assets/fr/181.webp)

因此，从外部角度来看，交易模式是完全一样的。

这两种交易结构具有完全相同的模式，这意味着即使外部观察者能够识别出 "石墙（x2）" 模式，他也无法掌握所有信息。他无法确定两个相同金额的 UTXO 中哪一个与付款相对应。他也无法确定两个输入的 UTXO 是来自两个不同的人（"石墙 x2"），还是属于加入他们的人（"石墙"）。

最后一点是由于 "石墙 x2 "交易与 "石墙 "交易的模式完全相同。从外部看，如果没有额外的背景信息，就无法区分石墙交易和石墙 x2 交易。然而，前者不是合作交易，而后者是合作交易。这就更增加了分析此类交易的疑点。

### 何时使用石墙和石墙 x2 交易？

当你想在交易中使用隐私工具时，逻辑应该如下：


- 您可以优先选择付费加入；
- 如果商家不支持 payjoins，则可使用石墙 x2 结构与其他人在支付之外进行合作交易；
- 如果找不到人一起进行 "石墙 x2 "交易，也可以自己进行 "石墙 x2 "交易，模仿 "石墙 x2 "交易的行为。

### 如何使用石墙和石墙 x2 交易？

石墙 "和 "石墙 x2 "交易可在 Samourai 钱包应用程序和 Sparrow 钱包软件上进行。

然而，与支付连接一样，在 Samourai 创始人被捕后，石墙 x2 交易现在只能通过相关各方之间手动交换 PSBT 来进行。遗憾的是，目前还不能通过 Soroban 进行自动交换。

您也可以通过任何比特币钱包软件手动执行此类交易。

在下一章中，除了我们已经学习过的内容外，我们还将学习另一种相对陌生但非常有用的隐私技术。

https://planb.network/tutorials/privacy/on-chain/stonewall-033daa45-d42c-40e1-9511-cea89751c3d4
https://planb.network/tutorials/privacy/on-chain/stonewall-x2-05120280-f6f9-4e14-9fb8-c9e603f73e5b
## 篮板

<chapterId>db9a20ac-a149-443d-884b-ea6c03f28499</chapterId>

使用比特币交易结构，在链分析中增加模糊性，如coinjoin，特别有利于隐私保护。然而，正如我们在 "payjoins "一章中所讨论的，coinjoin 交易在链中自然是可识别的。请记住我们在加密技术和联币技术之间建立的类比：当加密一个文件时，发现该加密文件的第三方无法访问其内容，但可以清楚地识别出该文件曾被修改以隐藏其内容。币值连接也是如此：当分析师检查币值连接交易时，即使他或她无法在输入和输出之间建立直接联系（反之亦然），他或她仍然可以识别出观察到的交易是币值连接。

根据您的硬币在经历接币周期后的预期用途，它经历了这一过程的事实可能会造成问题。例如，如果您计划在受监管的交易所平台上出售您的硬币，但它最近经历了一次接币，平台的链分析工具就会检测到这一事实。这时，平台可能会拒绝接受您的发生过接币的UTXO，甚至要求您做出解释，您的账户可能会被暂停或资金被冻结。在某些情况下，平台可能还会将您的行为报告给国家机关（例如，法国 TRACFIN 对数字资产服务提供商 (PSAN) 的要求）。

为了避免这种情况，我们需要一种能够模糊比特币过去痕迹的工具，以恢复某种形式的可替代性。这正是 "反弹 "的目标。

### 什么是跳弹？

Ricochet 是一种对自己（扫码）进行多次虚拟交易以模拟比特币所有权转移的技术。这种工具与我们讨论过的其他交易结构不同，因为它不允许预期匿名，而是一种追溯匿名。事实上，"反弹 "可以模糊比特币的特殊性，这些特殊性可能会因为比特币的过去而影响其可替代性。

为了掩盖过去的事件在硬币上留下的印记，例如硬币接合周期，蓖麻币会进行四次连续交易，用户在不同的地址向自己转账。

在这一系列交易之后，"回弹 "工具最终会将比特币运送到它们的最终目的地--交换平台。

这样做的目的是拉开距离，影响硬币的可替代性，例如硬币连接交易，以及最终消费行为可能会因为硬币的过去而拒绝这枚硬币。因此，链分析工具可能会得出结论：在事件发生后，硬币的所有权可能发生了变更，并认为这枚硬币是可替代的。在币合的情况下，链分析工具可以认为发送比特币和执行币合的不是同一个人，因此对发送者发起行动是无用的。

### 它为什么有效？

面对这种跳弹方法，我们可以想象，链分析软件会在四跳之后加深检测。然而，这些平台在优化检测阈值时面临两难选择。它们需要设定一个跳数限制，在这个跳数限制之后，它们就会承认所有权很可能已经发生了变化，与之前事件（如共同连接）的联系应该被忽略。

然而，确定这一阈值是有风险的：所观察到的跳转次数每增加一次，都会以指数形式增加误报的数量，即在交易是由其他人执行的情况下，个人被错误地标记为事件的参与者。这种情况会给这些公司带来更大的风险，因为误报会导致不满，从而使受影响的客户转向竞争对手。从长远来看，过高的检测阈值会导致平台失去比竞争对手更多的客户，从而威胁到平台的生存。因此，对于这些平台来说，增加所观察到的跳转次数是很复杂的，4 次跳转往往足以反驳其分析。

这里观察到的现象与六度分隔理论有些类似。

六度分隔理论认为，地球上的任何人都是通过不超过六个中间人的知识链与其他人联系在一起的。只需经过六个人，每个人都亲自了解下一个人，就可以联系到世界上的任何一个人。

比特币交易也有类似的现象。通过追踪足够数量的比特币交易，人们最终不可避免地会遇到币合。反弹法利用了这一原理，使用的跳转次数超过了交易所平台可以合理跟踪的次数。如果平台决定追踪更多的交易，那么就可以简单地增加一个跳转来规避这一措施。

### 何时以及如何使用跳弹？

最常见的回跳使用情况是，需要隐藏之前在自己拥有的 UTXO 上参与过合币的情况。在理想情况下，最好避免向受监管的实体转移已进行过合并上币的比特币。然而，在没有其他选择的情况下，特别是在将比特币变现为法定货币的紧急情况下，蓖麻币提供了一个有效的解决方案。

这种方法不仅对钱币接合有效，而且对任何其他可能影响钱币可替代性的标记也有效。

这种跳转方法的创意最初来自 Samourai 钱包团队，他们将其整合到自己的应用程序中，实现了流程自动化。在 Samourai 上使用该服务是要收费的，因为除了挖矿费用外，跳转还需要支付 100,000 萨特的服务费。因此，建议大额转账时使用。

Samourai 应用程序提供两种不同的跳弹：


- 高级跳转，即 "交错交付"，其优点是将 Samourai 的服务费分摊到连续五笔交易中。这种方法还能确保每笔交易都在不同的时间传送，并记录在不同的区块中，从而尽可能地模拟所有权变更的行为。这种方法虽然速度较慢，但对那些不着急的人来说更可取，因为它通过加强对链式分析的抵抗力，最大限度地提高了跳转的效率；
- 经典的跳转法，旨在通过在短时间内传输所有交易来快速执行操作。因此，与高级方法相比，这种方法的私密性和抗分析能力较差。这种方法只能用于紧急提交。

重投仅仅是向自己发送比特币。完全可以在任何钱包软件上手动执行重投，而无需使用专门的工具。只需稍后将相同的比特币转给自己，每次使用一个新的空地址即可。

在下一章中，我们将探讨几种秘密财产转移的技术。这些方法在工作方式和结果上都与我们迄今为止研究过的方法截然不同。

https://planb.network/tutorials/privacy/on-chain/ricochet-e0bb1afe-becd-44a6-a940-88a463756589
## 秘密财产转让

<chapterId>a2067036-849c-4d6b-87d2-44235cfae7a1</chapterId>

比特币的隐私技术之一是所有权的秘密转移。这种方法的目的是将比特币的所有权从一个人转移到另一个人，反之亦然，而这种交易在区块链上是不可见的。让我们一起来研究一下现有的不同技术及其优缺点。

### 硬币交换

CoinSwap 基于一个相对简单的概念：它使用智能合约促进两个用户之间比特币所有权的转移，无需信任，也不会在区块链上明确显示这种转移。

让我们想象一个简化的例子，爱丽丝和鲍勃。爱丽丝持有 1 枚 BTC，私钥为 $A$，鲍勃也持有 1 枚，私钥为 $B$。理论上，他们可以通过外部通信渠道交换私钥，进行秘密转账。

然而，这种天真的方法带来了很高的信任风险。没有什么能阻止爱丽丝在交换后保存一份 $A$ 私钥的副本，并在 Bob 持有私钥后用它来窃取比特币。

此外，没有任何保证能阻止爱丽丝接收鲍勃的私人密钥 $B$，却从不发送他的私人密钥 $A$ 作为回报。因此，这种交换依赖于双方之间的过度信任，在确保以安全的方式秘密转移所有权方面效率低下。

为了解决这些问题，并允许互不信任的双方进行交换，我们可以使用智能合约系统。智能合约是一个在满足预定义条件时自动运行的程序，在我们的案例中，它可以确保财产交换自动进行，而无需相互信任。

为此，我们可以使用 HTLC（_Hash Time-Locked Contracts_）或 PTLC（_Point Time-Locked Contracts_）。这两种协议的工作原理类似，都是使用一个时间锁定系统，确保交换成功完成或完全取消，从而保护双方资金的完整性。HTLC 和 PTLC 的主要区别在于 HTLC 使用哈希值和预图像来确保交易安全，而 PTLC 使用自适应签名。

在 Alice 和 Bob 之间使用 HTLC 或 PTLC 的 CoinSwap 场景中，交换是以安全的方式进行的：要么交换成功，双方都收到对方的 BTC；要么交换失败，双方都保留自己的 BTC。因此，任何一方都不可能欺骗或窃取对方的 BTC。

> HTLC也是通过闪电网络的双向渠道进行安全支付的机制。
> 在这种情况下，自适应签名的使用尤其有趣，因为它可以绕过传统的脚本（这是一种有时被称为 "无脚本脚本 "的机制）。这一功能有助于减少与交换相关的费用。自适应签名的另一个主要优点是不要求交易双方使用共同的哈希值，从而避免在某些类型的交换中暴露双方之间的直接联系。
### 自适应签名

自适应签名是一种加密方法，它将一个有效签名与一个附加签名（称为 "自适应签名"）整合在一起，以揭示一段秘密数据。这种机制的设计方式是，只要知道以下 3 个要素中的 2 个：有效签名、自适应签名和秘密，就可以推导出缺少的第三个要素。这种方法的一个有趣特性是，如果我们知道对方的自适应签名，以及与用于计算该自适应签名的秘密相关的椭圆曲线上的特定点，我们就可以推导出自己的自适应签名，该签名将与相同的秘密相兼容，而无需直接访问秘密本身。

在硬币交换中，自适应签名的使用允许参与者之间同时披露两个敏感信息，从而避免了相互信任的需要。让我们以爱丽丝和鲍勃为例来说明这一过程，他们希望交换各自拥有的 1 BTC，但彼此互不信任。他们使用自适应签名来消除这种交换中的信任需求。下面是他们的操作过程：


- 爱丽丝通过创建一个向鲍勃发送 1 BTC 的交易 $m_A$ 来启动交换。她使用自己的私人密钥 $p_A$ ($P_A = p_A \cdot G$) 、nonce $n_A$ ($N_A = n_A \cdot G$) 和秘密 $t$ ($T = t \cdot G$) 生成一个签名 $s_A$，以验证这笔交易：

$$s_A = n_A + t + H(N_A + T \parallel P_A \parallel m_A) \cdot p_A$$


- 爱丽丝从其真实签名 $s_A$ 中减去秘密 $t$，计算出适应签名 $s_A'$：

$$s_A' = s_A - t$$


- 爱丽丝向鲍勃发送她的自适应签名 $s'_A$、她的未签名交易 $m_A$、与秘密相对应的点 ($T$) 以及与非ce 相对应的点 ($N_A$)。这些元素构成了所谓的"_adapter_"。值得注意的是，仅凭这些信息，鲍勃无法获取爱丽丝的 BTC。
- 然而，鲍勃有能力验证爱丽丝是否试图窃取他的信息。为此，他会检查爱丽丝的自适应签名 $s_A'$ 是否与提议的交易 $m_A$ 匹配。如果下式正确，他就可以确定爱丽丝的自适应签名是有效的：

$$s_A' \cdot G = N_A + H(N_A + T \parallel P_A \parallel m_A) \cdot P_A$$


- 这一验证为鲍勃提供了足够的保证，让他可以放心地进行交易。然后，他创建自己的交易 $m_B$，打算向爱丽丝发送 1 BTC，并生成自己的自适应签名 $s_B'$，该签名也将与相同的秘密 $t$ 相关联。此时，只有爱丽丝知道 $t$ 的值；鲍勃只知道爱丽丝传送给他的相应点 $T$：

$$s_B' = n_B + H(N_B + T \parallel P_B \parallel m_B) \cdot p_B$$


- 鲍勃向爱丽丝发送他的自适应签名 $s_B'$、未签名的交易 $m_B$，以及与秘密相对应的点 ($T$) 和与非 Cce 相对应的点 ($N_B$)。知道秘密 $t$ 的爱丽丝现在可以将鲍勃的自适应签名 $s_B'$ 与该秘密结合起来，为交易 $m_B$ 生成有效签名 $s_B$，从而将鲍勃的 BTC 转给她：

$$s_B = s_B' + t$$

$$(s_B' + t) \cdot G = N_B + T + H(N_B + T \parallel P_B \parallel m_B) \cdot P_B$$


- Alice 在比特币区块链上传输此签名交易 $m_B$，以取回 Bob 承诺的 BTC。当鲍勃在区块链上看到这笔交易时，他可以提取签名 $s_B = s_B' + t$。有了这些信息，鲍勃就能分离出他所需要的著名的 $t$ 秘密：

$$t = (s_B' + t) - s_B' = s_B - s_B'$$


- 而事实上，这个秘密 $t$ 是鲍勃从爱丽丝的适配签名 $s_A'$ 生成有效签名 $s_A$ 所缺少的唯一元素。有了这个签名，就可以验证从 Alice 发送 BTC 到 Bob 的交易 $m_A$。然后，鲍勃计算出 $s_A$，进而在区块链上传输 $m_A$ 交易：

$$s_A = s_A' + t$$

$$(s_A' + t) \cdot G = N_A + T + H(N_A + T \parallel P_A \parallel m_A) \cdot P_A$$

让我们总结一下签名适配器在比特币兑换中是如何工作的。一开始，爱丽丝向鲍勃发送一个未签名的交易和一个适配器，让鲍勃验证稍后透露的秘密是否能让他获得比特币。作为回报，鲍勃向爱丽丝发送他的未签名交易和适配器。然后，爱丽丝可以通过使用该秘密传输有效的交易，最终完成鲍勃的交易并收回比特币。当该交易在区块链上发布时，鲍勃就有能力提取该秘密，从而解锁爱丽丝的交易。因此，如果爱丽丝发起转移鲍勃的比特币，鲍勃也可以反过来访问爱丽丝的比特币，而无需相互信任。

值得注意的是，硬币交易所是由 [Gregory Maxwell 于 2013 年 10 月在 BitcoinTalk](https://bitcointalk.org/index.php?topic=321228.0) 上首次提出的。

### 原子交换

与硬币交换类似，使用相同类型的智能合约，也可以进行原子交换。原子交换允许两个用户之间直接交换不同的加密货币，如 BTC 和 XMR，而无需信任或中介干预。这些交换之所以被称为 "原子 "交换，是因为它们只有两种可能的结果：要么交换成功，双方都满意；要么交换失败，双方都保留各自原有的加密货币，从而无需信任对方。

![BTC204](assets/fr/197.webp)

原子交换和硬币交换有类似的操作方法，在隐私方面也有相同的优缺点。事实上，从比特币的角度来看，原子交换相当于分两步进行的硬币交换。首先，我们将自己的 BTC 兑换成另一种加密货币，然后这种加密货币可以兑换成其他 BTC。最后，我们取回另一个用户的 BTC。这就是为什么在分析隐私问题时，我将这两个协议归类为秘密财产交换的原因。

![BTC204](assets/fr/198.webp)

然而，与硬币交易所不同，原子交易所在可用流动性方面可能存在不平衡，特别是在 BTC/XMR 交易所。一般来说，将比特币兑换成另类币比较容易，因为比特币的需求量很大，这使得这种兑换方向的溢价较低。然而，由于需求量较小，交易替代币以获得 BTC 可能会更加复杂，往往会导致非常高的溢价。

最后，当原子交易所涉及链上比特币和闪电网络上的比特币时，我们称之为"_潜水交易所_"。

### 它真的有用吗？

所有权的秘密转移，如硬币交换和原子交换，具有欺骗链分析启发式的优势。这些方法可以给人一种交易涉及同一用户的印象，即使实际所有权已经易手。然而，这些方法的主要缺点是，如果不使用额外的技术来破坏硬币的历史记录，风险会非常大。

实际上，当爱丽丝与鲍勃进行币币交换或原子交换时，她将自己的比特币所有权与鲍勃的比特币进行交换。在原子交换的情况下，交换包括一个替代币，但原理是一样的。因此，爱丽丝最终得到的是 B$ 币，而鲍勃得到的是 A$ 币。这增加了链式分析中的疑点，但币的历史仍然是可追溯的。如果分析师检查了 A 币，他或她就可以追踪 Alice 之前的活动，反之亦然。

从爱丽丝的角度来看，其风险在于某些实体可能会认为 $B$ 硬币的历史可疑。例如，如果鲍勃通过黑客等犯罪行为获得了 $B$币，那么该币就会与他的非法活动联系在一起。这样一来，爱丽丝就会发现自己拥有一枚硬币，她无法将其转移到受监管的交易平台，否则就有可能被冻结资金，甚至被指控与鲍勃的犯罪行为有关，尽管她与这些犯罪行为毫无关系。

当然，像币币交换或原子交换这样的隐私保护方法也受到了资金被当局监控的犯罪分子的青睐。这些协议让他们有机会处理被监控的比特币，以换取完全可替代的比特币。这也使他们能够通过将当局引向其他用户来达到转移视线的目的。因此，这些人有双重用途。

有了 Coinjoin，即使你的币与被监控的比特币混在一起，币的历史记录也会被破坏，这就提供了一种似是而非的可抵赖性，而在硬币交换或原子交换等秘密财产转移协议中是不存在的。

如果爱丽丝想避免任何风险，她就必须使用一种方法来破坏 $B$ 硬币的历史，例如通过硬币连接来运行它。这就提出了一个问题：将所有权的秘密转移和硬币连接结合起来是否有用？硬币接合通过中断硬币的历史，已经为爱丽丝提供了足够的隐私。因此，我的观点是，如果爱丽丝想要保护自己的隐私，直接进行硬币合并比先进行硬币交换再进行硬币合并更为谨慎。

要使秘密转移所有权的方法真正有效，并避免将 $A$ 用户的历史与 $B$ 用户的历史联系起来的风险，其使用必须广为人知。如果硬币交换被大量使用，并且当局知道这种普遍做法，那么就可以建立一种可信的否认形式。然而，只要这些转账的使用仍处于边缘状态，我相信这些方法对用户来说仍将是风险太大。

到目前为止，我们主要研究了交易层面的隐私保护方法。下一章，我们将探讨网络层面和交易扩散方面的问题。

## P2P 网络隐私

<chapterId>04a2467b-db84-4076-a9ff-919be5135106</chapterId>

在第 4 部分中，我们讨论了使用完整节点保护交易隐私的重要性。然而，重要的是要明白，你的节点本身也可能受到攻击，这些攻击试图获取你的活动信息。因此，在本章中，我们将探讨不同的隐私保护措施，不是在交易本身或比特币流的层面上，而是在网络层面上。

### 蒲公英

避免各种去匿名化攻击的一种方法是使用建议的蒲公英（Dandelion）。该传输协议在 BIP156 中正式提出，但从未在比特币上实施过。蒲公英的理念是改善比特币网络中交易路由的隐私性，以挫败各种形式的攻击。它的主要目标是隐藏最初在网络上传输交易的源节点。泄露该节点可以将比特币交易与特定的 IP 地址联系起来（如果该节点在未加密的网络上运行），从而为链分析提供切入点。

比特币上的活动与 IP 地址之间的这种关联给用户隐私带来了巨大风险。事实上，许多实体都可以轻易地将 IP 地址与个人身份联系起来。其中包括政府和互联网服务提供商。此外，这些信息可能会被公开，例如，如果你的 IP 地址和个人数据因网站数据库被黑客攻击而泄露。

在比特币的标准操作中，用户在其软件钱包中建立的交易会传输到其个人节点。该节点会立即将新交易传送给它所连接的所有对等节点。

然后，这些对等方对交易进行验证，确保其符合共识规则和本地标准化规则。一旦验证通过，每个对等节点又会将交易转发给它的对等节点，依此类推。

一个区块中等待整合的交易分布是相当均衡的，在统计上也是可预测的。这种漏洞会被串通一气的间谍节点利用，这些节点会合作监控和分析网络，以识别第一个传输交易的节点。如果观察者能找到源节点，他们就能认为交易来自该节点的操作者。这种观察可以将通常匿名的交易与特定的 IP 地址联系起来。

BIP156 的目标就是解决这个问题。为此，它在新交易的传输过程中引入了一个额外阶段，以在大规模公开传播之前保持匿名性。蒲公英首先使用一个 "茎 "阶段，在这个阶段，交易通过节点的随机路径发送。

然后，在 "绒毛"（吹孔）阶段将交易传送到整个网络。

茎和蒲公英指的是交易在网络中传播的行为，其形状类似蒲公英。

因此，间谍节点有可能将交易追溯到启动吹风阶段（大规模传输）的节点，但这个节点并不是最先传输交易的节点，因为它是从干系链中的最后一个节点接收的。如果间谍节点无法追踪干节点，它们也就无法识别源节点。

即使在干节点阶段存在间谍节点，疑虑也始终存在，因为一旦遇到扩散图中的诚实节点，间谍就无法确定该节点是原始源还是只是一个中间节点。

这种路由方法增加了追踪源节点的难度，使得通过网络追踪交易的源头变得复杂。因此，蒲公英限制了对手对网络进行去匿名化的能力，从而提高了隐私性。当交易在 "茎 "阶段穿越一个对其网络通信进行加密的节点（如 Tor 或 P2P Transport V2）时，这种方法会更加有效。

BIP156 尚未被整合到比特币核心中，目前被归类为 "拒绝 "状态。该协议的一个主要问题在于，在茎阶段，交易必须先由中间节点转发，然后再进行验证。正如我们所看到的，在正常的比特币模式中，每个节点都会先验证交易，然后再将其转发给同行。如果交易不符合节点的共识或本地标准化规则，就会被忽略，不会被转发。这个过程对于阻止 DoS 攻击非常重要，因为只有有效的交易才会被传送到整个网络。无效交易可能会大量产生，导致网络超载，但会在遇到的第一个节点被阻止，不会传播。蒲公英的主要风险在于，这种新协议可能会允许无效交易通过部分网络传输，从而为 DoS 攻击引入新的载体。

### P2P 传输 V2

P2P 传输 V2 是 BIP324 中提出的另一个网络协议。它是比特币 P2P 传输协议的一个新版本，采用了机会加密技术来提高节点间通信的保密性和安全性。

这一改进旨在解决 P2P 协议基本版本的几个问题。首先，对于被动的观察者来说，它使交换的数据与互联网上流通的其他类型的数据无法区分。其主要目的是防止政府、互联网服务提供商或 VPN 提供商大规模监控比特币用户。这也使这些实体确定互联网用户是否也是比特币用户，即他们是否在操作一个完整节点的任务变得更加复杂。

P2P V2 还能通过检测数据包中的特定模式，帮助降低审查和攻击风险。它使在网络层面实施各种类型的 Sybil 攻击变得更加复杂，成本也更高。Sybil攻击是指行为者为获得不当利益而制造多个虚假身份。在比特币网络中，这通常表现为一个行为者控制了大量完整的节点，并积极利用它们来增加连接。Sybil攻击可以是被动的，目的是收集信息和破坏用户机密；也可以是主动的，表现为Eclipse攻击。后者将特定节点与网络的其他部分隔离开来，使其可以审查用户或更改接收到的数据。最后，P2P V2 使 "中间人"（MITM）攻击的成本更高，更容易被发现。

P2P V2 实现的加密不包括身份验证，以免增加不必要的复杂性，也不会损害网络连接的无许可性质。不过，这种新的 P2P 传输协议能更好地防范被动攻击，并大大提高主动攻击的成本和可探测性。在网络信息中引入伪随机数据流，使那些想审查或操纵通信的攻击者的任务变得更加复杂。

在 2023 年 12 月部署的 Bitcoin Core 26.0 版本中，P2P V2 传输被列为一个选项（默认禁用）。在 2024 年 4 月的 27.0 版本中，它被默认启用。可以通过配置文件中的 "v2transport="选项进行更改。

### 托尔

要避免网络级节点的失密风险，一个相对简单的解决方案就是完全在 Tor 下运行。Tor 是一个由中继服务器（节点）组成的网络，可以匿名处理互联网上 TCP 连接的来源。它的工作原理是对数据进行多层加密封装。每个中继节点移除一层，以显示下一个节点的地址，直至到达最终目的地。Tor 网络通过防止中间节点知道数据的来源和目的地来确保匿名性，从而使观察者很难跟踪用户的活动。

因此，Tor 不仅可以对通信数据进行加密，还可以掩盖通信的来源和目的地。通过使用 Tor 进行个人节点通信，我们提高了交易的私密性：互联网服务提供商（ISP）无法解密通信，比特币网络中的其他节点也无法识别源节点的 IP 地址。此外，Tor 还可以向互联网服务提供商隐藏比特币的使用情况。

这种方法的主要风险在于 Tor 是一个独立于比特币的协议。如果你在 Tor 下有一个比特币节点，而 Tor 停止工作，那么你的比特币节点将无法再通信。

此外，需要注意的是，Tor 上的通信速度较慢。由于初始区块下载（IBD）需要大量通信，这种延迟在节点初始启动时尤其麻烦。因此，使用 Tor 时，与比特币网络的初始同步时间会大大延长。也可以在开放网络上执行 IBD，然后再激活 Tor。虽然这种方法会向你的互联网服务供应商透露你的比特币节点的存在，但一旦你切换到 Tor，它就会保护你的个人交易信息。

在探讨了网络层面的不同隐私保护方法之后，我还想在接下来的章节中介绍两种避免地址重复使用的优雅解决方案：BIP47 和静默支付。

## BIP47 和可重复使用的付款代码

<chapterId>ad88e076-a04b-4aec-b3b2-7b4760175504</chapterId>

正如我们在第三部分中看到的，地址重复使用是比特币协议中用户隐私的一个严重障碍。为了降低这些风险，强烈建议为钱包中收到的每一笔新付款生成一个新的收款地址。虽然如今使用现代软件和分层确定性钱包可以简化生成新地址的过程，但这种做法似乎有违直觉。

例如，在传统的银行系统中，我们习惯于分享我们的 IBAN，而这个 IBAN 始终保持不变。一旦我们告诉别人，他们就可以向我们发送多笔付款，而无需再次与我们互动。新银行还提供了更多现代化的可能性，例如在贝宝（PayPal）上使用唯一的电子邮件地址，或在 Revolut 上使用 RevTags。即使在金融领域之外，我们的日常标识符，如邮寄地址、电话号码和电子邮件地址，也是独一无二的永久性标识符。我们不必在每次新的互动中更新它们。

然而，比特币的工作原理却与此不同：必须为每笔交易生成一个新的接收地址。这种在易用性和隐私性之间的权衡可以追溯到比特币白皮书的起源。中本聪在 2008 年底发表第一版白皮书时，就已经警告过我们这种风险：

**"_作为额外的防火墙，可以为每笔交易使用新的密钥对，使它们与共同的所有者无关。

有许多方法可以在不造成地址重复使用的情况下用一个标识符接收多笔付款。这些方法各有利弊。在这些方法中，BIP47 是由 Justus Ranvier 提出并于 2015 年发布的一项提案。该提案旨在创建可重复使用的支付代码，允许对同一个人进行多次交易，同时避免地址重复使用。从本质上讲，BIP47 试图提供一个直观的支付系统，作为唯一的标识符，同时保护交易隐私。

![BTC204](assets/fr/212.webp)

BIP47 并没有直接改善用户隐私，因为 BIP47 支付提供的隐私水平与使用新地址的传统比特币交易相同。但是，它确实使比特币的使用更加方便和直观，而这种方便通常会损害隐私。多亏了 BIP47，这种易用性达到了与传统交易相同的隐私水平。这就是为什么 BIP47 是保护隐私的重要工具。

起初，BIP47 是一项整合到比特币核心中的提案，但从未被采纳。然而，一些软件选择在应用层独立实现它。因此，Samourai 钱包团队开发了自己的 BIP47 实现，名为 "PayNym"。

### BIP47 和 PayNym 的一般原则

BIP47 的目标是在不造成地址重复使用的情况下接收大量付款。它以使用可重复使用的付款代码为基础，允许不同的发件人向属于另一个用户的单个代码发送多笔付款。因此，收款人不必为每笔交易提供一个新地址，这大大方便了他们的交流，同时也保护了他们的隐私。

![BTC204](assets/it/66/4.webp)

这样，用户就可以在社交网络或自己的网站上自由分享自己的支付密码，而不会有隐私泄露的风险，这与传统的接收地址或公开密钥不同。

要进行交易，交易双方都必须拥有一个实现了 BIP47 的比特币钱包，如 Samourai Wallet 或 Sparrow Wallet 上的 PayNym。共同使用他们的支付密码会在他们之间建立一个秘密通道。为了有效地建立这个通道，发送方必须在比特币区块链上执行一个特定的交易，即 "通知交易"（稍后我会提供更多细节）。

两个用户的支付代码组合在一起就产生了共享秘密，进而可以创建大量独一无二的比特币接收地址（正好 2^32，约 40 亿）。因此，通过 BIP47 进行的支付实际上并不是针对支付代码本身，而是针对由相关用户的支付代码衍生出的经典收款地址。

然后，支付代码作为从钱包种子中衍生出来的虚拟标识符。在投资组合的分层衍生结构中，支付密码位于第 3 层，即账户层。

![BTC204](assets/it/66/5.webp)

BIP47 的派生目标由索引 `47'` (`0x8000002F`) 标识，指的是 BIP47。可重复使用支付代码的派生路径示例如下：

```plaintext
m/47'/0'/0'/
```

为了让您了解付款码的样子，下面是我的付款码：

```plaintext
M8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5
```

该代码还可以编码成二维码，以方便通信，就像传统的接收地址一样。

至于 PayNym Bots，这些有时在 Twitter 上看到的机器人是支付代码的可视化表示，由 Samourai Wallet 创建。它们是通过散列函数生成的，因此几乎具有唯一性。它们以`+`开头的一小串字符出现：

```plaintext
+throbbingpond8B1
+twilightresonance487
+billowingfire340
```

这些化身也可以用图像来表示：

![BTC204](assets/fr/215.webp)

虽然这些机器人在 BIP47 框架内没有特定的技术功能，但它们通过提供易于识别的视觉标识，在促进用户之间的互动方面发挥了作用。

---
*在本章有关 BIP47 的后续章节中，我们将详细介绍其运行情况，尤其是所使用的加密方法。要完全理解这些技术性较强的解释，首先必须了解高清钱包的结构、密钥生成过程以及基于椭圆曲线的加密技术的基本原理。如果您想了解更多有关这些概念的信息，Plan ₿ Network 提供了另一个免费课程：* * *。

https://planb.network/courses/46b0ced2-9028-4a61-8fbc-3b005ee8d70f
*我强烈建议您关注它，因为了解 BIP47 的技术运作将有助于您更轻松地理解我们将在接下来的章节中讨论的其他类似提案*。

---
### 可重复使用的付款代码

如前所述，可重复使用的支付代码位于 HD 钱包的第 3 层，这使其在钱包结构中的位置和作用都与 "xpub "类似。

80 个字节的支付密码划分如下：


- 字节 `0`：版本**。对于 BIP47 的第一个版本，该字节设置为 `0x01`；
- 字节 `1`：位字段**。该空间用于在特定用途中加入附加指示。对于 PayNym 的标准使用，该字节定义为 `0x00`；
- 字节 `2`：y`** 的奇偶校验。该字节为 `0x02` 或 `0x03`，表示公钥的序数是偶数还是奇数，因为使用的是压缩公钥；
- 从字节 `3` 到字节 `34`：x`**的值。这些字节代表公钥的尾数。x "和 "y "的奇偶校验值构成完整的压缩公开密钥；
- 从字节 `35` 到字节 `66`：链代码**。此空格包含与公钥相关的链代码；
- 从字节 `67` 到字节 `79`：填充**.该空间用于未来可能的开发。在当前版本中，这里只是简单地放置零，以达到 `OP_RETURN` 输出所需的 80 字节大小。

下面是我在上一节中介绍的可重复使用的支付代码的十六进制表示法：

```plaintext
0x010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000
```

![BTC204](assets/it/66/7.webp)

首先，有必要在开头加上前缀字节 `P` 以清楚地表明这是一个付款码。这个字节用 `0x47`表示：

```plaintext
0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000
```

最后，为确保支付密码的完整性，会使用 "HASH256 "进行校验和计算，其中包括使用 "SHA256 "函数进行双重散列。然后，将散列计算得出的前四个字节连接到支付密码的末尾：

```plaintext
0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000567080c4
```

完成这些步骤后，支付代码就准备就绪了。剩下的唯一步骤就是将其转换为基数 58，以获得最终版本：

```plaintext
PM8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5
```

在创建支付密码的过程中，我们使用压缩公钥和链码。两者都是通过钱包种子的确定性分层推导得出的。用于实现这一目标的推导路径是

```plaintext
m/47'/0'/0'/
```

为了生成可重复使用支付密码的压缩公钥和相关链码，我们首先从钱包种子开始计算主私钥。然后，我们使用索引 `47 + 2^31`（加强推导）推导出子密钥对。在这一步之后，我们会再连续推导出两个子密钥对，每个子密钥对都使用索引 `2^31`（强化推导）。

### 椭圆曲线 Diffie-Hellman 密钥交换 (ECDH)

BIP47 的核心加密协议简称为 ECDH，即_Elliptic-Curve Diffie-Hellman_。这种方法是原始 Diffie-Hellman 密钥交换的一种变体。

Diffie-Hellman 密钥协议是 1976 年推出的一种密钥协议，它允许各自配备一对密钥（公开密钥和私人密钥）的双方就共同的秘密达成一致，即使完全通过不安全的公开渠道进行通信。

![BTC204](assets/it/66/10.webp)

然后，这个共享秘密（这里是蓝色密钥）就可以用于其他操作。通常情况下，共享密钥可用于加密和解密不安全网络上的通信：

![BTC204](assets/fr/220.webp)

为了完成这种交换，Diffie-Hellman 使用模块运算来计算共享秘密。下面是对其工作原理的简化解释：


- 爱丽丝和鲍勃商定了一种共同的颜色（这里是黄色），这种颜色构成公共数据（攻击者知道这种颜色）；
- 爱丽丝选择了一种神秘的颜色，这里是红色，然后将两者混合得到橙色；
- 鲍勃还选择了一种神秘的颜色，这里是蓝色，然后与黄色混合得到绿色；
- 然后，它们交换获得的橙色和绿色。这种交换可以在不安全的观察网络中进行；
- 将鲍勃的绿色和他的秘密颜色混合，爱丽丝就能得到棕色；
- 鲍勃用爱丽丝的橙色和她的秘密蓝色做同样的运算，也得到了棕色。

![BTC204](assets/it/66/12.webp)

在这个简化过程中，棕色代表爱丽丝和鲍勃之间共享的秘密。重要的是要明白，在现实中，攻击者不可能将橙色和绿色分开，从而发现爱丽丝或鲍勃的秘密颜色。

现在，让我们不使用颜色类比，而是使用实数和模数运算，来看看这个协议究竟是如何运行的！

在讨论 Diffie-Hellman 机制之前，让我简要提醒大家我们需要的两个基本数学概念：


- 质数**是只有两个除数的自然数：1 美元和它本身。例如，7 美元是一个质数，因为它只能被 1 美元和 7 美元整除。另一方面，8 美元不是质数，因为它能被 1 美元、2 美元、4 美元和 8 美元整除。因此，它有四个正整数除数，而不是两个；
- mod**（表示为 $mod$或 $/%$）是一种数学运算，在两个整数之间，返回前者除以后者的欧几里得余数。例如，$16 \bmod 5 = 1$。

**爱丽丝和鲍勃之间的迪菲-赫尔曼密钥交换过程如下：**


- 爱丽丝和鲍勃商定了两个共同的数字：$p$ 和 $g$。$p$ 是一个质数，这个数字越大，迪菲-赫尔曼就越安全。$g$是$p$的一个原始根。这两个数字可以在不安全的网络上公开交流。它们相当于上述简化中的**黄色**。因此，爱丽丝和鲍勃必须使用完全相同的 $p$ 和 $g$。

确定这些参数后，爱丽丝和鲍勃各自选择一个随机秘密数字。爱丽丝称她的随机秘密数字为 $a$（相当于**红色**），鲍勃称他的随机秘密数字为 $b$（相当于**蓝色**）。这些数字必须严格保密。

双方不直接交换 $a$ 和 $b$，而是按如下方法计算 $A$ 和 $B$：

$A$ 等于 $g$ 升至 $a$ 的幂，模为 $p$：

$$
A = g^a \bmod p
$$

$B$等于$g$乘以$b$的幂模，再乘以$p$：

$$
B = g^b \bmod p
$$

双方交换值 $A$（相当于**橙色**）和 $B$（相当于**绿色**）。这种交换可以通过不安全的网络公开进行；

爱丽丝收到 $B$ 后，计算 $z$ 的值如下：

$z$ 等于 $B$ 升至 $a$ 的幂，模为 $p$：

$$
z = B^a \bmod p
$$

召回：

$$
B = g^b \bmod p
$$

因此，我们得到

$$
z = B^a \bmod p
$$

$$
z = (g^b)^a \bmod p
$$

应用指数规则：

$$
(x^n)^m = x^{nm}
$$

因此，我们得到

$$
z = g^{ba} \bmod p
$$


- 而鲍勃在得到 $A$ 后，也会按以下方法计算 $z$ 的值：

$z$ 等于 $A$ 升至 $b$ 的幂，模为 $p$：

$$
z = A^b \bmod p
$$

因此，我们得到

$$
z = (g^a)^b \bmod p
$$

$$
z = g^{ab} \bmod p
$$

$$
z = g^{ba} \bmod p
$$

由于模运算符的可分配性，爱丽丝和鲍勃得到了完全相同的 $z$ 值。这个数字代表了他们的共同秘密，相当于之前用颜料罐简化的**棕色**。现在，他们可以使用这个共同秘密在不安全的网络上对他们的通信进行对称加密。

攻击者即使掌握了 $p$、$g$、$A$ 和 $B$（公共值），也无法计算 $a$、$b$ 或 $z$（私人值）。要做到这一点，就必须反指数化，而不逐一尝试所有可能性是不可能完成的任务，因为这等同于计算离散对数，即有限循环群中指数的倒数。

因此，只要 $a$、$b$ 和 $p$ 的值足够大，迪菲-赫尔曼协议就是安全的。通常情况下，如果使用 2048 位参数（十进制有 600 位数字），测试 $a$ 和 $b$ 的所有可能性是不切实际的。迄今为止，这种算法被认为是安全的。

这正是 Diffie-Hellman 协议的主要缺点所在。为了安全起见，算法必须使用大数字。这就是为什么现在人们更喜欢 ECDH（椭圆曲线 Diffie-Hellman）算法的原因，它是 Diffie-Hellman 算法的一种变体，基于代数曲线，更准确地说，是椭圆曲线。这种方法可以在保持同等安全性的前提下使用更小的数字，从而减少计算和存储所需的资源。

算法的一般原理保持不变。不过，我们不再使用随机数 $a$ 和通过模乘计算得出的数 $A$，而是使用在椭圆曲线上建立的密钥对。我们不再依赖模运算符的可分配性，而是使用椭圆曲线上的群律，更具体地说，是该律的关联性。

简单解释一下椭圆曲线密码学的原理，私人密钥由一个介于 $1$ 和 $n-1$ 之间的随机数表示，其中 $n$ 代表曲线的阶数。而公钥则是该曲线上的一个特定点，根据等式，通过对从生成点开始的点进行加法和加倍运算，从私钥中获得：

$$
K = k \cdot G
$$

在这个公式中，$K$ 表示公钥，$k$ 表示私钥，$G$ 表示生成点。

这些密钥的基本特征之一是很容易从 $k$ 和 $G$ 中计算出 $K$，而从 $K$ 和 $G$ 中找到 $k$ 几乎是不可能的。这种不对称性产生了一种单向函数。换句话说，如果知道私钥，就很容易计算出公钥，但从公钥中找到私钥是不可能的。这种安全性仍然依赖于离散对数的计算难度。

我们将利用这一特性来调整我们的 Diffie-Hellman 算法。 **ECDH 的工作原理如下：**


- 爱丽丝和鲍勃共同商定了一条加密安全的椭圆曲线及其参数。这些信息是公开的；
- 爱丽丝生成一个随机数 $ka$，作为她的私人密钥。这个私人密钥必须保密。她通过对所选椭圆曲线上的点进行加法和倍增来确定自己的公开密钥 $Ka$：

$$
K_a = k_a \cdot G
$$


- 鲍勃还会生成一个随机数 $kb$，作为他的私人密钥。他计算出相关的公钥 $kb$：

$$
K_b = k_b \cdot G
$$


- 爱丽丝和鲍勃在不安全的公共网络上交换他们的公开密钥 $Ka$ 和 $Kb$。
- 爱丽丝将自己的私人密钥 $ka$ 应用于鲍勃的公开密钥 $Kb$，从而计算出曲线上的一个点 $(x,y)$：

$$
(x,y) = k_a \cdot K_b
$$


- 鲍勃将自己的私人密钥 $kb$ 应用于爱丽丝的公开密钥 $Ka$，从而计算出曲线上的一个点 $(x,y)$：

$$
(x,y) = k_b \cdot K_a
$$


- 爱丽丝和鲍勃会得到椭圆曲线上的同一个点。共享秘密将是这一点的 x$ 坐标。

事实上，它们获得的共享秘密是一样的，因为

(x,y) = k_a \cdot K_b = k_a \cdot (k_b \cdot G) = (k_a \cdot k_b) \cdot G = (k_b \cdot k_a) \cdot G = k_b \cdot (k_a \cdot G) = k_b \cdot K_a

$$
Un attaccante che osserva la rete pubblica non protetta può ottenere solo le chiavi pubbliche di ciascuna parte e i parametri della curva ellittica scelta. Come precedentemente spiegato, queste informazioni da sole non sono sufficienti per determinare le chiavi private. Pertanto, l'attaccante non può trovare il segreto condiviso tra Alice e Bob.
ECDH è quindi un algoritmo che consente lo scambio di chiavi. È spesso utilizzato in combinazione con altri metodi crittografici per stabilire un protocollo completo. Ad esempio, ECDH è integrato nel nucleo di TLS (_Transport Layer Security_), un protocollo di crittografia e autenticazione utilizzato per il livello di trasporto di Internet. TLS utilizza ECDHE per lo scambio di chiavi, una variante di ECDH dove le chiavi sono effimere, per garantire la confidenzialità persistente. Inoltre, TLS utilizza algoritmi di autenticazione come ECDSA, algoritmi di crittografia come AES e funzioni hash come SHA256.
TLS è notevolmente responsabile della `s` in `https` così come del lucchetto visibile nella barra degli indirizzi del tuo browser, simboli delle comunicazioni criptate. Seguendo questo corso, stai quindi utilizzando ECDH, ed è molto probabile che lo usi quotidianamente senza nemmeno saperlo.
### La Transazione di Notifica
Come abbiamo visto nella sezione precedente, ECDH è una variante dello scambio Diffie-Hellman che utilizza coppie di chiavi stabilite su una curva ellittica. Convenientemente, possediamo già molte coppie di chiavi aderenti a questo standard nei nostri portafogli Bitcoin! L'idea di BIP47 è di utilizzare le coppie di chiavi dei portafogli Bitcoin gerarchici deterministici di entrambe le parti per stabilire segreti condivisi ed effimeri tra di loro. Nel contesto di BIP47, viene utilizzato ECDHE (_Elliptic Curve Diffie-Hellman Ephemeral_).
ECDHE viene utilizzato per la prima volta in BIP47 per trasmettere il codice di pagamento dal mittente al destinatario. Questo è il famoso **notification transaction**. Questo passaggio è essenziale perché affinché BIP47 funzioni efficacemente, entrambe le parti coinvolte (il mittente e il destinatario) devono conoscere il codice di pagamento dell'altro. Questa conoscenza consente la derivazione di chiavi pubbliche effimere e, di conseguenza, indirizzi di ricezione vuoti associati.
Prima di questo scambio, il mittente è logicamente già a conoscenza del codice di pagamento del destinatario poiché lo ha recuperato off-chain, ad esempio, dal loro sito web, una fattura o i loro social media. Tuttavia, il destinatario potrebbe non conoscere necessariamente il codice di pagamento del mittente. Eppure, questo codice deve essere trasmesso a loro; altrimenti, non saranno in grado di derivare le chiavi effimere necessarie per identificare gli indirizzi dove sono conservati i loro bitcoin, né accedere ai loro fondi. Sebbene questa trasmissione del codice del mittente possa tecnicamente essere effettuata off-chain attraverso altri mezzi di comunicazione, ciò pone un problema se il portafoglio deve essere recuperato solo dal seme.
Infatti, a differenza degli indirizzi convenzionali, gli indirizzi BIP47 non sono derivati direttamente dal seed del destinatario—utilizzare un `xpub` sarebbe più semplice in questo caso—ma risultano da un calcolo che combina i codici di pagamento di entrambi: quello del mittente e quello del destinatario. Pertanto, se il destinatario perde il proprio portafoglio e tenta di ripristinarlo dal proprio seed, recupererà il proprio codice di pagamento, che è derivato direttamente dal loro seed. Tuttavia, per trovare gli indirizzi effimeri, sarà essenziale per loro avere anche i codici di pagamento di tutti coloro che hanno inviato loro bitcoin tramite BIP47. Da qui l'importanza della transazione di notifica, che consente di salvare queste informazioni sulla blockchain di Bitcoin, pur essendo in grado di trovarle molto facilmente senza dover cercare tra il miliardo di transazioni eseguite dal suo lancio nel 2009.
![BTC204](assets/it/66/15.webp)
Pertanto, sarebbe possibile implementare BIP47 senza ricorrere alla transazione di notifica, a condizione che ogni utente conservi un backup dei codici di pagamento dei propri pari. Tuttavia, questo metodo si rivela complesso da gestire finché non viene sviluppata una soluzione semplice, robusta ed efficiente per creare, conservare e aggiornare questi backup. Nello stato attuale delle cose, la transazione di notifica diventa quasi indispensabile.
Nei capitoli seguenti, studieremo altri protocolli con obiettivi simili a quelli di BIP47, ma che non richiedono una transazione di notifica. Queste alternative, tuttavia, introducono i propri compromessi.
Oltre al suo ruolo nel backup dei codici di pagamento, la transazione di notifica serve anche una funzione di notifica per il destinatario, come suggerisce il suo nome. Segnala al client del destinatario che è stato stabilito un nuovo canale di pagamento e suggerisce quindi di monitorare gli indirizzi effimeri risultanti.
### Il Modello di Privacy di BIP47
Prima di dettagliare il funzionamento tecnico della transazione di notifica, è importante discutere il modello di privacy associato a BIP47, che giustifica alcune misure prese durante la creazione di questa transazione iniziale.
Il codice di pagamento, di per sé, non rappresenta un rischio diretto per la privacy. A differenza del modello Bitcoin tradizionale, che mira a rompere il collegamento tra l'identità di un utente e le sue transazioni (che sono pubbliche) preservando l'anonimato di chiavi e indirizzi, il codice di pagamento può essere apertamente associato a un'identità senza rappresentare una minaccia.
Infatti, il codice di pagamento non è utilizzato per derivare direttamente gli indirizzi che ricevono pagamenti BIP47. Questi indirizzi sono invece generati attraverso l'applicazione di ECDH tra le chiavi derivate dai codici di pagamento delle due parti coinvolte.
Così, un codice di pagamento di per sé non porta direttamente a una perdita di privacy, poiché solo l'indirizzo di notifica è derivato da esso. Sebbene questo indirizzo possa rivelare alcune informazioni, normalmente non consente di scoprire le parti con cui si stanno conducendo transazioni, a meno che non si effettui un'analisi approfondita della catena. Infatti, se il mittente utilizza UTXO che possono essere collegati alla loro identità per eseguire la transazione di notifica, allora diventa possibile dedurre che la loro identità è probabilmente collegata ai pagamenti BIP47 al tuo codice di pagamento. Questo non rivelerà le transazioni sottostanti, ma indicherà la loro probabile esistenza.
Pertanto, è essenziale mantenere questa stretta separazione tra i codici di pagamento degli utenti. Verso questo obiettivo, il passo iniziale di comunicazione del codice è un momento critico per la privacy del pagamento, ma obbligatorio per il corretto funzionamento del protocollo. Se uno dei codici di pagamento può essere ottenuto pubblicamente (come su un sito web), il secondo codice, quello del mittente, non deve essere collegato al primo in nessun caso.
Prendiamo un esempio concreto: voglio fare una donazione a un movimento politico tramite BIP47:
- L'organizzazione ha reso pubblico il suo codice di pagamento sul suo sito web o tramite i suoi social network;
- Questo codice è quindi collegato al movimento politico;
- Recupero questo codice di pagamento;
- Prima di procedere con un invio, devo assicurarmi che conoscano il mio codice di pagamento, che è anche collegato alla mia identità poiché lo uso per ricevere transazioni sui miei social network.
Come trasmettere il mio codice senza rischi? L'uso di mezzi di comunicazione convenzionali potrebbe portare a una fuga di informazioni e, di conseguenza, associarmi a questo movimento politico. La transazione di notifica offre una soluzione grazie a uno strato di crittografia che impedisce precisamente questa associazione tra due codici. Sebbene questo non sia l'unico metodo per trasmettere segretamente il codice di pagamento del mittente, si dimostra molto efficace.
Nel diagramma sottostante, le linee arancioni indicano i punti in cui il flusso di informazioni deve essere interrotto, e le frecce nere mostrano le connessioni che potrebbero potenzialmente essere osservate da terze parti:
![BTC204](assets/it/66/16.webp)
In realtà, all'interno del modello tradizionale di privacy di Bitcoin, è spesso complesso dissociare completamente il flusso di informazioni tra la coppia di chiavi e l'utente, specialmente durante le transazioni a distanza. Ad esempio, nel contesto di una campagna di donazione, il destinatario deve inevitabilmente divulgare un indirizzo o una chiave pubblica tramite il loro sito web o social network. L'uso corretto di BIP47, in particolare con la transazione di notifica, permette di aggirare questo problema grazie a ECDHE e allo strato di crittografia che studieremo ulteriormente.
Ovviamente, il modello classico di privacy di Bitcoin si applica ancora alle chiavi pubbliche effimere, che sono derivate dalla combinazione dei due codici di pagamento. I due modelli sono in realtà complementari. Quello che voglio evidenziare qui è che, contrariamente all'uso abituale di una chiave pubblica per ricevere bitcoin, il codice di pagamento può essere collegato a una specifica identità, perché l'informazione "_Alice effettua una transazione con Bob_" viene interrotta in un'altra fase. Il codice di pagamento viene utilizzato per generare indirizzi di pagamento, ma basandosi unicamente sull'osservazione della blockchain, è impossibile collegare una transazione di pagamento BIP47 ai codici di pagamento utilizzati per eseguirla, a meno che gli UTXO coinvolti non fossero già collegati a un'identità precedentemente e gli utenti non abbiano associato i loro codici di pagamento alle rispettive identità.
Per riassumere, il modello di privacy offerto dai pagamenti BIP47 potrebbe essere considerato superiore a quello della base di Bitcoin, anche se non è magico in alcun modo.
### Costruzione della Transazione di Notifica
Ora, vediamo come funziona questa transazione di notifica. Immaginiamo che Alice voglia inviare fondi a Bob con BIP47. Nel mio esempio, Alice agisce come mittente e Bob come destinatario. Quest'ultimo ha pubblicato il suo codice di pagamento sul suo sito web. Pertanto, Alice è già a conoscenza del codice di pagamento di Bob.
**1- Alice calcola un segreto condiviso con ECDH:**
- Seleziona una coppia di chiavi dal suo portafoglio HD situato su un ramo diverso dal suo codice di pagamento. Nota, questa coppia non dovrebbe essere facilmente associata all'indirizzo di notifica di Alice, né all'identità di Alice (vedi sezione precedente);
- Alice seleziona la chiave privata da questa coppia. La chiamiamo $a$ (minuscolo);
$$

a

$$
```text
- Alice recupera la chiave pubblica associata all'indirizzo di notifica di Bob. Questa chiave è la prima figlia derivata dal codice di pagamento di Bob (indice $/0$). Chiamiamo questa chiave pubblica $B$ (maiuscolo). La chiave privata associata a questa chiave pubblica è chiamata $b$ (minuscolo). $B$ è determinata dall'addizione e dal raddoppio dei punti sulla curva ellittica da $G$ (il punto generatore) con $b$ (la chiave privata):
$$ B = b \cdot G $$
- Alice calcola un punto segreto $S$ (maiuscolo) sulla curva ellittica tramite l'addizione e il raddoppio dei punti applicando la sua chiave privata $a$ dalla chiave pubblica di Bob $B$.
$$ S = a \cdot B $$
- Alice calcola il fattore di oscuramento $f$ che le permetterà di criptare il suo codice di pagamento. Per fare ciò, determinerà un numero pseudo-casuale con la funzione HMAC-SHA512. Nel secondo input di questa funzione, utilizza un valore che solo Bob potrà recuperare: $x$ che è l'ascissa del punto segreto precedentemente calcolato. Il primo input è $o$ che è l'UTXO consumato in input di questa transazione (outpoint).
$$ f = \text{HMAC-SHA512}(o, x) $$
**2- Alice converte il suo codice di pagamento personale in base 2 (binario).**
**3- Utilizza questo fattore di oscuramento come chiave per eseguire la crittografia simmetrica sul payload del suo codice di pagamento.** L'algoritmo di crittografia utilizzato è semplicemente un `XOR`. L'operazione eseguita è paragonabile alla cifratura di Vernam, anche denominata "One-Time Pad".
- Alice prima divide il suo fattore di oscuramento in due: i primi 32 byte sono denominati $f1$ e gli ultimi 32 byte sono denominati $f2$. Quindi, abbiamo:
$$ f = f1 || f2 $$
- Alice calcola l'$x'$ criptato dell'ascissa della chiave pubblica $x$ del suo codice di pagamento, e il $c'$ criptato del suo codice catena $c$ separatamente. $f1$ e $f2$ agiscono rispettivamente come chiavi di crittografia. L'operazione utilizzata è il `XOR` (o esclusivo).
$$ x' = x \oplus f1 $$
$$ c' = c \oplus f2 $$
- Alice sostituisce i valori reali dell'ascissa della chiave pubblica $x$ e del codice catena $c$ nel suo codice di pagamento con i valori criptati $x'$ e $c'$.
**4-** Alice ora ha il suo codice di pagamento con un payload criptato. Costruirà e trasmetterà una transazione che coinvolge la sua chiave pubblica $A$ come input, un output all'indirizzo di notifica di Bob, e un output `OP_RETURN` contenente il suo codice di pagamento con il payload criptato. **Questa transazione è la transazione di notifica**.
Un `OP_RETURN` è un opcode che segna un output di una transazione Bitcoin come non valido. Oggi, è utilizzato per trasmettere o ancorare informazioni sulla blockchain di Bitcoin. Fino a 80 byte di dati possono essere memorizzati, che sono scritti sulla catena e quindi visibili a tutti gli altri utenti.
Come abbiamo visto nelle sezioni precedenti, ECDH è utilizzato per generare un segreto condiviso tra due utenti che comunicano su una rete non sicura, potenzialmente osservata da attaccanti. In BIP47, ECDH è utilizzato per la comunicazione sulla rete Bitcoin, che per sua natura è una rete di comunicazione trasparente osservata da molti attaccanti. Il segreto condiviso calcolato tramite lo scambio di chiavi ECDH è poi utilizzato per criptare le informazioni segrete da trasmettere: il codice di pagamento del mittente (di Alice).
Ricapitoliamo i passaggi che abbiamo appena esaminato insieme per eseguire una transazione di notifica:
- Alice recupera il codice di pagamento e l'indirizzo di notifica di Bob;
- Alice seleziona un UTXO che possiede nel suo portafoglio HD con la corrispondente coppia di chiavi;
- Calcola un punto segreto sulla curva ellittica utilizzando ECDH;
- Utilizza questo punto segreto per calcolare un HMAC, che è il fattore di oscuramento;
- Utilizza questo fattore di oscuramento per criptare il payload del suo codice di pagamento personale.
- Lei utilizza un output di transazione `OP_RETURN` per comunicare il codice di pagamento mascherato a Bob.
![BTC204](assets/it/66/17.webp)
### Transazione di Notifica: Studio Concreto
Per comprendere meglio il suo funzionamento, in particolare l'uso di `OP_RETURN`, esaminiamo insieme una vera transazione di notifica. Ho eseguito tale transazione sulla testnet, che potete trovare [cliccando qui](https://mempool.space/fr/testnet/tx/0e2e4695a3c49272ef631426a9fd2dae6ec3a469e3a39a3db51aa476cd09de2e).
![BTC204](assets/fr/227.webp)
Osservando questa transazione, possiamo vedere che ha un singolo input e 4 output:
- Il primo output è l'`OP_RETURN` che contiene il mio codice di pagamento mascherato;
- Il secondo output di 546 sats punta all'indirizzo di notifica del mio destinatario;
- Il terzo output di 15.000 sats rappresenta le commissioni di servizio, poiché ho utilizzato Samourai Wallet per costruire questa transazione;
- Il quarto output di 2 milioni di sats rappresenta il resto, ovvero la differenza rimanente dal mio input che ritorna a un altro indirizzo che mi appartiene.
Il più interessante da studiare è ovviamente l'output 0 che utilizza l'`OP_RETURN`. Vediamo più da vicino cosa contiene. Ecco lo `scriptPubKey` in esadecimale:
6a4c50010002b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d800000000000000000000000000
```

```text
In questo script, possiamo sezionare diverse parti. Prima di tutto, gli opcode:
6a4c
```

```text
Tra gli opcode, possiamo riconoscere `0x6a` che designa l'`OP_RETURN` e `0x4c` che designa l'`OP_PUSHDATA1`.
Il byte seguente questo ultimo opcode indica la dimensione del payload che segue. Indica `0x50`, ovvero 80 byte:
6a4c50
```

```text
Poi, abbiamo i metadati del mio codice di pagamento in chiaro:
010002
```

```text
La coordinata x criptata della chiave pubblica del mio codice di pagamento:
b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164
```

```text
Il codice catena criptato del mio codice di pagamento:
927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d8
```

```text
E infine, il padding per raggiungere 80 byte, la dimensione standard di un `OP_RETURN`:
00000000000000000000000000
```

```
Per capire meglio, ecco il mio codice di pagamento in chiaro in base 58:
````text
PM8TJQCyt6ovbozreUCBrfKqmSVmTzJ5vjqse58LnBzKFFZTwny3KfCDdwTqAEYVasn11tTMPc2FJsFygFd3YzsHvwNXLEQNADgxeGnMK8Ugmin62TZU
Quando si confronta il mio codice di pagamento in chiaro con l'`OP_RETURN`, è evidente che l'HRP (`0x47`) e il checksum (`0x8604e4db`) non vengono trasmessi. Questo è previsto, poiché queste informazioni sono destinate agli esseri umani.
Successivamente, possiamo identificare la versione (`0x01`), il campo di bit (`0x00`) e la parità della chiave pubblica (`0x02`). E, alla fine del codice di pagamento, i byte vuoti (`0x00000000000000000000000000`) sono utilizzati per riempire il codice fino a un totale di 80 byte. Tutti questi metadati vengono trasmessi in chiaro (non criptati).
Infine, si può osservare che la coordinata x della chiave pubblica (`0x77507c9c17a89cfca2d3af554745d6c2db0e7f6b2721a3941a504933103cc42a`) e il codice catena (`0xdd94881210d6e752a9abc8a9fa0070e85184993c4f643f1121dd807dd556d1dc`) sono stati criptati. Questo costituisce il payload del codice di pagamento.
### Cos'è XOR?
Nelle sezioni precedenti, abbiamo visto che il codice di pagamento è stato trasmesso criptato utilizzando l'operazione XOR. Prendiamoci un momento per capire come funziona questo operatore, poiché è ampiamente utilizzato nella crittografia.
XOR è un operatore logico bit a bit basato sull'algebra booleana. Con due operandi bit, restituisce `1` se i bit dello stesso rango sono diversi, e restituisce `0` se i bit dello stesso rango sono uguali. Ecco la tabella di verità di XOR basata sui valori degli operandi `D` e `E`:
| D   | E   | D XOR E |
| --- | --- | ------- |
| 0   | 0   | 0       |
| 0   | 1   | 1       |
| 1   | 0   | 1       |
| 1   | 1   | 0       |
Per esempio:
$$

$$
0110 \oplus 1110 = 1000
Oppure:
$$

$$
010011 \oplus 110110 = 100101
Con ECDH, l'uso di XOR come strato di crittografia è particolarmente adatto. Innanzitutto, a causa di questo operatore, la crittografia è simmetrica. Questo consente al destinatario di decifrare il codice di pagamento con la stessa chiave utilizzata per la crittografia. La chiave di crittografia e decrittografia viene calcolata dal segreto condiviso grazie a ECDH. Questa simmetria è resa possibile dalle proprietà commutativa e associativa dell'operatore XOR:
- Altre proprietà:
$$

$$
D \oplus D = 0
D ⊕ 0 = D
- Commutatività:
$$

$$
D \oplus E = E \oplus D
- Associatività:
$$

$$
D \oplus (E \oplus Z) = (D \oplus E) \oplus Z = D \oplus E \oplus Z
Se:
$$

$$
D \oplus E = L
Allora:
$$

$$
D \oplus L = D \oplus (D \oplus E) = D \oplus D \oplus E = 0 \oplus E = E \\
\therefore D \oplus L = E
Successivamente, questo metodo di cifratura assomiglia molto al cifrario di Vernam (One-Time Pad), l'unico algoritmo di cifratura conosciuto fino ad oggi che possiede sicurezza incondizionata (o assoluta). Affinché il cifrario di Vernam abbia questa caratteristica, la chiave di cifratura deve essere perfettamente casuale, deve essere della stessa dimensione del messaggio e deve essere utilizzata una sola volta. Nel metodo di cifratura utilizzato qui per BIP47, la chiave è effettivamente della stessa dimensione del messaggio, il fattore di offuscamento è esattamente della stessa dimensione della concatenazione della coordinata x della chiave pubblica con il codice catena del codice di pagamento. Questa chiave di cifratura è effettivamente utilizzata una sola volta. Tuttavia, questa chiave non è il risultato di una casualità perfetta poiché è un HMAC. È piuttosto pseudo-casuale. Pertanto, non si tratta di un cifrario di Vernam, ma il metodo è simile.
### Ricezione della Transazione di Notifica
Ora che Alice ha inviato la transazione di notifica a Bob, vediamo come lui la interpreta. Come promemoria, Bob deve essere in grado di accedere al codice di pagamento di Alice. Senza queste informazioni, come vedremo nella sezione seguente, non sarà in grado di derivare le coppie di chiavi create da Alice e, quindi, non sarà in grado di accedere ai suoi bitcoin ricevuti tramite BIP47. Per ora, il payload del codice di pagamento di Alice è criptato. Vediamo come Bob lo decifra.
**1-** Bob monitora le transazioni che creano output con il suo indirizzo di notifica.
**2-** Quando una transazione ha un output sul suo indirizzo di notifica, Bob la analizza per vedere se contiene un output OP_RETURN che segue lo standard BIP47.
**3-** Se il primo byte del payload OP_RETURN è `0x01`, Bob inizia la sua ricerca di un possibile segreto condiviso con ECDH:
- Bob seleziona la chiave pubblica nell'input della transazione. Ovvero, la chiave pubblica di Alice denominata $A$ con:
$$ A = a \cdot G $$
- Bob seleziona la chiave privata $b$ associata al suo indirizzo di notifica personale:
$$ b $$
- Bob calcola il punto segreto $S$ (segreto condiviso ECDH) sulla curva ellittica sommando e raddoppiando i punti, applicando la sua chiave privata $b$ alla chiave pubblica di Alice $A$:
$$ S = b \cdot A $$
- Bob determina il fattore di offuscamento $f$ che gli permetterà di decifrare il payload del codice di pagamento di Alice. Nello stesso modo in cui Alice aveva precedentemente calcolato, Bob troverà $f$ applicando HMAC-SHA512 su $x$ la coordinata x del punto segreto $S$, e su $o$ l'UTXO consumato come input in questa transazione di notifica:
$$ f = \text{HMAC-SHA512}(o, x) $$
**4-** Bob interpreta i dati nell'OP_RETURN della transazione di notifica come un codice di pagamento. Egli semplicemente decifra il payload di questo potenziale codice di pagamento usando il fattore di offuscamento $f$:
- Bob divide il fattore di offuscamento $f$ in 2 parti: i primi 32 byte di $f$ saranno $f1$ e gli ultimi 32 byte saranno $f2$;
- Bob decifra la coordinata x cifrata $x'$ della chiave pubblica dal codice di pagamento di Alice:
$$ x = x' \oplus f1 $$
- Bob decifra il valore del codice catena cifrato $c'$ dal codice di pagamento di Alice:
$$ c = c' \oplus f2 $$
**5-** Bob verifica se il valore della chiave pubblica dal codice di pagamento di Alice è effettivamente parte del gruppo secp256k1. Se è così, lo interpreta come un codice di pagamento valido. Altrimenti, ignora questa transazione.
Ora che Bob è a conoscenza del codice di pagamento di Alice, lei può inviargli fino a `2^32` pagamenti, senza mai dover effettuare un'altra transazione di notifica di questo tipo.
Perché funziona? Come fa Bob a determinare lo stesso fattore di offuscamento di Alice, e quindi a decifrare il suo codice di pagamento? Esaminiamo più da vicino il ruolo di ECDH in quello che abbiamo appena descritto.
Prima di tutto, stiamo trattando con la crittografia simmetrica. Questo significa che la chiave di cifratura e la chiave di decifratura sono lo stesso valore. Questa chiave nella transazione di notifica è il fattore di offuscamento:
$$ f = f1 || f2 $$
Pertanto, Alice e Bob devono ottenere lo stesso valore per $f$, senza trasmetterlo direttamente poiché un attaccante potrebbe rubarlo e decifrare le informazioni segrete. Questo fattore di offuscamento si ottiene applicando HMAC-SHA512 su 2 valori:
- la coordinata x di un punto segreto;
- e l'UTXO consumato come input nella transazione.
Bob, quindi, ha bisogno di queste due informazioni per decifrare il payload del codice di pagamento di Alice. Per l'UTXO come input, Bob può semplicemente recuperarlo osservando la transazione di notifica. Per il punto segreto, Bob dovrà usare ECDH. Come visto nella sezione precedente su Diffie-Hellman, semplicemente scambiando le rispettive chiavi pubbliche e applicando segretamente le proprie chiavi private alla chiave pubblica dell'altro, Alice e Bob possono trovare un punto specifico e segreto sulla curva ellittica. La transazione di notifica si basa su questo meccanismo:
- Coppia di chiavi di Bob:
$$ B = b \cdot G $$
- Coppia di chiavi di Alice:
$$ A = a \cdot G $$
- Per un segreto $S (x, y)$:
$$ S = a \cdot B = a \cdot (b \cdot G) = (b \cdot a) \cdot G = b \cdot A $$
Ora che Bob conosce il codice di pagamento di Alice, sarà in grado di rilevare i suoi pagamenti BIP47, e può derivare le chiavi private che bloccano i bitcoin ricevuti.
Ricapitoliamo i passaggi che abbiamo appena esaminato per ricevere e interpretare una transazione di notifica:
- Bob monitora gli output delle transazioni al suo indirizzo di notifica;
- Quando ne rileva uno, recupera le informazioni contenute nell'OP_RETURN;
- Bob seleziona la chiave pubblica in input e calcola un punto segreto usando ECDH;
- Usa questo punto segreto per calcolare un HMAC che è il fattore di offuscamento;
- Usa questo fattore di offuscamento per decifrare il payload del codice di pagamento di Alice contenuto nell'OP_RETURN.
### La Transazione di Pagamento BIP47
Studiamo ora insieme il processo di pagamento con BIP47. Per ricordarvi lo stato attuale delle cose:
- Alice conosce il codice di pagamento di Bob, che ha semplicemente recuperato dal suo sito web;
- Bob conosce il codice di pagamento di Alice grazie alla transazione di notifica;
- Alice effettuerà un primo pagamento a Bob. Potrà effettuarne molti altri allo stesso modo.
Prima di spiegare questo processo, penso sia importante ricordare gli indici su cui stiamo attualmente lavorando. Il percorso di derivazione di un codice di pagamento è descritto come segue: `m/47'/0'/0'`. La profondità successiva distribuisce gli indici in questo modo:
- La prima coppia di chiavi figlio normali (non rinforzate) è quella utilizzata per generare l'indirizzo di notifica di cui abbiamo parlato nella parte precedente: `m/47'/0'/0'/0`;
- Le coppie di chiavi figlio normali sono utilizzate all'interno di ECDH per generare indirizzi di ricezione dei pagamenti BIP47 come vedremo in questa sezione: da `m/47'/0'/0'/0` a `m/47'/0'/0'/2 147 483 647`;
- Le coppie di chiavi figlio rinforzate sono codici di pagamento effimeri: da `m/47'/0'/0'/0'` a `m/47'/0'/0'/2 147 483 647'`.
Ogni volta che Alice desidera inviare un pagamento a Bob, deriva un nuovo indirizzo vergine unico, grazie ancora al protocollo ECDH:
- Alice seleziona la prima chiave privata derivata dal suo codice di pagamento personale riutilizzabile:
$$ a $$
- Alice seleziona la prima chiave pubblica inutilizzata derivata dal codice di pagamento di Bob. Questa chiave pubblica, la chiameremo $B$. È associata alla chiave privata $b$ che solo Bob conosce:
$$ B = b \cdot G $$
- Alice calcola un punto segreto $S$ sulla curva ellittica tramite addizione e raddoppio di punti applicando la sua chiave privata $a$ alla chiave pubblica $B$ di Bob:
$$ S = a \cdot B $$
- Da questo punto segreto, Alice calcolerà il segreto condiviso $s$ (minuscolo). Per fare ciò, seleziona la coordinata x del punto segreto $S$ denominata $Sx$, e passa questo valore attraverso la funzione hash SHA256:
$$ S = (Sx, Sy) $$
$$ s = \text{SHA256}(Sx) $$
- Alice utilizza questo segreto condiviso $s$ per calcolare un indirizzo Bitcoin di ricezione dei pagamenti. Inizialmente, verifica che $s$ sia contenuto nell'ordine della curva secp256k1. In caso contrario, incrementa l'indice della chiave pubblica di Bob per derivare un altro segreto condiviso;
- In secondo luogo, calcola una chiave pubblica $K0$ aggiungendo sulla curva ellittica i punti $B$ e $s·G$. In altre parole, Alice aggiunge la chiave pubblica derivata dal codice di pagamento di Bob $B$ con un altro punto calcolato sulla curva ellittica tramite addizione e raddoppio con il segreto condiviso $s$ dal punto generatore della curva secp256k1 $G$. Questo nuovo punto rappresenta una chiave pubblica, e lo chiamiamo $K0$:
$$ K0 = B + s \cdot G $$
- Con questa chiave pubblica $K0$, Alice può derivare un indirizzo vergine standard di ricezione (per esempio, SegWit V0 in bech32).
Una volta che Alice ha ottenuto l'indirizzo di ricezione di Bob $K0$, può eseguire una transazione Bitcoin in modo standard. Per fare ciò, seleziona un UTXO di sua proprietà, assicurato da una coppia di chiavi di un ramo diverso del suo portafoglio HD, e lo spende per soddisfare un output all'indirizzo di Bob $K0$. È importante notare che questo pagamento, una volta derivato l'indirizzo, segue un processo convenzionale e non dipende più dalle chiavi associate a BIP47.
Ricapitoliamo i passaggi che abbiamo appena eseguito insieme per inviare un pagamento BIP47:
- Alice seleziona la prima chiave privata derivata dal suo codice di pagamento personale;
- Calcola un punto segreto sulla curva ellittica utilizzando ECDH dalla prima chiave pubblica derivata non utilizzata dal codice di pagamento di Bob;
- Utilizza questo punto segreto per calcolare un segreto condiviso con SHA256;
- Utilizza questo segreto condiviso per calcolare un nuovo punto segreto sulla curva ellittica;
- Aggiunge questo nuovo punto segreto alla chiave pubblica di Bob;
- Ottiene una nuova chiave pubblica effimera per la quale solo Bob ha la chiave privata associata;
- Alice può effettuare una transazione standard a Bob con l'indirizzo di ricezione effimero derivato.
![BTC204](assets/it/66/21.webp)
Se Alice desidera effettuare un secondo pagamento, seguirà gli stessi passaggi di prima, eccetto che questa volta selezionerà la seconda chiave pubblica derivata dal codice di pagamento di Bob. Specificamente, utilizzerà la prossima chiave non utilizzata. Otterrà così un nuovo indirizzo di ricezione appartenente a Bob, designato $K1$:
![BTC204](assets/it/66/22.webp)
Può continuare in questo modo e derivare fino a `2^32` indirizzi non utilizzati appartenenti a Bob.
Da un punto di vista esterno, osservando la blockchain, è teoricamente impossibile differenziare un pagamento BIP47 da un pagamento standard. Ecco un esempio di transazione di pagamento BIP47 sul Testnet:
```

94b2e59510f2e1fa78411634c98a77bbb638e28fb2da00c9f359cd5fc8f87254
````
Questo sembra una transazione standard con un input consumato, un output di pagamento e un resto:
![BTC204](assets/fr/232.webp)
### Ricevere il Pagamento BIP47 e Derivare la Chiave Privata
Alice ha appena effettuato il suo primo pagamento a un nuovo indirizzo BIP47 appartenente a Bob. Ora vediamo come Bob riceve questo pagamento. Vedremo anche perché Alice non ha accesso alla chiave privata dell'indirizzo che ha appena generato da sola, e come Bob recupera questa chiave per spendere i bitcoin che ha appena ricevuto.
Non appena Bob riceve la transazione di notifica da Alice, deriva la chiave pubblica BIP47 $K0$ anche prima che lei abbia inviato qualsiasi pagamento. Poi monitora qualsiasi pagamento all'indirizzo associato. Infatti, deriva immediatamente diversi indirizzi che monitorerà ($K0$, $K1$, $K2$, $K3$...). Ecco come deriva questa chiave pubblica $K0$:
- Bob seleziona la prima chiave privata derivata dal suo codice di pagamento. Questa chiave privata è denominata $b$. È associata alla chiave pubblica $B$ con cui Alice aveva fatto i suoi calcoli nel passaggio precedente:
$$ b $$
- Bob seleziona la prima chiave pubblica di Alice derivata dal suo codice di pagamento. Questa chiave è denominata $A$. È associata alla chiave privata $a$ con cui Alice aveva fatto i suoi calcoli, e di cui solo Alice è a conoscenza. Bob può eseguire questo processo poiché è a conoscenza del codice di pagamento di Alice che le è stato trasmesso con la transazione di notifica:
$$ A = a \cdot G $$
- Bob calcola il punto segreto $S$, mediante addizione e raddoppio di punti sulla curva ellittica, applicando la sua chiave privata $b$ alla chiave pubblica di Alice $A$. Qui troviamo l'uso di ECDH che garantisce che questo punto $S$ sarà lo stesso sia per Bob che per Alice:
$$ S = b \cdot A $$
- Proprio come ha fatto Alice, Bob isola la coordinata x di questo punto $S$. Abbiamo chiamato questo valore $Sx$. Egli passa questo valore attraverso la funzione SHA256 per trovare il segreto condiviso $s$ (minuscolo):
$$ s = \text{SHA256}(Sx) $$
- Proprio come Alice, Bob calcola il punto $s·G$ sulla curva ellittica. Poi, aggiunge questo punto segreto alla sua chiave pubblica $B$. Ottiene così un nuovo punto sulla curva ellittica che interpreta come una chiave pubblica $K0$:
$$ K0 = B + s \cdot G $$
Una volta che Bob ha questa chiave pubblica $K0$, può derivare la chiave privata associata per essere in grado di spendere i suoi bitcoin. È l'unico che può generare questa chiave privata:
- Bob aggiunge la sua chiave privata figlio $b$ derivata dal suo codice di pagamento personale. È l'unico che può ottenere il valore di $b$. Poi, aggiunge $b$ con il segreto condiviso $s$ per ottenere $k0$, la chiave privata di $K0$:
$$ k0 = b + s $$
Grazie alla legge di gruppo della curva ellittica, Bob ottiene esattamente la chiave privata corrispondente alla chiave pubblica usata da Alice. Abbiamo quindi:
$$ K0 = k0 \cdot G $$
Riassumerò i passaggi che abbiamo appena esaminato insieme per ricevere un pagamento BIP47 e calcolare la chiave privata corrispondente:
- Bob seleziona la prima chiave privata figlio derivata dal suo codice di pagamento personale;
- Calcola un punto segreto sulla curva ellittica usando ECDH dalla prima chiave pubblica figlio derivata dal codice catena di Alice;
- Usa questo punto segreto per calcolare un segreto condiviso con SHA256;
- Usa questo segreto condiviso per calcolare un nuovo punto segreto sulla curva ellittica;
- Aggiunge questo nuovo punto segreto alla sua chiave pubblica personale;
- Ottiene una nuova chiave pubblica effimera, alla quale Alice invierà il suo primo pagamento;
- Bob calcola la chiave privata associata a questa chiave pubblica effimera aggiungendo la sua chiave privata figlio derivata dal suo codice di pagamento e il segreto condiviso.
![BTC204](assets/it/66/24.webp)
Poiché Alice non può ottenere $b$ (la chiave privata di Bob), lei non è in grado di determinare $k0$ (la chiave privata associata all'indirizzo di ricezione BIP47 di Bob). Schematicamente, possiamo rappresentare il calcolo del segreto condiviso $S$ così:
![BTC204](assets/it/66/19.webp)
Una volta trovato il segreto condiviso con ECDH, Alice e Bob calcolano la chiave pubblica di pagamento BIP47 $K0$, e Bob calcola anche la chiave privata associata $k0$:
![BTC204](assets/it/66/25.webp)
### Rimborsare il Pagamento BIP47
Poiché Bob è a conoscenza del codice di pagamento riutilizzabile di Alice, ha già tutte le informazioni necessarie per inviarle un rimborso. Non avrà bisogno di contattare nuovamente Alice per chiedere informazioni. Dovrà semplicemente notificarla con una transazione di notifica, specialmente affinché lei possa recuperare i suoi indirizzi BIP47 con il suo seed, e poi potrà anche inviarle fino a `2^32` pagamenti.
La funzionalità di rimborso è specifica per BIP47 ed è uno dei suoi vantaggi rispetto ad altri metodi che studieremo nei prossimi capitoli, come i Pagamenti Silenziosi.
Bob può quindi rimborsare Alice nello stesso modo in cui lei gli ha inviato i pagamenti. I ruoli si invertono:
![BTC204](assets/it/66/26.webp)
_Un grande ringraziamento a [Fanis Michalakis](https://x.com/FanisMichalakis) per la sua revisione e preziosi consigli esperti sull'articolo che ha ispirato la scrittura di questo capitolo!_
https://planb.network/tutorials/privacy/on-chain/paynym-bip47-a492a70b-50eb-4f95-a766-bae2c5535093
## Pagamenti Silenziosi
<chapterId>2871d594-414e-4598-a830-91c9eb84dfb8</chapterId>
Il BIP47 è stato criticato per la sua inefficienza sulla blockchain. Come spiegato nel capitolo precedente, richiede una transazione di notifica per ogni nuovo destinatario. Questo vincolo diventa trascurabile se si prevede di stabilire un canale di pagamento duraturo con questo destinatario. Infatti, una singola transazione di notifica apre la strada a un numero quasi infinito di pagamenti BIP47 successivi.
Tuttavia, in determinate situazioni, la transazione di notifica può rappresentare un ostacolo per l'utente. Prendiamo l'esempio di una donazione una tantum a un destinatario: con un indirizzo Bitcoin classico, una singola transazione è sufficiente per effettuare la donazione. Ma con il BIP47, sono necessarie due transazioni: una per la notifica e un'altra per il pagamento effettivo. Quando la domanda di spazio nel blocco è bassa e le commissioni di transazione sono minime, questo passaggio aggiuntivo generalmente non rappresenta un problema. Tuttavia, durante i periodi di congestione, le commissioni di transazione possono diventare esorbitanti per un singolo pagamento, potenzialmente raddoppiando il costo per l'utente rispetto a una transazione Bitcoin standard, il che può essere inaccettabile per l'utente.
Per situazioni in cui l'utente prevede di effettuare solo pochi pagamenti a un identificatore statico, sono state sviluppate altre soluzioni. Tra queste ci sono i Pagamenti Silenziosi, descritti nel [BIP352](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki). Questo protocollo consente l'uso di un identificatore statico per ricevere pagamenti senza generare riutilizzo dell'indirizzo e senza richiedere l'uso di transazioni di notifica. Esaminiamo come funziona questo protocollo.
---
_Per comprendere appieno questo capitolo, è essenziale essere familiari con il funzionamento di ECDH (Elliptic Curve Diffie-Hellman) e la derivazione delle chiavi crittografiche in un portafoglio HD. Questi concetti sono stati dettagliati nel capitolo precedente sul BIP47. Non li ripeterò qui. Se non sei ancora familiare con queste nozioni, ti consiglio di consultare il capitolo precedente prima di continuare con questo. Non riprenderò nemmeno i rischi associati al riutilizzo degli indirizzi di ricezione, né l'importanza di avere un identificatore unico per ricevere pagamenti._
---
### Perché non spostare la notifica?
Come discusso nel capitolo sul BIP47, la transazione di notifica svolge principalmente due funzioni:
- Notifica il destinatario;
- Trasmette il codice di pagamento del mittente.
Si potrebbe ingenuamente pensare che questo processo di notifica potrebbe essere effettuato off-chain. In teoria, ciò è completamente fattibile: sarebbe sufficiente per il destinatario indicare un mezzo di comunicazione per ricevere i codici di pagamento BIP47 dai mittenti. Tuttavia, questo approccio presenta due problemi principali:
- Primo, ciò sposterebbe il processo di trasmissione del codice su un altro protocollo di comunicazione. Le questioni relative ai costi e alla privacy dello scambio rimarrebbero, ma sarebbero semplicemente trasferite a questo nuovo protocollo. In termini di privacy, ciò potrebbe anche creare un collegamento tra l'identità di un utente e l'attività sulla blockchain, cosa che cerchiamo di evitare eseguendo la notifica direttamente sulla blockchain. Inoltre, effettuare la notifica fuori dalla blockchain introdurrebbe rischi di censura (come il blocco dei fondi) che non esistono su Bitcoin;
Successivamente, ciò porrebbe un problema di recupero. Con BIP47, il destinatario deve assolutamente conoscere i codici di pagamento dei mittenti per accedere ai fondi. Questo è vero al momento della ricezione, ma anche in caso di recupero dei fondi tramite il seed in caso di perdita del portafoglio. Con le notifiche onchain, questo rischio viene evitato, poiché l'utente può trovare e decifrare le transazioni di notifica semplicemente conoscendo il proprio seed. Tuttavia, se la notifica viene eseguita fuori dalla blockchain, l'utente dovrebbe mantenere un backup dinamico di tutti i codici di pagamento ricevuti, il che è impraticabile per l'utente medio.
Tutti questi vincoli rendono l'uso della notifica onchain indispensabile nel contesto di BIP47. Eppure, i Pagamenti Silenziosi cercano specificamente di evitare questo passaggio di notifica onchain a causa del suo costo. Pertanto, la soluzione adottata non è spostare la notifica, ma eliminarla completamente. Per raggiungere questo obiettivo, deve essere accettato un compromesso: quello della scansione. A differenza di BIP47, dove l'utente sa esattamente dove trovare i propri fondi grazie alle transazioni di notifica, nel contesto dei Pagamenti Silenziosi, l'utente deve esaminare tutte le transazioni Bitcoin esistenti per rilevare eventuali pagamenti che potrebbero essere destinati a loro. Per ridurre questo onere operativo, la ricerca di Pagamenti Silenziosi è limitata solo alle transazioni che probabilmente contengono tali pagamenti, ovvero quelle che includono almeno un output Taproot P2TR. La scansione si concentra esclusivamente anche sulle transazioni dalla data di creazione del portafoglio (non c'è bisogno di scandire transazioni risalenti al 2009 se il portafoglio è stato creato nel 2024).
Pertanto, potete vedere perché BIP47 e Pagamenti Silenziosi, sebbene mirino a un obiettivo simile, comportano compromessi diversi e **quindi si rivolgono effettivamente a casi d'uso distinti**. Per i pagamenti una tantum, come le donazioni occasionali, i Pagamenti Silenziosi sono più appropriati a causa del loro costo inferiore. Al contrario, per le transazioni regolari allo stesso destinatario, come nel caso delle piattaforme di scambio o dei pool di mining, BIP47 potrebbe essere preferito.
Esploriamo insieme il funzionamento tecnico dei Pagamenti Silenziosi per capirne meglio le implicazioni. Per fare ciò, suggerisco di adottare lo stesso approccio del documento esplicativo di BIP352. Scomporremo gradualmente i calcoli da eseguire, elemento per elemento, giustificando ogni nuova aggiunta.
### Alcuni concetti da comprendere
Prima di iniziare, è importante chiarire che i Pagamenti Silenziosi si basano esclusivamente sull'uso di tipi di script P2TR (_Pay to Taproot_). A differenza di BIP47, non è necessario derivare gli indirizzi di ricezione dalle chiavi pubbliche figlie tramite hashing. Infatti, nello standard P2TR, la chiave pubblica modificata viene utilizzata direttamente e apertamente nell'indirizzo. Così, un indirizzo di ricezione Taproot è essenzialmente una chiave pubblica accompagnata da alcuni metadati. Questa chiave pubblica modificata è l'aggregazione di altre due chiavi pubbliche: una che consente la spesa diretta e tradizionale tramite una semplice firma, e l'altra che rappresenta la radice di Merkle del MAST, che autorizza la spesa soggetta alla soddisfazione di una delle condizioni potenzialmente iscritte nell'albero di Merkle.
![BTC204](assets/it/67/01.webp)
La decisione di limitare i Pagamenti Silenziosi esclusivamente a Taproot è motivata da due ragioni principali:
- Primo, facilita significativamente l'implementazione e gli aggiornamenti futuri nel software del portafoglio, poiché è necessario aderire a un solo standard;
- In secondo luogo, questo approccio aiuta a migliorare l'insieme di anonimato degli utenti incoraggiandoli a non disperdersi tra diversi tipi di script, che generano impronte di portafoglio distinte nell'analisi della catena (per maggiori informazioni su questo concetto, vi invito a consultare il capitolo 4 della parte 2).
### Derivazione naive di una chiave pubblica di Pagamenti Silenziosi
Iniziamo con un semplice esempio che ti aiuterà a comprendere il funzionamento di base dei Pagamenti Silenziosi (SP, Silent Payments). Prendiamo Alice e Bob, due utenti Bitcoin. Alice vuole inviare bitcoin a Bob su un nuovo indirizzo di ricezione. Tre obiettivi devono essere raggiunti in questo processo:
- Alice deve essere in grado di generare un nuovo indirizzo;
- Bob deve essere in grado di identificare un pagamento inviato a questo specifico indirizzo;
- Bob deve essere in grado di ottenere la chiave privata associata a questo indirizzo per poter spendere i suoi fondi.
Alice ha un UTXO nel suo portafoglio Bitcoin protetto con la seguente coppia di chiavi:
- $a$: la chiave privata;
- $A$: la chiave pubblica ($A = a \cdot G$)
Bob ha un indirizzo SP che ha pubblicato su internet con:
- $b$: la chiave privata;
- $B$: la chiave pubblica ($B = b \cdot G$)
Recuperando l'indirizzo di Bob, Alice è in grado di calcolare un nuovo indirizzo vuoto che appartiene a Bob usando ECDH. Chiamiamo questo indirizzo $P$:
$$ P = B + \text{hash}(a \cdot B) \cdot G $$
In questa equazione, Alice ha semplicemente calcolato il prodotto scalare della sua chiave privata $a$ e della chiave pubblica di Bob $B$. Ha passato questo risultato attraverso una funzione hash conosciuta da tutti. Il valore di output è poi moltiplicato scalarmente per il punto generatore $G$ della curva ellittica `secp256k1`. Infine, Alice aggiunge il punto ottenuto alla chiave pubblica di Bob $B$. Una volta che Alice ha questo indirizzo $P$, lo usa come output in una transazione, il che significa che invia bitcoin ad esso.
> _Nel contesto dei Pagamenti Silenziosi, la funzione "hash" corrisponde a una funzione hash SHA256 etichettata specificamente con `BIP0352/SharedSecret`, assicurando che gli hash generati siano unici per questo protocollo e non possano essere riutilizzati in altri contesti, fornendo anche una protezione aggiuntiva contro il riutilizzo di nonce nelle firme. Questo standard corrisponde a quello [specificato nel BIP340 per le firme Schnorr](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) su `secp256k1`._
Grazie alle proprietà della curva ellittica su cui si basa ECDH, sappiamo che:
$$ a \cdot B = b \cdot A $$
Bob sarà quindi in grado di calcolare l'indirizzo di ricezione su cui Alice ha inviato i bitcoin. Per fare ciò, monitora tutte le transazioni Bitcoin che soddisfano i criteri dei Pagamenti Silenziosi e applica il seguente calcolo a ciascuna di esse per vedere se il pagamento è indirizzato a lui (_scanning_):
$$ P' = B + \text{hash}(b \cdot A) \cdot G $$
Quando esamina la transazione di Alice, si rende conto che $P'$ è uguale a $P$. Sa quindi che questo pagamento è indirizzato a lui:
$$ P' = B + \text{hash}(b \cdot A) \cdot G = B + \text{hash}(a \cdot B) \cdot G = P $$
Da qui, Bob sarà in grado di calcolare la chiave privata $p$ che consente di spendere l'indirizzo $P$:
$$ p = (b + \text{hash}(b \cdot A)) \bmod n $$
Come puoi vedere, per calcolare questa chiave privata $p$, è necessario avere la chiave privata $b$. Solo Bob ha questa chiave privata $b$. Sarà quindi effettivamente l'unico in grado di spendere i bitcoin inviati al suo indirizzo di Pagamenti Silenziosi.
![BTC204](assets/fr/236.webp)
_Didascalia:_
- $B$: La chiave pubblica / indirizzo statico pubblicato da Bob
- $b$: La chiave privata di Bob
- $A$: La chiave pubblica dell'UTXO di Alice usata come input per la transazione
- $a$: La chiave privata di Alice
- $G$: Il punto generatore della curva ellittica `secp256k1`
- $\text{SHA256}$: La funzione di hashing SHA256 etichettata con `BIP0352/SharedSecret`
- $s$: Il segreto comune ECDH
- $P$: La chiave pubblica / indirizzo unico per il pagamento a Bob
Ecco un approccio inizialmente piuttosto ingenuo nell'uso dell'indirizzo statico di Bob, denotato $B$, per derivare un indirizzo unico $P$ per inviare bitcoin. Tuttavia, questo metodo è troppo semplicistico e presenta diversi difetti che necessitano di correzione. Il primo problema è che, in questo schema, Alice non può creare molteplici output per Bob all'interno della stessa transazione.
### Come creare molteplici output?
Nell'esempio della sezione precedente, Alice crea un singolo output che andrà a Bob al suo indirizzo unico $P$. Con lo stesso input selezionato, è impossibile per Alice creare due indirizzi vergini distinti per Bob, poiché il metodo utilizzato porterebbe sempre allo stesso risultato per $P$, quindi allo stesso indirizzo. Tuttavia, ci possono essere molte situazioni in cui Alice desidera dividere il suo pagamento a Bob in diverse piccole somme, creando così molteplici UTXO. È quindi necessario trovare un metodo che permetta di farlo.
Per raggiungere questo obiettivo, modificheremo leggermente il calcolo che Alice esegue per derivare $P$, in modo che possa generare due indirizzi distinti per Bob, ovvero $P_0$ e $P_1$.
Per modificare il calcolo e ottenere 2 indirizzi diversi, è sufficiente aggiungere un intero che modifica il risultato. Così, Alice aggiungerà $0$ nel suo calcolo per ottenere l'indirizzo $P_0$ e $1$ per ottenere l'indirizzo $P_1$. Chiamiamo questo intero $i$:
$$ P_i = B + \text{hash}(a \cdot B \text{ ‖ } i) \cdot G $$
Il processo di calcolo rimane invariato rispetto al metodo precedente, eccetto che questa volta Alice concatenerà $a \cdot B$ con $i$ prima di procedere al hash. È quindi sufficiente cambiare $i$ per avere un nuovo indirizzo appartenente a Bob. Ad esempio:
$$ P_0 = B + \text{hash}(a \cdot B \text{ ‖ } 0) \cdot G $$
$$ P_1 = B + \text{hash}(a \cdot B \text{ ‖ } 1) \cdot G $$
Quando Bob esamina la blockchain per i Pagamenti Silenziosi destinati a lui, inizia utilizzando $i = 0$ per l'indirizzo $P_0$. Se non trova nessun pagamento su $P_0$, conclude che questa transazione non contiene nessun Pagamento Silenzioso per lui e smette di analizzarla. Tuttavia, se $P_0$ è valido e contiene un pagamento per lui, procede con $P_1$ nella stessa transazione per verificare se Alice ha effettuato un secondo pagamento. Se $P_1$ risulta essere invalido, interrompe la sua ricerca per questa transazione; altrimenti, continua a testare valori successivi di $i$.
$$ P_1 = B + \text{hash}(b \cdot A \text{ ‖ } 1) \cdot G $$
Poiché Bob si ferma immediatamente a $i = 0$ se $P_0$ non produce risultati, l'uso di questo intero aggiunge quasi nessun onere operativo aggiuntivo a Bob per la fase di scansione delle transazioni.
Bob può quindi calcolare le chiavi private nello stesso modo:
$$

p_0 = (b + text{hash}(b \cdot A \text{‖ } 0)) \bmod n

$$
p_1 = (b + \text{hash}(b \cdot A \text{ ‖ } 1)) \bmod n
$$

_迪达斯卡利亚：_


- $B$:La chiave pubblica / indirizzo statico pubblicato da Bob
- $b$:鲍勃的私房话
- $A$:爱丽丝UTXO 的公共代码，用作传输输入
- $a$:爱丽丝的私房话
- $G$： `secp256k1`椭圆曲线的生成点
- $\text{SHA256}$：通过 `BIP0352/SharedSecret` 获取 SHA256 哈希值的功能
- $s_0$: ECDH 的第一个秘密
- s_1$：ECDH 的第二序列
- $P_0$:向鲍勃付款的第一个公开号码/唯一号码
- $P_1$:La seconda chiave pubblica / indirizzo unico peril pagamento a Bob

有了这种方法，我们就能制定出一个很好的协议，但还存在一些需要改进的地方，特别是要防止对吲哚的滥用。

### 如何避免滥用索引？

正如我们在前面的章节中所看到的，爱丽丝使用了保护自己的UTXO的chiavi coppia，用来计算与鲍勃的ECDH密码。这个密码允许推导出唯一标识 $P_0$。不过，如果爱丽丝多次使用这个标识，她使用的标识符（$a$, $A$）可以保护更多的UTXO。在这种情况下，如果 Alice 使用同一个字符串 $A$ 保护两个 UTXO，对 Bob 的静态标识 $B$ 进行了两次支付，这就构成了 Bob 对标识的重复使用。

> _Il riutizzo degli indirizzi è una pratica molto negativeiva per la privacy degli utenti.为了解原因，建议您阅读本说明的主要部分。
因此，由于 $P_0$ 是由 $A$ 和 $B$ 产生的，如果 Alice 为 $B$ 的第二笔支付产生了第二个 $P_0$ ID，并使用相同的字符串 $A$，那么最终将获得相同的 $P_0$ ID。为避免这种风险并防止在无声支付卡内部滥用发票，我们必须对计算结果进行适当修改。

我们希望爱丽丝消耗的每一个UTXO 都能从鲍勃的账户中得到一个唯一的标识，即使有更多的UTXO 也能从同一个账户中得到保护。因此，在计算唯一索引 $P_0$ 时，只需引用所有 UTXO 即可。这个参考值就是作为输入消耗的 UTXO 的哈希值：

$$ \text{inputHash} = \text{hash}(\text{outpoint} \text{ ‖ } A) $$

这样，爱丽丝就可以在计算单个指数 $P_0$ 时使用这个输入：

在扫描过程中，Bob 还可以添加 $\text{inputHash}$，因为他所需要做的就是为 $\text{outpoint}$ 进行转码：

$$ P_0 = B + \text{inputHash} （ \text{inputHash} \cdot b \cdot A \text{ ‖ } 0） \cdot G $$

一旦找到有效的 $P_0$，就可以计算相应的私有链 $p_0$：

$$
p_0 = (b + \text{hash}(\text{inputHash} \cdot b \cdot A \text{ ‖ } 0)) \bmod n
$$

```text
_Legenda:_
- $B$: La chiave pubblica / indirizzo statico pubblicato da Bob
- $b$: La chiave privata di Bob
- $A$: La chiave pubblica dell'UTXO di Alice usata come input per la transazione
- $a$: La chiave privata di Alice
- $H$: L'hash dell'UTXO usato come input
- $G$: Il punto generatore della curva ellittica `secp256k1`
- $\text{SHA256}$: La funzione di hash SHA256 etichettata con `BIP0352/SharedSecret`
- $s_0$: Il primo segreto condiviso ECDH
- $P_0$: La prima chiave pubblica / indirizzo unico per il pagamento a Bob
Al momento, i nostri calcoli presuppongono che Alice utilizzi un singolo input per la sua transazione. Tuttavia, dovrebbe essere in grado di utilizzare più input. Di conseguenza, da parte di Bob, per ogni transazione contenente più input, teoricamente avrebbe bisogno di calcolare l'ECDH per ogni input per determinare se un pagamento è destinato a lui. Questo metodo non è soddisfacente, quindi abbiamo bisogno di trovare una soluzione per ridurre il carico di lavoro!
### Modificare le chiavi pubbliche negli input
Per risolvere questo problema, invece di utilizzare la coppia di chiavi che protegge un input specifico da parte di Alice, useremo la somma di tutte le coppie di chiavi utilizzate negli input della transazione. Questa somma sarà quindi considerata come una nuova coppia di chiavi. Questa tecnica è nota come "tweak".
Per esempio, immagina che la transazione di Alice abbia 3 input, ognuno protetto con una coppia di chiavi diversa:
- $a_0$ protegge l'input #0;
- $a_1$ protegge l'input #1;
- $a_2$ protegge l'input #2.
Seguendo il metodo descritto sopra, Alice dovrebbe scegliere una singola coppia di chiavi tra $a_0$, $a_1$ e $a_2$ per calcolare il segreto ECDH e generare l'indirizzo di pagamento unico $P$ dall'indirizzo statico $B$ di Bob. Tuttavia, questo approccio richiede a Bob di testare ogni possibilità sequenzialmente, partendo da $a_0$, poi $a_1$, e così via, fino all'identificazione di una coppia che genera un indirizzo valido $P$. Questo processo richiede che Bob esegua il calcolo ECDH su tutti gli input di tutte le transazioni, aumentando significativamente il carico di lavoro operativo di scansione.
Per evitare ciò, chiederemo ad Alice di eseguire il suo calcolo di $P$ utilizzando la somma di tutte le chiavi in input. Prendendo il nostro esempio, la chiave privata modificata $a$ sarebbe calcolata come segue:
$$ a = a_0 + a_1 + a_2 $$
Allo stesso modo, Alice e Bob saranno in grado di calcolare la chiave pubblica modificata:
$$ A = A_0 + A_1 + A_2 $$
Grazie a questo metodo, a Bob basta calcolare la somma delle chiavi pubbliche della transazione, poi calcolare il segreto ECDH da $A$ soltanto, il che riduce notevolmente il numero di calcoli da fare per la fase di scansione. Tuttavia, ricorda dalla sezione precedente. Avevamo incluso nel nostro calcolo l'hash $\text{inputHash}$ che viene usato come nonce per prevenire il riutilizzo degli indirizzi:
$$ \text{inputHash} = \text{hash}(\text{outpoint} \text{ ‖ } A) $$
Ma se ci sono più input in una transazione, è necessario determinare quale $\text{outpoint}$ viene scelto in questo calcolo. Secondo il BIP352, il criterio di selezione per $\text{outpoint}$ da usare è scegliere il più piccolo lessicograficamente, il che significa selezionare l'UTXO che appare per primo in ordine alfabetico. Questo metodo standardizza l'UTXO da scegliere in ogni transazione. Ad esempio, se questo $\text{outpoint}$ più piccolo lessicograficamente è $\text{outpoint}_L$, il calcolo di $\text{inputHash}$ sarà:
$$ \text{inputHash} = \text{hash}(\text{outpoint}\_L \text{ ‖ } A) $$
I calcoli rimangono quindi identici a quelli presentati nella sezione precedente, eccetto che la chiave privata $a$ e la sua corrispondente chiave pubblica $A$ non rappresentano più una coppia che protegge un singolo input, ma ora rappresentano la modifica di tutte le coppie di chiavi negli input.
### Separare le Chiavi di Spesa e di Scansione
Finora, abbiamo discusso dell'indirizzo statico di Pagamento Silenzioso $B$ come di una chiave pubblica unica. Ricorda, è questa chiave pubblica $B$ che viene usata da Alice per creare il segreto condiviso ECDH, che a sua volta viene usato per calcolare l'indirizzo di pagamento unico $P$. Bob usa questa chiave pubblica $B$ e la corrispondente chiave privata $b$ per la fase di scansione. Ma userà anche la chiave privata $b$ per calcolare la chiave privata $p$ che consente di spendere dall'indirizzo $P$.
Lo svantaggio di questo metodo è che la chiave privata $b$, che viene usata per calcolare tutte le chiavi private per gli indirizzi che ricevono Pagamenti Silenziosi, viene anche usata da Bob per scansionare le transazioni. Questo passaggio richiede che la chiave $b$ sia disponibile su un software di portafoglio connesso a Internet, il che la espone a un rischio maggiore di furto rispetto al mantenerla su un portafoglio freddo. Idealmente, sarebbe vantaggioso poter approfittare dei Pagamenti Silenziosi mantenendo la chiave privata $b$, che controlla l'accesso a tutte le altre chiavi private, al sicuro su un portafoglio hardware. Fortunatamente, il protocollo è stato adattato per permettere esattamente questo.
Per raggiungere questo obiettivo, il BIP352 specifica che il ricevente usa 2 diverse coppie di chiavi:
- $B_{\text{spend}}$: per calcolare le chiavi private degli indirizzi di pagamento unici;
- $B_{\text{scan}}$: per trovare indirizzi di pagamento unici.
In questo modo, Bob può mantenere la chiave privata $b_{\text{spend}}$ su un portafoglio hardware e usare la chiave privata $b_{\text{scan}}$ su software online per trovare i suoi Pagamenti Silenziosi, senza rivelare $b_{\text{spend}}$. Tuttavia, le chiavi pubbliche $B_{\text{scan}}$ e $B_{\text{spend}}$ sono entrambe pubblicamente rivelate, poiché si trovano nell'indirizzo statico di Bob $B$:
Per calcolare un indirizzo di pagamento unico $P_0$ appartenente a Bob, Alice eseguirà il seguente calcolo:
$$ P*0 = B*{\text{spend}} + \text{hash}(\text{inputHash} \cdot a \cdot B\_{\text{scan}} \text{ ‖ } 0) \cdot G $$
Per trovare i pagamenti indirizzati a lui, Bob eseguirà il seguente calcolo:
$$ P*0 = B*{\text{spend}} + \text{hash}(\text{inputHash} \cdot b\_{\text{scan}} \cdot A \text{ ‖ } 0) \cdot G $$
Come puoi vedere, fino a questo momento, Bob non ha avuto bisogno di usare $b_{\text{spend}}$ che si trova sul suo portafoglio hardware. Quando desidera spendere $P_0$, può quindi eseguire il seguente calcolo per trovare la chiave privata $p_0$:
$$ p*0 = (b*{\text{spend}} + \text{hash}(\text{inputHash} \cdot b\_{\text{scan}} \cdot A \text{ ‖ } 0)) \bmod n $$
_Didascalia:_
- $B_{\text{scan}}$: Chiave pubblica di scansione di Bob (indirizzo statico)
- $b_{\text{scan}}$: Chiave privata di scansione di Bob
- $B_{\text{spend}}$: Chiave pubblica di spesa di Bob (indirizzo statico)
- $b_{\text{spend}}$: Chiave privata di spesa di Bob
- $A$: La somma delle chiavi pubbliche in input (tweak)
- $a$: La chiave privata corrispondente alla chiave pubblica modificata
- $H$: L'hash dell'UTXO più piccolo (lessicograficamente) usato in input
- $G$: Il punto generatore della curva ellittica `secp256k1`
- $\text{SHA256}$: La funzione di hashing SHA256 etichettata con `BIP0352/SharedSecret`
- $s_0$: Il primo segreto condiviso ECDH
- $P_0$: La prima chiave pubblica / indirizzo di pagamento unico per Bob
### Utilizzando indirizzi SP con un'etichetta
Bob ha quindi un indirizzo statico $B$ per i Pagamenti Silenziosi come segue:
$$ B = B*{\text{scan}} \text{ ‖ } B*{\text{spend}} $$
Il problema con questo metodo è che non permette di segregare i diversi pagamenti inviati a questo indirizzo. Ad esempio, se Bob ha 2 clienti diversi per la sua attività e vuole differenziare chiaramente i pagamenti da ciascuno, avrebbe bisogno di 2 indirizzi statici diversi. Una soluzione ingenua, con l'approccio attuale, sarebbe che Bob crei due portafogli separati, ognuno con il proprio indirizzo statico, o addirittura stabilisca due indirizzi statici diversi all'interno dello stesso portafoglio. Tuttavia, questa soluzione richiede la scansione dell'intera blockchain due volte (una per ciascun indirizzo) per rilevare rispettivamente i pagamenti destinati a ciascun indirizzo. Questa doppia scansione aumenta in modo irragionevole l'onere operativo per Bob.
Per risolvere questo problema, BIP352 utilizza un sistema di etichettatura che consente di avere diversi indirizzi statici senza aumentare in modo irragionevole il carico di lavoro per trovare Pagamenti Silenziosi sulla blockchain. Per fare ciò, viene aggiunto un intero $m$ alla chiave pubblica di spesa $B_{\text{spend}}$. Questo intero può assumere il valore di $1$ per il primo indirizzo statico, poi $2$ per il secondo, e così via. Le chiavi di spesa $B_{\text{spend}}$ saranno d'ora in poi chiamate $B_m$ e saranno costruite in questo modo:
$$ B*m = B*{\text{spend}} + \text{hash}(b\_{\text{scan}} \text{ ‖ } m) \cdot G $$
Per esempio, per la prima chiave di spesa con l'etichetta $1$:
$$ B*1 = B*{\text{spend}} + \text{hash}(b\_{\text{scan}} \text{ ‖ } 1) \cdot G $$
L'indirizzo statico pubblicato da Bob consisterà ora di $B_{\text{scan}}$ e $B_m$. Per esempio, il primo indirizzo statico con l'etichetta $1$ sarà:
$$ B = B\_{\text{scan}} \text{ ‖ } B_1 $$
> _Iniziamo solo dall'etichetta 1 perché l'etichetta 0 è riservata per il resto._
Alice, da parte sua, deriverà l'indirizzo di pagamento unico $P$ nello stesso modo di prima, ma utilizzando il nuovo $B_1$ invece di $B_{\text{spend}}$.
$$ P*0 = B_1 + \text{hash}(\text{inputHash} \cdot a \cdot B*{\text{scan}} \text{ ‖ } 0) \cdot G $$
In realtà, Alice potrebbe non sapere nemmeno che Bob ha un indirizzo etichettato, poiché lei semplicemente utilizza la seconda parte dell'indirizzo statico che lui le ha fornito, che in questo caso, è il valore $B_1$ piuttosto che $B_{\text{spend}}$.
Per scansionare i pagamenti, Bob utilizzerà sempre il valore del suo indirizzo statico iniziale con $B_{\text{spend}}$ in questo modo:
$$ P*0 = B*{\text{spend}} + \text{hash}(\text{inputHash} \cdot b\_{\text{scan}} \cdot A \text{ ‖ } 0) \cdot G $$
Poi, semplicemente sottrae il valore che trova per $P_0$ da ogni output uno per uno. Poi controlla se uno dei risultati di queste sottrazioni corrisponde al valore di una delle etichette che usa nel suo portafoglio. Se corrisponde, per esempio, per l'output #4 con l'etichetta $1$, ciò significa che questo output è un Pagamento Silenzioso associato al suo indirizzo statico etichettato $B_1$:
$$ Out*4 - P_0 = \text{hash}(b*{\text{scan}} \text{ ‖ } 1) \cdot G $$
Questo funziona perché:
$$ B*1 = B*{\text{spend}} + \text{hash}(b*{\text{scan}} \text{ ‖ } 1) \cdot G $$
Grazie a questo metodo, Bob può utilizzare una moltitudine di indirizzi statici ($B_1$, $B_2$, $B_3$...), tutti derivati dal suo indirizzo statico base ($B = B*{\text{scan}} \text{ ‖ } B*{\text{spend}}$), al fine di separare correttamente gli usi.
Tuttavia, questa separazione degli indirizzi statici è valida solo da una prospettiva di gestione personale del portafoglio e non consente la separazione delle identità. Poiché tutti hanno lo stesso $B*{\text{scan}}$, è molto facile associare tutti gli indirizzi statici insieme e dedurre che appartengono a una singola entità.
_Didascalia:_
- $B_{\text{scan}}$: chiave pubblica di scansione di Bob (indirizzo statico)
- $b_{\text{scan}}$: chiave privata di scansione di Bob
- $B_{\text{spend}}$: chiave pubblica di spesa di Bob (indirizzo iniziale)
- $B_m$: chiave pubblica di spesa etichettata di Bob (indirizzo statico)
- $b_m$: chiave privata di spesa etichettata di Bob
- $A$: La somma delle chiavi pubbliche in input (tweak)
- $a$: La chiave privata corrispondente alla chiave pubblica modificata
- $H$: L'hash del più piccolo UTXO (lessicograficamente) utilizzato come input
- $G$: Il punto generatore della curva ellittica `secp256k1`
- $\text{SHA256}$: La funzione di hashing SHA256 etichettata con `BIP0352/SharedSecret`
- $s_0$: Il primo segreto condiviso ECDH
- $P_0$: La prima chiave pubblica / indirizzo unico per il pagamento a Bob
- $p_0$: La chiave privata del primo indirizzo di pagamento unico a Bob
- $X$: L'hash della chiave privata di scansione con l'etichetta
### Come Costruire un Indirizzo per Pagamenti Silenziosi?
Per costruire un indirizzo dedicato ai Pagamenti Silenziosi, è necessario prima derivare 2 coppie di chiavi nel proprio portafoglio Bitcoin HD:
- La coppia $b_{\text{scan}}$, $B_{\text{scan}}$ per cercare i pagamenti indirizzati a noi;
- La coppia $b_{\text{spend}}$, $B_{\text{spend}}$ per spendere i bitcoin che abbiamo ricevuto.
Queste coppie sono derivate seguendo questi percorsi (_Bitcoin Mainnet_):
scan: m / 352' / 0' / 0' / 1' / 0
spend: m / 352' / 0' / 0' / 0' / 0
```

```text
Una volta disponibili queste 2 coppie di chiavi, si concatenano semplicemente (una di seguito all'altra) per creare il payload dell'indirizzo statico:
$$ B = B*{\text{scan}} \text{ ‖ } B*{\text{spend}} $$
Se si desidera utilizzare etichette, $B_{\text{spend}}$ viene sostituito con $B_m$:
$$ B = B\_{\text{scan}} \text{ ‖ } B_m $$
Con l'etichetta $m$:
$$ B*m = B*{\text{spend}} + \text{hash}(b\_{\text{scan}} \text{ ‖ } m) \cdot G $$
Una volta disponibile questo payload, si aggiunge la HRP (_Human-Readable Part_) `sp` e la versione `q` (= versione 0). Viene anche aggiunto un checksum, e l'indirizzo è formattato in bech32m.
Ad esempio, ecco il mio indirizzo statico per i Pagamenti Silenziosi:
sp1qqvhjvsq2vz8zwrw372vuzle7472zup2ql3pz64yn5cpkw5ngv2n6jq4nl8cgm6zmu48yk3eq33ryc7aam6jrvrg0d0uuyzecfhx2wgsumcurv77e
```