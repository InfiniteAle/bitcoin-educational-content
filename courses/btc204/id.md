---
name: Privasi pada Bitcoin
goal: Memahami dan menguasai prinsip-prinsip perlindungan privasi saat menggunakan Bitcoin
objectives: 

  - Mendefinisikan konsep teoretis yang diperlukan untuk memahami pertaruhan perlindungan privasi
  - Mengetahui cara mengidentifikasi dan memitigasi risiko yang terkait dengan hilangnya privasi pengguna di Bitcoin
  - Menggunakan metode dan alat untuk melindungi privasi Anda di Bitcoin
  - Memahami metode analisis rantai dan mengembangkan strategi pertahanan

---
# Lindungi privasi Anda di bitcoin

Di dunia di mana privasi transaksi keuangan secara bertahap menjadi sebuah kemewahan, memahami dan menguasai prinsip-prinsip perlindungan privasi dalam penggunaan Bitcoin sangatlah penting. Pelatihan ini memberi Anda semua kunci, baik teori maupun praktik, untuk mencapai tujuan ini secara mandiri.

Saat ini, di Bitcoin, ada perusahaan yang mengkhususkan diri dalam analisis rantai. Bisnis inti mereka adalah mengganggu privasi Anda untuk mengkompromikan kerahasiaan transaksi Anda. Faktanya, "hak privasi" pada Bitcoin tidak ada. Oleh karena itu, tergantung pada Anda, pengguna, untuk menegaskan hak-hak alamiah Anda dan melindungi kerahasiaan transaksi Anda, karena tidak ada orang lain yang akan melakukannya untuk Anda.

Pelatihan ini disajikan sebagai kursus generalis yang komprehensif. Setiap gagasan teknis dijelaskan secara terperinci dan didukung oleh diagram penjelasan. Tujuannya adalah agar pengetahuan dapat diakses oleh semua orang. Oleh karena itu, BTC204 dapat diakses oleh pengguna pemula dan menengah. Pelatihan ini juga menawarkan nilai tambah bagi para pengguna bitcoin yang lebih berpengalaman, karena kita akan mempelajari beberapa konsep teknis yang sering kali tidak dikenal.

Bergabunglah bersama kami untuk mengubah penggunaan Bitcoin Anda dan menjadi pengguna yang terinformasi, yang mampu memahami isu-isu seputar kerahasiaan dan melindungi privasi Anda.

+++
# Pendahuluan

<partId>e17474a8-8899-4bdb-a7f8-bc52ddb01440</partId>

## Pengantar Pelatihan

<chapterId>08ba1933-f393-4fb5-8279-777d874caedb</chapterId>

Di dunia di mana privasi transaksi keuangan secara bertahap menjadi sebuah kemewahan, memahami dan menguasai prinsip-prinsip perlindungan privasi dalam penggunaan Bitcoin sangatlah penting. Pelatihan ini memberi Anda semua kunci, baik teori maupun praktik, untuk mencapai tujuan ini secara mandiri.

Saat ini, dalam ekosistem Bitcoin, terdapat perusahaan-perusahaan yang berspesialisasi dalam analisis blockchain. Bisnis inti mereka adalah mengganggu privasi Anda, mengorbankan kerahasiaan transaksi Anda. Faktanya, "hak privasi" pada Bitcoin tidak ada. Oleh karena itu, terserah kepada Anda, pengguna, untuk menegaskan hak-hak alamiah Anda dan melindungi kerahasiaan transaksi Anda, karena tidak ada orang lain yang akan melakukannya untuk Anda.

Bitcoin tidak hanya ada untuk "Angka Naik" dan pelestarian nilai tabungan. Karena fitur dan sejarahnya yang unik, Bitcoin adalah alat ekonomi alternatif. Berkat penemuan luar biasa ini, Anda dapat dengan bebas mengelola uang Anda, membelanjakannya, dan mengakumulasikannya, tanpa ada yang bisa menghentikan Anda.

Bitcoin menawarkan pelarian yang damai dari kuk negara, memungkinkan Anda untuk sepenuhnya menikmati hak-hak alami Anda, yang tidak dapat diganggu gugat oleh hukum yang ada. Berkat penemuan Satoshi Nakamoto, Anda memiliki kekuatan untuk menegakkan hak Anda atas properti pribadi dan mendapatkan kembali kebebasan Anda untuk membuat kontrak.

Akan tetapi, Bitcoin tidak bersifat anonim secara default, yang dapat menimbulkan risiko bagi individu yang terlibat dalam ekonomi alternatif, terutama di wilayah yang berada di bawah rezim yang lalim. Tetapi ini bukan satu-satunya bahaya. Karena bitcoin adalah aset yang berharga dan tidak disensor, ia dapat menarik perhatian para pencuri. Oleh karena itu, melindungi privasi Anda juga menjadi sebuah isu keamanan: hal ini dapat membantu Anda mencegah serangan siber dan serangan fisik.

Seperti yang akan kita lihat, meskipun protokol ini menawarkan perlindungan privasi yang melekat, sangat penting untuk menggunakan alat tambahan untuk mengoptimalkan dan mempertahankan privasi ini. Kursus ini dirancang sebagai jalur generalis yang komprehensif untuk memahami masalah privasi pada Bitcoin. Setiap pengertian teknis akan dibahas secara detail dan didukung oleh diagram penjelasan. Tujuannya adalah untuk membuat pengetahuan dapat diakses oleh semua orang, termasuk pengguna pemula dan menengah. Untuk pengguna Bitcoin yang lebih berpengalaman, kami juga akan membahas konsep-konsep yang sangat teknis dan terkadang kurang dikenal selama kursus ini untuk memperdalam pemahaman tentang setiap topik.

Tujuan dari kursus ini bukan untuk membuat Anda sepenuhnya anonim dalam penggunaan Bitcoin, melainkan untuk memberi Anda alat penting untuk mengetahui cara melindungi privasi Anda sesuai dengan tujuan pribadi Anda. Anda akan memiliki kebebasan untuk memilih dari konsep dan alat yang disajikan untuk mengembangkan strategi Anda sendiri, yang disesuaikan dengan tujuan dan kebutuhan spesifik Anda.

### Bagian 1: Definisi dan Konsep Utama

Untuk memulainya, kita akan melihat bersama-sama dasar-dasar yang mengatur cara kerja Bitcoin, dan kemudian dengan tenang membahas pengertian terkait privasi. Sangatlah penting untuk menguasai beberapa konsep dasar, seperti UTXO, menerima alamat atau skrip, sebelum kita dapat sepenuhnya memahami konsep-konsep yang akan kita bahas pada bagian selanjutnya. Kami juga akan memperkenalkan model privasi umum Bitcoin, seperti yang dibayangkan oleh Satoshi Nakamoto, yang akan memungkinkan kita untuk memahami masalah dan risiko yang terkait.

![BTC204](assets/it/11/1.webp)

### Bagian 2: Memahami Analisis Rantai dan Cara Melindungi Diri Anda

Di bagian kedua, kita mempelajari teknik yang digunakan oleh perusahaan analisis blockchain untuk melacak aktivitas Anda di Bitcoin. Memahami metode-metode ini sangat penting untuk meningkatkan perlindungan privasi Anda. Bagian ini bertujuan untuk memeriksa strategi penyerang untuk lebih memahami risiko dan meletakkan dasar untuk teknik yang akan kita pelajari di bagian selanjutnya. Kita akan menganalisa pola transaksi, heuristik internal dan eksternal, serta interpretasi yang masuk akal dari pola-pola ini. Sebagai tambahan dari komponen teoritis, kita akan belajar bagaimana menggunakan block explorer untuk melakukan analisis rantai melalui contoh-contoh praktis dan latihan.

![BTC204](assets/fr/002.webp)

### Bagian 3: Penguasaan Praktik Terbaik untuk Melindungi Privasi Anda

Di bagian ketiga kursus ini, kita akan membahas inti dari masalah ini: latihan! Tujuannya adalah untuk menguasai semua praktik terbaik yang penting yang seharusnya menjadi refleks alami bagi setiap pengguna Bitcoin. Kita akan membahas penggunaan alamat baru, pelabelan, konsolidasi, penggunaan node penuh, serta metode KYC dan akuisisi. Tujuannya adalah untuk memberikan Anda gambaran umum yang komprehensif mengenai jebakan-jebakan yang perlu dihindari untuk membangun fondasi yang kuat dalam upaya perlindungan privasi. Untuk beberapa praktik ini, Anda akan dipandu ke tutorial khusus untuk mengimplementasikannya.

![BTC204](assets/it/11/3.webp)

### Bagian 4: Memahami Transaksi Coinjoin

Bagaimana kita dapat berbicara tentang privasi bitcoin tanpa membahas coinjoin? Di bagian 4, Anda akan mengetahui semua yang perlu Anda ketahui tentang metode pencampuran ini. Anda akan mempelajari apa itu coinjoin, sejarah dan tujuannya, serta berbagai jenis coinjoin yang ada. Terakhir, untuk pengguna yang lebih berpengalaman, kita akan mengetahui apa itu anonset dan entropi, serta bagaimana cara menghitung indikator-indikator ini.

![BTC204](assets/it/11/4.webp)

### Bagian 5: Memahami Masalah Teknik Privasi Tingkat Lanjut Lainnya

Pada bagian kelima, kami akan memberikan gambaran umum mengenai semua teknik yang ada untuk melindungi privasi Anda di Bitcoin selain coinjoin. Selama bertahun-tahun, para pengembang telah menunjukkan kreativitas yang tinggi dalam mendesain alat yang didedikasikan untuk privasi. Kita akan memeriksa semua metode ini, seperti payjoin, transaksi kolaboratif, Coin Swap dan Atomic Swap, dengan merinci cara kerjanya, tujuan dan potensi kelemahannya.

Kita juga akan membahas privasi pada tingkat jaringan node dan difusi transaksi. Kita juga akan membahas berbagai protokol yang telah diusulkan selama bertahun-tahun untuk meningkatkan privasi pengguna Bitcoin, termasuk protokol alamat statis.

![BTC204](assets/fr/005.webp)

# Definisi dan Konsep Utama

<partId>b9bbbde3-34c0-4851-83e8-e2ffb029cf31</partId>

## Model UTXO dari Bitcoin

<chapterId>8d6b50c5-bf74-44f4-922b-25204991cb75</chapterId>

Bitcoin pada dasarnya adalah mata uang, tetapi tahukah Anda secara konkret bagaimana BTC direpresentasikan dalam protokol?

### UTXO dari Bitcoin: Apa Itu?

Dalam protokol Bitcoin, pengelolaan unit moneter didasarkan pada model UTXO, yang merupakan singkatan dari "_Unspent Transaction Output_."

Model ini sangat berbeda dengan sistem perbankan tradisional, yang mengandalkan mekanisme rekening dan saldo untuk melacak arus keuangan. Faktanya, dalam sistem perbankan, saldo individu disimpan dalam rekening yang ditautkan ke identitas. Contohnya, ketika Anda membeli baguette dari tukang roti, bank Anda hanya mendebet jumlah pembelian dari rekening Anda, sehingga mengurangi saldo Anda, sementara rekening tukang roti dikreditkan dengan jumlah yang sama, sehingga menambah saldonya. Dalam sistem ini, tidak ada hubungan antara uang yang masuk ke rekening Anda dan uang yang keluar dari rekening Anda, selain catatan transaksi.

Pada Bitcoin, cara kerjanya berbeda. Konsep akun tidak ada, dan unit moneter dikelola bukan melalui saldo, melainkan melalui UTXO. UTXO mewakili jumlah tertentu dari bitcoin yang belum dibelanjakan, sehingga membentuk sebuah "potongan bitcoin", yang bisa berukuran besar atau kecil. Sebagai contoh, sebuah UTXO dapat bernilai `500 BTC` atau hanya `700 SATS`.

**> Pengingat:** Satoshi, yang sering disingkat menjadi sat, adalah unit terkecil dari Bitcoin, sebanding dengan satu sen dalam mata uang fiat.

```plaintext
1 BTC = 100,000,000 SATS
```

Secara teoritis, UTXO dapat mewakili nilai berapa pun dalam bitcoin, mulai dari yang paling kecil hingga maksimum teoretis sekitar 21 juta BTC. Namun, secara logika tidak mungkin untuk memiliki semua 21 juta bitcoin, dan ada ambang batas ekonomi yang lebih rendah yang disebut "debu", di bawahnya UTXO dianggap tidak ekonomis untuk dibelanjakan.

**>Tahukah Anda, UTXO terbesar yang pernah dibuat di Bitcoin memiliki nilai `500.000 BTC`. Ini dibuat oleh platform MtGox selama operasi konsolidasi pada bulan November 2011: [29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf](https://mempool.space/fr/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)

### UTXO dan Ketentuan Pembelanjaan

UTXO adalah alat tukar dalam Bitcoin. Setiap transaksi melibatkan konsumsi UTXO sebagai input dan pembuatan UTXO baru sebagai output. Ketika sebuah transaksi dilakukan, UTXO yang digunakan sebagai input dianggap "dihabiskan", dan UTXO baru dibuat dan diberikan kepada penerima yang tertera pada output transaksi. Dengan demikian, UTXO hanya mewakili output transaksi yang tidak terpakai, dan dengan demikian merupakan jumlah bitcoin milik pengguna pada waktu tertentu.

![BTC204](assets/it/21/2.webp)

Semua UTXO dilindungi oleh skrip yang mendefinisikan kondisi di mana UTXO dapat digunakan. Untuk menggunakan UTXO, pengguna harus menunjukkan kepada jaringan bahwa dia memenuhi persyaratan yang ditetapkan oleh skrip yang melindungi UTXO tersebut. Umumnya, UTXO dilindungi oleh kunci publik (atau alamat penerima yang mewakili kunci publik ini). Untuk mengeluarkan UTXO yang terkait dengan kunci publik ini, pengguna harus membuktikan bahwa dia memegang kunci privat yang sesuai dengan memberikan tanda tangan digital yang dibuat dengan kunci ini. Inilah sebabnya mengapa dikatakan bahwa dompet bitcoin Anda tidak benar-benar berisi bitcoin, melainkan menyimpan kunci pribadi Anda, yang pada gilirannya memberikan Anda akses ke UTXO Anda dan, lebih jauh lagi, bitcoin yang diwakilinya.

![BTC204](assets/it/21/3.webp)

Karena konsep akun tidak ada dalam Bitcoin, saldo dompet hanyalah jumlah nilai dari semua UTXO yang dapat dibelanjakan. Sebagai contoh, jika dompet Bitcoin Anda dapat membelanjakan 4 UTXO berikut ini:

```plaintext
- 2 BTC
- 8 BTC
- 5 BTC
- 2 BTC
```

Total saldo dompet Anda adalah `17 BTC`.

![BTC204](assets/it/21/4.webp)

## Struktur transaksi Bitcoin

<chapterId>29d3aaab-de2e-4746-ab40-c9748898850c</chapterId>

### Input dan output dari sebuah transaksi

Transaksi bitcoin adalah transaksi yang dicatat di blockchain yang memungkinkan transfer kepemilikan bitcoin dari satu orang ke orang lain. Lebih khusus lagi, karena kita berada dalam model UTXO dan tidak ada akun, transaksi memenuhi kondisi pengeluaran yang melindungi satu atau lebih UTXO, mengkonsumsinya dan, secara ekuivalen, menciptakan UTXO baru yang dilengkapi dengan kondisi pengeluaran baru. Singkatnya, sebuah transaksi memindahkan bitcoin dari skrip yang terpenuhi ke skrip baru yang dimaksudkan untuk melindunginya.

![BTC204](assets/it/22/1.webp)

Setiap transaksi Bitcoin terdiri dari satu atau lebih input dan satu atau lebih output. Input adalah UTXO yang dikonsumsi oleh transaksi untuk menghasilkan output. Keluarannya adalah UTXO baru yang dapat digunakan sebagai input untuk transaksi selanjutnya.

![BTC204](assets/it/22/2.webp)

**> Tahukah Anda? Secara teoritis, sebuah transaksi bitcoin dapat memiliki jumlah input dan output yang tak terbatas. Hanya ukuran blok maksimum yang membatasi jumlah ini. Setiap input dalam transaksi bitcoin mengacu pada UTXO (Unspent Transaction Output) yang belum terpakai sebelumnya. Untuk menggunakan UTXO sebagai input, pemiliknya harus membuktikan bahwa ia adalah pemilik yang sah dengan memvalidasi skrip yang terkait dengannya, yaitu memenuhi syarat pengeluaran yang diberlakukan. Umumnya, hal ini melibatkan pemberian tanda tangan digital yang dihasilkan dengan kunci privat yang sesuai dengan kunci publik yang pada awalnya mengamankan UTXO tersebut. Skrip kemudian memverifikasi bahwa tanda tangan tersebut sesuai dengan kunci publik yang digunakan saat menerima dana.

Di sisi lain, setiap output menentukan jumlah bitcoin yang akan ditransfer, dan juga penerima. Yang terakhir ini ditentukan oleh skrip baru yang secara umum mengunci UTXO yang baru dibuat dengan alamat penerima atau kunci publik yang baru.

Agar transaksi dianggap sah menurut aturan konsensus, total output harus kurang dari atau sama dengan total input. Dengan kata lain, jumlah UTXO baru yang dihasilkan oleh transaksi tidak boleh melebihi jumlah UTXO yang dikonsumsi sebagai input. Prinsip ini logis: jika Anda hanya memiliki jumlah `500.000 SATS`, Anda tidak dapat melakukan pembelian `700.000 SATS`.

### Pertukaran dan Konsolidasi dalam Transaksi Bitcoin

Dengan demikian, tindakan transaksi Bitcoin pada UTXO dapat dibandingkan dengan peleburan koin emas. Faktanya, UTXO tidak dapat dibagi, tetapi hanya disatukan. Ini berarti bahwa seorang pengguna tidak dapat dengan mudah membagi UTXO yang mewakili sejumlah bitcoin menjadi beberapa UTXO yang lebih kecil. Ia harus menghabiskannya seluruhnya dalam sebuah transaksi untuk membuat satu atau beberapa UTXO baru dengan nilai yang berubah-ubah pada outputnya, yang harus lebih kecil atau sama dengan nilai awal.

Mekanisme ini mirip dengan koin emas. Bayangkan Anda memiliki koin 2 ons dan ingin melakukan pembayaran 1 ons, dengan asumsi penjual tidak dapat memberikan kembalian. Anda harus melebur koin Anda dan mencetak 2 koin baru dengan berat masing-masing 1 ons.

Pada bitcoin, operasinya serupa. Misalkan Alice memiliki UTXO sebesar `10.000 SATS` dan ingin membeli baguette seharga `4.000 SATS`. Alice akan melakukan transaksi dengan input 1 UTXO senilai `10.000 SATS` yang akan ia konsumsi seluruhnya, dan pada outputnya, ia akan membuat 2 UTXO senilai `4.000 SATS` dan `6.000 SATS`. UTXO senilai `4.000 SATS` akan dikirim ke tukang roti sebagai pembayaran untuk baguette, sedangkan UTXO senilai `6.000 SATS` akan kembali ke Alice sebagai kembalian. UTXO yang kembali ke pengirim awal transaksi inilah yang disebut sebagai "kembalian" dalam jargon Bitcoin.

Sekarang bayangkan Alice tidak memiliki satu UTXO dengan `10.000 SATS`, melainkan dua UTXO dengan masing-masing `3.000 SATS`. Dalam situasi ini, tidak ada satu pun UTXO yang cukup untuk memenuhi `4.000 SATS` untuk baguette. Oleh karena itu, Alice harus menggunakan kedua UTXO sebesar `3.000 SATS` sebagai input untuk transaksinya secara bersamaan. Dengan cara ini, total input akan mencapai `6.000 SATS`, yang memungkinkannya untuk membayar `4.000 SATS` kepada penjual roti. Metode ini, yang melibatkan pengelompokan beberapa UTXO ke dalam input transaksi, sering disebut sebagai `konsolidasi.

### Biaya Transaksi

Secara intuitif, orang mungkin berpikir bahwa biaya transaksi juga merupakan hasil dari sebuah transaksi. Namun pada kenyataannya, tidak demikian. Biaya transaksi mewakili selisih antara total input dan total output. Ini berarti bahwa setelah menggunakan sebagian dari nilai input untuk menutupi output yang diinginkan dalam sebuah transaksi, sejumlah input tetap tidak terpakai. Jumlah yang tersisa ini merupakan biaya transaksi.

```plaintext
Commissioni = input totali - output totali
```

Mari kita kembali ke contoh Alice yang memiliki UTXO sebesar `10.000 SATS` dan ingin membeli baguette seharga `4.000 SATS`. Alice membuat transaksi dengan UTXO-nya sebesar `10.000 SATS` sebagai input. Dia kemudian menghasilkan output sebesar `4.000 SATS` yang ditujukan untuk tukang roti untuk membayar baguette. Untuk mendorong para penambang agar memasukkan transaksinya ke dalam blok, Alice memberikan `200 SATS` sebagai komisi. Dengan demikian, dia menciptakan output kedua, sisanya, yang akan dikembalikan kepadanya, sebesar `5.800 SATS`.

Dengan menerapkan rumus komisi, kita sebenarnya melihat bahwa ada `200 SATS` yang tersisa untuk para penambang:

```plaintext
Commissioni = input totali - output totali
Spese = 10.000 - (4.000 + 5.800)
Spese = 10.000 - 9.800
Spese = 200
```

Ketika seorang penambang berhasil memvalidasi sebuah blok, mereka berhak untuk mengumpulkan biaya ini untuk semua transaksi yang termasuk dalam blok mereka, melalui apa yang dikenal sebagai transaksi "coinbase".

### Penciptaan UTXO pada Bitcoin

Jika Anda telah mengikuti paragraf sebelumnya dengan seksama, Anda sekarang tahu bahwa UTXO hanya dapat dibuat dengan mengkonsumsi UTXO lain yang sudah ada. Dengan demikian, koin-koin dalam Bitcoin membentuk sebuah rantai yang berkesinambungan. Namun, Anda mungkin bertanya-tanya bagaimana UTXO pertama muncul dalam rantai ini. Hal ini menimbulkan masalah yang mirip dengan masalah ayam dan telur: dari mana asal UTXO yang pertama kali muncul?

Jawabannya terletak pada **transaksi coinbase**.

Coinbase adalah jenis transaksi Bitcoin yang spesifik, unik untuk setiap blok dan selalu menjadi yang pertama. Hal ini memungkinkan penambang yang telah menemukan bukti kerja yang valid untuk menerima reward blok mereka. Hadiah ini terdiri dari dua elemen: **Hibah blok dan biaya transaksi yang telah dibahas di bagian sebelumnya.

Fitur unik dari transaksi coinbase adalah bahwa transaksi ini merupakan satu-satunya yang dapat menciptakan bitcoin dari nol, tanpa perlu mengkonsumsi input untuk menghasilkan outputnya. Bitcoin yang baru dibuat ini merupakan apa yang bisa disebut sebagai "UTXO asli"

Bitcoin dari block grant adalah BTC baru yang dibuat begitu saja, mengikuti jadwal penerbitan yang telah ditentukan dalam aturan konsensus. Hibah blok dibagi dua setiap 210.000 blok, sekitar setiap empat tahun, dalam proses yang disebut "halving" Awalnya, 50 bitcoin dibuat per subsidi, tetapi jumlah ini secara bertahap menurun; saat ini, 3.125 bitcoin per blok.

Sedangkan untuk bagian biaya transaksi, meskipun mewakili BTC yang baru dibuat, biaya tersebut tidak boleh melebihi selisih antara total input dan output semua transaksi dalam satu blok. Kita telah melihat sebelumnya bahwa biaya ini mewakili bagian input yang tidak digunakan dalam output transaksi. Bagian ini secara teknis "hilang" selama transaksi, dan penambang memiliki hak untuk membuat ulang nilai ini dalam bentuk satu atau lebih UTXO baru. Oleh karena itu, ini adalah transfer nilai dari pengirim transaksi ke penambang yang menambahkannya ke blockchain.

**> Tahukah Anda?** Bitcoin yang dihasilkan dari transaksi coinbase tunduk pada periode pematangan 100 blok di mana mereka tidak dapat dibelanjakan oleh penambang. Aturan ini dimaksudkan untuk menghindari komplikasi yang terkait dengan penggunaan bitcoin yang baru dibuat pada sebuah rantai yang nantinya dapat menjadi usang.

### Implikasi dari model UTXO

Pertama, model UTXO secara langsung mempengaruhi biaya transaksi dalam Bitcoin. Karena kapasitas setiap blok terbatas, para penambang memilih transaksi yang menawarkan biaya terbaik dibandingkan dengan ruang yang akan mereka tempati di blok tersebut. Faktanya, semakin banyak UTXO yang disertakan dalam sebuah transaksi sebagai input dan output, maka semakin berat transaksi tersebut dan oleh karena itu membutuhkan biaya yang lebih tinggi. Ini adalah salah satu alasan mengapa sering kali ada upaya untuk mengurangi jumlah UTXO dalam portofolio kita, yang juga dapat memengaruhi privasi, sebuah topik yang akan kita bahas secara mendetail di bagian ketiga pelatihan ini.

Selanjutnya, seperti yang telah disebutkan di bagian sebelumnya, koin-koin pada Bitcoin pada dasarnya adalah rantai UTXO. Setiap transaksi menciptakan sebuah hubungan antara UTXO masa lalu dan UTXO masa depan. Dengan demikian, UTXO memungkinkan pelacakan eksplisit terhadap jalur bitcoin dari pembuatannya hingga penggunaannya saat ini. Transparansi ini dapat dilihat secara positif, karena memungkinkan setiap pengguna untuk memastikan keaslian bitcoin yang diterima. Akan tetapi, prinsip ketertelusuran dan kemampuan untuk diaudit inilah yang menjadi dasar dari analisis rantai, sebuah praktik yang dirancang untuk mengorbankan privasi Anda. Kita akan mempelajari praktik ini secara mendalam di bagian kedua pelatihan.

## Model privasi Bitcoin

<chapterId>769d8963-3ed5-4094-b21d-9203c7d9e465</chapterId>

### Mata uang: Keaslian, Integritas, dan Pembelanjaan Ganda

Salah satu fungsi mata uang adalah untuk memecahkan masalah keinginan yang bertepatan. Dalam sistem berbasis barter, melakukan pertukaran tidak hanya membutuhkan seseorang yang menawarkan barang yang memenuhi kebutuhan saya, tetapi juga menyediakan barang yang nilainya setara dengan barang yang memenuhi kebutuhan mereka. Menemukan keseimbangan ini terbukti rumit.

Inilah sebabnya mengapa mata uang digunakan, yang memungkinkan transfer nilai dalam ruang dan waktu.

Agar mata uang dapat mengatasi masalah ini, sangat penting bagi pihak yang menyediakan barang atau jasa untuk yakin akan kemampuannya untuk membelanjakan uang tersebut di kemudian hari. Oleh karena itu, setiap individu yang rasional yang ingin menerima suatu bentuk mata uang, baik digital maupun fisik, akan memastikan bahwa mata uang tersebut memenuhi dua kriteria dasar:


- Koin harus utuh dan asli;**- **dan tidak boleh digunakan dua kali.**

Ketika menggunakan mata uang fisik, karakteristik pertama adalah yang paling kompleks untuk ditegaskan. Selama periode sejarah yang berbeda, integritas koin logam sering dikompromikan oleh praktik-praktik seperti pemotongan atau pelubangan. Contohnya, pada zaman Romawi kuno, masyarakat biasa mengikis tepi koin emas untuk mengambil sebagian logam mulia, sekaligus mengawetkannya untuk transaksi di masa depan. Dengan demikian, nilai intrinsik koin berkurang, tetapi nilai nominalnya tetap sama. Ini adalah alasan utama mengapa garis-garis kemudian diciptakan di tepi koin.

Keaslian juga merupakan karakteristik yang sulit untuk diverifikasi dengan cara moneter fisik. Saat ini, teknik untuk memerangi pemalsuan semakin kompleks, sehingga memaksa pedagang untuk berinvestasi dalam sistem verifikasi yang mahal.

Di sisi lain, karena sifatnya, pembayaran ganda tidak menjadi masalah untuk mata uang fisik. Jika saya memberi Anda uang kertas €10, uang tersebut akan berpindah dari tangan saya ke tangan Anda, tentu saja tidak termasuk kemungkinan untuk membelanjakan unit moneter yang sama beberapa kali. Singkatnya, saya tidak akan bisa membelanjakan uang kertas €10 itu lagi.

Untuk mata uang digital, kesulitannya berbeda. Memastikan keaslian dan integritas sebuah koin seringkali lebih mudah. Seperti yang kita lihat pada bagian sebelumnya, model UTXO Bitcoin memungkinkan sebuah koin untuk ditelusuri kembali ke asalnya, sehingga memverifikasi bahwa koin tersebut memang dibuat sesuai dengan aturan konsensus oleh penambang.

Namun, memastikan tidak adanya pembayaran ganda lebih rumit, karena barang digital apa pun pada dasarnya adalah informasi. Tidak seperti barang fisik, informasi tidak terbagi selama pertukaran, tetapi menyebar dengan cara menggandakan. Sebagai contoh, jika saya mengirimi Anda sebuah dokumen melalui email, dokumen tersebut akan digandakan. Anda tidak dapat memverifikasi dengan pasti bahwa saya telah menghapus dokumen aslinya.

### Mencegah Pembayaran Ganda pada Bitcoin

Satu-satunya cara untuk menghindari duplikasi aset digital adalah dengan mengetahui semua pertukaran di dalam sistem. Dengan begitu, Anda dapat mengetahui siapa yang memiliki apa dan memperbarui kepemilikan setiap orang berdasarkan transaksi yang dilakukan. Inilah yang dilakukan, misalnya, dengan uang kertas dalam sistem perbankan. Ketika Anda membayar €10 ke pedagang dengan kartu kredit, bank mencatat pertukaran ini dan memperbarui buku besar.

Pada Bitcoin, pencegahan pembayaran ganda dilakukan dengan cara yang sama. Tujuannya adalah untuk memastikan tidak adanya transaksi yang telah menggunakan koin-koin tersebut. Jika koin-koin tersebut tidak pernah digunakan, maka dapat dipastikan tidak akan terjadi pembayaran ganda. Prinsip ini dijelaskan oleh Satoshi Nakamoto dalam White Paper dengan kalimat yang terkenal ini:

**"Satu-satunya cara untuk mengonfirmasi tidak adanya transaksi adalah dengan mengetahui semua transaksi." ** "Satu-satunya cara untuk mengonfirmasi tidak adanya transaksi adalah dengan mengetahui semua transaksi

Namun, tidak seperti model perbankan, tidak ada keinginan untuk mempercayai entitas pusat pada Bitcoin. Penting bagi semua pengguna untuk dapat mengonfirmasi tidak adanya pembayaran ganda, tanpa bergantung pada pihak ketiga. Oleh karena itu, setiap orang perlu mengetahui semua transaksi Bitcoin. Inilah mengapa transaksi Bitcoin disiarkan secara publik di semua node jaringan dan dicatat dalam teks biasa di blockchain.

Penyebaran informasi kepada publik inilah yang memperumit perlindungan privasi pada Bitcoin. Dalam sistem perbankan tradisional, secara teori, hanya lembaga keuangan yang mengetahui transaksi yang dilakukan. Di sisi lain, pada Bitcoin, semua pengguna diberitahu tentang semua transaksi, melalui node masing-masing.

### Model privasi: sistem perbankan vs. Bitcoin

Dalam sistem tradisional, rekening bank Anda ditautkan dengan identitas Anda. Bank dapat mengetahui nasabah mana yang memiliki rekening bank mana dan transaksi apa saja yang terkait dengannya. Namun, aliran informasi ini terputus antara bank dan domain publik. Dengan kata lain, tidak mungkin untuk mengetahui saldo dan transaksi rekening bank milik orang lain. Hanya bank yang memiliki akses ke informasi ini.

Sebagai contoh, bankir Anda mengetahui bahwa Anda membeli baguette setiap pagi di toko roti terdekat, tetapi tetangga Anda tidak mengetahui transaksi ini. Dengan demikian, arus informasi dapat diakses oleh pihak-pihak yang berkepentingan, terutama bank, tetapi tetap tidak dapat diakses oleh pihak luar.

Karena kendala penyebaran transaksi ke publik yang telah kita lihat pada bagian sebelumnya, model privasi Bitcoin tidak dapat mengikuti model sistem perbankan. Dalam kasus Bitcoin, karena aliran informasi tidak dapat diinterupsi antara transaksi dan domain publik, **model privasi didasarkan pada pemisahan antara identitas pengguna dan transaksi** itu sendiri.

Sebagai contoh, jika Anda membeli baguette dari tukang roti dengan membayar menggunakan BTC, tetangga Anda, yang memiliki node lengkapnya sendiri, dapat melihat transaksi Anda, seperti halnya dia dapat melihat semua transaksi lain dalam sistem. Namun, jika prinsip privasi dihormati, mereka seharusnya tidak dapat menghubungkan transaksi spesifik ini dengan identitas Anda.

Namun karena transaksi Bitcoin bersifat publik, maka masih memungkinkan untuk membuat hubungan di antara mereka untuk menyimpulkan informasi mengenai pihak-pihak yang terlibat. Kegiatan ini bahkan merupakan spesialisasi tersendiri yang disebut "analisis rantai." Di bagian selanjutnya dari kursus ini, saya mengundang Anda untuk menjelajahi dasar-dasar analisis rantai untuk memahami bagaimana bitcoin Anda dilacak dan mengetahui cara untuk melindungi diri Anda dengan lebih baik.

# Memahami Analisis Rantai dan Cara Melindungi Diri Anda

<partId>4739371e-9fef-45b0-bcaa-b7a4df6b4470</partId>

## Apa itu Analisis Rantai pada Bitcoin?

<chapterId>7d198ba6-4af2-4f24-86cb-3c79cb25627e</chapterId>

### Definisi dan Operasi

Analisis rantai adalah sebuah praktik yang mencakup semua metode yang digunakan untuk melacak aliran bitcoin di blockchain. Umumnya, analisis rantai didasarkan pada pengamatan fitur-fitur pada sampel transaksi sebelumnya. Kemudian, hal ini melibatkan identifikasi fitur-fitur yang sama dalam transaksi yang ingin dianalisis dan menyimpulkan interpretasi yang masuk akal. Metode pemecahan masalah dari pendekatan praktis untuk menemukan solusi yang cukup baik inilah yang disebut dengan "heuristik"

Untuk menyederhanakan, analisis rantai dilakukan dalam tiga langkah utama:

1. **Mengamati blockchain;**

2. **Identifikasi karakteristik yang diketahui;**

3. **Mendeduksi asumsi.**

Analisis blockchain dapat dilakukan oleh siapa saja. Cukup dengan memiliki akses ke informasi publik dari blockchain melalui sebuah node penuh untuk mengamati pergerakan transaksi dan membuat asumsi. Ada juga alat gratis yang memfasilitasi analisis ini, seperti situs web [OXT.me] (https://oxt.me/), yang akan kita bahas secara rinci dalam dua bab terakhir dari bagian ini. Akan tetapi, risiko privasi yang utama berasal dari perusahaan yang berspesialisasi dalam analisis rantai. Perusahaan-perusahaan ini telah membawa analisis rantai ke skala industri dan menjual layanan mereka ke lembaga keuangan atau pemerintah. Di antara perusahaan-perusahaan ini, Chainalysis mungkin yang paling terkenal.

### Tujuan Analisis Rantai

Salah satu tujuan analisis rantai adalah untuk mengelompokkan berbagai aktivitas di Bitcoin untuk menentukan keunikan pengguna yang melakukannya. Selanjutnya, akan memungkinkan untuk mencoba menghubungkan kumpulan aktivitas ini dengan identitas yang sebenarnya.

Ingatlah kembali bab sebelumnya. Saya telah menjelaskan mengapa model privasi Bitcoin pada awalnya didasarkan pada pemisahan identitas pengguna dari transaksi mereka. Oleh karena itu, akan sangat menggoda untuk berpikir bahwa analisis on-chain tidak berguna, karena meskipun Anda dapat mengelompokkan aktivitas on-chain, aktivitas tersebut tidak dapat dikaitkan dengan identitas yang sebenarnya.

Secara teoritis, pernyataan ini akurat. Pada bagian pertama dari pelatihan ini, kita telah melihat bahwa pasangan kunci kriptografi digunakan untuk menetapkan kondisi pada UTXO. Pada dasarnya, pasangan kunci ini tidak mengungkapkan informasi apa pun tentang identitas pemegangnya. Jadi, meskipun kita dapat mengelompokkan aktivitas yang terkait dengan pasangan kunci yang berbeda, hal ini tidak memberi tahu kita apa pun tentang entitas di balik aktivitas tersebut.

Akan tetapi, kenyataan praktisnya jauh lebih kompleks. Ada banyak sekali perilaku yang berisiko menghubungkan identitas asli dengan aktivitas onchain. Dalam analisis, ini disebut titik masuk, dan ada banyak.

Yang paling umum, tentu saja, adalah KYC (_Know Your Customer_). Jika Anda menarik bitcoin Anda dari platform yang teregulasi ke salah satu alamat penerima pribadi Anda, maka beberapa orang dapat menautkan identitas Anda ke alamat ini. Secara umum, titik masuk dapat berupa segala bentuk interaksi antara kehidupan nyata Anda dan transaksi bitcoin. Sebagai contoh, jika Anda memposting alamat penerima di jejaring sosial Anda, ini bisa menjadi titik masuk untuk analisis. Jika Anda melakukan pembayaran bitcoin kepada penjual roti, mereka dapat mengaitkan wajah Anda (yang merupakan bagian dari identitas Anda) dengan alamat Bitcoin.

Titik masuk ini hampir tidak dapat dihindari dalam penggunaan Bitcoin. Meskipun Anda bisa mencoba membatasi cakupannya, mereka akan tetap ada. Oleh karena itu, sangat penting untuk menggabungkan metode-metode yang bertujuan untuk menjaga privasi Anda. Meskipun menjaga pemisahan antara identitas asli dan transaksi Anda merupakan pendekatan yang menarik, namun hal ini masih belum cukup untuk saat ini. Memang, jika semua aktivitas onchain Anda dapat dikelompokkan bersama, maka titik masuk sekecil apa pun kemungkinan akan membahayakan satu lapisan privasi yang telah Anda buat.

### Mempertahankan Diri dari Analisis Rantai

Oleh karena itu, kita juga harus mampu mengatasi analisis blockchain dalam penggunaan Bitcoin. Dengan melakukan hal ini, kita dapat meminimalisir agregasi aktivitas kita dan membatasi dampak dari sebuah titik masuk terhadap privasi kita.

Faktanya, untuk melawan analisis blockchain dengan lebih baik, pendekatan apa yang lebih baik daripada membiasakan diri Anda dengan metode yang digunakan dalam analisis blockchain? Jika Anda ingin mengetahui cara meningkatkan privasi Anda di Bitcoin, Anda perlu memahami metode-metode ini. Ini akan memungkinkan Anda untuk lebih memahami teknik-teknik seperti coinjoin atau payjoin (teknik yang akan kita pelajari di bagian akhir pelatihan ini), dan mengurangi kesalahan yang mungkin Anda lakukan.

Dalam konteks ini, kita dapat membuat analogi dengan kriptografi dan kriptanalisis. Seorang kriptografer yang baik adalah seorang kriptanalis yang baik. Untuk merancang sebuah algoritma kriptografi baru, Anda perlu mengetahui serangan apa yang akan dihadapi dan juga mempelajari mengapa algoritma sebelumnya telah diretas. Prinsip yang sama berlaku untuk privasi pada Bitcoin. Memahami metode analisis blockchain adalah kunci untuk melindungi diri Anda. Itulah mengapa saya mengusulkan seluruh bagian tentang analisis blockchain dalam pelatihan ini.

https://planb.network/tutorials/privacy/on-chain/coinjoin-samourai-wallet-e566803d-ab3f-4d98-9136-5462009262ef
https://planb.network/fr/tutorials/privacy/on-chain/payjoin-848b6a23-deb2-4c5f-a27e-93e2f842140f
### Metode analisis blockchain

Penting untuk dipahami bahwa analisis blockchain bukanlah sebuah ilmu pasti. Analisis ini bergantung pada heuristik yang berasal dari pengamatan sebelumnya atau interpretasi logis. Aturan-aturan ini memungkinkan hasil yang cukup dapat diandalkan, tetapi tidak pernah dengan ketepatan yang mutlak. Dengan kata lain, **analisis blockchain selalu melibatkan dimensi probabilitas dalam kesimpulan yang dikeluarkan**. Sebagai contoh, seseorang dapat memperkirakan dengan kepastian yang lebih besar atau lebih kecil bahwa dua alamat adalah milik entitas yang sama, akan tetapi kepastian total akan selalu berada di luar jangkauan.

Tujuan utama dari analisis blockchain terletak pada agregasi berbagai heuristik untuk meminimalisir risiko kesalahan. Dalam artian, ini adalah akumulasi bukti yang memungkinkan kita untuk lebih dekat dengan kenyataan.

Heuristik terkenal ini dapat dikelompokkan ke dalam beberapa kategori yang akan kita bahas bersama:


- Model transaksi (atau model transaksi);**
- Heuristik internal dari transaksi;**
- Heuristik di luar transaksi.**

### Satoshi Nakamoto dan analisis blockchain

Perlu dicatat bahwa dua heuristik pertama untuk analisis rantai ditemukan oleh Satoshi Nakamoto sendiri. Dia membahasnya di Bagian 10 dari Buku Putih Bitcoin. Ini adalah:


- common Input Property Heuristics (CIOH);
- dan penggunaan ulang alamat.

![BTC204](assets/fr/031.webp)

Sumber: S. Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System," https://bitcoin.org/bitcoin.pdf, 2009.

Pada bab-bab berikutnya, kita akan mengeksplorasi tentang hal ini, tetapi sudah menarik untuk dicatat bahwa kedua heuristik ini masih mempertahankan keunggulannya dalam analisis rantai saat ini.

## Templat Transaksi

<chapterId>d365a101-2d37-46a5-bfb9-3c51e37bf96b</chapterId>

Model transaksi adalah sebuah pola umum atau struktur dari sebuah transaksi yang dapat ditemukan di blockchain, yang interpretasinya sudah diketahui. Ketika kita mempelajari pola, kita akan fokus pada satu transaksi yang akan kita analisis pada tingkat tinggi.

Dengan kata lain, kita hanya akan melihat jumlah UTXO di input dan jumlah UTXO di output, tanpa memikirkan detail yang lebih spesifik atau lingkungan transaksi. Dari pola yang diamati, kita akan dapat menginterpretasikan sifat transaksi. Kita kemudian akan mencari fitur-fitur dalam strukturnya dan menyimpulkan interpretasi.

![BTC204](assets/it/32/01.webp)

Pada bagian ini, kita akan bersama-sama menemukan pola transaksi utama yang dapat ditemukan dalam analisis rantai, dan untuk setiap pola, saya akan memberi Anda kemungkinan interpretasi dari struktur ini, bersama dengan contoh konkret.

### Pengiriman Sederhana (atau Pembayaran Sederhana)

Mari kita mulai dengan model yang sangat populer, karena model ini adalah model yang muncul di sebagian besar pembayaran bitcoin. Model pembayaran sederhana ditandai dengan mengonsumsi satu atau lebih UTXO di input dan menghasilkan 2 UTXO di output. Oleh karena itu, model ini akan muncul seperti ini:

![BTC204](assets/it/32/02.webp)

Ketika kita mengidentifikasi struktur transaksi ini pada blockchain, kita sudah dapat menarik sebuah interpretasi. Seperti namanya, pola ini menunjukkan bahwa kita berurusan dengan transaksi kirim atau bayar. Pengguna telah menggunakan UTXO mereka sebagai input untuk menghasilkan output berupa UTXO pembayaran dan UTXO kembalian (uang yang dikembalikan ke pengguna yang sama).

Dengan demikian, kita tahu bahwa pengguna yang diamati mungkin tidak lagi memiliki salah satu dari dua output UTXO (yang pembayaran), tetapi masih memiliki UTXO yang lain (yang kembalian).

Saat ini, tidak mungkin bagi kita untuk menentukan output mana yang mewakili UTXO yang mana, karena ini bukan tujuan dari studi model. Kita akan mencapai tujuan ini dengan mengandalkan heuristik yang akan kita pelajari di bagian berikut. Pada tahap ini, tujuan kita terbatas pada mengidentifikasi sifat transaksi yang dimaksud, yang dalam hal ini adalah pengiriman sederhana.

Sebagai contoh, berikut ini adalah transaksi Bitcoin yang mengadopsi model pengiriman sederhana:

```plaintext
b6cc79f45fd2d7669ff94db5cb14c45f1f879ea0ba4c6e3d16ad53a18c34b769
```

![BTC204](assets/it/32/03.webp)

Fonte: [Mempool.space](https://mempool.space/fr/tx/b6cc79f45fd2d7669ff94db5cb14c45f1f879ea0ba4c6e3d16ad53a18c34b769)

Setelah contoh pertama ini, Anda seharusnya memiliki pemahaman yang lebih baik tentang apa yang dimaksud dengan mempelajari "model transaksi" Kita mempelajari sebuah transaksi dengan hanya berfokus pada strukturnya, tanpa memperhitungkan lingkungan atau detail spesifik transaksi. Kita hanya melihatnya secara global pada langkah pertama ini.

Sekarang, setelah Anda memahami apa itu model, mari kita beralih ke model lain yang ada.

### Menyapu

Model kedua ini dicirikan dengan mengkonsumsi satu UTXO sebagai input dan menghasilkan satu UTXO sebagai output.

![BTC204](assets/it/32/04.webp)

Interpretasi dari model ini adalah bahwa kita berurusan dengan transfer otomatis. Pengguna telah mentransfer bitcoin-nya ke dirinya sendiri, ke alamat lain yang dimilikinya. Karena tidak ada sisa dalam transaksi, maka sangat kecil kemungkinannya bahwa kita berurusan dengan pembayaran. Faktanya, ketika pembayaran dilakukan, hampir tidak mungkin bagi pembayar untuk memiliki UTXO yang sama persis dengan jumlah yang diminta oleh penjual, ditambah dengan biaya transaksi. Oleh karena itu, pembayar dipaksa untuk menghasilkan output sisa.

Oleh karena itu, kita tahu bahwa pengguna yang diamati mungkin masih memiliki UTXO ini. Dalam konteks analisis rantai, jika kita tahu bahwa UTXO yang digunakan sebagai input dalam transaksi adalah milik Alice, kita dapat mengasumsikan bahwa UTXO yang ada di output juga merupakan miliknya. Yang akan menjadi menarik nantinya adalah menemukan heuristik internal pada transaksi yang dapat memperkuat asumsi ini (kita akan mempelajari heuristik ini di Bagian 3.3).

Sebagai contoh, berikut ini adalah transaksi Bitcoin yang mengadopsi model sweeping:

```plaintext
35f1072a0fda5ae106efb4fda871ab40e1f8023c6c47f396441ad4b995ea693d
```

![BTC204](assets/it/32/05.webp)

Sumber:[Mempool.space](https://mempool.space/fr/tx/35f1072a0fda5ae106efb4fda871ab40e1f8023c6c47f396441ad4b995ea693d) Akan tetapi, pola seperti ini juga dapat mengungkapkan sebuah transfer mandiri ke sebuah akun platform bursa mata uang digital. Dengan mempelajari alamat yang diketahui dan konteks transaksi, kita dapat mengetahui apakah ini merupakan konsolidasi ke dompet penyimpanan mandiri atau penarikan ke platform. Memang, alamat platform bursa sering kali mudah diidentifikasi.

Mari kita kembali ke contoh Alice: jika konsolidasi mengarah ke alamat platform yang diketahui (seperti Binance, misalnya), ini dapat berarti bahwa bitcoin ditransfer keluar dari kepemilikan langsung Alice, mungkin dengan tujuan untuk menjual atau menyimpannya di platform ini. Di sisi lain, jika alamat tujuan tidak diketahui, masuk akal untuk mengasumsikan bahwa itu hanyalah dompet lain yang masih milik Alice. Tetapi jenis penelitian ini lebih masuk ke dalam kategori heuristik dan bukan studi pola.

### Konsolidasi

Model ini dicirikan dengan mengkonsumsi beberapa UTXO sebagai input dan menghasilkan satu UTXO sebagai output.

![BTC204](assets/it/32/06.webp)

Interpretasi dari pola ini adalah bahwa kita sedang berada di tengah-tengah konsolidasi. Ini adalah praktik umum di kalangan pengguna Bitcoin untuk menggabungkan beberapa UTXO untuk mengantisipasi kemungkinan kenaikan biaya transaksi. Dengan melakukan operasi ini selama periode ketika biaya rendah, Anda dapat menghemat biaya di masa mendatang. Kita akan membahas lebih lanjut mengenai praktik ini di Bab 4.3.

Kita dapat menyimpulkan bahwa pengguna di balik model transaksi ini mungkin memiliki semua UTXO input dan masih memiliki UTXO output. Ini jelas merupakan transfer otomatis.

Sama seperti konsolidasi, jenis pola ini juga dapat mengungkapkan transfer mandiri ke akun platform bursa. Dengan mempelajari alamat yang diketahui dan konteks transaksi, kita dapat mengetahui apakah ini merupakan konsolidasi ke dompet penyimpanan mandiri atau penarikan ke platform.

Sebagai contoh, berikut ini adalah transaksi Bitcoin yang mengadopsi skema konsolidasi:

```plaintext
77c16914211e237a9bd51a7ce0b1a7368631caed515fe51b081d220590589e94
```

![BTC204](assets/it/32/07.webp)

Fonte: [Mempool.space](https://mempool.space/fr/tx/77c16914211e237a9bd51a7ce0b1a7368631caed515fe51b081d220590589e94)

Dalam konteks analisis rantai, model ini dapat mengungkapkan banyak informasi. Sebagai contoh, jika kita tahu bahwa salah satu input adalah milik Alice, kita bisa mengasumsikan bahwa semua input dan output lain dari transaksi ini adalah miliknya. Asumsi ini kemudian memungkinkan kita untuk menelusuri kembali rantai transaksi sebelumnya untuk menemukan dan menganalisis transaksi lain yang mungkin terkait dengan Alice.

![BTC204](assets/it/32/08.webp)

### Pengeluaran yang dikelompokkan

Model ini dicirikan oleh konsumsi beberapa UTXO sebagai input (seringkali hanya satu) dan produksi banyak UTXO sebagai output.

![BTC204](assets/it/32/09.webp)

Interpretasi dari pola ini adalah bahwa kita berurusan dengan pembelanjaan yang dibundel. Ini adalah praktik yang kemungkinan besar mengungkapkan aktivitas ekonomi yang signifikan, seperti platform pertukaran. Pengeluaran yang dikelompokkan memungkinkan entitas-entitas ini untuk menghemat biaya dengan mengkonsolidasikan pengeluaran mereka ke dalam satu transaksi.

Kita dapat menyimpulkan dari model ini bahwa input UTXO berasal dari perusahaan dengan aktivitas ekonomi yang signifikan dan output UTXO akan menyebar. Sebagian besar akan menjadi milik pelanggan perusahaan yang menarik bitcoin dari platform. Sebagian lagi mungkin masuk ke perusahaan mitra. Akhirnya, pasti akan ada satu atau lebih bursa yang kembali ke perusahaan penerbit.

Sebagai contoh, berikut ini adalah transaksi Bitcoin yang mengadopsi model pembelanjaan yang dikelompokkan (mungkin, ini adalah transaksi yang dikeluarkan oleh platform Bybit):

```plaintext
8a7288758b6e5d550897beedd13c70bcbaba8709af01a7dbcc1f574b89176b43
```

![BTC204](assets/it/32/10.webp)

Fonte: [Mempool.space](https://mempool.space/fr/tx/8a7288758b6e5d550897beedd13c70bcbaba8709af01a7dbcc1f574b89176b43)

### Transaksi Khusus Protokol

Di antara pola-pola transaksi, kita juga dapat mengidentifikasi pola-pola yang menunjukkan penggunaan protokol tertentu. Sebagai contoh, Whirlpool coinjoins (yang akan kita bahas pada Bagian 5) akan memiliki struktur yang mudah diidentifikasi yang memungkinkan mereka untuk dibedakan dari transaksi lain yang lebih tradisional.

![BTC204](assets/it/32/11.webp)

Analisis pola ini menunjukkan bahwa kita mungkin berurusan dengan transaksi kolaboratif. Kita juga dapat mengamati coinjoin. Jika hipotesis terakhir terbukti akurat, maka jumlah output dapat memberikan perkiraan kasar jumlah peserta coinjoin.

Sebagai contoh, berikut ini adalah transaksi Bitcoin yang mengadopsi model jenis transaksi kolaboratif coinjoin:

```plaintext
00601af905bede31086d9b1b79ee8399bd60c97e9c5bba197bdebeee028b9bea
```

![BTC204](assets/it/32/12.webp)

Fonte: [Mempool.space](https://mempool.space/fr/tx/00601af905bede31086d9b1b79ee8399bd60c97e9c5bba197bdebeee028b9bea)

Ada banyak protokol lain yang memiliki struktur spesifiknya sendiri. Dengan demikian, kita dapat membedakan transaksi jenis Wabisabi, transaksi Stamps, atau bahkan Rune, misalnya.

Berkat model-model transaksi ini, kita sudah dapat menginterpretasikan sejumlah informasi tentang transaksi tertentu. Namun, struktur transaksi bukanlah satu-satunya sumber informasi untuk analisis. Kita juga dapat mempelajari detailnya. Detail-detail ini, yang bersifat internal dari sebuah transaksi, adalah apa yang saya sebut sebagai "heuristik internal", dan kita akan mempelajarinya di bab berikut.

## Heuristik Internal

<chapterId>c54b5abe-872f-40f4-a0d0-c59faff228ba</chapterId>

Heuristik internal adalah fitur spesifik yang diidentifikasi dalam transaksi itu sendiri, tanpa perlu memeriksa lingkungannya, yang memungkinkan kita untuk membuat kesimpulan. Tidak seperti model yang berfokus pada keseluruhan struktur transaksi pada tingkat yang tinggi, heuristik internal didasarkan pada sekumpulan data yang dapat diekstrak. Ini termasuk:


- Jumlah UTXO yang berbeda yang masuk dan keluar;
- Segala sesuatu tentang skrip: menerima alamat, versi, waktu penguncian, dll.

Umumnya, jenis heuristik ini akan memungkinkan kita untuk mengidentifikasi sisa dalam transaksi tertentu. Dengan demikian, kita dapat terus melacak sebuah entitas di beberapa transaksi. Faktanya, jika kita mengidentifikasi UTXO milik pengguna yang ingin kita lacak, sangat penting untuk menentukan, ketika mereka melakukan transaksi, output mana yang telah ditransfer ke pengguna lain dan output mana yang mewakili sisanya, sehingga tetap dalam kepemilikan mereka.

![BTC204](assets/it/33/01.webp)

Saya ingatkan lagi bahwa heuristik ini sama sekali tidak akurat. Jika digunakan secara terpisah, mereka hanya memungkinkan kita untuk mengidentifikasi skenario yang masuk akal. Akumulasi dari heuristik yang berbeda inilah yang membantu mengurangi ketidakpastian, tanpa menghilangkannya sepenuhnya.

### Kesamaan Internal

Heuristik ini melibatkan mempelajari kesamaan antara input dan output dari transaksi yang sama. Jika kita mengamati fitur yang sama pada input dan hanya pada salah satu output dari transaksi, maka kemungkinan besar output ini merupakan output lainnya.

Fitur yang paling jelas adalah penggunaan ulang alamat penerima dalam transaksi yang sama.

![BTC204](assets/it/33/02.webp)

Heuristik ini hanya menyisakan sedikit ruang untuk keraguan. Kecuali jika kunci pribadi seseorang telah diretas, alamat penerima yang sama tidak dapat dihindari akan mengungkapkan aktivitas dari satu pengguna. Interpretasi yang selanjutnya adalah bahwa sisa transaksi adalah output dengan alamat yang sama dengan input. Hal ini memungkinkan pelacakan individu secara terus menerus berdasarkan pada sisa transaksi ini.

Sebagai contoh, berikut ini adalah sebuah transaksi di mana heuristik ini dapat diterapkan secara wajar:

```plaintext
54364146665bfc453a55eae4bfb8fdf7c721d02cb96aadc480c8b16bdeb8d6d0
```

![BTC204](assets/fr/046.webp)

Fonte: [Mempool.space](https://mempool.space/tx/54364146665bfc453a55eae4bfb8fdf7c721d02cb96aadc480c8b16bdeb8d6d0)

Kemiripan antara input dan output ini tidak berhenti pada penggunaan ulang alamat. Kesamaan dalam penggunaan skrip dapat memungkinkan penerapan heuristik. Sebagai contoh, terkadang versi yang sama dapat diamati antara input dan salah satu output transaksi.

![BTC204](assets/it/33/04.webp)

Pada diagram ini, kita dapat melihat bahwa input No. 0 membuka skrip P2WPKH (SegWit V0 yang dimulai dengan `bc1q`). Keluaran No. 0 menggunakan jenis skrip yang sama. Akan tetapi, output #1 menggunakan skrip P2TR (SegWit V1 yang dimulai dengan `bc1p`). Interpretasi dari fitur ini adalah kemungkinan alamat dengan versi yang sama dengan input adalah alamat yang lain. Oleh karena itu, alamat tersebut masih milik pengguna yang sama.

Berikut ini adalah satu transaksi di mana heuristik ini dapat diterapkan secara wajar:

```plaintext
db07516288771ce5d0a06b275962ec4af1b74500739f168e5800cbcb0e9dd578
```

![BTC204](assets/fr/048.webp)

Fonte: [Mempool.space](https://mempool.space/tx/db07516288771ce5d0a06b275962ec4af1b74500739f168e5800cbcb0e9dd578)

Dalam kasus ini, kita dapat melihat bahwa input No. 0 dan output No. 1 menggunakan skrip P2WPKH (SegWit V0), sementara output No. 0 menggunakan jenis skrip yang berbeda, yaitu P2PKH (Legacy). Pada awal tahun 2010, heuristik berdasarkan versi skrip ini relatif tidak membantu karena keterbatasan jenis skrip yang tersedia. Namun, seiring berjalannya waktu dan dengan pembaruan Bitcoin selanjutnya, semakin banyak jenis skrip yang diperkenalkan. Heuristik ini menjadi semakin relevan karena, dengan semakin beragamnya jenis skrip, pengguna terbagi menjadi kelompok-kelompok yang lebih kecil, sehingga meningkatkan peluang untuk menerapkan heuristik penggunaan ulang versi internal ini. Untuk alasan ini, dari perspektif privasi saja, disarankan untuk memilih jenis skrip yang paling umum. Sebagai contoh, saat saya menulis baris ini, skrip Taproot (`bc1p`) lebih jarang digunakan daripada skrip SegWit V0 (`bc1q`). Meskipun yang pertama menawarkan keuntungan ekonomi dan privasi dalam konteks tertentu, untuk penggunaan tanda tangan tunggal yang lebih tradisional, mungkin lebih baik untuk tetap menggunakan standar yang lebih lama karena alasan privasi sampai standar baru diadopsi secara lebih luas.

### Pembayaran dengan Bilangan Bulat

Heuristik internal lain yang dapat membantu kita mengidentifikasi sisa adalah dengan menggunakan angka yang dibulatkan. Umumnya, ketika dihadapkan pada skema pembayaran sederhana (1 input dan 2 output), jika salah satu output menghabiskan jumlah yang dibulatkan, maka itu mewakili pembayaran.

![BTC204](assets/it/33/06.webp)

Dengan eliminasi, jika satu output mewakili pembayaran, maka output lainnya mewakili perubahan. Oleh karena itu, dapat disimpulkan bahwa kemungkinan besar pengguna yang melakukan transaksi masih memiliki output yang diidentifikasi sebagai kembalian.

Perlu dicatat bahwa heuristik ini tidak selalu dapat diterapkan, karena sebagian besar pembayaran masih dilakukan dalam satuan mata uang fiat. Faktanya, ketika seorang pedagang di Perancis menerima bitcoin, dia biasanya tidak menampilkan harga yang stabil dalam sat. Ia lebih memilih untuk melakukan konversi antara harga dalam euro dan jumlah bitcoin yang harus dibayarkan. Oleh karena itu, seharusnya tidak ada angka yang dibulatkan dalam hasil transaksi.

Namun, seorang analis mungkin mencoba melakukan konversi ini dengan mempertimbangkan nilai tukar yang berlaku pada saat transaksi ditransmisikan melalui jaringan. Ambil contoh transaksi dengan input `97.552 sats` dan dua output, satu dari `31.085 sats` dan satu lagi `64.152 sats`. Sekilas, transaksi ini tidak terlihat melibatkan jumlah yang dibulatkan. Namun, dengan menggunakan nilai tukar `64,339 pada saat transaksi, kita mendapatkan konversi ke euro yang terlihat sebagai berikut:


- Masukan sebesar €62,76;
- Keluaran sebesar €20;
- Output sebesar €41,27.

Setelah dikonversi ke mata uang fiat, transaksi ini memungkinkan penerapan heuristik pembayaran dengan jumlah yang dibulatkan. Hasil dari €20 mungkin ditujukan untuk pedagang, atau berganti pemilik. Kesimpulannya, hasil dari €41,27 mungkin tetap dimiliki oleh pengguna asli.

![BTC204](assets/it/33/07.webp)

Jika suatu hari nanti, Bitcoin menjadi unit akun yang lebih disukai dalam transaksi kita, heuristik ini dapat menjadi lebih berguna untuk analisis.

Sebagai contoh, berikut ini adalah sebuah transaksi di mana heuristik ini mungkin dapat diterapkan:

```plaintext
2bcb42fab7fba17ac1b176060e7d7d7730a7b807d470815f5034d52e96d2828a
```

![BTC204](assets/fr/051.webp)

Fonte: [Mempool.space](https://mempool.space/tx/2bcb42fab7fba17ac1b176060e7d7d7730a7b807d470815f5034d52e96d2828a)

### Hasil Terbesar

Ketika ada perbedaan yang sangat besar antara dua output dari sebuah transaksi dalam model pembayaran sederhana, dapat diperkirakan bahwa output yang lebih besar kemungkinan besar adalah sisanya.

![BTC204](assets/it/33/09.webp)

Heuristik keluaran terbesar ini mungkin adalah yang paling tidak akurat. Ketika diidentifikasi sendiri, ia agak lemah. Namun, fitur ini dapat dikombinasikan dengan heuristik lain untuk mengurangi ketidakpastian interpretasi kita.

Sebagai contoh, jika kita memeriksa sebuah transaksi yang memiliki satu output dengan jumlah bulat dan output lain dengan jumlah yang lebih besar, aplikasi gabungan dari heuristik pembayaran bulat dan heuristik yang terkait dengan output yang lebih besar memungkinkan kita untuk mengurangi tingkat ketidakpastian.

Sebagai contoh, berikut ini adalah sebuah transaksi di mana heuristik ini mungkin dapat diterapkan:

```plaintext
b79d8f8e4756d34bbb26c659ab88314c220834c7a8b781c047a3916b56d14dcf
```

![BTC204](assets/fr/053.webp)

Fonte: [Mempool.space](https://mempool.space/tx/b79d8f8e4756d34bbb26c659ab88314c220834c7a8b781c047a3916b56d14dcf)

## Heuristik Eksternal

<chapterId>4a170e3b-200d-431a-8285-18a23ff617ba</chapterId>

Studi heuristik eksternal melibatkan analisis kesamaan, pola, dan karakteristik dari elemen-elemen tertentu yang tidak bersifat intrinsik terhadap transaksi itu sendiri. Dengan kata lain, jika sebelumnya kita hanya terbatas pada mengeksploitasi elemen-elemen intrinsik dari transaksi dengan heuristik internal, sekarang kita memperluas bidang analisis kita ke lingkungan transaksi melalui heuristik eksternal.

### Penggunaan Ulang Alamat

Ini adalah salah satu heuristik yang paling terkenal di antara para penggemar Bitcoin. Penggunaan ulang alamat memungkinkan koneksi dibuat antara transaksi yang berbeda dan UTXO yang berbeda. Hal ini terjadi ketika sebuah alamat penerima Bitcoin digunakan beberapa kali.

Dengan demikian, dimungkinkan untuk mengeksploitasi penggunaan ulang alamat dalam transaksi yang sama sebagai heuristik internal untuk mengidentifikasi sisanya (seperti yang kita lihat di bab sebelumnya). Akan tetapi, penggunaan ulang alamat juga dapat berfungsi sebagai heuristik eksternal untuk mengenali keunikan sebuah entitas di balik beberapa transaksi.

Interpretasi dari penggunaan ulang alamat adalah bahwa semua UTXO yang terkunci pada alamat ini adalah milik (atau pernah menjadi milik) entitas yang sama. Heuristik ini menyisakan sedikit ruang untuk ketidakpastian. Ketika dapat diidentifikasi, interpretasi yang mengikutinya kemungkinan besar akan sesuai dengan kenyataan. Dengan demikian, hal ini memungkinkan pengelompokan aktivitas onchain yang berbeda.

![BTC204](assets/it/34/01.webp)

Seperti yang telah dijelaskan pada bagian pendahuluan Bagian 3 ini, heuristik ini ditemukan oleh Satoshi Nakamoto sendiri. Dalam White Paper, ia secara khusus menyebutkan solusi bagi pengguna untuk menghindarinya, yaitu dengan menggunakan alamat baru untuk setiap transaksi baru:

"Sebagai perlindungan tambahan, pasangan kunci baru dapat digunakan untuk setiap transaksi agar tidak terhubung dengan pemilik yang sama."

![BTC204](assets/fr/055.webp)

Sumber: S. Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System," https://bitcoin.org/bitcoin.pdf, 2009.

Sebagai contoh, berikut ini adalah alamat yang digunakan kembali dalam beberapa transaksi:

```plaintext
bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0
```

Sumber:[Mempool.space](https://mempool.space/address/bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0)

### Kemiripan Tulisan dan Sidik Jari Dompet

Selain penggunaan ulang alamat, ada beberapa heuristik lain untuk menghubungkan saham ke portofolio yang sama atau ke sekelompok alamat.

Pertama-tama, seorang analis dapat mengambil keuntungan dari kesamaan dalam penggunaan skrip. Sebagai contoh, skrip minoritas tertentu seperti multisig dapat diidentifikasi dengan lebih mudah daripada skrip SegWit V0. Semakin besar kelompok tempat kita bersembunyi, semakin sulit untuk mengidentifikasi kita. Inilah sebabnya, dalam protokol Coinjoin yang baik, semua peserta menggunakan jenis skrip yang sama persis.

Secara umum, seorang analis juga dapat berfokus pada karakteristik sidik jari dari sebuah portofolio. Ini adalah proses spesifik yang terkait dengan penggunaan yang dapat diidentifikasi dengan tujuan mengeksploitasinya sebagai heuristik pelacakan. Dengan kata lain, jika seseorang mengamati akumulasi karakteristik internal yang sama pada transaksi yang dikaitkan dengan entitas yang dilacak, seseorang dapat mencoba mengidentifikasi karakteristik yang sama pada transaksi lain.

Sebagai contoh, dapat diidentifikasi bahwa pengguna yang dilacak secara sistematis mengirimkan sisanya ke alamat P2TR (`bc1p...`). Jika proses ini diulang, ini bisa digunakan sebagai heuristik untuk kelanjutan analisis kita. Sidik jari lain dapat digunakan, seperti urutan UTXO, penempatan sisa di output, sinyal RBF (Replace-by-Fee), atau bahkan, nomor versi, bidang `nSequence`, dan bidang `nLockTime`.

Seperti yang dijelaskan oleh [@LaurentMT] (https://twitter.com/LaurentMT) dalam [Space Kek #19] (https://podcasters.spotify.com/pod/show/decouvrebitcoin/episodes/SpaceKek-19---Analyse-de-chane--anonsets-et-entropie-e1vfuji) (podcast berbahasa Perancis), kegunaan sidik jari dompet dalam analisis rantai meningkat secara signifikan dari waktu ke waktu. Memang, meningkatnya jumlah jenis skrip dan penyebaran yang semakin bertahap dari kemampuan baru ini oleh perangkat lunak dompet menonjolkan perbedaannya. Bahkan mungkin saja seseorang dapat secara akurat mengidentifikasi perangkat lunak yang digunakan oleh entitas yang dilacak. Oleh karena itu, penting untuk memahami bahwa studi mengenai jejak digital dompet terbukti sangat relevan untuk transaksi-transaksi yang baru saja terjadi, lebih dari transaksi yang dimulai pada awal tahun 2010.

Untuk meringkas, sidik jari dapat berupa praktik tertentu, yang dilakukan secara otomatis oleh dompet atau secara manual oleh pengguna, yang dapat ditemukan pada transaksi lain untuk membantu analisis kami.

### Heuristik Kepemilikan Umum atas Input (CIOH)

CIOH, singkatan dari "Common Input Ownership Heuristic" dalam bahasa Inggris, adalah sebuah heuristik yang menyatakan bahwa ketika sebuah transaksi mencakup beberapa input, kemungkinan besar input tersebut berasal dari satu entitas. Akibatnya, kepemilikannya bersifat umum.

Untuk menerapkan Common Ownership Heuristics of Inputs (CIOH), pertama-tama kita mengamati sebuah transaksi yang memiliki banyak input. Ini bisa dari minimal 2 input hingga maksimal 30 input. Setelah karakteristik ini teridentifikasi, kami memeriksa apakah transaksi tersebut tidak sesuai dengan model transaksi yang diketahui. Contohnya, jika transaksi tersebut memiliki 5 input dengan jumlah yang kurang lebih sama dan 5 output dengan jumlah yang sama persis, kita tahu bahwa transaksi tersebut merupakan struktur coinjoin. Oleh karena itu, kita tidak dapat menerapkan IOCH.

Namun, jika transaksi tersebut tidak sesuai dengan model transaksi kolaboratif yang diketahui, maka kita dapat menyimpulkan bahwa semua input mungkin berasal dari entitas yang sama. Hal ini bisa sangat berguna untuk memperluas klaster yang sudah diketahui atau untuk melanjutkan pelacakan.

CIOH ditemukan oleh Satoshi Nakamoto. Dia membahas hal ini di bagian 10 Buku Putih:

"_[...] keterkaitan tidak dapat dihindari dengan transaksi multi-input, yang tentu saja mengungkapkan bahwa input mereka dimiliki oleh pemilik yang sama. Risikonya adalah jika pemilik sebuah kunci terungkap, keterkaitan dapat mengungkapkan transaksi lain yang dimiliki oleh pemilik yang sama._"

Sangat menarik untuk dicatat bahwa Satoshi Nakamoto, bahkan sebelum peluncuran resmi Bitcoin, telah mengidentifikasi dua kerentanan privasi utama bagi para pengguna, yaitu IOCH dan penggunaan ulang alamat. Prediksi tersebut cukup luar biasa, karena kedua heuristik ini tetap menjadi yang paling berguna dalam analisis blockchain hingga saat ini.

Sebagai contoh, berikut ini adalah sebuah transaksi yang mungkin bisa kita terapkan IOCH:

```plaintext
20618e63b6eed056263fa52a2282c8897ab2ee71604c7faccfe748e1a202d712
```

Fonte: [Mempool.space](https://mempool.space/tx/20618e63b6eed056263fa52a2282c8897ab2ee71604c7faccfe748e1a202d712)

### Data offchain

Tentu saja, analisis on-chain tidak terbatas hanya pada data onchain. Data dari analisis sebelumnya atau yang tersedia di Internet juga dapat digunakan untuk menyempurnakan analisis.

Sebagai contoh, jika diamati bahwa transaksi yang terlacak secara sistematis ditransmisikan dari node Bitcoin yang sama dan alamat IP-nya dapat diidentifikasi, maka akan memungkinkan untuk mengidentifikasi transaksi lain dari entitas yang sama, serta menentukan bagian dari identitas pengirim. Meskipun praktik ini tidak mudah dilakukan, karena membutuhkan banyak node untuk beroperasi, ada kemungkinan beberapa perusahaan yang berspesialisasi dalam analisis rantai akan menggunakannya.

Analis juga memiliki pilihan untuk mengandalkan analisis yang sebelumnya dibuat secara open-source, atau pada analisis sebelumnya. Mungkin dapat ditemukan sebuah keluaran yang mengarah ke sebuah klaster alamat yang sudah diidentifikasi. Terkadang, mungkin juga dapat mengandalkan output yang mengarah ke platform bursa, alamat perusahaan-perusahaan ini sudah diketahui secara umum.

Demikian pula, seseorang dapat melakukan analisis dengan eliminasi. Sebagai contoh, jika selama analisis transaksi dengan dua output, salah satunya terhubung ke klaster alamat yang sudah diketahui tetapi berbeda dari entitas yang sedang dilacak, maka dapat ditafsirkan bahwa output yang lain mungkin mewakili yang lainnya.

Analisis rantai juga termasuk bagian dari OSINT (_Open Source Intelligence_) yang sedikit lebih umum dalam pencarian di internet. Inilah sebabnya mengapa tidak disarankan untuk memposting alamat penerima secara langsung di media sosial atau di situs web, baik dengan nama samaran atau tidak.

![BTC204](assets/fr/063.webp)

### Pola Temporal

Hal ini kurang umum dipertimbangkan, tetapi perilaku manusia tertentu dapat dikenali secara langsung. Yang paling berguna dalam analisis mungkin adalah pola tidur Anda! Ya, ketika Anda tidur, Anda mungkin tidak mengirimkan transaksi Bitcoin. Karena Anda biasanya tidur pada waktu yang sama, maka analisis temporal biasa digunakan dalam analisis on-chain. Hal ini hanya melibatkan katalogisasi waktu-waktu ketika transaksi entitas tertentu dikirimkan ke jaringan Bitcoin. Menganalisis pola temporal ini memungkinkan kita untuk menyimpulkan banyak informasi.

Pertama-tama, analisis temporal terkadang akan mengidentifikasi sifat entitas yang dilacak. Jika terlihat bahwa transaksi ditransmisikan secara konsisten selama 24 jam, maka hal ini akan menunjukkan aktivitas ekonomi yang kuat. Entitas di balik transaksi ini kemungkinan besar adalah sebuah perusahaan, yang mungkin bersifat internasional, dan mungkin memiliki prosedur yang terotomatisasi secara internal.

Sebagai contoh, [saya telah mengenali pola ini beberapa bulan yang lalu] (https://twitter.com/Loic_Pandul/status/1701127409712452072) dengan menganalisa [transaksi yang secara keliru mengalokasikan biaya 19 bitcoin] (https://mempool.space/tx/d5392d474b4c436e1c9d1f4ff4be5f5f9bb0eb2e26b61d2781751474b7e870fd). Analisis sementara yang sederhana memungkinkan saya untuk berasumsi bahwa kami berurusan dengan layanan otomatis, dan oleh karena itu mungkin sebuah entitas besar seperti platform bursa.

Faktanya, beberapa hari kemudian, diketahui bahwa dana tersebut adalah milik PayPal, melalui platform pertukaran Paxos.

Sebaliknya, jika kita melihat bahwa pola waktu agak tersebar di 16 jam yang sangat spesifik, maka kita dapat memperkirakan bahwa kita berurusan dengan pengguna perorangan, atau mungkin bisnis lokal tergantung pada volume yang diperdagangkan.

Selain sifat dari entitas yang diamati, model temporal juga dapat memberikan perkiraan lokasi pengguna melalui zona waktu. Kita kemudian dapat menautkan transaksi lain, dan menggunakan cap waktu ini sebagai heuristik tambahan yang dapat ditambahkan ke analisis kita.

Sebagai contoh, pada alamat yang digunakan kembali yang saya sebutkan sebelumnya, kita dapat mengamati bahwa transaksi, baik yang masuk maupun yang keluar, terkonsentrasi pada interval 13 jam.

```plaintext
bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0
```

![BTC204](assets/fr/064.webp)

Sumber: OXT.me

Kisaran ini mungkin sesuai dengan Eropa, Afrika atau Timur Tengah. Oleh karena itu, kami dapat menyimpulkan bahwa pengguna di balik transaksi ini tinggal di sana.

Dalam daftar yang berbeda, analisis waktu juga memungkinkan hipotesis bahwa Satoshi Nakamoto tidak beroperasi dari Jepang, melainkan dari Amerika Serikat: [_The Time Zones of Satoshi Nakamoto_] (https://medium.com/@insearchofsatoshi/the-time-zones-of-satoshi-nakamoto-aa40f035178f)

## Aplikasi Praktis dengan Penjelajah Blok

<chapterId>6493cf2f-225c-405f-9375-c4304f1087ed</chapterId>

Dalam bab terakhir ini, kita akan menerapkan konsep yang telah kita pelajari sejauh ini. Saya akan memberikan contoh-contoh transaksi Bitcoin yang nyata, dan Anda harus mengekstrak informasi yang saya minta.

Idealnya, untuk latihan ini, penggunaan alat analisis chain profesional akan lebih baik. Namun, setelah ditutupnya pembuat Samourai Wallet, satu-satunya alat analisis gratis OXT.me tidak lagi tersedia. Oleh karena itu, kita akan memilih penjelajah blok klasik untuk latihan ini. Saya menyarankan untuk menggunakan [Mempool.space](https://mempool.space/) karena memiliki banyak fitur dan berbagai alat analisis rantai, tetapi Anda juga dapat memilih penjelajah lain seperti [Bitcoin Explorer](https://bitcoinexplorer.org/). Sebagai permulaan, saya akan memperkenalkan latihan-latihannya. Gunakan penjelajah blok Anda untuk menyelesaikannya dan tuliskan jawaban Anda pada selembar kertas. Kemudian, di akhir bab ini, saya akan memberikan jawabannya agar Anda dapat memeriksa dan mengoreksi hasil Anda.

transaksi yang dipilih untuk latihan ini dipilih semata-mata berdasarkan karakteristiknya secara acak. Bab ini dimaksudkan untuk tujuan pendidikan dan informasi saja. Saya ingin menjelaskan bahwa saya tidak menganjurkan atau mendorong penggunaan alat bantu ini untuk tujuan jahat. Tujuannya adalah untuk mengajarkan Anda cara melindungi diri Anda dari analisis berantai, bukan melakukan analisis untuk mengekspos informasi pribadi orang lain

### Latihan 1

ID transaksi yang akan dianalisis:

```plaintext
3769d3b124e47ef4ffb5b52d11df64b0a3f0b82bb10fd6b98c0fd5111789bef7
```

Apa nama model dari transaksi ini dan interpretasi yang masuk akal apa yang dapat ditarik dengan hanya memeriksa modelnya, yaitu struktur transaksinya?

### Latihan 2

ID transaksi yang akan dianalisis:

```plaintext
baa228f6859ca63e6b8eea24ffad7e871713749d693ebd85343859173b8d5c20
```

Apa nama model dari transaksi ini dan interpretasi yang masuk akal apa yang dapat ditarik dengan hanya memeriksa modelnya, yaitu struktur transaksinya?

### Latihan 3

ID transaksi yang akan dianalisis:

```plaintext
3a9eb9ccc3517cc25d1860924c66109262a4b68f4ed2d847f079b084da0cd32b
```

Bagaimana pola transaksi ini?

Setelah mengidentifikasi modelnya, dengan menggunakan heuristik internal transaksi, output apa yang kemungkinan besar akan mewakili sisanya?

### Latihan 4

ID transaksi yang akan dianalisis:

```plaintext
35f0b31c05503ebfdf7311df47f68a048e992e5cf4c97ec34aa2833cc0122a12
```

Bagaimana pola transaksi ini?

Setelah mengidentifikasi modelnya, dengan menggunakan heuristik internal transaksi, output apa yang kemungkinan besar akan mewakili sisanya?

### Latihan 5

Bayangkan Loïc memposting salah satu alamat Bitcoin-nya untuk menerima pembayaran di jejaring sosial Twitter:

![BTC204](assets/fr/065.webp)

```plaintext
bc1qja0hycrv7g9ww00jcqanhfpqmzx7luqalum3vu
```

Dengan menggunakan **hanya heuristik penggunaan ulang alamat**, transaksi Bitcoin apa saja yang dapat kita hubungkan dengan identitas Loïc?

jelas, saya bukan pemilik sebenarnya dari alamat penerima ini dan saya tidak mempostingnya di media sosial. Ini adalah alamat yang saya pilih secara acak dari blockchain._

### Latihan 6

Setelah Latihan 5, dengan menggunakan heuristik penggunaan ulang alamat, Anda dapat mengidentifikasi beberapa transaksi Bitcoin yang melibatkan Loïc. Biasanya, di antara transaksi yang teridentifikasi, Anda seharusnya sudah mengidentifikasi transaksi ini:

Transaksi ini merupakan transaksi pertama yang mengirimkan dana ke alamat Loïc. Menurut Anda, dari mana asal bitcoin yang diterima oleh Loïc melalui transaksi ini?

### Latihan 7

Setelah mengikuti Latihan 5, dengan menggunakan heuristik penggunaan ulang alamat, Anda sudah dapat mengidentifikasi beberapa transaksi Bitcoin yang melibatkan Loïc. Sekarang, Anda ingin mencari tahu dari mana Loïc berasal. Berdasarkan transaksi yang ditemukan, lakukan analisis waktu untuk menemukan zona waktu yang mungkin digunakan oleh Loïc. Dari zona waktu ini, tentukan lokasi di mana Loïc tinggal (negara, negara bagian/wilayah, kota...).

### Latihan 8

Berikut ini adalah transaksi Bitcoin untuk dipelajari:

```plaintext
bb346dae645d09d32ed6eca1391d2ee97c57e11b4c31ae4325bcffdec40afd4f
```

Dengan hanya melihat transaksi ini, informasi apa yang dapat kita tafsirkan?

### Solusi untuk latihan

**_Latihan 1:_**

Model dari transaksi ini adalah pembayaran sederhana. Jika kita hanya mempelajari strukturnya, kita dapat menginterpretasikan bahwa satu output mewakili perubahan dan output lainnya mewakili pembayaran yang sebenarnya. Kita kemudian mengetahui bahwa pengguna yang diamati mungkin tidak lagi memiliki salah satu dari dua UTXO dalam output (yang untuk pembayaran), tetapi masih memiliki UTXO lainnya (yang untuk kembalian).

**_Latihan 2:_**

Pola transaksi ini adalah pola pembelanjaan batch. Pola ini mungkin mengindikasikan aktivitas ekonomi yang signifikan, seperti platform pertukaran. Kita dapat menyimpulkan bahwa input UTXO berasal dari perusahaan dengan aktivitas ekonomi yang signifikan dan output UTXO akan menyebar. Sebagian akan menjadi milik pelanggan perusahaan yang telah menarik bitcoin mereka ke dompet penyimpanan mandiri. Sebagian lagi mungkin akan masuk ke perusahaan mitra. Akhirnya, pasti akan ada sisa yang kembali ke perusahaan penerbit.

**_Latihan 3:_**

Model dari transaksi ini adalah model pembayaran sederhana. Oleh karena itu, kita bisa menerapkan heuristik internal pada transaksi tersebut untuk mencoba mengidentifikasi sisanya.

Secara pribadi, saya telah mengidentifikasi setidaknya dua heuristik internal yang mendukung hipotesis yang sama:


- Penggunaan kembali jenis skrip yang sama;
- Output terbesar.

Heuristik yang paling jelas adalah penggunaan kembali jenis skrip yang sama. Faktanya, output `0` adalah `P2SH`, yang dapat dikenali dari alamat penerimanya yang dimulai dengan `3`:

```plaintext
3Lcdauq6eqCWwQ3UzgNb4cu9bs88sz3mKD
```

Sedangkan output `1` adalah `P2WPKH`, yang dapat diidentifikasi dengan alamatnya yang dimulai dengan `bc1q`:

```plaintext
bc1qya6sw6sta0mfr698n9jpd3j3nrkltdtwvelywa
```

UTXO yang digunakan sebagai input untuk transaksi ini juga menggunakan skrip `P2WPKH`:

```plaintext
bc1qyfuytw8pcvg5vx37kkgwjspg73rpt56l5mx89k
```

Dengan demikian, kita dapat mengasumsikan bahwa output `0` berhubungan dengan pembayaran dan output `1` adalah sisa transaksi, yang berarti pengguna input masih memiliki output `1`.

Untuk mendukung atau menolak hipotesis ini, kita dapat mencari heuristik lain yang mengonfirmasi pemikiran kita atau mengurangi probabilitas bahwa hipotesis kita benar.

Saya telah mengidentifikasi setidaknya satu heuristik lainnya. Ini adalah keluaran terbesar. Keluaran `0` mengukur `123.689 sat`, sedangkan keluaran `1` mengukur `505.839 sat`. Oleh karena itu, terdapat perbedaan yang signifikan antara kedua keluaran ini. Heuristik dari output yang lebih besar menunjukkan bahwa output yang lebih banyak kemungkinan adalah sisanya. Oleh karena itu, heuristik ini semakin memperkuat hipotesis awal kami.

Tampaknya pengguna yang memberikan input UTXO masih memegang output `1`, yang tampaknya mewakili sisa transaksi.

**_Latihan 4:_**

Model dari transaksi ini adalah model pembayaran sederhana. Oleh karena itu, kita bisa menerapkan heuristik internal pada transaksi tersebut untuk mencoba mengidentifikasi sisanya.

Saya secara pribadi telah mengidentifikasi setidaknya dua heuristik internal yang mendukung hipotesis yang sama:


- Penggunaan kembali jenis skrip yang sama;
- Output dari jumlah bulat.

Heuristik yang paling jelas adalah penggunaan kembali jenis skrip yang sama. Faktanya, output `0` adalah `P2SH`, yang dapat dikenali dari alamat penerimanya yang dimulai dengan `3`:

```plaintext
3FSH5Mnq6S5FyQoKR9Yjakk3X4KCGxeaD4
```

Sedangkan output `1` adalah `P2WPKH`, yang dapat diidentifikasi dengan alamatnya yang dimulai dengan `bc1q`:

```plaintext
bc1qvdywdcfsyavt4v8uxmmrdt6meu4vgeg439n7sg
```

UTXO yang digunakan sebagai input untuk transaksi ini juga menggunakan skrip `P2WPKH`:

```plaintext
bc1qku3f2y294h3ks5eusv63dslcua2xnlzxx0k6kp
```

Dengan demikian, kita dapat mengasumsikan bahwa output `0` berhubungan dengan pembayaran dan output `1` adalah sisa transaksi, yang berarti bahwa pengguna input masih memegang output `1`.

Untuk mendukung atau menolak hipotesis ini, kita dapat mencari heuristik lain yang mengonfirmasi pemikiran kita atau mengurangi probabilitas bahwa hipotesis kita benar.

Saya telah mengidentifikasi setidaknya satu heuristik lainnya. Ini adalah output dari jumlah bulat. Output `0` mengukur `70.000 satoshi`, sedangkan output `1` mengukur `22.962 satoshi`. Oleh karena itu, kita berurusan dengan output yang bulat sempurna dalam unit akun BTC. Heuristik output bulat menunjukkan bahwa UTXO dengan satu jumlah bulat mungkin merupakan pembayaran, dan dengan eliminasi, yang lain mewakili sisanya. Oleh karena itu, heuristik ini semakin memperkuat hipotesis awal kami.

Namun, dalam contoh ini, heuristik lain mungkin menantang asumsi awal kita. Pada kenyataannya, keluaran `0` lebih besar daripada keluaran `1`. Jika kita mendasarkan penalaran kita pada heuristik bahwa keluaran terbesar pada umumnya adalah sisa, kita mungkin menyimpulkan bahwa keluaran `0` adalah sisa. Namun, hipotesis tandingan ini tampaknya tidak masuk akal, karena dua heuristik lainnya terlihat jauh lebih meyakinkan dibandingkan dengan heuristik output terbesar. Oleh karena itu, tampaknya masuk akal untuk mempertahankan hipotesis awal kita meskipun terdapat kontradiksi yang jelas.

Oleh karena itu, tampaknya pengguna yang memberikan UTXO sebagai input masih memegang output `1`, yang tampaknya mewakili sisa transaksi.

**_Latihan 5:_**

Kita dapat melihat bahwa 8 transaksi dapat dikaitkan dengan identitas Loïc. Dari jumlah tersebut, 4 di antaranya melibatkan penerimaan bitcoin:

```plaintext
2d9575553c99578268ffba49a1b2adc3b85a29926728bd0280703a04d051eace
8b70bd322e6118b8a002dbdb731d16b59c4a729c2379af376ae230cf8cdde0dd
d5864ea93e7a8db9d3fb113651d2131567e284e868021e114a67c3f5fb616ac4
bc4dcf2200c88ac1f976b8c9018ce70f9007e949435841fc5681fd33308dd762
```

Empat lainnya adalah tentang pengiriman bitcoin:

```plaintext
8b52fe3c2cf8bef60828399d1c776c0e9e99e7aaeeff721fff70f4b68145d540
c12499e9a865b9e920012e39b4b9867ea821e44c047d022ebb5c9113f2910ed6
a6dbebebca119af3d05c0196b76f80fdbf78f20368ebef1b7fd3476d0814517d
3aeb7ce02c35eaecccc0a97a771d92c3e65e86bedff42a8185edd12ce89d89cc
```

**_Latihan 6:_**

Jika kita memeriksa pola transaksi ini, terlihat jelas bahwa transaksi ini merupakan pengeluaran yang dikelompokkan. Faktanya, transaksi ini memiliki satu input dan 51 output, yang mengindikasikan aktivitas ekonomi yang signifikan. Oleh karena itu, kita dapat mengasumsikan bahwa Loïc melakukan penarikan bitcoin dari platform bursa.

Beberapa elemen memperkuat hipotesis ini. Pertama, jenis skrip yang digunakan untuk melindungi input UTXO adalah skrip P2SH multisig 2/3, yang menunjukkan tingkat keamanan tingkat lanjut yang khas pada platform bursa:

```plaintext
OP_PUSHNUM_2
OP_PUSHBYTES_33 03eae02975918af86577e1d8a257773118fd6ceaf43f1a543a4a04a410e9af4a59
OP_PUSHBYTES_33 03ba37b6c04aaf7099edc389e22eeb5eae643ce0ab89ac5afa4fb934f575f24b4e
OP_PUSHBYTES_33 03d95ef2dc0749859929f3ed4aa5668c7a95baa47133d3abec25896411321d2d2d
OP_PUSHNUM_3
OP_CHECKMULTISIG
```

Selain itu, alamat yang dianalisis `3PUv9tQMSDCEPSMsYSopA5wDW86pwRFbNF` digunakan kembali di lebih dari 220.000 transaksi yang berbeda, yang sering kali merupakan karakteristik dari platform bursa yang umumnya tidak peduli dengan privasinya. Heuristik temporal yang diterapkan pada alamat ini juga menunjukkan penyebaran transaksi yang teratur hampir setiap hari selama periode 3 bulan, dengan waktu yang diperpanjang lebih dari 24 jam, yang menunjukkan aktivitas yang terus menerus dari sebuah platform bursa.

Terakhir, volume yang diproses oleh entitas ini sangat besar. Faktanya, alamat tersebut menerima dan mengirim 44 BTC selama 222.262 transaksi antara Desember 2022 dan Maret 2023. Volume yang signifikan ini semakin mengonfirmasi kemungkinan sifat aktivitas platform bursa.

**_Latihan 7:_**

Menganalisis waktu konfirmasi transaksi, waktu UTC berikut ini dapat dilihat:

```plaintext
05:43
20:51
18:12
17:16
04:28
23:38
07:45
21:55
```

Dengan menganalisis waktu-waktu ini, terlihat bahwa zona waktu UTC-7 dan UTC-8 konsisten dengan rentang aktivitas manusia yang umum (antara pukul 8 pagi dan 11 malam) untuk sebagian besar waktu:

```plaintext
05:43 UTC > 22:43 UTC-7
20:51 UTC > 13:51 UTC-7
18:12 UTC > 11:12 UTC-7
17:16 UTC > 10:16 UTC-7
04:28 UTC > 21:28 UTC-7
23:38 UTC > 16:38 UTC-7
07:45 UTC > 00:45 UTC-7
21:55 UTC > 14:55 UTC-7
05:43 UTC > 21:43 UTC-8
20:51 UTC > 12:51 UTC-8
18:12 UTC > 10:12 UTC-8
17:16 UTC > 09:16 UTC-8
04:28 UTC > 20:28 UTC-8
23:38 UTC > 15:38 UTC-8
07:45 UTC > 23:45 UTC-8
21:55 UTC > 13:55 UTC-8
```

Zona waktu UTC-7 sangat relevan pada musim panas, karena mencakup negara bagian dan wilayah seperti:


- California (dengan kota-kota seperti Los Angeles, San Francisco, dan San Diego);
- Nevada (dengan Las Vegas);
- Oregon (dengan Portland);
- Washington (dengan Seattle);
- Wilayah Kanada di British Columbia (dengan kota-kota seperti Vancouver dan Victoria).

Informasi ini menunjukkan bahwa Loïc mungkin tinggal di Pantai Barat Amerika Serikat atau Kanada.

**_Latihan 8:_**

Analisis dari transaksi ini menunjukkan adanya 5 input dan satu output, yang tampaknya mengindikasikan konsolidasi. Penerapan heuristik CIOH menunjukkan bahwa semua UTXO dalam input dimiliki oleh satu entitas, dan bahwa UTXO dalam output juga dimiliki oleh entitas ini. Tampaknya pengguna memilih untuk menggabungkan beberapa UTXO yang dimilikinya ke dalam satu UTXO di output, dengan tujuan untuk mengkonsolidasikan koin miliknya. Pendekatan ini mungkin dimotivasi oleh keinginan untuk mengambil keuntungan dari biaya transaksi yang rendah saat ini untuk mengurangi biaya di masa depan.

---
untuk penulisan Bagian 3 tentang analisis rantai ini, saya mengandalkan sumber-sumber berikut:_


- seri empat artikel berjudul: [Memahami Privasi Bitcoin dengan OXT] (https://medium.com/oxt-research/understanding-bitcoin-privacy-with-oxt-part-1-4-8177a40a5923), diproduksi oleh Samourai Wallet pada tahun 2021;_
- berbagai laporan dari [OXT Research] (https://medium.com/oxt-research), serta alat analisis rantai gratis mereka (yang saat ini tidak lagi tersedia setelah penangkapan para pendiri Samourai Wallet); _
- secara umum, pengetahuan saya berasal dari berbagai tweet dan konten dari [@LaurentMT](https://twitter.com/LaurentMT) dan [@ErgoBTC](https://twitter.com/ErgoBTC);_
- \_The [Space Kek #19](https://podcasters.spotify.com/pod/show/decouvrebitcoin/episodes/SpaceKek-19---Analyse-de-chane--anonsets-et-entropie-e1vfuji) di mana saya berpartisipasi bersama dengan [@louneskmt](https://twitter.com/louneskmt), [@TheoPantamis](https://twitter.com/TheoPantamis), [@Sosthene\_\_](https://twitter.com/Sosthene___), dan [@LaurentMT](https://twitter.com/LaurentMT).\_

saya ingin mengucapkan terima kasih kepada para penulis, pengembang, dan produsernya. Terima kasih juga kepada para pengulas yang dengan cermat mengoreksi artikel yang menjadi dasar untuk bagian 3 ini dan memberikan penghargaan kepada saya dengan saran ahli mereka:_


- [Gilles Cadignan](https://twitter.com/gillesCadignan);_
- [Ludovic Lars](https://viresinnumeris.fr/)._

# Menguasai Praktik Terbaik untuk Melindungi Privasi Anda

<partId>9bd04b63-f1af-4e50-9061-6bc90009df68</partId>

## Penggunaan Ulang Alamat

<chapterId>f3e97645-3df3-41bc-a4ed-d2c740113d96</chapterId>

Setelah mempelajari teknik-teknik yang dapat membahayakan privasi Anda di Bitcoin, di bagian ketiga ini, kita akan membahas praktik-praktik terbaik yang dapat Anda terapkan untuk melindungi diri Anda sendiri. Bagian ini tidak bertujuan untuk mengeksplorasi metode-metode untuk meningkatkan privasi, sebuah topik yang akan dibahas nanti, tetapi lebih kepada memahami cara berinteraksi dengan Bitcoin secara tepat untuk menjaga privasi yang ditawarkannya secara alami, tanpa harus menggunakan teknik-teknik tambahan.

Tentu saja, untuk memulai bagian ketiga ini, kita akan membahas tentang penggunaan ulang alamat. Fenomena ini merupakan ancaman utama terhadap privasi pengguna. Oleh karena itu, bab ini mungkin yang paling penting dalam keseluruhan kursus ini.

### Apa yang dimaksud dengan alamat penerima?

Alamat penerima bitcoin adalah sebuah string karakter atau pengenal yang digunakan untuk menerima bitcoin ke dalam dompet.

Secara teknis, alamat penerima bitcoin tidak "menerima" bitcoin dalam arti harfiah, melainkan mendefinisikan kondisi di mana bitcoin dapat dibelanjakan. Secara khusus, ketika pembayaran dikirimkan kepada Anda, transaksi pengirim membuat UTXO baru yang ditujukan untuk Anda dalam output dari UTXO yang dikonsumsi dalam input. Pada output ini, sebuah skrip diterapkan yang mendefinisikan bagaimana UTXO ini dapat digunakan nantinya. Skrip ini dikenal sebagai "_ScriptPubKey_" atau "_Locking Script_." Alamat penerima Anda, lebih tepatnya muatannya, tertanam dalam skrip ini. Untuk menyederhanakan, skrip ini pada dasarnya menyatakan:

> "_Untuk mengeluarkan UTXO baru ini, tanda tangan digital harus diberikan menggunakan kunci pribadi yang terkait dengan alamat penerima ini._"
![BTC204](assets/fr/067.webp)

Alamat Bitcoin memiliki beberapa jenis yang berbeda tergantung dari model skrip yang digunakan. Model pertama, yang dikenal sebagai "_Legacy_," meliputi alamat `P2PKH` (_Pay-to-PubKey-Hash_) dan `P2SH` (_Pay-to-Script-Hash_). Alamat P2PKH selalu dimulai dengan `1` dan P2SH dengan `3`. Meskipun masih aman, format ini sekarang sudah tidak digunakan lagi, karena memiliki biaya transaksi yang lebih tinggi dan menawarkan privasi yang lebih rendah daripada standar yang baru.

Alamat SegWit V0 (`P2WPKH` dan `P2WSH`) dan alamat Taproot / SegWit V1 (`P2TR`) mewakili format modern. Alamat SegWit dimulai dengan `bc1q` dan alamat Taproot, yang diperkenalkan pada tahun 2021, dimulai dengan `bc1p`.

Sebagai contoh, berikut ini adalah alamat penerima Taproot:

```text
bc1ps5gd2ys8kllz9alpmcwxqegn7kl3elrpnnlegwkm3xpq2h8da07spxwtf5
```

Cara pembuatan ScriptPubKey akan bergantung pada standar yang Anda gunakan:

| Templat Skrip | ScriptPubKey | ---------------- | ----------------------------------------------------------- | ----------------------------------------------------------- |

| P2PKH | OP_DUP OP_HASH160 `<pubKeyHash>` OP_EQUALVERIFY OP_CHECKSIG |

| P2SH | OP_HASH160 `<scriptHash>` OP_EQUAL |

| P2WPKH | 0 `<pubKeyHash>` | | |

| P2WSH | 0 `<witnessScriptHash>` | | |

| P2SH - P2WPKH | OP_HASH160 `<redeemScriptHash>` OP_EQUAL |

| P2SH - P2WSH | OP_HASH160 `<redeemScriptHash>` OP_EQUAL |

| P2TR | 1 `<pubKey>` | | |

Adapun konstruksi alamat penerima, juga tergantung pada templat skrip yang dipilih:


- Untuk alamat `P2PKH` dan `P2WPKH`, payload, atau inti dari alamat tersebut, merepresentasikan hash dari kunci publik;
- Untuk alamat `P2SH` dan `P2WSH`, payload merepresentasikan hash dari sebuah skrip;
- Sedangkan untuk alamat `P2TR`, muatannya adalah kunci publik yang dimodifikasi. Keluaran `P2TR` menggabungkan aspek-aspek dari _Bayar-ke-PubKey_ dan _Bayar-ke-Script_. Kunci publik yang dimodifikasi adalah hasil dari penambahan kunci publik pembelanjaan klasik dengan sebuah "modifikasi", yang berasal dari akar Merkle dari sekumpulan skrip yang juga dapat digunakan untuk membelanjakan bitcoin.

![BTC204](assets/it/67/01.webp)

Alamat yang ditampilkan pada perangkat lunak dompet anda juga termasuk sebuah HRP (_Human-Readable Part_), biasanya `bc` untuk alamat pasca SegWit, sebuah pemisah `1`, dan sebuah nomor versi `q` untuk SegWit V0 dan `p` untuk Taproot/SegWit V1. Checksum juga ditambahkan untuk memastikan integritas dan keabsahan alamat selama transmisi.

Terakhir, alamat dimasukkan ke dalam format standar:


- Base58periksa untuk alamat Legacy yang lama;
- Bech32 untuk alamat SegWit;
- Bech32m untuk alamat Taproot.

Berikut ini adalah matriks penjumlahan untuk format bech32 dan bech32m (SegWit dan Taproot) dari basis 10:

| + | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |



| 0 | q | p | z | r | y | 9 | x | 8 | 8

| 8 | g | f | 2 | t | v | d | w | 0 |

| 16 | s | 3 | j | n | 5 | 4 | k | h | | 24 | c | e | 6 | m | u | a | 7 | l | l

### Apa yang dimaksud dengan Penggunaan Ulang Alamat?

Penggunaan ulang alamat mengacu pada praktik penggunaan alamat penerima yang sama untuk memblokir beberapa UTXO yang berbeda.

Seperti yang telah kita lihat pada bagian sebelumnya, setiap UTXO memiliki ScriptPubKey yang menguncinya dan harus dipenuhi agar UTXO dapat digunakan sebagai input dalam transaksi baru. Di dalam ScriptPubKey inilah alamat penerimaan (payload) disematkan.

Ketika beberapa ScriptPubKey berisi alamat penerima yang sama, hal ini dikenal dengan istilah penggunaan ulang alamat. Dalam praktiknya, ini berarti bahwa seorang pengguna telah memberikan alamat yang sama beberapa kali kepada pengirim untuk menerima bitcoin melalui beberapa pembayaran. Dan memang, praktik ini merupakan bencana bagi privasi Anda.

### Mengapa Penggunaan Ulang Alamat Menjadi Masalah?

Karena blockchain bersifat publik, maka mudah untuk melihat alamat mana yang memblokir UTXO mana dan berapa banyak bitcoin. Jika alamat yang sama digunakan untuk beberapa transaksi, maka dapat disimpulkan bahwa semua bitcoin yang terkait dengan alamat tersebut adalah milik orang yang sama. Praktik ini membahayakan privasi pengguna dengan mengizinkan hubungan deterministik untuk dibuat antara transaksi yang berbeda dan melacak bitcoin di blockchain. Satoshi Nakamoto sendiri menyoroti masalah ini dalam Buku Putih Bitcoin:

> sebagai firewall tambahan, pasangan kunci baru dapat digunakan untuk setiap transaksi agar tidak terhubung dengan pemilik yang sama
![BTC204](assets/fr/055.webp)

Sumber: S. Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System," https://bitcoin.org/bitcoin.pdf, 2009.

Tujuan yang ingin dicapai oleh Satoshi dengan pernyataan ini adalah untuk membuat sebuah firewall tambahan jika terjadi hubungan antara identitas pengguna dengan pasangan kunci pada Bitcoin, untuk menghindari semua aktivitas mereka dihubungkan secara publik dengan identitas mereka. Saat ini, dengan menjamurnya perusahaan analitik blockchain dan peraturan KYC, penggunaan alamat unik tidak lagi menjadi "firewall tambahan", tetapi merupakan praktik yang diperlukan bagi siapa saja yang ingin menjaga privasi mereka seminimal mungkin.

Ketika Anda menggunakan kembali sebuah alamat, Anda membuat sebuah hubungan yang hampir tidak terbantahkan antara semua transaksi yang terkait dengan alamat tersebut. Walaupun hal ini tidak secara langsung membahayakan dana Anda, karena enkripsi pada kurva elips memastikan keamanan kunci pribadi Anda, hal ini memudahkan untuk memonitor aktivitas Anda. Faktanya, siapa pun yang memiliki node dapat mengamati transaksi dan saldo alamat Anda, yang sepenuhnya membahayakan anonimitas Anda.

![BTC204](assets/it/34/01.webp)

Untuk mengilustrasikan hal ini, mari kita ambil contoh Bob, seorang pengguna yang secara teratur membeli bitcoin dalam jumlah kecil melalui Dollar Cost Averaging (DCA) dan selalu mengirimkannya ke alamat yang sama. Setelah dua tahun, alamat ini berisi sejumlah besar bitcoin. Jika Bob menggunakan alamat ini untuk melakukan pembayaran ke pedagang lokal, pedagang tersebut dapat melihat semua dana yang terkait dan mengurangi kekayaan Bob. Hal ini dapat menimbulkan risiko keamanan pribadi, termasuk upaya pencurian atau pemerasan. Jika Bob menggunakan alamat baru untuk menerima setiap pembelian berkala, dia akan mengungkapkan informasi yang jauh lebih sedikit kepada pedagang.

Dalam analisis rantai, kami membedakan antara 2 jenis penggunaan ulang alamat:


- Penggunaan ulang eksternal;
- Penggunaan ulang internal dalam suatu transaksi.

Yang pertama diamati ketika sebuah alamat digunakan kembali dalam beberapa transaksi Bitcoin yang berbeda. Inilah yang telah kita bahas sebelumnya: heuristik ini memungkinkan kita untuk menyimpulkan bahwa semua UTXO yang dilewatkan melalui alamat ini adalah milik satu entitas.

Penggunaan ulang alamat internal tidak diamati ketika penggunaan ulang terjadi di beberapa transaksi, tetapi ketika terjadi dalam transaksi yang sama. Memang, jika alamat yang sama yang digunakan untuk mengunci input digunakan sebagai output dalam sebuah transaksi, maka kita dapat menyimpulkan bahwa output ini masih milik pengguna yang sama (sisa), dan bahwa output kedua mewakili pembayaran yang sebenarnya. Heuristik lain ini memungkinkan dana untuk dilacak di beberapa transaksi.

![BTC204](assets/it/33/02.webp)

Penggunaan ulang alamat adalah momok yang nyata pada Bitcoin. Menurut situs web OXT.me (saat ini tidak dapat diakses), tingkat penggunaan ulang alamat Bitcoin secara keseluruhan sekitar 52 persen pada tahun 2022:

![BTC204](assets/fr/069.webp)

Angka ini sangat besar, tetapi sebagian besar berasal dari platform pertukaran daripada pengguna individu.

### Bagaimana cara menghindari penggunaan ulang alamat?

Menghindari penggunaan ulang alamat cukup mudah: **hanya gunakan alamat baru untuk setiap pembayaran baru yang masuk ke dompet Anda**.

Berkat BIP32, portofolio modern sekarang bersifat deterministik dan hirarkis. Ini berarti bahwa seorang pengguna dapat menghasilkan sejumlah besar alamat dari satu informasi awal: seed. Dengan menyimpan satu informasi ini, semua private key di dalam dompet dapat dipulihkan, sehingga dapat mengakses dana yang diamankan oleh alamat yang sesuai.

![BTC204](assets/fr/070.webp)

Itulah sebabnya, ketika Anda menekan tombol "_receive_" pada perangkat lunak dompet Anda, Anda akan ditawarkan alamat penerima yang tidak terpakai setiap kali. Setelah menerima bitcoin di alamat ini, perangkat lunak secara otomatis menyarankan alamat baru.

> nB: Baru-baru ini, beberapa perangkat lunak dompet telah mengumumkan niatnya untuk berhenti membuat alamat kosong, karena khawatir hal ini akan dianggap sebagai bentuk pencucian uang oleh pihak berwenang. Jika perangkat lunak Anda termasuk di antaranya, saya sangat menyarankan Anda untuk segera menggantinya, karena hal ini tidak dapat diterima oleh pengguna._
Jika Anda membutuhkan pengenal statis untuk menerima pembayaran, seperti untuk menerima donasi, misalnya, menggunakan alamat Bitcoin klasik tidak disarankan karena risiko penggunaan ulang. Anda lebih suka menggunakan alamat Lightning, atau untuk pengenal pembayaran onchain statis, Anda bisa memilih BIP47 atau Silent Payments. Cara kerja protokol-protokol ini akan dijelaskan secara rinci di Bagian 6 pelatihan ini.

## Pelabelan dan Kontrol Koin

<chapterId>fbdb07cd-c025-48f2-97b0-bd1bc21c68a8</chapterId>

Seperti yang telah kita temukan pada bagian analisis rantai, ada banyak heuristik dan pola yang dapat digunakan untuk menyimpulkan informasi mengenai sebuah transaksi. Sebagai pengguna, penting untuk mengetahui teknik-teknik ini untuk melindungi diri Anda dengan lebih baik.

Hal ini sangat melibatkan manajemen yang ketat terhadap dompet seseorang dalam penjagaan pribadi, yang mencakup mengetahui asal UTXO, serta pemilihan UTXO yang akan digunakan selama pembayaran. Manajemen dompet yang efektif ini bergantung pada dua fitur penting dari dompet Bitcoin yang baik: pelabelan dan kontrol koin.

Pada bab ini, kita akan mempelajari fitur-fitur ini dan melihat bagaimana Anda dapat menggunakannya dengan cerdas, tanpa menambah beban kerja, untuk mengoptimalkan privasi Anda di Bitcoin.

### Apa yang dimaksud dengan Pelabelan?

Penandaan adalah sebuah praktik yang melibatkan pemberian anotasi atau label pada UTXO tertentu di dalam dompet Bitcoin. Anotasi ini disimpan secara lokal oleh perangkat lunak dompet dan tidak pernah dikirimkan melalui jaringan Bitcoin. Oleh karena itu, penandaan adalah alat untuk manajemen pribadi.

Misalnya, jika saya memiliki UTXO dari pembelian P2P di Bisq dengan Charles, saya dapat memberikan label "`Non-KYC Bisq Charles`".

Penandaan adalah praktik yang baik untuk membantu mengingat asal atau tujuan UTXO, sehingga memudahkan pengelolaan dana dan mengoptimalkan privasi. Faktanya, dompet Bitcoin Anda mungkin berisi beberapa UTXO. Jika sumber UTXO ini berbeda, Anda mungkin tidak ingin menggabungkan UTXO ini di masa mendatang, jika tidak, Anda dapat mengungkapkan kepemilikan bersama mereka. Dengan memberi label yang tepat pada semua koin Anda, Anda memastikan bahwa Anda akan mengingat asal-usulnya ketika Anda membutuhkannya, bahkan jika itu baru terjadi beberapa tahun lagi.

### Apa yang dimaksud dengan kontrol koin?

Penggunaan aktif penandaan menjadi lebih menarik ketika digabungkan dengan opsi kontrol koin pada perangkat lunak dompet Anda.

Kontrol koin adalah sebuah fitur yang terdapat pada perangkat lunak dompet Bitcoin yang baik yang memberikan Anda kemampuan untuk memilih secara manual UTXO tertentu untuk digunakan sebagai input dalam melakukan sebuah transaksi. Faktanya, untuk memenuhi pembayaran keluar, Anda harus menggunakan UTXO yang masuk sebagai gantinya. Untuk beberapa alasan yang akan kita lihat nanti, Anda mungkin ingin memilih dengan tepat koin mana yang akan digunakan sebagai input untuk memenuhi pembayaran tertentu. Inilah yang dimungkinkan oleh kontrol koin. Sebagai analogi, fungsi ini mirip dengan tindakan memilih koin tertentu di dompet Anda saat Anda membayar baguette.

Penggunaan perangkat lunak dompet yang dikendalikan koin, dikombinasikan dengan pelabelan UTXO, memungkinkan pengguna untuk secara akurat membedakan dan memilih UTXO untuk transaksi mereka.

### Bagaimana cara memberi label UTXO Anda dengan benar?

Tidak ada metode universal untuk memberi label UTXO yang cocok untuk semua orang. Terserah Anda untuk menentukan sistem pelabelan sehingga Anda dapat dengan mudah menavigasi portofolio Anda. Bagaimanapun, perlu diingat bahwa pelabelan yang baik adalah yang dapat Anda pahami saat Anda membutuhkannya. Jika dompet Bitcoin Anda hanya untuk menyimpan, mungkin label-label tersebut tidak akan berguna bagi Anda hingga beberapa dekade mendatang. Oleh karena itu, pastikan label tersebut jelas, akurat, dan inklusif.

Penting agar orang yang Anda cintai dapat dengan mudah mengidentifikasi sumber dana jika suatu hari mereka membutuhkan akses ke portofolio Anda. Hal ini dapat membantu mereka untuk alasan privasi dan juga untuk kebutuhan hukum, jika mereka perlu menjelaskan asal usul dana di hadapan pihak berwenang.

Aspek terpenting dari pelabelan adalah mencatat sumber UTXO. Anda cukup menunjukkan bagaimana koin ini tiba di dompet Anda. Apakah berasal dari pembelian di platform bursa? Pembayaran dari pelanggan? Pertukaran peer-to-peer? Atau apakah itu sisa dari pembelian? Jadi, Anda dapat menentukannya:


- `Pickup Exchange.com`;
- `Klien Pembayaran David`;
- 'Beli P2P Charles';
- 'Menahan diri dari pembelian sofa'

Untuk menyempurnakan pengelolaan UTXO Anda dan mematuhi strategi pemisahan dana dalam portofolio Anda, Anda dapat memperkaya label Anda dengan penanda tambahan untuk mencerminkan pemisahan ini. Jika portofolio Anda berisi dua kategori UTXO yang tidak ingin Anda campur, Anda dapat mengintegrasikan penanda ke dalam label Anda untuk membedakan kelompok-kelompok ini dengan jelas. Penanda pemisahan ini akan bergantung pada kriteria Anda, seperti membedakan antara UTXO dari proses akuisisi yang melibatkan KYC, atau antara dana profesional dan dana pribadi. Mengambil contoh label yang telah disebutkan sebelumnya, hal ini dapat diterjemahkan menjadi:


- `KYC - Penarikan Exchange.com`;
- 'KYC - Pembayaran Pelanggan David';
- `TANPA KYC - Beli P2P Charles`;
- `TANPA KYC - Sisa dari pembelian sofa`

Juga disarankan untuk mengabadikan pelabelan koin selama transaksi. Contohnya, ketika mengkonsolidasikan UTXO tanpa KYC, pastikan untuk menandai UTXO yang dihasilkan tidak hanya sebagai `konsolidasi`, tetapi secara khusus sebagai `konsolidasi tanpa KYC` untuk menjaga jejak yang jelas mengenai asal usul koin.

Terakhir, tidak wajib untuk mencantumkan tanggal pada label. Kebanyakan perangkat lunak dompet sudah menampilkan tanggal transaksi, dan selalu memungkinkan untuk mengambil informasi ini pada penjelajah blok menggunakan TXID-nya.

### Bagaimana Cara Memilih Koin dengan Benar?

Ketika Anda melakukan transaksi, kontrol koin memungkinkan Anda untuk secara khusus memilih UTXO mana yang akan digunakan sebagai input untuk memenuhi output pembayaran. Ada dua aspek yang harus dipertimbangkan dalam pilihan ini:


- Kemampuan penerima pembayaran untuk menautkan bagian dari identitas Anda ke UTXO yang digunakan sebagai input;
- Kemampuan pengamat luar untuk membuat koneksi di antara semua UTXO yang dikonsumsi sebagai input.

Untuk mengilustrasikan poin pertama, mari kita ambil contoh konkret. Misalkan Anda membeli roti baguette dengan bitcoin dari toko roti lokal Anda. Anda menggunakan satu atau beberapa UTXO milik Anda sendiri sebagai input untuk membayar setidaknya harga baguette sebagai output, ditambah biaya transaksi. Tukang roti Anda kemudian berpotensi mengaitkan wajah Anda, atau bagian lain dari identitas Anda yang dia ketahui, dengan koin yang digunakan sebagai input. Dengan mengetahui keberadaan tautan ini, Anda mungkin lebih memilih untuk memilih satu UTXO tertentu daripada yang lain saat melakukan pembayaran.

Misalnya, jika salah satu UTXO Anda berasal dari platform pertukaran dan Anda lebih suka agar pembuat roti tidak mengetahui akun Anda di platform ini, Anda tidak akan menggunakan UTXO ini untuk pembayaran. Jika Anda memiliki UTXO bernilai tinggi yang menunjukkan jumlah bitcoin yang signifikan, Anda juga dapat memilih untuk tidak menggunakannya agar pembuat roti tidak mengetahui kekayaan BTC Anda.

Oleh karena itu, pilihan UTXO yang akan digunakan untuk poin pertama ini didasarkan pada keputusan pribadi, yang dipengaruhi oleh apa yang ingin Anda ungkapkan atau tidak. Label yang telah Anda tetapkan pada UTXO setelah diterima akan membantu Anda memilih UTXO yang, ketika dibelanjakan, hanya menampilkan informasi yang Anda inginkan untuk diungkapkan kepada penerima.

Selain informasi yang berpotensi diungkapkan kepada penerima, pilihan input Anda juga memengaruhi apa yang Anda ungkapkan kepada semua pengamat blockchain. Faktanya, dengan menggunakan beberapa UTXO sebagai input untuk transaksi Anda, Anda mengungkapkan bahwa mereka dimiliki oleh entitas yang sama, menurut Heuristik Kepemilikan Umum Input (CIOH).

Ketika Anda memilih koin, Anda harus menyadari bahwa transaksi yang akan Anda kirimkan akan membuat tautan antara semua UTXO yang digunakan. Tautan ini dapat menjadi masalah bagi privasi pribadi Anda, terutama jika UTXO berasal dari sumber yang berbeda.

Kembali ke contoh UTXO saya tanpa KYC dari Bisq; saya ingin menghindari menggabungkannya dengan UTXO dari, katakanlah, platform bursa teregulasi yang mengetahui identitas saya. Faktanya, jika saya menggunakan 2 UTXO ini sebagai input dalam transaksi yang sama, platform yang teregulasi akan dapat menautkan identitas saya dengan UTXO yang saya beli di Bisq, padahal sebelumnya tidak ditautkan dengan identitas saya.

Terakhir, untuk memilih UTXO mana yang akan digunakan sebagai input untuk transaksi, yang paling penting adalah hindari menggunakan banyak UTXO. Jika memungkinkan, pilihlah satu koin yang cukup besar untuk menutupi pembayaran Anda. Dengan demikian, Anda benar-benar menghindari risiko yang terkait dengan COINJOIN. Namun, jika tidak ada UTXO yang cukup untuk pembayaran Anda dan Anda perlu menggunakan beberapa UTXO, pastikan UTXO tersebut berasal dari sumber yang sama untuk meminimalkan risiko koneksi yang tidak diinginkan. Selain itu, perlu diingat bahwa penerima dapat mengaitkan informasi yang mereka miliki tentang Anda dengan riwayat koin yang digunakan sebagai input.

### Memahami Pemilihan Koin Otomatis

Pada bagian sebelumnya, kita telah membahas pemilihan UTXO secara manual untuk sebuah transaksi. Namun, apa yang terjadi jika perangkat lunak dompet melakukan pemilihan ini secara otomatis? Ada beberapa metode untuk menentukan koin mana yang akan digunakan, dan pemilihan UTXO adalah bidang penelitian yang nyata dalam Bitcoin. Tujuan utama dari proses otomatis ini sering kali adalah untuk meminimalkan biaya transaksi bagi pengguna.

Metode pemilihan UTXO seperti FIFO (_First In First Out_) dan LIFO (_Last In First Out_) adalah yang paling sederhana tetapi juga paling tidak efisien. Dengan FIFO, koin tertua dalam portofolio akan digunakan terlebih dahulu. Pendekatan ini secara umum tidak efisien untuk meminimalisir biaya transaksi dan untuk menjaga privasi, kecuali dalam kasus di mana penguncian waktu relatif digunakan dan harus diperbarui secara teratur. Sebaliknya, LIFO memprioritaskan penggunaan UTXO terbaru. Meskipun sederhana, kedua metode ini sering kali terbukti tidak efisien.

Metode yang lebih canggih adalah _Knapsack Solver_. Ini adalah metode yang digunakan dalam dompet Bitcoin Core hingga versi 0.17. Metode ini melibatkan pemilihan UTXO secara berulang dan acak dari dompet, menjumlahkannya ke dalam subkelompok, dan menyimpan solusi yang mengurangi bobot transaksi sebanyak mungkin untuk mengurangi biaya pengguna.

Algoritma _Branch-and-Bound_ (BNB), yang sering dijuluki "Algoritma Murch" mengacu pada penemunya, menggantikan _Knapsack Solver_ di Bitcoin Core mulai dari versi 0.17. Metode yang lebih canggih ini bertujuan untuk menemukan sekumpulan UTXO yang sama persis dengan jumlah yang dibutuhkan untuk memenuhi hasil transaksi. Tujuan dari BNB adalah untuk meminimalkan jumlah sisa dan juga biaya dengan mengurangi apa yang disebut dengan kriteria pemborosan yang memperhitungkan biaya langsung dan juga biaya yang diharapkan di masa depan untuk sisa tersebut. Metode ini berasal dari konsep _Branch-and-Bound_ yang asli, yang dirancang pada tahun 1960 oleh Ailsa Land dan Alison Harcourt, dan menawarkan optimasi komisi yang lebih tepat daripada _Knapsack Solver_.

Semua metode pemilihan UTXO otomatis ini dapat efektif dalam mengurangi biaya transaksi, tetapi sering kali tidak efisien dalam menjaga privasi pengguna. Faktanya, algoritme ini dapat menggabungkan beberapa UTXO ke dalam input, sehingga mengungkapkan kepemilikan bersama dari UTXO ini karena COH. Tentunya, metode ini tidak dapat memperhitungkan label yang dilampirkan pada UTXO, yang sangat penting untuk secara sadar memilih koin mana yang akan diungkapkan kepada penerima transaksi. Saat ini, satu-satunya solusi untuk mengoptimalkan privasi dalam pemilihan koin adalah dengan melakukannya secara manual.

### Tutorial Pelabelan UTXO

Jika Anda ingin mengetahui cara menandai UTXO Anda, kami telah menyusun sebuah tutorial komprehensif mengenai perangkat lunak dompet Bitcoin utama yang ada:

https://planb.network/tutorials/privacy/on-chain/utxo-labelling-d997f80f-8a96-45b5-8a4e-a3e1b7788c52
## KYC dan Identifikasi Kunci

<chapterId>cec6b9d9-0eed-4f85-bc4e-1e9aa59ca605</chapterId>

KYC adalah singkatan dari "Know Your Customer", yang merupakan prosedur regulasi yang diterapkan oleh beberapa perusahaan yang beroperasi di industri Bitcoin. Prosedur ini bertujuan untuk memverifikasi dan mencatat identitas pelanggan mereka dengan tujuan untuk memerangi pencucian uang dan pendanaan teroris.

Konkretnya, KYC melibatkan pengumpulan berbagai informasi pribadi dari klien, yang mungkin berbeda menurut yurisdiksi, tetapi umumnya mencakup ID, foto, dan bukti tempat tinggal. Informasi ini kemudian diverifikasi dan disimpan untuk digunakan di masa mendatang.

Prosedur ini telah menjadi wajib untuk semua platform bursa yang teregulasi di sebagian besar negara Barat. Ini berarti siapa pun yang ingin menukarkan mata uang fiat dengan bitcoin melalui platform ini harus mematuhi persyaratan KYC.

Prosedur ini bukannya tanpa risiko terhadap privasi dan keamanan pengguna. Pada bab ini, kami akan membahas risiko-risiko tersebut secara mendetail dan menganalisa dampak spesifik dari proses KYC dan identifikasi terhadap privasi pengguna Bitcoin.

### Memfasilitasi Pelacakan Onchain

Resiko pertama yang terkait dengan KYC adalah bahwa KYC menyediakan sebuah titik masuk yang lebih disukai untuk analisis blockchain. Seperti yang telah kita lihat pada bagian sebelumnya, analis dapat mengelompokkan dan melacak aktivitas pada blockchain dengan menggunakan pola transaksi dan heuristik. Ketika mereka berhasil mengelompokkan aktivitas pengguna di dalam blockchain, hanya dengan menemukan satu titik masuk di antara semua transaksi dan kunci, hal ini sudah cukup untuk mengkompromikan privasi mereka.

![BTC204](assets/fr/078.webp)

Ketika Anda mengirimkan ke KYC, Anda memberikan titik masuk yang sangat berkualitas tinggi untuk analisis rantai, karena Anda menautkan alamat penerima yang digunakan ketika Anda menarik bitcoin dari platform bursa ke identitas lengkap Anda yang terverifikasi. Secara teori, informasi ini hanya diketahui oleh perusahaan tempat Anda memberikannya, namun, seperti yang akan kita lihat nanti, risiko kehilangan data adalah nyata. Selain itu, fakta bahwa perusahaan menyimpan informasi ini bisa menjadi masalah, bahkan jika mereka tidak membagikannya.

Dengan demikian, kecuali jika ada tindakan lain yang diambil untuk membatasi penyatuan aktivitas seseorang di blockchain, siapa pun yang mengetahui titik masuk KYC berpotensi menghubungkan semua aktivitas mereka di Bitcoin dengan identitas mereka. Dari sudut pandang perusahaan ini, penggunaan Bitcoin akan kehilangan semua kerahasiaannya.

![BTC204](assets/fr/079.webp)

Sebagai perbandingan, seolah-olah seorang bankir di _Bank X_ memiliki akses tidak hanya ke semua transaksi yang dilakukan dengan _Bank X_, tetapi juga dapat mengamati transaksi dengan _Bank Y_ dan semua transaksi tunai miliknya.

Ingatlah kembali bagian pertama dari pelatihan ini: model privasi Bitcoin, seperti yang dirancang oleh Satoshi Nakamoto, didasarkan pada pemisahan antara identitas pengguna dan pasangan kuncinya. Walaupun lapisan privasi ini tidak lagi memadai saat ini, namun tetaplah bijaksana untuk membatasi degradasinya sebanyak mungkin.

### Paparan terhadap Pengawasan Negara

Masalah utama kedua dengan KYC adalah bahwa KYC mengungkapkan kepada negara bahwa seseorang telah memiliki bitcoin pada suatu waktu. Ketika Anda membeli bitcoin melalui pihak yang teregulasi, maka negara dapat mengetahui kepemilikan ini. Saat ini, hal ini mungkin terlihat sepele, tetapi penting untuk diingat bahwa masa depan politik dan ekonomi suatu negara tidak berada di tangan seseorang.

Pertama-tama, negara dapat dengan cepat mengadopsi sikap otoriter. Sejarah penuh dengan contoh-contoh di mana kebijakan berubah secara tiba-tiba. Saat ini, di Eropa, para penggemar Bitcoin dapat menulis artikel tentang Bitcoin, menghadiri konferensi, dan mengelola dompet penyimpanan sendiri. Namun, siapa yang bisa mengatakan apa yang akan terjadi di hari esok? Jika Bitcoin tiba-tiba menjadi musuh publik nomor satu, dikaitkan dengan Bitcoin dalam daftar negara bisa menjadi masalah.

Nantinya, dalam menghadapi krisis ekonomi yang parah, negara dapat mempertimbangkan untuk menyita bitcoin yang dimiliki oleh warga negara. Mungkin besok, para pengguna bitcoin akan dianggap mengambil keuntungan dari krisis dan akan dikenai pajak yang terlalu tinggi karena keuntungan modal mereka dalam menghadapi devaluasi mata uang fiat.

Anda mungkin berpikir bahwa ini bukan masalah karena bitcoin Anda dikocok dan karenanya tidak dapat dilacak. Namun, ketertelusuran bukanlah masalah di sini. Masalah yang sebenarnya adalah negara mengetahui bahwa Anda telah memiliki bitcoin. Informasi sederhana ini bisa jadi cukup untuk memberatkan Anda atau meminta pertanggungjawaban Anda. Anda bisa saja mengklaim bahwa Anda membelanjakan bitcoin Anda, namun hal tersebut akan tercermin dalam pengembalian pajak Anda, dan Anda akan ketahuan. Anda juga bisa mengatakan bahwa Anda kehilangan kunci Anda dalam sebuah kecelakaan perahu, tetapi di luar lelucon Twitter, apakah Anda benar-benar berpikir bahwa itu akan cukup untuk membebaskan Anda?

Oleh karena itu, penting untuk mempertimbangkan risiko yang terkait dengan fakta sederhana bahwa negara mungkin mengetahui bahwa Anda memiliki BTC, meskipun risiko ini mungkin terlihat jauh hari ini.

Masalah lain yang ditimbulkan oleh KYC dalam hal pengawasan negara adalah pelaporan wajib oleh platform yang diatur. Meskipun saya tidak terbiasa dengan peraturan di yurisdiksi lain, di Prancis, _Penyedia Layanan Aset Digital_ (PSAN) diwajibkan untuk melaporkan kepada pengawas keuangan setiap pergerakan dana yang mereka anggap mencurigakan.

Dengan demikian, di Prancis pada tahun 2023, 1.449 tindakan mencurigakan dilaporkan oleh PSAN. Untuk saat ini, sebagian besar tindakan ini terkait dengan kejahatan. Namun, pihak berwenang juga meminta platform yang teregulasi untuk melaporkan transaksi Bitcoin yang mencurigakan hanya berdasarkan strukturnya. Jika Anda melakukan transaksi kolaboratif, atau bahkan hanya sebuah transaksi yang memiliki pola yang tidak lazim, dan transaksi ini terjadi di dekat penarikan bitcoin Anda dari platform-platform ini, Anda mungkin akan dilaporkan ke pihak berwenang. Bahkan jika tidak ada kesalahan dan Anda menggunakan hak-hak Anda secara sah, pelaporan ini dapat menyebabkan peningkatan pengawasan dan pengawasan, ketidaknyamanan yang dapat Anda hindari tanpa KYC.

### Risiko kehilangan data pribadi

Masalah lain dengan KYC terletak pada kenyataan bahwa KYC mengharuskan penyimpanan semua data pribadi Anda di server perusahaan swasta. Kejadian-kejadian baru-baru ini telah mengingatkan kita bahwa tidak ada yang kebal terhadap kegagalan, baik yang berhubungan dengan keuangan maupun TI. Pada tahun 2022, pelanggan Celsius menderita akibatnya. Sebagai akibat dari kebangkrutan perusahaan, nama-nama kreditor dan jumlah aset mereka dipublikasikan oleh sistem peradilan AS selama proses administrasi.

Lebih dari dua tahun yang lalu, sebuah entitas keamanan siber terkemuka di dunia mata uang kripto mengalami pencurian data pribadi pelanggannya. Meskipun kejadian ini tidak secara langsung berkaitan dengan pembelian bitcoin, risiko ini juga tetap ada pada platform bursa. Oleh karena itu, ada risiko yang pasti terkait dengan data pribadi ini.

Memang benar bahwa kita telah mempercayakan sebagian besar data pribadi kita kepada perusahaan swasta. Akan tetapi, risikonya ada dua, karena data ini tidak hanya memungkinkan Anda untuk diidentifikasi, tetapi juga terkait dengan aktivitas di bitcoin. Memang, ketika seorang peretas dapat mengakses data pelanggan platform bursa, mereka dapat berasumsi bahwa pelanggan ini memiliki bitcoin. Risiko ini diperparah dengan fakta bahwa bitcoin, seperti aset berharga lainnya, menarik minat para pencuri.

Jika terjadi pelanggaran data, kemungkinan besar, Anda bisa menjadi target upaya phishing yang ditargetkan. Yang terburuk, Anda bisa menemukan diri Anda berada di tengah-tengah ancaman fisik terhadap rumah Anda.

Selain risiko spesifik yang terkait dengan Bitcoin, perlu juga mempertimbangkan bahaya yang terkait dengan pengiriman dokumen identitas. Memang, jika terjadi kebocoran data, ada kemungkinan untuk menjadi korban pencurian identitas. Oleh karena itu, masalah yang dipertaruhkan tidak hanya terbatas pada perlindungan kerahasiaan transaksi, tetapi juga mempengaruhi keamanan pribadi setiap individu.

### Kesalahpahaman umum mengenai KYC

Penting untuk menghilangkan beberapa kesalahpahaman umum tentang KYC yang sering ditemukan di Twitter atau dalam diskusi kami di antara para pengguna bitcoin.

Pertama-tama, salah jika Anda berpikir bahwa melindungi privasi seseorang untuk bitcoin yang diperoleh melalui KYC (Kenali Pelanggan Anda) tidak berguna. Alat dan metode untuk privasi pada bitcoin bervariasi dan memiliki tujuan yang berbeda. Menggunakan transaksi coinjoin pada bitcoin dari KYC, misalnya, bukanlah ide yang buruk. Tentu saja, Anda harus berhati-hati dengan platform bursa yang teregulasi untuk menghindari akun Anda dibekukan atau diblokir, tetapi dari sudut pandang teknis, praktik-praktik ini tidak bertentangan. Coinjoin memiliki efek mengganggu riwayat koin, yang membantu mengatasi beberapa risiko analisis rantai yang terkait dengan KYC. Walaupun tidak menghilangkan semua risiko, hal ini sudah merupakan sebuah manfaat yang signifikan.

Privasi pada bitcoin tidak boleh dilihat secara biner, sebagai perbedaan antara bitcoin "anonim" dan bitcoin lainnya yang tidak anonim. Memiliki bitcoin yang diperoleh melalui KYC tidak berarti bahwa semuanya hilang; sebaliknya, penggunaan alat privasi mungkin terbukti lebih bermanfaat.

Sebaliknya, mendapatkan bitcoin melalui metode non-KYC tidak menjamin privasi yang sempurna dan tidak membebaskan Anda dari kebutuhan untuk mengambil tindakan perlindungan lainnya. Jika Anda memiliki bitcoin non-KYC namun menggunakan alamat penerima beberapa kali, transaksi Anda dapat dilacak dan dikelompokkan. Hubungan sekecil apa pun dengan dunia di luar bitcoin dapat membahayakan satu lapisan privasi yang Anda miliki. Oleh karena itu, penting untuk mempertimbangkan semua alat dan metode yang meningkatkan privasi pada Bitcoin sebagai pelengkap. Setiap teknik mengatasi risiko tertentu dan dapat menambahkan lapisan perlindungan tambahan. Dengan demikian, memiliki bitcoin non-KYC sama sekali tidak membebaskan Anda dari tindakan pencegahan lainnya.

### Apakah KYC dapat dibatalkan?

Saya terkadang ditanya apakah mungkin untuk "kembali" setelah menyelesaikan KYC dan, seperti yang bisa Anda bayangkan dari paragraf sebelumnya, jawabannya bernuansa. Untuk menghindari risiko yang terkait dengan KYC, metode yang paling sederhana adalah dengan tidak menggunakannya saat membeli bitcoin. Kami akan menguraikan topik ini di bab selanjutnya. Akan tetapi, jika KYC sudah dilakukan dan bitcoin sudah dibeli, adakah cara untuk mengurangi risiko yang ditimbulkan?

Untuk risiko pelacakan transaksi Anda, penggunaan coinjoin adalah salah satu solusinya. Kita akan membahas metode ini secara mendetail nanti dalam pelatihan, tetapi ketahuilah bahwa coinjoin dapat mengacaukan riwayat koin dan mencegah ketertelusuran masa lalu-sekarang dan masa lalu-sekarang. Bahkan untuk BTC yang diperoleh melalui platform yang teregulasi, teknik ini dapat mencegah ketertelusurannya.

Akan tetapi, coinjoin tidak menghilangkan risiko kedua yang terkait dengan KYC: fakta bahwa negara mengetahui kepemilikan bitcoin Anda. Bahkan, meskipun koin Anda tidak lagi dapat dilacak, negara, tergantung pada yurisdiksinya, mungkin memiliki akses ke pernyataan alienasi kripto-aktif Anda. Karena risiko ini tidak bersifat teknis tetapi administratif, tidak ada solusi khusus bitcoin untuk menghilangkannya, selain menghindari paparan terhadap KYC. Satu-satunya pendekatan legal untuk mengurangi risiko ini adalah dengan menjual bitcoin Anda yang diperoleh melalui platform teregulasi pada platform teregulasi, dan kemudian membelinya kembali melalui cara tanpa KYC. Dengan menjual dan mendeklarasikan pelepasannya, administrasi akan mencatat bahwa Anda tidak lagi memilikinya.

Mengenai risiko data pribadi dan dokumen identitas Anda terungkap, ini adalah bahaya di luar Bitcoin, dan tidak ada solusi teknis untuk menghindarinya. Setelah data Anda diungkapkan, sulit untuk membalikkan keadaan. Anda bisa mencoba menutup akun Anda di platform, tetapi ini tidak menjamin penghapusan data KYC Anda, terutama jika verifikasi identitas dialihdayakan. Memverifikasi penghapusan informasi Anda sepenuhnya tidak mungkin dilakukan. Oleh karena itu, tidak ada solusi untuk sepenuhnya mencegah risiko ini dan memastikan bahwa risiko ini tidak ada lagi.

### Perbedaan antara KYC dan identifikasi kunci

Terkadang, beberapa pengguna bitcoin cenderung memperluas istilah "KYC" ke setiap pertukaran BTC yang melibatkan transfer atau pembayaran kartu kredit, karena cara-cara ini juga dapat mengungkapkan asal pembayaran, seperti halnya KYC. Akan tetapi, penting untuk tidak mengacaukan KYC dengan identifikasi kunci. Secara pribadi, saya harus mengakui bahwa persepsi saya tentang topik ini telah berkembang seiring berjalannya waktu.

KYC secara khusus merujuk pada prosedur regulasi yang diterapkan oleh beberapa perusahaan untuk memverifikasi dan mencatat identitas pelanggan mereka. Ini adalah masalah biner: ketika Anda memperoleh bitcoin, Anda tunduk pada KYC, atau tidak. Akan tetapi, identifikasi kunci, yang merupakan sebuah aspek dari identitas pengguna dengan aktivitas onchain, tidaklah bersifat biner, melainkan mewakili sebuah kontinum. Memang, dalam konteks membeli atau menjual bitcoin, identifikasi ini selalu memungkinkan dalam berbagai tingkatan.

Contohnya, jika Anda membeli bitcoin di platform teregulasi di Swiss, KYC (Kenali Pelanggan Anda) tidak diperlukan. Akan tetapi, mungkin ada identifikasi kunci Anda karena pembelian dilakukan melalui rekening bank Anda. Di sinilah dua risiko pertama yang terkait dengan KYC muncul - memfasilitasi pelacakan onchain dan paparan terhadap pengawasan pemerintah - yang juga dapat muncul di bursa non-KYC. Jika entitas Swiss melaporkan transaksi yang mencurigakan kepada pihak berwenang di negara Anda, mereka dapat dengan mudah memeriksa rekening bank yang digunakan untuk pembelian untuk menemukan identitas Anda. Dengan demikian, membeli tanpa KYC pada platform teregulasi memiliki skala risiko yang cukup tinggi untuk identifikasi kunci.

Akan tetapi, menghindari platform yang teregulasi dan memilih metode akuisisi P2P (Peer-to-Peer) tidak sepenuhnya menghilangkan risiko identifikasi kunci, tetapi hanya menguranginya. Pertimbangkan contoh pembelian di Bisq atau platform P2P lainnya. Untuk menyelesaikan dengan mitra Anda, Anda mungkin akan menggunakan rekening bank Anda. Jika pihak berwenang menanyai orang yang Anda ajak bertransaksi dan meminta nama Anda, kita akan menghadapi risiko 1 dan 2 yang disebutkan di atas. Risiko-risiko ini tentu saja jauh lebih rendah daripada pembelian non-KYC di platform, dan bahkan lebih rendah daripada pembelian dengan KYC, tetapi masih ada pada tingkat yang lebih rendah.

Terakhir, meskipun Anda membeli bitcoin melalui penukaran uang tunai secara fisik, Anda tidak sepenuhnya anonim. Orang yang bertransaksi dengan Anda melihat wajah Anda, yang merupakan bagian dari identitas Anda. Meskipun minimal dalam contoh ini, kemungkinan adanya kunci identifikasi masih ada.

Kesimpulannya, selama pertukaran bitcoin dengan aset lain, baik itu pembelian mata uang fiat atau penjualan aset riil, selalu ada suatu bentuk identifikasi kunci. Tergantung pada metode pertukaran yang dipilih, identifikasi ini dapat bervariasi dalam intensitasnya. Penting untuk tidak mengacaukan identifikasi ini dengan KYC, yang merupakan proses regulasi yang jelas. Akan tetapi, terdapat hubungan antara KYC dan spektrum identifikasi, karena KYC berada di ujung atas spektrum ini, karena secara sistematis memfasilitasi identifikasi kunci pengguna oleh pihak berwenang.

## Metode Penjualan dan Akuisisi

<chapterId>756598af-95aa-4c77-ac48-243c7ad89530</chapterId>

Setelah membaca bab sebelumnya, Anda mungkin bertanya-tanya bagaimana cara membeli atau menjual bitcoin tanpa harus menjalani proses verifikasi identitas untuk menghindari risiko yang terkait dengan KYC. Ada beberapa metode untuk melakukan pertukaran.

### Pertukaran P2P secara Tunai

Seperti yang telah kita lihat, metode terbaik dalam hal privasi tetaplah pertukaran P2P (peer-to-peer) dengan penyelesaian tunai. Metode ini memungkinkan Anda untuk meminimalkan jejak yang tertinggal dan secara signifikan mengurangi kemungkinan identifikasi kunci, apakah Anda seorang pembeli atau penjual.

Akan tetapi, praktik ini memiliki risiko keamanan pribadi. Bahaya utama terletak pada kenyataan bahwa, selama pertukaran, pihak lawan akan mengetahui bahwa Anda memiliki jumlah yang signifikan, baik dalam bentuk uang tunai atau bitcoin. Informasi ini dapat menarik perhatian orang-orang yang berniat jahat. Pada kenyataannya, secara umum disarankan untuk tetap berhati-hati mengenai kepemilikan bitcoin. Saran ini juga dapat diterapkan pada uang tunai. Namun, saat melakukan pertukaran secara langsung, tidak dapat dihindari untuk mengungkapkan bahwa Anda memiliki bitcoin, yang dapat menimbulkan keserakahan.

Untuk membatasi risiko ini, saya sarankan agar Anda memprioritaskan transaksi tunai dengan orang yang dipercaya, seperti anggota keluarga atau teman dekat. Sebagai alternatif, Anda juga dapat mempertimbangkan untuk melakukan pertukaran di [pertemuan Bitcoin lokal] (https://btcmap.org/communities/map), setelah menghadiri beberapa kali. Hal ini akan memungkinkan Anda untuk lebih mengenal peserta lain dan tidak sendirian saat melakukan pertukaran secara fisik. Namun, penting untuk diketahui bahwa pertukaran uang tunai P2P secara inheren memiliki risiko terhadap keamanan pribadi Anda yang tidak ada ketika melakukan pembelian melalui platform yang teregulasi dan rekening bank Anda.

Selain itu, tergantung di mana Anda tinggal, mengangkut dan menyimpan uang dalam jumlah besar dapat menimbulkan risiko, baik bitcoin maupun uang tunai.

Menukar uang tunai juga dapat menimbulkan risiko hukum saat pemeriksaan polisi atau pemeriksaan lainnya. Meskipun di sebagian besar negara tidak ada batasan jumlah uang tunai yang dapat Anda bawa, jumlah yang terlalu besar dapat menimbulkan kecurigaan. Oleh karena itu, berhati-hatilah, terutama jika Anda harus melakukan perjalanan jauh, dan hindari transaksi yang terlalu besar sekaligus sehingga Anda tidak perlu membenarkan kepemilikan uang tunai dalam jumlah yang signifikan.

Terakhir, kelemahan lain dari pembelian P2P adalah harganya yang sering kali lebih tinggi daripada yang teramati pada platform yang teregulasi. Penjual sering kali mengenakan biaya tambahan mulai dari 1% hingga lebih dari 10%. Ada beberapa alasan yang menjelaskan perbedaan harga ini. Pertama, ini adalah praktik umum di antara penjual P2P yang telah ditetapkan dari waktu ke waktu. Selain itu, penjual memiliki biaya transaksi yang terkait dengan pengiriman dana ke pembeli. Ada juga risiko pencurian yang lebih tinggi dalam penjualan P2P dibandingkan dengan transaksi platform, yang membenarkan biaya untuk risiko yang diambil. Terakhir, premi mungkin relatif terhadap permintaan dan kualitas bursa dalam hal privasi. Sebagai pembeli, keuntungan privasi dihargai dengan biaya tambahan yang dibebankan oleh penjual. Beberapa pengguna bitcoin juga percaya bahwa kenaikan harga BTC yang dibeli di P2P mencerminkan nilai sebenarnya dan berpendapat bahwa harga yang lebih rendah di platform yang diatur adalah hasil dari pertukaran privasi informasi pribadi Anda.

### Pertukaran P2P melalui Platform Pencocokan

Alternatif yang lebih tidak berisiko dalam hal keamanan pribadi adalah dengan melakukan pertukaran P2P secara eksklusif secara online, melalui metode pembayaran elektronik seperti PayPal, transfer bank, atau Revolut.

Pendekatan ini membantu menghindari banyak risiko yang terkait dengan transaksi tunai. Akan tetapi, risiko pihak lawan tidak memenuhi komitmennya selama pertukaran online lebih besar. Faktanya, selama pertukaran fisik, jika Anda menyerahkan uang kepada penjual yang tidak mengirimi Anda bitcoin sebagai imbalannya, Anda bisa langsung memanggilnya karena dia berdiri di depan Anda. Sebaliknya, secara online, seringkali tidak mungkin untuk menemukan seseorang yang telah mencuri dari Anda.

Untuk mengurangi risiko ini, platform pencocokan khusus dapat digunakan untuk bursa P2P. Platform-platform ini menggunakan mekanisme resolusi konflik untuk melindungi pengguna yang dirugikan. Umumnya, mereka menawarkan sistem escrow, di mana bitcoin disimpan hingga pembayaran dalam mata uang fiat dikonfirmasi oleh penjual.

Dalam hal keamanan pribadi, metode pembelian ini jauh lebih aman dibandingkan dengan pertukaran uang tunai secara fisik. Akan tetapi, seperti yang telah disebutkan sebelumnya, pertukaran P2P online meninggalkan lebih banyak jejak daripada pertukaran fisik, yang dapat merugikan privasi Bitcoin. Dengan menggunakan metode pembayaran fiat online seperti bank, Anda mengekspos lebih banyak informasi yang dapat memfasilitasi identifikasi kunci.

Sekali lagi, saya menyarankan agar Anda tidak melakukan transaksi besar dalam satu transaksi di platform ini. Dengan membagi transaksi Anda, Anda menyebarkan risiko yang terkait dengan potensi pencurian oleh pihak lawan.

Kerugian lain dari pembelian P2P adalah harganya sering kali lebih tinggi daripada yang terlihat pada platform yang teregulasi. Penjual sering kali mengenakan biaya tambahan mulai dari 1% hingga lebih dari 10%. Ada beberapa alasan yang menjelaskan perbedaan harga ini. Pertama, ini adalah praktik umum di antara penjual P2P yang telah ditetapkan dari waktu ke waktu. Selain itu, penjual memiliki biaya transaksi yang terkait dengan pengiriman dana ke pembeli. Ada juga risiko pencurian yang lebih tinggi dalam penjualan P2P dibandingkan dengan transaksi platform, yang membenarkan biaya untuk risiko yang diambil. Terakhir, premi mungkin relatif terhadap permintaan dan kualitas bursa dalam hal privasi. Sebagai pembeli, keuntungan privasi dihargai dengan biaya tambahan yang dibebankan oleh penjual. Beberapa pengguna bitcoin juga percaya bahwa harga yang lebih tinggi dari BTC yang dibeli secara P2P mencerminkan nilai sebenarnya dan berpendapat bahwa harga yang lebih rendah pada platform yang teregulasi adalah hasil dari pertukaran privasi informasi pribadi Anda.

Mengenai solusi, saya secara pribadi selalu menggunakan [Bisq] (https://bisq.network/) dan sangat puas dengan mereka. Sistem mereka sudah mapan dan tampaknya dapat diandalkan. Namun, Bisq hanya tersedia di PC dan antarmukanya mungkin terlalu rumit untuk pemula. Kerugian lainnya adalah Bisq beroperasi secara eksklusif dengan transaksi onchain, yang dapat menjadi mahal selama periode biaya transaksi yang tinggi pada Bitcoin.

-> Pelajari tentang tutorial kami di Bisq.

https://planb.network/tutorials/exchange/peer-to-peer/bisq-fe244bfa-dcc4-4522-8ec7-92223373ed04
Untuk pilihan yang lebih mudah, Anda bisa mencoba [Peach] (https://peachbitcoin.com/), sebuah aplikasi seluler yang memfasilitasi hubungan antara pembeli dan penjual dengan sistem penyelesaian sengketa yang terintegrasi. Prosesnya lebih intuitif daripada Bisq.

-> Pelajari tentang tutorial kami di Peach.

Pilihan online lainnya adalah [HodlHodl] (https://hodlhodl.com/), platform mapan yang menawarkan likuiditas yang baik, meskipun saya pribadi belum mengujinya.

-> Pelajari tentang tutorial kami di HodlHodl.

https://planb.network/tutorials/exchange/peer-to-peer/peach-wallet-db64fe42-17ca-4b24-abb8-e7d4c03b2028
https://planb.network/tutorials/exchange/peer-to-peer/hodlhodl-d7344cd5-6b18-40f5-8e78-2574a93a3879
Untuk solusi berbasis Lightning Network, Anda dapat mencoba [RoboSats] (https://learn.robosats.com/) dan [LNP2PBot] (https://lnp2pbot.com/). RoboSats dapat diakses melalui situs web dan relatif mudah digunakan. LNP2PBot lebih tidak lazim karena beroperasi melalui sistem pertukaran pada aplikasi perpesanan Telegram.

-> Lihat tutorial kami tentang RoboSats.

-> Lihat tutorial kami di LNP2PBot.

https://planb.network/tutorials/exchange/peer-to-peer/robosats-b60e4f7c-533a-4295-9f6d-5368152e8c06
https://planb.network/tutorials/exchange/peer-to-peer/lnp2pbot-v2-e6bcb210-610b-487d-970c-7cce85273e3c
### Platform teregulasi tanpa KYC

Tergantung pada negara tempat Anda tinggal, Anda mungkin memiliki akses ke platform teregulasi yang tidak memerlukan prosedur KYC untuk membeli atau menjual bitcoin. Di Swiss, misalnya, Anda bisa menggunakan platform seperti [Relai] (https://relai.app/) dan [MtPelerin] (https://www.mtpelerin.com/).

-> Pelajari tentang tutorial kami tentang Relai.

Seperti yang telah kita lihat pada bab sebelumnya, jenis platform ini menghindarkan Anda dari risiko yang terkait dengan prosedur KYC, tetapi platform ini memiliki tingkat risiko yang lebih tinggi untuk identifikasi kunci. Dalam hal privasi Bitcoin, platform ini menawarkan perlindungan yang lebih baik dibandingkan metode pembelian KYC, tetapi kurang menarik dibandingkan bursa P2P.

Akan tetapi, dalam hal keamanan pribadi, menggunakan platform ini jauh lebih kecil risikonya dibandingkan dengan bursa P2P. Platform ini juga lebih mudah digunakan daripada platform yang memfasilitasi pertukaran P2P.

https://planb.network/tutorials/exchange/centralized/relai-v2-30a9671d-e407-459d-9203-4c3eae15b30e
### ATM

Pilihan lain untuk membeli atau menjual bitcoin tanpa KYC adalah ATM mata uang kripto (ATM). Secara pribadi, saya tidak pernah berkesempatan untuk menguji solusi ini, karena tidak ada di negara saya. Tetapi metode ini bisa sangat menarik, tergantung di mana Anda tinggal.

Masalah dengan ATM adalah bahwa ATM dilarang di beberapa negara atau diatur secara ketat di negara lain. Jika ATM memerlukan proses verifikasi identitas, maka ATM menghadapi risiko yang sama dengan platform KYC yang teregulasi. Akan tetapi, jika ATM mengizinkan transaksi tanpa verifikasi identitas untuk jumlah yang kecil, maka penggunaannya dapat menawarkan tingkat privasi yang sebanding dengan pertukaran P2P berbasis uang tunai, menghindari sebagian besar risiko yang terkait dengan jenis pertukaran ini.

Kerugian utama ATM terletak pada biaya penukaran valuta asing yang sering kali tinggi, mulai dari beberapa persen hingga 15 persen dari jumlah yang ditukarkan.

### Kartu Hadiah

Terakhir, saya juga ingin menyajikan solusi yang bekerja dengan baik bagi mereka yang ingin menggunakan bitcoin mereka setiap hari untuk pembelian daripada menjualnya untuk mata uang fiat.

Cara terbaik untuk membelanjakan BTC adalah dengan menggunakan bitcoin secara langsung atau Lightning Network untuk membeli barang atau jasa. Namun, di banyak negara, jumlah pedagang yang menerima bitcoin masih terbatas. Oleh karena itu, alternatif praktisnya adalah dengan menggunakan kartu hadiah.

Beberapa platform yang tidak membutuhkan prosedur KYC menawarkan kemampuan untuk menukarkan bitcoin dengan kartu hadiah yang dapat digunakan di toko-toko besar. Platform-platform ini termasuk [CoinsBee] (https://www.coinsbee.com/), [The Bitcoin Company] (https://thebitcoincompany.com/), dan [Bitrefill] (https://www.bitrefill.com/). Platform-platform ini sangat memudahkan penggunaan bitcoin Anda sehari-hari dengan mengizinkan Anda untuk mengakses berbagai macam produk dan layanan tanpa harus melalui konversi mata uang fiat.

https://planb.network/tutorials/exchange/centralized/bitrefill-8c588412-1bfc-465b-9bca-e647a647fbc1
### Metode Akuisisi Lainnya

Di antara metode-metode lain untuk mendapatkan bitcoin sambil melindungi privasi Anda, tentu saja, adalah menambang. Untuk mulai menambang satoshi, Anda tidak perlu mengungkapkan identitas Anda; cukup temukan bukti pekerjaan yang valid dan kirimkan ke jaringan. Jika Anda memilih pooled mining, beberapa pool memerlukan bentuk identifikasi, seperti KYC, sementara yang lain tidak.

Metode lainnya adalah bekerja dengan imbalan bitcoin. Metode akuisisi ini bisa jadi menarik, tetapi tingkat identifikasi yang diperlukan sangat bervariasi, tergantung pada situasinya.

\Untuk menulis bab ini, saya menggunakan kursus BTC205 yang dibuat oleh [@pivi\_\_] (https://x.com/pivi___) di Jaringan Plan ₿ (hanya tersedia dalam bahasa Prancis untuk saat ini).\_

## Konsolidasi, Manajemen UTXO dan CIOH

<chapterId>d0486c8f-332d-402b-ae2e-949416752b9c</chapterId>

Salah satu aspek yang paling rumit untuk dikelola saat Anda memiliki portofolio penyimpanan mandiri Anda sendiri adalah konsolidasi. Haruskah Anda melakukan konsolidasi? Apa tujuannya? Berapa ukuran UTXO yang harus Anda capai? Apa saja pengorbanan privasinya? Itulah yang akan kita coba jelajahi di bagian ini.

### Apa yang dimaksud dengan konsolidasi?

Pengoperasian Bitcoin mirip dengan pasar lelang di mana transaksi yang menawarkan biaya terbaik akan disukai oleh para penambang. Namun, setiap blok memiliki bobot maksimum, sehingga membatasi jumlah transaksi yang dapat dimasukkan. Karena sebuah blok diproduksi rata-rata setiap 10 menit, maka ruang yang tersedia di setiap blok adalah sumber daya yang langka.

Para penambang, yang bisnisnya melibatkan biaya yang signifikan dalam hal listrik, modal, dan pemeliharaan, secara alami berusaha untuk memaksimalkan profitabilitas mereka. Mereka cenderung memilih transaksi yang menawarkan biaya tertinggi dibandingkan dengan bobotnya.

Faktanya, tidak semua transaksi Bitcoin memiliki bobot yang sama. Transaksi yang memiliki lebih banyak input dan output akan memiliki bobot yang lebih besar. Sebagai contoh, pertimbangkan 2 transaksi:


- Transaksi A mencakup 1 input dan 1 output. Transaksi ini menetapkan 1.994 sat biaya dan bobotnya 141 vB;
- Transaksi B yang lebih kompleks, dengan 2 input dan 2 output, mengalokasikan 2.640 sat komisi untuk bobot 220 vB.

Pada contoh tersebut, walaupun transaksi B menawarkan total komisi yang lebih tinggi, penambang akan memilih transaksi A karena transaksi tersebut menawarkan rasio komisi terhadap bobot yang lebih baik. Berikut adalah perhitungan untuk setiap transaksi, yang dinyatakan dalam sat per virtual byte (sat/vB):

```text
TXA: 1994 / 141 = 14 sat/vB
TXB: 2640 / 220 = 12 sat / vB
```

Ini berarti bahwa untuk setiap unit berat, transaksi A menawarkan lebih banyak biaya daripada transaksi B, meskipun transaksi B menawarkan lebih banyak biaya secara absolut.

Oleh karena itu, semakin menarik bagi pengguna untuk mengonsumsi jumlah input seminimal mungkin dalam transaksi mereka. Namun, perlu untuk mengkonsumsi jumlah yang cukup untuk memenuhi pembayaran output. Oleh karena itu, dalam mengelola portofolio seseorang, perlu memiliki UTXO dalam jumlah yang cukup besar.

Prinsip konsolidasi adalah memanfaatkan periode ketika biaya Bitcoin rendah untuk menggabungkan UTXO kecil menjadi satu UTXO yang lebih besar. Dengan demikian, ketika biaya Bitcoin naik, seseorang dapat bertransaksi dengan input minimal, dan dengan demikian menghabiskan lebih sedikit biaya absolut. Tujuannya adalah untuk merencanakan transaksi wajib yang akan dilakukan selama periode komisi tinggi.

Selain menghemat biaya transaksi, mengkonsolidasikan UTXO membantu menghindari terciptanya "debu" Debu mengacu pada UTXO yang nilainya dalam satuan sangat rendah sehingga tidak cukup untuk menutupi biaya transaksi yang diperlukan untuk membelanjakannya. Hal ini membuat UTXO ini tidak rasional secara ekonomi untuk digunakan selama biaya transaksi tetap tinggi. Dengan mengelompokkan UTXO Anda secara proaktif, Anda mencegahnya menjadi debu, memastikan bahwa semua dana Anda tetap dapat digunakan.

### Berapa ukuran minimum untuk UTXO Anda?

Terkadang, saya ditanya berapa nilai minimum yang direkomendasikan untuk UTXO. Sayangnya, tidak ada jawaban yang universal, karena tergantung pada preferensi Anda dan kondisi pasar untuk komisi. Namun, berikut ini adalah rumus yang dapat membantu Anda menentukan ambang batas yang sesuai dengan kebutuhan Anda:

$$
\frac {P \times F}T = M
$$

Dimana:


- p$ adalah bobot transaksi;
- $F$ mewakili nilai maksimum dalam satoshi per vbyte (sats/vB) yang bersedia Anda tanggung;
- $T$ adalah persentase biaya transaksi yang bersedia Anda bayarkan terhadap nilai total UTXO;
- $M$ adalah jumlah minimum dalam satoshi untuk setiap UTXO.

Dengan asumsi Anda ingin menutup komisi untuk transaksi SegWit standar dengan 1 input dan 2 output, dengan berat 141 vB. Jika Anda menutup hingga 800 sat/vB, dan Anda bersedia membayar komisi paling banyak 12 persen dari nilai UTXO, maka perhitungannya adalah:

$$
\frac{141 \times 800}{0.12} = 940\ 000
$$

Dalam contoh ini, akan lebih bijaksana untuk mempertahankan nilai minimum 940.000 sat untuk UTXO dalam portofolio Anda.

### Konsolidasi dan COIH

Salah satu heuristik yang paling banyak digunakan dalam analisis blockchain adalah COIH (_Common Input Ownership Heuristic_), yang memungkinkan kita untuk mengasumsikan bahwa semua input ke transaksi Bitcoin adalah milik entitas yang sama. Tepatnya, prinsip konsolidasi adalah mengkonsumsi beberapa UTXO sebagai input dan membuat satu UTXO sebagai output. Oleh karena itu, konsolidasi memungkinkan penerapan COIH.

![BTC204](assets/fr/097.webp)

Dalam praktiknya, ini berarti bahwa pengamat luar dapat menyimpulkan bahwa semua UTXO yang terkonsolidasi mungkin milik orang yang sama dan satu-satunya output yang dihasilkan adalah milik mereka juga. Situasi ini dapat membahayakan privasi Anda dengan menghubungkan riwayat transaksi yang berbeda. Sebagai contoh, katakanlah saya menggabungkan 3 UTXO yang diperoleh di P2P dengan satu UTXO yang diperoleh melalui platform yang memerlukan KYC:

![BTC204](assets/fr/098.webp)

Dengan demikian, entitas mana pun yang memiliki akses ke data platform bursa, termasuk lembaga pemerintah, dapat mengidentifikasi bahwa saya memiliki sejumlah BTC. Sebelumnya, UTXO ini tidak secara langsung terhubung dengan identitas saya; sekarang sudah terhubung. Selain itu, hal ini menunjukkan kepada semua sumber bahwa saya memiliki sejumlah bitcoin.

Dalam mengelola UTXO, pertimbangan ekonomi, yang mendorong konsolidasi untuk mengurangi biaya, dengan demikian bertentangan dengan praktik privasi yang baik, yang akan merekomendasikan untuk tidak pernah menggabungkan UTXO Anda. Pilihan antara ekonomi dan privasi dengan demikian tergantung pada prioritas masing-masing pengguna.

Jika Anda dapat menghindari konsolidasi sambil mempertahankan ukuran UTXO yang besar, itu sangat ideal. Untuk melakukan ini, optimalkan metode akuisisi Anda. Jika Anda membeli bitcoin di DCA, cobalah untuk mengatur jarak pembelian satu kali Anda seluas mungkin untuk mengelompokkan nilainya ke dalam lebih sedikit UTXO. Akan lebih mudah untuk mengelola pembelian satu kali sebesar €1.000 setiap 2 bulan daripada pembelian €120 setiap minggu. Hal ini akan meminimalkan jumlah UTXO yang dihasilkan dan menyederhanakan pengelolaan portofolio Anda sekaligus menjaga privasi Anda.

Jika Anda merasa perlu menggabungkan bitcoin Anda, prioritaskan penggabungan UTXO dari sumber yang sama. Misalnya, menggabungkan 10 UTXO dari satu platform akan berdampak lebih kecil terhadap privasi Anda daripada menggabungkan 5 UTXO dari platform A dengan 5 UTXO dari platform B. Jika konsolidasi dari berbagai sumber tidak dapat dihindari, cobalah untuk memisahkannya berdasarkan karakteristiknya. Misalnya, kelompokkan UTXO yang diperoleh melalui KYC ke dalam satu transaksi, dan yang diperoleh di P2P ke dalam transaksi lainnya.

Dalam hal apa pun, ingatlah bahwa konsolidasi apa pun pasti menyebabkan hilangnya privasi. Oleh karena itu, kaji dengan cermat kebutuhan akan hal ini dan potensi dampaknya terhadap privasi Anda, dengan mempertimbangkan risikonya.

## Praktik Baik Lainnya

<chapterId>b5216965-7d13-4ea1-9b7c-e292966a487b</chapterId>

Mari kita jelajahi bersama beberapa praktik terbaik lainnya yang dapat membantu Anda mengoptimalkan privasi Anda di Bitcoin.

### Simpul Lengkap

Memiliki bitcoin Anda dalam penitipan pribadi memang bagus, tetapi menggunakan node Anda sendiri secara penuh akan lebih baik! Inilah sebabnya mengapa memiliki node Anda sendiri sangat penting untuk penggunaan bitcoin yang berdaulat penuh:


- Resistensi terhadap Penyensoran**: Transaksi Anda tidak dapat diblokir oleh siapa pun;
- Independensi dari Pihak Ketiga**: Anda tidak lagi bergantung pada layanan eksternal apa pun untuk memverifikasi data blockchain;
- Partisipasi Aktif**: Anda memiliki kemampuan untuk menetapkan aturan validasi Anda sendiri dan berpartisipasi secara langsung dalam konsensus;
- Kontribusi ke Jaringan**: Dengan menjalankan sebuah node, Anda membantu memperkuat dan mendistribusikan jaringan Bitcoin;
- Pendidikan Teknis**: Menjalankan sebuah node penuh adalah cara terbaik untuk memperdalam pengetahuan teknis Anda tentang Bitcoin.

Selain manfaat-manfaat tersebut, menggunakan full node juga meningkatkan privasi Anda ketika Anda mengirimkan transaksi. Ketika Anda mengeluarkan sebuah transaksi, transaksi tersebut pertama kali dibuat dan ditandatangani melalui dompet Anda. Untuk mengirimkannya ke jaringan Bitcoin, transaksi tersebut harus diketahui oleh setidaknya satu node. Dengan menggunakan node Anda sendiri, Anda secara langsung mengontrol transmisi ini, sehingga meningkatkan privasi Anda dan membatasi risiko kehilangan data.

![BTC204](assets/fr/099.webp)

Jika Anda tidak memiliki simpul Bitcoin Anda sendiri, Anda akan dipaksa untuk menggunakan simpul Bitcoin milik pihak ketiga, seperti yang ditawarkan oleh penyedia perangkat lunak dompet Anda. Selain transmisi transaksi, dompet Anda membutuhkan akses ke berbagai informasi seperti transaksi yang tertunda, saldo yang terkait dengan alamat Anda, atau jumlah konfirmasi untuk transaksi Anda. Untuk mengakses semua data ini, Anda perlu melakukan kueri pada sebuah node.

![BTC204](assets/fr/100.webp)

Resiko utama ketika Anda tidak menggunakan node Bitcoin Anda adalah operator node pihak ketiga dapat mengamati aktivitas Anda di blockchain, atau bahkan membagikan informasi ini kepada entitas lain. Untuk membatasi risiko ini, solusi perantaranya adalah dengan menggunakan perangkat lunak dompet yang memungkinkan Anda untuk menyembunyikan koneksi Anda melalui Tor. Hal ini dapat mengurangi eksposur data Anda. Akan tetapi, solusi optimal tetaplah dengan memiliki node Bitcoin Anda sendiri dan menggunakannya untuk mengirimkan transaksi Anda. Tentu saja, Anda juga harus memastikan bahwa tidak ada informasi yang bocor keluar dari node Anda, tetapi ini adalah topik lain yang akan kita bahas di bagian selanjutnya.

Selain manfaat yang jelas untuk privasi Anda, memiliki node penuh Anda sendiri juga memastikan kebenaran data di blockchain, melindungi dari penyensoran, dan memungkinkan Anda untuk secara aktif berpartisipasi dalam tata kelola Bitcoin. Dengan menggunakan node Anda sendiri, Anda menyumbangkan bobot ekonomi Anda pada blockchain pilihan Anda, yang sangat penting saat terjadi konflik di dalam komunitas, seperti pada saat Perang Ukuran Blok dari tahun 2015 hingga 2017, misalnya. Jika terjadi fork, menggunakan node pihak ketiga dapat membuat Anda mendukung rantai yang tidak Anda inginkan, karena operator node membuat pilihan untuk Anda. Seperti yang dapat Anda pahami, dari sudut pandang privasi dan kedaulatan individu yang lebih umum, sangat penting untuk menjalankan dan menggunakan node Anda sendiri secara penuh!

### Heuristik Analisis yang Menipu

Secara umum, penting untuk memahami heuristik yang telah kita bahas pada bagian sebelumnya agar dapat menghindari atau menipu mereka dengan lebih baik. Mengadopsi sejumlah praktik terbaik dapat terbukti bermanfaat, bahkan jika praktik tersebut tidak terlalu penting. Praktik-praktik tersebut menawarkan lapisan perlindungan tambahan yang penting untuk menjaga privasi saat menggunakan Bitcoin.

Saran pertama yang dapat saya berikan adalah berbaur dengan kerumunan orang banyak. Pada Bitcoin, ini berarti menggunakan templat skrip yang paling banyak digunakan. Sebagai contoh, skrip P2WSH, yang sering digunakan untuk konfigurasi multisig SegWit V0, sangat jarang digunakan. Skrip ini tidak memungkinkan Anda untuk bersembunyi dalam sekumpulan besar anonimitas. Hal yang sama juga berlaku untuk model yang lebih tua seperti P2PKH atau P2SH. Meskipun mereka banyak terdapat dalam set UTXO, mereka semakin jarang digunakan untuk transaksi baru.

Secara umum, lebih aman untuk bergerak ke arah standar skrip terbaru, selama standar tersebut diadopsi secara memadai. Jadi, meskipun pada tahun 2022 saya akan menyarankan untuk tidak menggunakan P2TR (Taproot) karena adopsinya yang rendah, pada tahun 2024 saya akan merekomendasikan untuk memilih jenis skrip ini, atau jika tidak, untuk skrip SegWit V0, karena jumlah transaksi yang menggunakan P2TR mulai mewakili porsi yang sangat signifikan.

Sumber:[txstats.com](https://txstats.com/d/000000054/utxo-set-repartition-by-output-type)

Tips lain untuk menjaga privasi Anda adalah mencoba menghindari heuristik transaksi internal. Sebagai contoh, ketika Anda melakukan pembayaran, Anda dapat mencoba untuk menghindari membuat output dengan jumlah yang bulat, karena hal ini dapat menandakan bahwa output lainnya merupakan kembalian. Jika Anda harus mengirim 100 ribu satoshi kepada teman, pertimbangkan untuk mentransfer jumlah yang sedikit lebih tinggi untuk menghindari heuristik ini. Demikian pula, cobalah untuk tidak membuat output sisa yang tidak proporsional dibandingkan dengan pembayaran yang dilakukan, karena hal ini juga dapat mengungkapkan output mana yang mewakili sisa.

Terakhir, jika Anda melakukan transaksi Bitcoin secara rutin, pastikan Anda tidak selalu mengirimkannya pada waktu yang sama. Dengan mendistribusikan pengiriman transaksi Anda sepanjang hari dan minggu, Anda menghindari pengamat luar untuk mendeteksi pola waktu berdasarkan zona waktu yang dapat meningkatkan analisis mereka.

Selain semua praktik terbaik yang dapat Anda terapkan setiap hari, ada beberapa metode yang lebih efektif untuk memutus pelacakan bitcoin Anda. Ini termasuk, tentu saja, transaksi coinjoin, yang akan kita pelajari secara mendalam di bagian berikut.

# Memahami Transaksi Coinjoin

<partId>6d0bbf16-3714-4db1-9897-2d45019f6bdc</partId>

## Apa yang dimaksud dengan Transaksi Coinjoin?

<chapterId>0862bc6b-1c48-4aa4-b76d-4f547b469008</chapterId>

Setelah mempelajari dasar-dasar perlindungan privasi, sekarang kita akan membahas teknik-teknik yang lebih canggih yang bertujuan untuk secara aktif mempertahankan privasi Anda, terutama dengan memisahkan riwayat bitcoin Anda. Di bagian selanjutnya, kita akan menjelajahi banyak teknik kecil, tetapi pertama-tama saya ingin memberi tahu Anda tentang coinjoin.

Coinjoin sering dianggap sebagai cara yang paling efektif untuk melindungi privasi pengguna Bitcoin. Namun, apa sebenarnya transaksi coinjoin itu? Mari kita cari tahu bersama.

### Prinsip Dasar Coinjoin

Coinjoin adalah sebuah teknik yang mengganggu pelacakan bitcoin pada blockchain. Teknik ini didasarkan pada transaksi kolaboratif dengan struktur spesifik dengan nama yang sama: transaksi coinjoin.

Seperti yang telah kita lihat pada bagian pertama pelatihan ini, transaksi pada Bitcoin diketahui oleh semua pengguna melalui node mereka. Oleh karena itu, sangat mudah untuk memverifikasi rantai tanda tangan elektronik dari setiap koin dan mengamati sejarahnya. Ini berarti bahwa semua pengguna dapat mencoba menganalisis transaksi pengguna lain. Akibatnya, anonimitas pada tingkat transaksi tidak mungkin dilakukan. Akan tetapi, anonimitas dipertahankan pada tingkat identifikasi individu. Tidak seperti perbankan tradisional di mana setiap akun dihubungkan dengan identitas pribadi, pada Bitcoin, dana dihubungkan dengan pasangan kunci kriptografi (atau skrip), sehingga menawarkan kepada para pengguna sebuah bentuk pseudonimitas di balik pengenal kriptografi.

![BTC204](assets/it/51/01.webp)

Dengan demikian, kerahasiaan pada bitcoin dikompromikan ketika pengamat luar dapat mengasosiasikan UTXO tertentu dengan pengguna yang teridentifikasi. Setelah asosiasi ini terbentuk, maka akan memungkinkan untuk melacak transaksi mereka dan menganalisa riwayat bitcoin mereka. Coinjoin merupakan sebuah teknik yang dikembangkan untuk mengganggu pelacakan UTXO untuk memberikan tingkat kerahasiaan tertentu kepada pengguna Bitcoin di tingkat transaksi.

Coinjoin meningkatkan kerahasiaan pengguna Bitcoin dengan memperumit analisis rantai untuk pengamat luar. Strukturnya memungkinkan beberapa koin dari pengguna yang berbeda untuk digabungkan ke dalam satu transaksi, sehingga mengaburkan jejak dan menyulitkan untuk menentukan hubungan antara alamat input dan output.

Penting untuk dipahami bahwa tujuan dari transaksi coinjoin adalah untuk mengacaukan riwayat koin. Teknik ini tidak memberikan anonimitas permanen atau menghentikan ketertelusuran bitcoin secara permanen, berlawanan dengan apa yang mungkin dipikirkan. Coinjoin hanya bertujuan untuk menginterupsi riwayat pada titik di mana transaksi coinjoin dilakukan. Akan tetapi, sebelum dan sesudah transaksi ini, koin tetap memiliki risiko privasi yang sama.

![BTC204](assets/fr/104.webp)

### Bagaimana cara kerja coinjoin?

Prinsip coinjoin didasarkan pada pendekatan kolaboratif: beberapa pengguna yang ingin menggabungkan bitcoin mereka menyetorkan jumlah yang sama ke dalam input transaksi yang sama. Jumlah ini kemudian didistribusikan kembali dalam bentuk output dengan nilai yang sama kepada setiap pengguna.

![BTC204](assets/fr/105.webp)

Di akhir transaksi, menjadi tidak mungkin untuk mengaitkan output tertentu dengan input pengguna yang diketahui. Tidak ada hubungan langsung antara input dan output, yang memutus hubungan antara pengguna dan UTXO mereka, serta riwayat setiap koin.

![BTC204](assets/fr/106.webp)

Mari kita ambil contoh Alice. Dia ingin mengirim sekitar 100.000 satoshi (sats) kepada saudara perempuannya, Eve, untuk ulang tahunnya. Namun, Alice tidak ingin Eve dapat melacak riwayat transaksinya karena dia tidak ingin mengungkapkan berapa banyak bitcoin yang dimilikinya atau bagaimana dia memperolehnya. Untuk melakukan ini, Alice memutuskan untuk mengacaukan riwayat UTXO-nya dengan transaksi coinjoin. Dia mengatur dengan Bob, Charles, David, dan Frank untuk melakukan transaksi kolaboratif: Alice, Bob, Charles, David, dan Frank masing-masing menjaminkan UTXO sebanyak 105.000 satoshi (dengan 5.000 satoshi untuk biaya penambangan) sebagai input untuk transaksi:

![BTC204](assets/fr/107.webp)


- Sebagai imbalan dari penggunaan input ini, masing-masing menghasilkan alamat baru untuk membuat lima output identik masing-masing 100.000 sat. Setiap peserta mengambil satu keluaran:

![BTC204](assets/fr/108.webp)


- Alice berakhir dengan UTXO sebesar 100.000 sat yang memiliki riwayat yang beragam. Dia menggunakan UTXO ini dalam transaksi baru untuk mengirim jumlah tersebut kepada Eve untuk ulang tahunnya:

![BTC204](assets/fr/109.webp)


- Jika Eve mencoba menganalisis transaksi ini untuk mengekstrak informasi, ia akan menemukan transaksi coinjoin yang melibatkan Alice, Bob, Charles, David, dan Frank. Karena Eve tidak dapat membedakan siapa pemilik setiap input karena keseragaman jumlahnya, ia tidak dapat melacak riwayat UTXO Alice atau menentukan berapa banyak bitcoin yang dimiliki saudara perempuannya atau bagaimana ia memperolehnya:

![BTC204](assets/fr/110.webp)

Dalam skenario ini, Alice menggunakan teknik coinjoin untuk meningkatkan privasinya terhadap analisis mundur. Faktanya, Alice melindungi dirinya sendiri dari kemungkinan analisis oleh Eve yang akan dimulai dari transaksi tertentu untuk melacak sejarah UTXO ke belakang. Perlindungan terhadap analisis dari masa sekarang ke masa lalu ini adalah apa yang kita sebut sebagai anonset retrospektif. Kita akan membahas konsep ini secara lebih detail di bab-bab terakhir bagian ini.

Namun, coinjoin juga menawarkan kemungkinan untuk meningkatkan privasi terhadap analisis masa lalu-ke-sekarang, yang disebut dengan prospective anonset. Mari kita kembali ke contoh kita di mana Alice mengirimkan 98.000 sats kepada Eve pada hari ulang tahunnya, tetapi dengan membalikkan perannya. Sekarang mari kita bayangkan bahwa Hawa yang mengkhawatirkan privasinya. Bahkan, Alice mungkin tergoda untuk mengikuti koin yang ia kirimkan kepada Eve untuk mengumpulkan informasi. Eve dapat menggabungkan UTXO yang baru diterima ini dengan semua UTXO-nya yang lain, yang dapat mengungkapkan kepada Alice jumlah bitcoin yang ia simpan di dompetnya. Untuk menghindari hal ini, Eve juga dapat mengacaukan riwayat koin yang baru diterima.


- Eve, Grace, Mallory, Oscar, dan Victor masing-masing memasukkan UTXO sebesar 98.000 satoshi sebagai input ke dalam transaksi Bitcoin:

![BTC204](assets/fr/111.webp)


- Sebagai imbalan untuk menggunakan input ini, masing-masing memberikan alamat baru untuk membuat 5 output masing-masing 97.500 sat, sama persis. Setiap pengguna mengambil satu keluaran:

![BTC204](assets/fr/112.webp)


- Eve sekarang memiliki UTXO sebesar 97.500 sat dengan riwayat yang rusak. Dia dapat menggunakannya tanpa takut akan transaksi di masa depan. Faktanya, jika Alice mencoba mengikuti bitcoin yang ia kirimkan kepada Eve, ia akan menemukan transaksi coinjoin. Dia tidak akan dapat menentukan keluaran UTXO mana yang dimiliki Eve. Analisis kemudian menjadi tidak mungkin:

![BTC204](assets/fr/113.webp)

Pada contoh pertama, kita telah melihat bagaimana coinjoin dapat melindungi privasi sebuah koin dalam kaitannya dengan masa lalunya, dan pada contoh kedua, bagaimana coinjoin juga dapat mengamankan sejarah sebuah koin dalam kaitannya dengan masa depannya. Itulah mengapa saya menyebutkan bahwa coinjoin harus dilihat sebagai sebuah peristiwa satu kali yang membagi sejarah koin ke dua arah:

![BTC204](assets/fr/104.webp)

### Pencampuran, coinjoin, mixer... Apa bedanya?

Istilah "pencampuran" terkadang digunakan untuk mendeskripsikan coinjoin, sebuah istilah yang ditolak oleh beberapa pengguna bitcoin karena mereka khawatir akan kebingungan dengan kustodian. Namun, menurut saya kekhawatiran ini tidak berdasar karena, dalam konteks matematika, coinjoin secara tepat mewujudkan konsep pencampuran.

Dalam bidang matematika secara umum, pencampuran mengacu pada sifat sistem dinamik di mana, setelah waktu tertentu, semua bagian dari ruang awal secara teoritis dapat dicampur dengan bagian lainnya. Pencampuran menyiratkan bahwa posisi partikel atau keadaan suatu sistem berevolusi sedemikian rupa sehingga distribusi masa depannya tidak bergantung pada distribusi awalnya, sehingga mencapai keadaan di mana karakteristik keadaan awal terdistribusi secara seragam di ruang sistem. Inilah yang terjadi pada coinjoin dengan bitcoin. Jadi, menurut saya, coinjoin benar-benar merupakan metode pencampuran koin.

![BTC204](assets/fr/114.webp)

Namun, penting untuk membedakan coinjoin dengan mixer. Mixer adalah sebuah layanan di mana pengguna mengirimkan bitcoin mereka untuk dicampurkan. Layanan ini sempat populer pada tahun 2010-an, tetapi penggunaannya telah menurun karena dua kelemahan utama dibandingkan dengan coinjoin:


- Mereka mengharuskan pengguna untuk melepaskan hak asuh dana mereka selama proses pencampuran, membuat mereka rentan terhadap risiko pencurian;
- Tidak ada jaminan bahwa mixer tidak akan mencatat detail transaksi, atau bahkan menjual informasi ini kepada perusahaan analisis blockchain.

![BTC204](assets/fr/115.webp)

Saat ini, para pengguna lebih memilih coinjoin, karena memungkinkan mereka untuk memegang kendali penuh atas dana mereka selama proses berlangsung. Peserta dalam coinjoin tidak mengambil risiko bitcoin mereka dicuri oleh pihak lain yang terlibat. Mari kita telusuri bersama bagaimana hal ini bisa terjadi di bab selanjutnya.

## Zerolink dan Chaumian Coinjoins

<chapterId>326c9654-b359-4906-b23d-d6518dd5dc3e</chapterId>

Privasi yang disediakan oleh coinjoin didasarkan pada ukuran grup tempat karya kita disembunyikan. Oleh karena itu, perlu untuk menemukan peserta sebanyak mungkin. Sangat mungkin untuk menjalankan coinjoin secara manual, dengan pengguna yang ditemukan secara independen, tetapi metode ini rumit dan tidak memungkinkan untuk anonset yang besar.

Inilah sebabnya mengapa koordinator coinjoin telah berkembang di Bitcoin. Peran mereka adalah untuk menghubungkan pengguna yang berbeda dan mengirimkan informasi yang diperlukan untuk keberhasilan penyelesaian transaksi kolaboratif.

![BTC204](assets/fr/116.webp)

Namun, bagaimana kita dapat memastikan bahwa koordinator tidak pernah memiliki kendali atas bitcoin pengguna, dan meskipun dia adalah orang yang membuat transaksi coinjoin, bagaimana kita dapat memastikan bahwa dia tidak dapat menghubungkan input dan output pengguna, yang dapat menyebabkan hilangnya privasi?

### Tanda Tangan Buta Chaum

Implementasi coinjoin modern menggunakan tanda tangan buta David Chaum untuk mencegah kebocoran informasi. Mari kita pelajari bersama bagaimana cara kerja tanda tangan buta ini.

Tanda tangan buta Chaum adalah bentuk tanda tangan digital di mana pemberi tanda tangan tidak mengetahui isi pesan yang ditandatanganinya. Namun, tanda tangan tersebut dapat diverifikasi kemudian dengan pesan aslinya. Teknik ini dikembangkan oleh kriptografer David Chaum pada tahun 1983.

Ambil contoh sebuah perusahaan yang ingin mengautentikasi dokumen rahasia, seperti kontrak, tanpa mengungkapkan isinya. Perusahaan menerapkan proses penyembunyian yang secara kriptografis mengubah dokumen asli dengan cara yang dapat dibalik. Dokumen yang telah dimodifikasi ini dikirim ke otoritas sertifikasi yang menerapkan tanda tangan buta tanpa mengetahui konten yang mendasarinya. Setelah menerima dokumen yang ditandatangani, perusahaan menghapus penyamaran dari tanda tangan tersebut. Hasilnya adalah dokumen asli yang diautentikasi oleh tanda tangan otoritas, tanpa otoritas pernah melihat konten aslinya.

Dengan demikian, tanda tangan buta Chaum memungkinkan sertifikasi keaslian dokumen tanpa mengetahui isinya, memastikan kerahasiaan data pengguna dan integritas dokumen yang ditandatangani.

### Chaumian Coinjoins

Dalam "Chaumian CoinJoins," penggunaan tanda tangan buta Tor dan David Chaum digabungkan untuk memastikan bahwa koordinator tidak dapat mengetahui pengguna mana yang memiliki setiap output. Proses konstruksi transaksi coinjoin terdiri dari 3 langkah utama: registrasi input, registrasi output, dan penandatanganan transaksi. Mari kita lihat proses ini melalui contoh Alice, salah satu peserta coinjoin. Semua peserta lain mengikuti langkah yang sama dengan Alice, masing-masing dengan caranya sendiri.

**Langkah 1: Pendaftaran input.**


- Alice mengirimkan UTXO kepada koordinator yang ingin ia gunakan sebagai input untuk transaksi, serta alamat penerima terselubung yang ingin ia gunakan sebagai output untuk menerima bitcoin-nya. Oleh karena itu, koordinator tidak dapat mengetahui alamat Alice. Ia hanya melihat versi tersamarnya.
- Koordinator memverifikasi keabsahan input, kemudian menandatangani alamat terselubung Alice dengan kunci pribadinya. Dia kemudian mengirimkan tanda tangan buta kepada Alice.

**Langkah 2: Merekam output.**


- Alice sekarang dapat menghapus penyamaran dari alamatnya yang ditandatangani oleh kunci pribadi koordinator. Dia membuat sambungan baru dengan identitas Tor yang berbeda. Koordinator tidak dapat mengidentifikasi bahwa itu adalah Alice yang tersambung dengan identitas baru ini.
- Alice mengirimkan alamat dan tanda tangan yang disamarkan kepada koordinator (yang masih belum tahu bahwa itu adalah Alice).

**Langkah 3: Menandatangani transaksi.**


- Koordinator juga mengambil output yang tidak disamarkan dari semua peserta. Dengan tanda tangan yang terkait, ia dapat memverifikasi bahwa setiap output yang dikirim secara anonim benar-benar ditandatangani oleh kunci pribadinya sebelumnya, memastikan keabsahannya. Kemudian ia siap untuk membuat transaksi coinjoin dan mengirimkannya kepada para partisipan untuk ditandatangani.
- Alice, seperti peserta lainnya, memverifikasi bahwa input dan outputnya telah dimasukkan dengan benar ke dalam transaksi yang dibuat oleh koordinator. Jika semuanya memuaskan, dia mengirimkan tanda tangan yang membuka skrip inputnya kepada koordinator.
- Setelah mengumpulkan tanda tangan dari semua peserta coinjoin, koordinator dapat mengirimkan transaksi melalui jaringan Bitcoin sehingga dapat ditambahkan ke dalam sebuah blok.

Dalam sistem ini, koordinator tidak dapat menghubungkan input ke output tertentu. Selain itu, ia tidak dapat memiliki dana peserta, karena ia tidak pernah memiliki akses ke kunci pribadi yang diperlukan untuk membuka UTXO mereka. Sepanjang proses, dan hingga akhir langkah 3, dia bahkan tidak memiliki akses ke tanda tangan. Ketika Alice dan peserta lainnya menandatangani transaksi global, setelah memverifikasi bahwa semuanya sudah benar, koordinator tidak dapat lagi memodifikasi transaksi ini, termasuk outputnya, tanpa membatalkannya. Dengan demikian, hal ini mencegah pencurian bitcoin oleh koordinator.

Pada akhirnya, ketika mereka mendaftarkan output mereka dalam transaksi, pengguna coinjoin menginginkan jaminan yang serupa dengan warga negara yang memberikan suara dalam pemilu. Terdapat dualitas antara aspek publik dan privat dari tindakan ini. Di satu sisi, ada hal yang ingin Anda jaga kerahasiaannya: untuk pemilih, mereka tidak ingin suara mereka dikaitkan dengan identitas mereka; untuk pengguna coinjoin, mereka tidak ingin output mereka dikaitkan dengan input mereka. Faktanya, jika koordinator, atau pihak lain, berhasil membuat hubungan antara input dan output, coinjoin akan kehilangan seluruh tujuannya. Seperti yang telah dijelaskan sebelumnya, coinjoin harus berfungsi sebagai jeda dalam sejarah koin. Jeda ini terjadi karena ketidakmampuan untuk mengaitkan input tertentu dengan output tertentu dalam transaksi coinjoin (prospective anonset) dan sebaliknya (retrospective anonset).

Di sisi lain, ada aspek publik: pemilih ingin memastikan bahwa surat suara mereka dimasukkan ke dalam kotak suara; demikian pula, pengguna coinjoin ingin memastikan bahwa output mereka dimasukkan ke dalam transaksi coinjoin. Faktanya, sangat penting bagi peserta coinjoin untuk dapat memverifikasi keberadaan output mereka sebelum menandatangani transaksi, jika tidak, koordinator dapat mencuri dana tersebut.

Kedua aspek publik dan privat ini, yang dimungkinkan oleh penggunaan tanda tangan buta David Chaum, yang meyakinkan para peserta coinjoining Chaumians bahwa bitcoin mereka tidak akan dicuri, dan dana mereka tidak dapat dilacak.

### Siapa yang menemukan konsep coinjoin?

Sulit untuk menentukan dengan pasti siapa yang pertama kali memperkenalkan ide coinjoin pada Bitcoin, dan siapa yang memunculkan ide untuk menggunakan tanda tangan buta David Chaum dalam konteks ini. Sering kali dianggap bahwa Gregory Maxwell yang pertama kali menyebutkannya dalam [sebuah posting di BitcoinTalk pada tahun 2013] (https://bitcointalk.org/index.php?topic=279249.0):

Menggunakan Tanda Tangan Buta Chaum: Pengguna terhubung dan memberikan input (dan alamat untuk sisanya) serta versi kriptografis yang disamarkan dari alamat yang ingin mereka kirimkan koin pribadi mereka; server menandatangani token dan mengembalikannya kepada pengguna. Pengguna terhubung kembali secara anonim, mengungkapkan alamat keluaran mereka, dan mengirimkannya kembali ke server. Server dapat melihat bahwa semua output telah ditandatangani olehnya dan, sebagai hasilnya, semua output berasal dari peserta yang valid. Kemudian, orang-orang terhubung kembali dan menandatangani.

Maxwell, G. (2013, Agustus 22). koinBersama: Privasi Bitcoin untuk dunia nyata_. Forum BitcoinTalk. https://bitcointalk.org/index.php?topic=279249.0

Akan tetapi, sebelumnya sudah ada penyebutan mengenai tanda tangan Chaum dalam konteks pencampuran dan coinjoin. [Pada bulan Juni 2011, Duncan Townsend mempresentasikan di BitcoinTalk] (https://bitcointalk.org/index.php?topic=12751.0) sebuah mixer yang menggunakan tanda tangan Chaum dengan cara yang sangat mirip dengan coinjoins Chaumians modern.

Dalam thread yang sama, ada [pesan hashcoin sebagai tanggapan terhadap Duncan Townsend] (https://bitcointalk.org/index.php?topic=12751.msg315793#msg315793) untuk meningkatkan mixernya. Proses yang dijelaskan dalam pesan ini merupakan proses yang paling mendekati coinjoin. Sistem yang serupa juga disebutkan dalam [pesan dari Alex Mizrahi pada tahun 2012] (https://gist.github.com/killerstorm/6f843e1d3ffc38191aebca67d483bd88#file-laundry), saat dia menasihati pencipta Tenebrix, salah satu altcoin pertama yang menjadi dasar penciptaan Litecoin di kemudian hari. Bahkan istilah "coinjoin" itu sendiri tidak ditemukan oleh Greg Maxwell, tetapi berasal dari ide Peter Todd.

![BTC204](assets/fr/125.webp)

### Zerolink

Zerolink adalah sebuah protokol pencampuran yang komprehensif yang mengintegrasikan coinjoin Chaumiani dan berbagai strategi untuk melindungi anonimitas pengguna dari berbagai bentuk analisis rantai, sehingga mengurangi kesalahan yang berhubungan dengan manajemen dompet. Protokol ini [diperkenalkan oleh nopara73 dan TDevD pada tahun 2017] (https://github.com/nopara73/ZeroLink/blob/master/README.md).

![BTC204](assets/fr/126.webp)

Seperti namanya, prinsip Zerolink adalah melakukan transaksi coinjoin yang memastikan bahwa hubungan antara input dan output tidak dapat dilacak. Fitur ini dicapai dengan memastikan bahwa semua output memiliki jumlah yang identik sempurna.

![BTC204](assets/fr/127.webp)

Langkah pencegahan penting yang dilakukan oleh Zerolink adalah dengan memisahkan UTXO yang belum tercampur dengan UTXO yang sudah tercampur dengan menggunakan set kunci kriptografi yang terpisah, atau bahkan dengan dompet yang terpisah. Dengan cara ini, dompet "pra-campuran", yang ditujukan untuk koin sebelum pencampuran, dibedakan dari dompet "pasca-campuran", yang diperuntukkan bagi koin yang telah dicampur.

![BTC204](assets/fr/128.webp)

Pemisahan UTXO yang ketat ini berfungsi terutama untuk mencegah hubungan yang tidak disengaja antara UTXO campuran dan UTXO yang tidak dicampur. Faktanya, jika hubungan seperti itu terjadi, efektivitas coinjoin pada UTXO campuran dibatalkan tanpa sepengetahuan pengguna, sehingga membahayakan kerahasiaan UTXO yang riwayatnya diyakini telah rusak. Tautan ini dapat muncul baik melalui penggunaan ulang alamat untuk mengamankan UTXO campuran dengan yang tidak tercampur, atau dengan menerapkan Heuristik Kepemilikan Masukan Umum (CIOH) jika pengguna menggunakan UTXO campuran dan yang tidak tercampur sebagai masukan untuk transaksi yang sama. Dengan memisahkan portofolio pra-pencampuran dan pasca-pencampuran, asosiasi yang tidak disengaja ini dapat dihindari dan pengguna terlindungi dari kesalahan yang tidak disengaja.

![BTC204](assets/fr/129.webp)

Pemisahan ini juga menawarkan kemungkinan penerapan aturan yang berbeda antara portofolio pra-pencampuran dan pasca-pencampuran pada tingkat perangkat lunak portofolio. Misalnya, dalam portofolio pasca-pencampuran, perangkat lunak dapat melarang penggabungan UTXO input untuk mencegah penerapan CIOH yang akan membahayakan anonset pengguna. Hal ini juga memungkinkan untuk menstandarkan penggunaan skrip dan opsi transaksi (seperti pensinyalan RBF, misalnya) untuk mencegah identifikasi dengan sidik jari dompet.

Saat ini, Whirlpool adalah satu-satunya implementasi coinjoin yang menerapkan protokol Zerolink secara ketat. Pada bab berikut, kita akan mengeksplorasi berbagai implementasi coinjoin yang ada serta kelebihan dan kekurangan masing-masing.

## Implementasi Coinjoin

<chapterId>e37ed073-9498-4e4f-820b-30951e829596</chapterId>

pada tahun 2024, kita melihat perubahan signifikan dalam alat yang tersedia bagi pengguna yang ingin menjalankan coinjoin di Bitcoin. Saat ini kita sedang berada dalam periode yang krusial, dan pasar coinjoin sedang mengalami restrukturisasi besar-besaran. Oleh karena itu, bab ini kemungkinan akan diperbarui dari waktu ke waktu._

Untuk saat ini, ada 3 implementasi coinjoin yang berbeda pada Bitcoin:


- Pusaran air;
- Wabisabi;
- JoinMarket.

Setiap implementasi ini bertujuan untuk memecahkan sejarah UTXO melalui transaksi coinjoin. Akan tetapi, mekanismenya sangat bervariasi. Oleh karena itu, penting untuk memahami cara kerja masing-masing untuk memilih opsi yang paling sesuai dengan kebutuhan Anda.

### JoinMarket

JoinMarket, yang dibuat pada tahun 2015 oleh Adam Gibson dan Chris Belcher, berbeda dengan implementasi coinjoin lainnya karena model pencocokan pengguna yang unik. Sistem ini didasarkan pada pasar pertukaran P2P di mana beberapa pengguna, "pembuat", membuat bitcoin mereka tersedia untuk pencampuran, sementara yang lain, "pengambil", menggunakan dana ini untuk mengeksekusi coinjoin dengan imbalan biaya.

![BTC204](assets/fr/130.webp)

Dalam model ini, "pembuat" menyediakan bitcoin mereka untuk "pengambil" dan menerima bayaran sebagai imbalan atas layanan mereka. Di sisi lain, "pengambil" membayar untuk menggunakan bitcoin "pembuat" untuk melakukan transaksi coinjoin mereka sendiri. Biaya layanan bervariasi sesuai dengan perannya: "pembuat" mengumpulkan biaya untuk penawaran likuiditas mereka, sementara "pengambil" membayar komisi. Pasar ini beroperasi secara bebas tanpa syarat penggunaan.

Kelemahan utama dari JoinMarket adalah kerumitan penggunaannya, yang membutuhkan pengetahuan tentang terminal untuk mengeksploitasinya secara efektif. Meskipun kerumitan ini tidak menjadi penghalang bagi pengguna yang berpengalaman, hal ini dapat membatasi akses ke masyarakat umum. Namun, baru-baru ini diperkenalkannya antarmuka web yang disebut JAM telah memudahkan penggunaannya.

![BTC204](assets/fr/131.webp)

Sumber: [JAM](https://github.com/joinmarket-webui/jam/blob/devel/docs/assets/screenshot-dark.webp)

Akan tetapi, hambatan teknis tetap menjadi kendala utama. Dalam ekosistem coinjoin, di mana kerahasiaan ditingkatkan oleh jumlah partisipan, batasan apa pun yang mengurangi aksesibilitas secara langsung memengaruhi likuiditas yang tersedia, yang merupakan faktor penting dalam efisiensi pencampuran. Bitcoin, yang sudah menjadi ceruk dalam transaksi keuangan, melihat penggunaan coinjoin sebagai sub-ceruk, dan JoinMarket mewakili bagian yang lebih khusus lagi, sehingga membatasi potensinya untuk meningkatkan anonset para penggunanya.

Terlepas dari model pencocokan P2P yang inovatif untuk coinjoin, JoinMarket memiliki beberapa kekurangan yang signifikan, terutama dalam hal struktur transaksi. Tidak seperti implementasi lain seperti Whirlpool, JoinMarket tidak menjamin kesetaraan yang sempurna antara output, dan hubungan deterministik dapat ditarik antara input dan output. Ini juga tidak memiliki alat untuk mencegah koin yang sudah tercampur agar tidak tercampur lagi, yang dapat membahayakan kerahasiaan yang diinginkan oleh pengguna. Akhirnya, meskipun konsep JoinMarket menarik, terutama bagi mereka yang tertarik dengan pasar likuiditas yang dinamis, kelemahan struktural dan kompleksitas teknisnya membuatnya, menurut pendapat saya, kurang menarik, baik untuk pemula maupun para ahli yang mencari implementasi koin bersama.

### Wabisabi

Wabisabi adalah implementasi lain dari coinjoin, dengan pendekatan yang memusatkan koordinasi transaksi. Model ini dirancang oleh Ádám Ficsór (nopara73), Yuval Kogman, Lucas Ontivero, dan István András Seres pada tahun 2021, dan diintegrasikan ke dalam perangkat lunak Wasabi 2.0 pada tahun berikutnya. Wabisabi secara tepat mewakili evolusi model coinjoin dari perangkat lunak Wasabi yang diluncurkan pada tahun 2018.

Pada akhir tahun 2010-an, Wasabi mengadopsi struktur transaksional untuk coinjoin yang sangat berbeda dari Whirlpool. Untuk meningkatkan anonset para pesertanya, Wasabi menggunakan transaksi coinjoin yang sangat besar yang mengelompokkan lusinan peserta. Sebaliknya, Whirlpool memilih beberapa transaksi kecil, yang memungkinkan peningkatan anonset secara eksponensial pada setiap siklus.

Metode untuk menangani sisa juga membedakan kedua implementasi tersebut. Dengan Whirlpool, sisa dikecualikan dan diisolasi dari UTXO sebelum siklus coinjoin oleh TX0, sebuah konsep yang akan saya jelaskan lebih lanjut di bab berikutnya. Dengan Wasabi, di sisi lain, sisanya membentuk salah satu output dari transaksi coinjoin, mempertahankan hubungan deterministik antara beberapa input dan output.

Dengan Wabisabi, versi 2.0 dari Wasabi telah mengadaptasi pendekatannya terhadap coinjoin untuk mendekati Whirlpool. Meskipun transaksi coinjoin tetap sangat besar, sekarang dimungkinkan untuk melakukan beberapa putaran berurutan, sehingga mengikuti model Whirlpool. Upaya khusus juga telah dilakukan dalam pengelolaan perubahan: tidak seperti Wasabi 1.0, di mana perubahan secara langsung terkait dengan input pengguna, Wabisabi mencoba membagi perubahan menjadi beberapa jumlah kecil, didistribusikan dalam denominasi yang sama untuk semua peserta.

Kami akan mengilustrasikan hal ini dengan contoh sederhana yang hanya melibatkan 2 pengguna: Alice ingin menggabungkan 115.000 sat dan Bob, 210.000 sat. Dengan mengabaikan komisi, dengan Wasabi 1.0, transaksi coinjoin akan menghasilkan 3 output 100.000 sat, ditambah 1 sisa 15.000 sat untuk Alice dan 1 sisa 10.000 sat untuk Bob. Sisa output akan selalu terhubung dengan input:

Di bawah Wabisabi, transaksi yang sama akan menghasilkan 3 output dari 100.000 sat dan 5 output dari 5.000 sat, sehingga menyebarkan sisanya sehingga tidak dapat ditelusuri secara langsung ke input tertentu:

Secara pribadi, saya percaya bahwa manajemen perubahan di Wabisabi memiliki beberapa risiko yang dapat mengganggu keefektifannya dalam hal privasi:


- Ketika seorang pengguna menyumbangkan UTXO yang jauh lebih besar daripada peserta lain, dia pasti akan mendapatkan sejumlah perubahan yang akan dikaitkan dengan inputnya. Hal ini bertentangan dengan tujuan awal protokol, yang bertujuan untuk menghilangkan perubahan yang dapat diidentifikasi;
- Penggandaan penunjukan untuk memecah-mecah sisanya secara paradoks dapat merusak efisiensi pencampuran. Proses ini dapat menyebabkan penurunan anonset untuk output tertentu karena output tersebut menjadi lebih mudah diidentifikasi;
- Metode ini juga menghasilkan UTXO bernilai rendah yang menimbulkan masalah manajemen bagi pengguna. UTXO kecil ini, jika terlalu mahal untuk dibelanjakan dibandingkan dengan nilainya, dapat menjadi "debu" Fenomena ini mendorong pengguna untuk menggabungkan beberapa input UTXO dalam transaksi mereka di masa mendatang atau mengkonsolidasikannya. Dalam kedua kasus tersebut, karena COH, hal ini dapat mengurangi anonset yang diperoleh atau sepenuhnya membatalkan manfaat privasi yang diperoleh dari koin awal.

Tidak seperti Whirlpool, yang mengimplementasikan protokol ZeroLink dengan memastikan pemisahan yang ketat antara pra-campuran dan pasca-campuran UTXO, Wabisabi tidak mempertahankan pemisahan yang ketat ini. Ada juga masalah dengan penggunaan ulang alamat oleh beberapa pelanggan Wasabi, yang jelas sangat merugikan pengguna.

Pada versi 2.0 dari Wasabi, kebijakan harga coinjoin yang baru telah diterapkan. Sekarang, biaya koordinator ditetapkan sebesar 0,3 persen untuk UTXO yang lebih besar dari 0,01 bitcoin, sedangkan untuk UTXO yang lebih kecil, biaya ini sepenuhnya dinolkan. Selain itu, remix untuk UTXO yang lebih kecil ini gratis, meskipun biaya penambangan tetap ada untuk semua transaksi, termasuk remix.

Kebijakan ini berbeda dengan Whirlpool, di mana komisi tetap, terlepas dari ukuran anonset yang diperoleh. Dengan Wasabi 2.0, meskipun komisi koordinator disetel ulang ke nol untuk UTXO kecil, pengguna tetap harus membayar komisi penambangan untuk semua transaksi, termasuk remix.

Pada saat artikel ini ditulis, penggunaan Wasabi telah menjadi jauh lebih kompleks sebagai akibat dari peristiwa baru-baru ini. Memang, setelah penangkapan para pendiri Samourai Wallet, zkSNACKs, perusahaan yang membiayai dan mengelola pengembangan Wasabi, mengumumkan penghentian layanan koordinasi koinnya pada 1 Juni 2024. Koordinator ini, yang diatur untuk default ke Wasabi, memiliki sebagian besar likuiditas.

Dengan ditutupnya koordinator utama ini, pengguna sekarang harus terhubung ke koordinator independen yang baru. Perubahan ini menimbulkan kekhawatiran: di satu sisi, koordinator baru mungkin tidak memiliki likuiditas yang cukup, sehingga mengurangi efektivitas coinjoin dalam hal privasi. Di sisi lain, ada risiko bertemu dengan koordinator yang jahat. Situasi ini menambah risiko baru yang signifikan bagi mereka yang ingin menggunakan Wabisabi.

Selain masalah teknis, keputusan zkSNACKs, perusahaan di balik Wasabi, untuk menggunakan layanan perusahaan analitik blockchain untuk menyaring peserta ke dalam coinjoins menimbulkan pertanyaan etis dan strategis yang serius. Ide awalnya adalah untuk mencegah penggunaan coinjoin di Wasabi oleh para penjahat, sebuah langkah yang mungkin terlihat sah. Akan tetapi, hal ini menimbulkan sebuah paradoks: membayar biaya kepada koordinator, yang misi utamanya adalah untuk meningkatkan privasi pengguna, hanya untuk mendanai sebuah perusahaan yang bertujuan untuk mengkompromikan privasi yang sama.

Yang lebih mengkhawatirkan lagi adalah prinsip penyaringan, yang sangat kontras dengan filosofi Bitcoin yang menyediakan sistem keuangan yang terbuka dan tidak disensor. Meskipun mungkin terlihat dibenarkan untuk mengecualikan aktivitas kriminal, penyaringan ini juga dapat menargetkan individu yang tindakannya, meskipun diklasifikasikan sebagai ilegal dalam beberapa konteks, mungkin dapat dibenarkan secara moral atau bermanfaat secara sosial. Contoh Edward Snowden mengilustrasikan dikotomi ini dengan sempurna: dianggap sebagai penjahat oleh beberapa pemerintah karena pengungkapannya, dia dilihat oleh pemerintah lain sebagai whistleblower yang bertindak untuk kepentingan publik. Kerumitan ini menggarisbawahi potensi bahaya penyaringan, yang meskipun dimulai dengan niat baik, pada akhirnya dapat membahayakan hak dan keamanan pengguna yang sah. Saya juga bisa saja menyebutkan para aktivis dan jurnalis yang teraniaya di bawah rezim otoriter tertentu. Seperti yang sudah Anda duga, preferensi saya tidak diragukan lagi adalah model Whirlpool untuk melakukan koin bersama di Bitcoin. Sistem ini menonjol karena ketelitiannya dan menawarkan jaminan yang unggul dalam hal privasi. Sistem ini juga merupakan satu-satunya yang mengusulkan pencampuran yang dianggap sempurna dalam konteks matematika. Menurut pendapat saya, model ini mewakili masa depan koin bersama di Bitcoin. Oleh karena itu, saya mengajak Anda untuk mengeksplorasi model ini secara lebih mendalam di bab selanjutnya.

## Pengoperasian Pusaran Air

<chapterId>bdbd7109-e36d-4b4f-a3c6-928df4e9bfda</chapterId>

Whirlpool berbeda dengan metode coinjoin lainnya dengan menggunakan transaksi "_ZeroLink_", yang memastikan bahwa secara teknis tidak ada hubungan antara semua input dan semua output. Pencampuran sempurna ini dicapai melalui struktur di mana setiap peserta berkontribusi dalam jumlah yang sama dalam input (dengan pengecualian biaya penambangan), sehingga menghasilkan output dengan jumlah yang sama persis.

Pendekatan yang ketat pada input ini memberikan karakteristik unik pada transaksi coinjoin Whirlpool: tidak adanya hubungan deterministik antara input dan output. Dengan kata lain, setiap output memiliki probabilitas yang sama untuk dikaitkan dengan peserta mana pun, relatif terhadap semua output lain dalam transaksi.

![BTC204](assets/fr/136.webp)

### Pengoperasian Umum Pusaran Air

Awalnya, jumlah peserta di setiap coinjoin Whirlpool dibatasi hingga 5 orang, dengan 2 pendatang baru dan 3 remixer (kami akan menjelaskan konsep ini nanti). Namun, peningkatan biaya untuk transaksi on-chain yang diamati pada tahun 2023 mendorong tim Samourai untuk memikirkan kembali model mereka untuk meningkatkan privasi sekaligus mengurangi biaya. Dengan demikian, dengan mempertimbangkan situasi pasar komisi dan jumlah peserta, koordinator sekarang dapat mengatur coinjoin yang terdiri dari 6, 7, atau 8 peserta. Sesi yang disempurnakan ini disebut dengan nama "_Surge Cycles_." Penting untuk dicatat bahwa terlepas dari konfigurasinya, selalu hanya ada 2 peserta baru dalam coinjoin Whirlpool.

Dengan demikian, transaksi Whirlpool dicirikan oleh jumlah input dan output yang identik, yang dapat:


- 5 input dan 5 output;

![BTC204](assets/fr/137.webp)


- 6 input dan 6 output;

![BTC204](assets/fr/138.webp)


- 7 input dan 7 output;

![BTC204](assets/fr/139.webp)


- 8 input dan 8 output.

![BTC204](assets/fr/140.webp)

Dengan demikian, model yang diusulkan Whirlpool didasarkan pada transaksi coinjoin kecil. Tidak seperti Wabisabi dan JoinMarket, di mana ketahanan anonset didasarkan pada volume partisipan dalam satu siklus (atau beberapa siklus), Whirlpool bergantung pada penggabungan beberapa siklus kecil. Dalam model ini, pengguna hanya mengeluarkan biaya pada saat awal masuk ke dalam pool, sehingga mereka dapat berpartisipasi dalam banyak remix tanpa biaya tambahan. Pendatang baru yang menanggung biaya penambangan untuk para remixer.

Dengan setiap koin tambahan di mana sebuah koin berpartisipasi, bersama dengan koin-koin lainnya yang ditemui di masa lalu, anonset akan tumbuh secara eksponensial. Tujuannya, kemudian, adalah untuk mengambil keuntungan dari remix gratis ini, yang, dengan setiap kejadian, membantu memperkuat kepadatan anonset yang terkait dengan setiap campuran koin.

Whirlpool didesain dengan mempertimbangkan dua persyaratan penting:


- Aksesibilitas implementasi pada perangkat seluler, karena Samourai Wallet pada dasarnya adalah aplikasi ponsel cerdas;
- Kecepatan siklus remixing untuk mendorong peningkatan yang signifikan dalam anonset.

Keharusan ini memandu para pengembang Samourai Wallet dalam mendesain Whirlpool, sehingga mereka membatasi jumlah partisipan per siklus. Terlalu sedikit peserta akan mengganggu keefektifan coinjoin, secara drastis mengurangi anonset yang dihasilkan di setiap siklus, sementara terlalu banyak peserta akan menimbulkan masalah manajemen pada aplikasi seluler dan menghambat aliran siklus.

Pada akhirnya, tidak perlu memiliki jumlah peserta yang banyak untuk melakukan coinjoin di Whirlpool karena anonset direalisasikan dari akumulasi beberapa siklus coinjoin. Prinsip yang paling penting di sini adalah homogenitas UTXO dari semua peserta, karena hal ini memungkinkan terjadinya pencampuran yang sempurna, dan dengan demikian mendapatkan manfaat penuh dari siklus pencampuran dan remixing.

### Kumpulan dan tarif Coinjoin

Agar beberapa siklus ini dapat secara efektif meningkatkan anonset koin campuran, beberapa kerangka kerja harus dibuat untuk membatasi jumlah UTXO yang digunakan. Oleh karena itu, Whirlpool mendefinisikan beberapa pool.

Sebuah pool mewakili sekelompok pengguna yang ingin bergabung bersama, yang menyetujui jumlah UTXO yang akan digunakan untuk mengoptimalkan proses coinjoin dengan tetap menjaga homogenitas koin yang sempurna. Setiap pool menentukan jumlah tetap untuk UTXO, yang harus dipenuhi oleh pengguna untuk dapat berpartisipasi. Jadi, untuk melakukan coinjoin dengan Whirlpool, sebuah pool harus dipilih. Pool yang saat ini tersedia adalah sebagai berikut:


- 0.5 bitcoin;
- 0.05 bitcoin;
- 0.01 bitcoin;
- 0.001 bitcoin (= 100.000 satoshi).

Dengan bergabung ke dalam sebuah pool dengan bitcoin Anda, bitcoin tersebut akan dibagi untuk menghasilkan UTXO yang homogen dengan peserta lain di dalam pool tersebut. Setiap pool memiliki batas maksimum; oleh karena itu, untuk jumlah yang melebihi batas ini, Anda akan dipaksa untuk membuat dua entri terpisah ke dalam pool yang sama atau beralih ke pool lain dengan jumlah yang lebih besar:

| Pool (bitcoin) | Jumlah maksimum per entri (bitcoin)

|----------------|----------------------------------------|

| 0,5 | 35 |

| 0,05 | 3,5 |

| 0,01 | 0,7 |

| 0,001 | 0,025 |

Sebuah UTXO dianggap sebagai bagian dari pool ketika sudah siap untuk diintegrasikan ke dalam koin bersama. Namun, ini tidak berarti bahwa pengguna kehilangan kepemilikannya. Seperti yang telah kita lihat pada bab-bab pertama di bagian ini, melalui siklus pencampuran yang berbeda, Anda tetap memegang kendali penuh atas kunci Anda dan, akibatnya, atas bitcoin Anda. Inilah yang membedakan teknik coinjoin dengan teknik pencampuran terpusat lainnya.

Untuk bergabung dengan pool coinjoin, biaya layanan dan biaya penambangan harus dibayarkan. Biaya layanan ditetapkan untuk setiap pool dan dimaksudkan untuk memberikan kompensasi kepada tim yang bertanggung jawab atas pengembangan dan pemeliharaan Whirlpool.

Biaya layanan untuk menggunakan Whirlpool harus dibayar satu kali saat memasuki kolam renang. Setelah langkah ini selesai, Anda dapat berpartisipasi dalam jumlah remix yang tidak terbatas tanpa biaya tambahan. Berikut ini adalah biaya tetap saat ini untuk setiap kolam renang:

| Pool (bitcoin) | Biaya input (bitcoin) | Biaya input (bitcoin)

| -------------- | --------------------------------- |

| 0.5 | 0.0175 |

| 0.05 | 0.00175 |

| 0,01 | 0,0005 (50.000 sat) | 0,01

| 0,001 | 0,00005 (5.000 sat) | 0,00005 (5.000 sat)

Biaya ini pada dasarnya berfungsi sebagai tiket masuk ke pool yang Anda pilih, berapa pun jumlah yang Anda masukkan ke dalam coinjoin. Jadi, apakah Anda masuk ke pool 0,01 BTC dengan tepat 0,01 BTC atau masuk dengan 0,5 BTC, biayanya akan tetap sama dalam nilai absolut.

Sebelum melanjutkan dengan coinjoin Whirlpool, pengguna kemudian memiliki pilihan di antara 2 strategi:


- Pilihlah kelompok yang lebih kecil untuk meminimalkan biaya layanan, dengan mengetahui bahwa mereka akan menerima beberapa UTXO yang lebih kecil sebagai imbalannya;
- Atau lebih memilih kumpulan yang lebih besar, setuju untuk membayar biaya yang lebih tinggi untuk mendapatkan sejumlah kecil UTXO yang bernilai lebih tinggi.

Secara umum, tidak disarankan untuk menggabungkan beberapa UTXO campuran setelah siklus coinjoin, karena hal ini dapat mengganggu privasi yang diperoleh, terutama karena heuristik kepemilikan input yang umum (CIOH: _Common-Input-Ownership-Heuristic_). Oleh karena itu, mungkin bijaksana untuk memilih pool yang lebih besar, bahkan jika itu berarti membayar lebih banyak, untuk menghindari terlalu banyak UTXO yang bernilai kecil sebagai output. Pengguna harus mengevaluasi trade-off ini untuk memilih pool yang dia sukai.

Selain biaya layanan, biaya penambangan yang melekat pada setiap transaksi Bitcoin juga harus dipertimbangkan. Sebagai pengguna Whirlpool, Anda harus membayar biaya penambangan untuk transaksi persiapan (`Tx0`) dan juga biaya untuk koin pertama. Semua koin berikutnya akan gratis, karena model Whirlpool yang membayar pendatang baru.

Faktanya, dalam setiap coinjoin Whirlpool, 2 pengguna di antara masukannya adalah peserta baru. Input lainnya berasal dari remixer. Akibatnya, biaya penambangan untuk semua peserta dalam transaksi ditanggung oleh 2 peserta baru ini, yang kemudian juga akan mendapatkan keuntungan dari remix gratis:

![BTC204](assets/it/54/07.webp)

Karena sistem biaya ini, Whirlpool benar-benar berbeda dari implementasi coinjoin lainnya karena anonimitas UTXO tidak sebanding dengan harga yang dibayarkan oleh pengguna. Dengan demikian, tingkat anonimitas yang sangat tinggi dapat dicapai dengan hanya membayar biaya masuk pool dan biaya penambangan untuk 2 transaksi (`Tx0` dan campuran awal).

Penting untuk diperhatikan bahwa pengguna juga harus menanggung biaya penambangan untuk menarik UTXO mereka dari pool setelah menjalankan beberapa coinjoin, kecuali jika mereka telah memilih opsi `mix to`, yang memungkinkan mereka untuk memberikan alamat eksternal yang akan secara langsung menerima dana sebagai output dari coinjoin, tanpa transaksi tambahan.

### Akun Dompet HD

Untuk melakukan coinjoin melalui Whirlpool, dompet harus membuat beberapa akun terpisah. Ini adalah prinsip dari protokol ZeroLink. Sebuah akun, dalam konteks dompet HD (_Hierarchical Deterministic_), merupakan sebuah bagian yang sepenuhnya terisolasi dari yang lain, pemisahan ini terjadi pada tingkat kedalaman ketiga dari hirarki dompet, yaitu pada tingkat `xpub`.

![BTC204](assets/it/54/08.webp)

Sebuah dompet HD secara teoritis dapat menghasilkan hingga `2^(32/2)` akun yang berbeda. Akun awal, yang digunakan secara default pada semua dompet Bitcoin, berhubungan dengan indeks `0`.

Untuk portofolio yang disesuaikan dengan Whirlpool, 4 akun digunakan untuk memenuhi persyaratan proses ZeroLink:


- Akun **deposito**, diidentifikasi dengan indeks `0'`;
- Rekening bank **bad** (atau "bursa beracun"), diidentifikasi dengan indeks `2 147 483 644'`;
- Akun **premix**, diidentifikasi dengan indeks `2 147 483 645'`;
- Akun **postmix**, diidentifikasi dengan indeks `2 147 483 646'`.

Masing-masing akun ini menjalankan fungsi spesifik dalam proses penggabungan, yang akan kita bahas di bagian berikut.

Semua akun ini ditautkan ke satu seed, yang memungkinkan pengguna untuk memulihkan akses ke semua bitcoin mereka menggunakan frasa pemulihan dan, jika perlu, kata sandi mereka. Akan tetapi, perlu untuk menentukan pada perangkat lunak, selama operasi pemulihan ini, indeks yang berbeda dari akun-akun yang telah digunakan.

Sekarang mari kita periksa berbagai tahapan coinjoin Whirlpool dalam akun-akun ini.

### TX0

Titik awal dari setiap coinjoin Whirlpool adalah **akun deposit**. Akun ini adalah akun yang secara otomatis Anda gunakan ketika Anda membuat dompet bitcoin baru. Akun ini harus dikreditkan dengan bitcoin yang ingin Anda campurkan.

`Tx0` merupakan langkah pertama dalam proses pencampuran Whirlpool. Ini bertujuan untuk menyiapkan dan menyamakan UTXO untuk coinjoin, membaginya menjadi unit yang sesuai dengan jumlah kolam yang dipilih, untuk memastikan homogenitas pencampuran. UTXO yang telah disamakan kemudian dikirim ke akun **premix**. Sedangkan untuk selisih yang tidak dapat masuk ke dalam pool, dipisahkan ke dalam akun tertentu: **bad bank** (atau "toxic exchange").

Transaksi `Tx0` awal ini juga berfungsi untuk melunasi biaya layanan yang harus dibayarkan kepada koordinator coinjoin. Tidak seperti langkah-langkah selanjutnya, transaksi ini tidak bersifat kolaboratif; oleh karena itu, pengguna harus menanggung seluruh biaya penambangan:

![BTC204](assets/it/54/09.webp)

Dalam contoh transaksi `Tx0` ini, input sebesar `372.000 sats` dari **rekening deposito** dibagi menjadi beberapa output UTXO, yang didistribusikan sebagai berikut:


- Sejumlah `5.000 sats` dialokasikan kepada koordinator untuk biaya layanan, sesuai dengan entri ke dalam kumpulan `100.000 sats`;
- 3 UTXO yang disiapkan untuk pencampuran, dialihkan ke akun **premix** kami dan didaftarkan ke koordinator. UTXO ini disetarakan dengan harga `108.000 sats` masing-masing, untuk menutupi biaya penambangan untuk campuran awal di masa mendatang;
- Surplus yang tidak dapat masuk ke dalam pool, karena terlalu kecil, dianggap sebagai pertukaran beracun. Ini dikirim ke akun spesifiknya. Di sini, pertukaran ini berjumlah `40.000 sat`;
- Terakhir, ada `3.000 sat` yang bukan merupakan output, tetapi merupakan biaya penambangan yang diperlukan untuk mengonfirmasi `Tx0`.

Sebagai contoh, berikut ini adalah Tx0 Whirlpool yang asli (bukan milik saya): [edef60744f539483d868caff49d4848e5cc6e805d6cdc8d0f9bdbbaedcb5fc46](https://mempool.space/fr/tx/edef60744f539483d868caff49d4848e5cc6e805d6cdc8d0f9bdbbaedcb5fc46)

![BTC204](assets/fr/145.webp)

### Perubahan yang Beracun

Kelebihan yang tidak dapat diintegrasikan ke dalam pool, di sini setara dengan `40.000 sats`, dialihkan ke akun **bad bank**, yang juga disebut sebagai "pertukaran beracun", untuk memastikan pemisahan yang ketat dari UTXO lain dalam portofolio.

UTXO ini berbahaya bagi privasi pengguna karena tidak hanya masih terkait dengan masa lalu pengguna, dan dengan demikian mungkin dengan identitas pemiliknya, tetapi juga ditandai sebagai milik pengguna yang telah berpartisipasi dalam koin bersama.

![BTC204](assets/fr/146.webp)

Jika UTXO ini digabungkan dengan keluaran yang diacak, mereka akan kehilangan semua privasi yang diperoleh selama siklus coinjoin, terutama karena CIOH (_Common-Input-Ownership-Heuristic_). Jika digabungkan dengan perubahan beracun lainnya, pengguna berisiko kehilangan privasi karena ini akan menghubungkan input yang berbeda dari siklus coinjoin. Oleh karena itu, ini harus ditangani dengan hati-hati. Kita akan membahas pengelolaan UTXO beracun ini secara lebih rinci di bagian terakhir bab ini.

### Campuran Awal

Setelah `Tx0` selesai, UTXO yang telah disamakan dikirim ke akun **premix** dalam portofolio kami, siap untuk dimasukkan ke dalam siklus penggabungan pertama mereka, yang juga disebut "campuran awal." Jika, seperti dalam contoh kita, `Tx0` menghasilkan beberapa UTXO yang dimaksudkan untuk pencampuran, masing-masing akan diintegrasikan ke dalam campuran awal yang terpisah.

Pada akhir dari campuran pertama ini, akun **premix** akan kosong, sementara koin kita, setelah membayar biaya penambangan untuk koin pertama ini, akan diselesaikan dengan jumlah yang ditentukan oleh pool yang dipilih. Dalam contoh kita, UTXO awal kita sebesar `108.000 satoshi` akan berkurang menjadi tepat `100.000 satoshi`.

![BTC204](assets/fr/147.webp)

### The Remixes

Setelah pencampuran awal, UTXO ditransfer ke akun **postmix**. Akun ini mengumpulkan UTXO yang sudah dicampur dan yang menunggu untuk di-remix. Ketika klien Whirlpool aktif, UTXO di akun **postmix** secara otomatis tersedia untuk remix dan akan dipilih secara acak untuk berpartisipasi dalam putaran baru ini.

Sebagai pengingat, remix sepenuhnya gratis: tidak ada biaya layanan tambahan atau biaya penambangan yang diperlukan. Menyimpan UTXO di akun **postmix** akan menjaga nilainya tetap utuh dan secara bersamaan meningkatkan anonsetnya. Inilah sebabnya mengapa penting untuk mengizinkan koin-koin ini berpartisipasi dalam beberapa siklus coinjoin. Ini sama sekali tidak memerlukan biaya dan meningkatkan level anonset mereka.

Ketika Anda memutuskan untuk membelanjakan UTXO campuran, Anda dapat melakukannya langsung dari akun **postmix** ini. Disarankan untuk menyimpan UTXO campuran di akun ini untuk mendapatkan keuntungan dari remix gratis dan untuk mencegahnya meninggalkan sirkuit Whirlpool, yang dapat mengurangi privasinya.

### Bagaimana cara mengelola akun postmix Anda dengan benar?

Setelah menjalankan siklus coinjoin, strategi terbaik adalah menyimpan UTXO Anda di akun **postmix**, sambil menunggu penggunaannya di masa mendatang. Bahkan disarankan untuk membiarkannya melakukan remix tanpa batas waktu hingga Anda perlu membelanjakannya.

Beberapa pengguna dapat mempertimbangkan untuk mentransfer bitcoin campuran mereka ke dompet perangkat keras yang terlindungi. Hal ini memungkinkan, tetapi penting untuk mengikuti rekomendasi Samourai Wallet dengan cermat agar tidak mengganggu kerahasiaan yang diperoleh.

Menggabungkan UTXO adalah kesalahan yang paling sering dilakukan. Anda harus menghindari menggabungkan UTXO campuran dengan UTXO yang tidak tercampur dalam transaksi yang sama untuk menghindari heuristik Common-Input-Ownership (CIOH). Hal ini membutuhkan pengelolaan yang cermat terhadap UTXO dalam portofolio Anda, terutama dalam hal pelabelan.

![BTC204](assets/fr/148.webp)

Penting juga untuk berhati-hati dalam mengkonsolidasikan UTXO campuran secara bersamaan. Konsolidasi moderat dapat dilakukan jika UTXO campuran Anda memiliki anonset yang signifikan, tetapi hal ini akan mengurangi kerahasiaan koin Anda. Pastikan konsolidasi tidak terlalu signifikan atau dilakukan setelah jumlah penggabungan yang tidak mencukupi, karena berisiko menimbulkan hubungan yang disimpulkan antara UTXO Anda sebelum dan sesudah siklus penggabungan. Jika Anda ragu dengan manipulasi ini, praktik terbaiknya adalah tidak menggabungkan UTXO setelah pencampuran, dan mentransfernya satu per satu ke dompet perangkat keras Anda, menghasilkan alamat kosong baru setiap kali. Ingatlah untuk memberi label yang benar pada setiap UTXO yang diterima.

Juga tidak disarankan untuk mentransfer postmix UTXO Anda ke dompet yang menggunakan skrip yang tidak umum. Sebagai contoh, jika Anda masuk ke Whirlpool dari dompet multisig yang menggunakan skrip `P2WSH`, ada kemungkinan kecil Anda akan tercampur dengan pengguna lain yang memiliki jenis dompet yang sama pada awalnya. Jika Anda menarik postmix Anda di dompet multisig yang sama, tingkat privasi bitcoin campuran Anda akan sangat berkurang. Selain script, ada banyak sidik jari dompet lain yang dapat menipu Anda.

Seperti halnya transaksi Bitcoin lainnya, penting juga untuk tidak menggunakan alamat penerima secara berulang-ulang. Setiap transaksi baru harus diterima di alamat baru yang kosong.

Solusi paling sederhana dan paling aman adalah membiarkan UTXO campuran Anda beristirahat di akun **postmix** mereka, sehingga mereka dapat mencampurnya dan menyentuhnya hanya untuk membelanjakannya. Portofolio Samourai dan Sparrow memiliki perlindungan tambahan terhadap semua risiko analisis rantai ini. Perlindungan ini membantu Anda menghindari kesalahan.

### Bagaimana cara mengelola perubahan toksik Anda dengan benar?

Selanjutnya, Anda harus berhati-hati dalam menangani perubahan toksik Anda, perubahan yang tidak dapat masuk ke dalam pool coinjoin. UTXO beracun ini, yang dihasilkan dari penggunaan Whirlpool, menimbulkan risiko terhadap privasi Anda karena mereka membuat hubungan antara Anda dan penggunaan coinjoin. Oleh karena itu, sangat penting untuk menanganinya dengan hati-hati dan tidak menggabungkannya dengan UTXO lain, terutama UTXO campuran.

Berikut adalah beberapa strategi yang perlu dipertimbangkan untuk menggunakannya:


- Campurkan di kolam yang lebih kecil:** Jika UTXO beracun Anda cukup besar untuk ditampung di kolam yang lebih kecil, pertimbangkan untuk mencampurkannya. Ini sering kali merupakan pilihan terbaik. Namun, mencampurkan beberapa UTXO beracun bersama-sama untuk mengakses kolam tidak disarankan, karena ini dapat menghubungkan pintu masuk yang berbeda.
- Tandai sebagai "tidak dapat dibelanjakan":** Pendekatan lain adalah berhenti menggunakannya, tandai sebagai "tidak dapat dibelanjakan" di akun khusus dan cukup hodl. Hal ini memastikan bahwa Anda tidak membelanjakannya secara tidak sengaja. Jika nilai bitcoin meningkat, pool baru yang lebih cocok untuk UTXO beracun Anda mungkin akan muncul;
- Memberikan donasi:** Pertimbangkan untuk memberikan donasi, bahkan donasi sederhana, kepada pengembang yang bekerja pada Bitcoin dan perangkat lunak terkait. Anda juga dapat menyumbang ke organisasi yang menerima BTC. Jika mengelola UTXO beracun Anda tampak terlalu rumit, Anda bisa menyingkirkannya dengan memberikan donasi.
- Beli Kartu Hadiah:** Platform seperti [Bitrefill] (https://www.bitrefill.com/) memungkinkan Anda untuk menukar bitcoin dengan kartu hadiah yang dapat digunakan di berbagai pedagang. Ini bisa menjadi cara untuk membuang UTXO beracun Anda tanpa kehilangan nilai yang terkait.
- Gabungkan ke Monero:** Dompet Samourai menawarkan layanan pertukaran atom antara BTC dan XMR. Ini sangat ideal untuk mengelola UTXO beracun dengan mengkonsolidasikannya ke Monero, tanpa mengorbankan privasi Anda melalui KYC, sebelum mengirimnya kembali ke Bitcoin. Namun, opsi ini bisa jadi mahal dalam hal biaya penambangan dan premi karena kendala likuiditas.
- Kirim ke Lightning Network:** Mentransfer UTXO ini ke Lightning Network untuk mendapatkan keuntungan dari pengurangan biaya transaksi adalah opsi yang menarik. Namun, metode ini dapat mengungkapkan beberapa informasi tergantung pada penggunaan Lightning Anda dan oleh karena itu harus dilakukan dengan hati-hati.

### Bagaimana cara menggunakan Whirlpool?

Setelah penangkapan para pendiri Samourai Wallet dan penyitaan server mereka pada tanggal 24 April 2024, alat Whirlpool tidak lagi berfungsi, bahkan bagi mereka yang memiliki Dojo sendiri. Sebelumnya, alat ini tersedia di Samourai Wallet dan Sparrow Wallet.

![BTC204](assets/fr/149.webp)

Namun, masih ada kemungkinan bahwa instrumen ini dapat digunakan kembali dalam beberapa minggu ke depan, tergantung pada hasil uji coba, atau diluncurkan kembali dengan cara yang berbeda. Bagaimanapun, saya percaya bahwa pasar coinjoin di Bitcoin tidak akan tetap tanpa pasokan untuk waktu yang lama, karena ada permintaan yang jelas. Selain itu, model Whirlpool, yang paling canggih dalam hal privasi, pasti akan digunakan untuk implementasi lain di masa depan.

Kami mengikuti perkembangan kasus ini serta perkembangan terkait alat yang terkait. Yakinlah bahwa kami akan memperbarui pelatihan ini saat informasi baru tersedia.

Pada bab berikutnya, kita akan mengetahui apa itu "anonset", bagaimana indikator ini dihitung, dan bagaimana indikator ini dapat membantu kita memperkirakan efektivitas siklus coinjoin.

https://planb.network/tutorials/privacy/on-chain/coinjoin-sparrow-wallet-84def86d-faf5-4589-807a-83be60720c8b
https://planb.network/tutorials/privacy/on-chain/coinjoin-samourai-wallet-e566803d-ab3f-4d98-9136-5462009262ef
https://planb.network/tutorials/privacy/on-chain/coinjoin-dojo-c4b20263-5b30-4c74-ae59-dc8d0f8715c2
## Set Anonimitas

<chapterId>be1093dc-1a74-40e5-9545-2b97a7d7d431</chapterId>

Setelah mempelajari cara kerja coinjoin dan tantangan yang terkait dengan penggabungan yang efektif, sekarang kita akan mempelajari cara mengukur keefektifan ini. Bagaimana cara menentukan apakah proses coinjoin efektif dan tingkat anonimitas apa yang diperoleh sebuah koin? Inilah yang akan kita bahas dalam bab ini dengan set anonimitas atau "anonset" dalam bahasa Inggris.

### Pengingat tentang Kegunaan Coinjoin

Kegunaan CoinJoin terletak pada kemampuannya untuk menghasilkan penyangkalan yang masuk akal dengan membenamkan koin Anda di dalam sekelompok koin yang tidak dapat dibedakan. Tujuan dari tindakan ini adalah untuk memutus hubungan penelusuran, baik dari masa lalu ke masa kini dan dari masa kini ke masa lalu.

Dengan kata lain, seorang analis yang mengetahui transaksi awal Anda (`Tx0`) pada saat masuknya siklus CoinJoin seharusnya tidak dapat mengidentifikasi dengan pasti UTXO Anda pada saat keluarnya siklus remix (analisis dari masuk ke siklus hingga keluar dari siklus).

![BTC204](assets/it/55/01.webp)

Sebaliknya, seorang analis yang mengetahui UTXO Anda pada output siklus CoinJoin seharusnya tidak dapat menentukan transaksi asli pada input siklus (analisis dari output siklus ke input siklus).

![BTC204](assets/it/55/02.webp)

Untuk menilai kesulitan seorang analis dalam menghubungkan masa lalu dengan masa sekarang dan sebaliknya, perlu untuk mengukur ukuran kelompok koin yang homogen di mana koin Anda disembunyikan. Ukuran ini memberi tahu kita jumlah analisis yang memiliki probabilitas yang sama. Jadi, jika analisis yang benar tenggelam di antara 3 analisis lain yang memiliki probabilitas yang sama, tingkat penyembunyian Anda sangat rendah. Namun, jika analisis yang benar berada di dalam satu set yang terdiri dari 20.000 analisis yang memiliki kemungkinan yang sama, koin Anda tersembunyi dengan sangat baik. Dan tepatnya, ukuran set ini mewakili indikator yang disebut anonset.

### Memahami Anonset

Anonset berfungsi sebagai indikator untuk menilai tingkat privasi UTXO tertentu. Lebih khusus lagi, mereka mengukur jumlah UTXO yang tidak dapat dibedakan dalam set yang mencakup koin yang sedang dipelajari. Persyaratan untuk set UTXO yang homogen berarti bahwa anonset biasanya dihitung pada siklus CoinJoin. Penggunaan indikator ini sangat relevan untuk Whirlpool CoinJoin karena keseragamannya.

Anonset memungkinkan, jika diperlukan, untuk menilai kualitas CoinJoins. Ukuran anonset yang besar berarti tingkat anonimitas yang tinggi, karena menjadi sulit untuk membedakan UTXO tertentu dalam set yang homogen.

Ada 2 jenis anonset:


- Calon anonset; ** Calon anonset;**
- Anonset retrospektif.**

### Calon Anonset

Anonset berwawasan ke depan menunjukkan ukuran kelompok di mana UTXO yang dipelajari disembunyikan di pintu keluar siklus, dengan mengetahui UTXO di pintu masuk, yaitu jumlah koin yang tidak dapat dibedakan yang ada di dalam kelompok ini. Dalam bahasa Inggris, nama indikator ini adalah "forward anonset," atau "metrik berwawasan ke depan."

Indikator ini memberikan ukuran ketahanan privasi mata uang terhadap analisis masa lalu-ke-sekarang (input ke output).

![BTC204](assets/it/55/03.webp)

Metrik ini memperkirakan sejauh mana UTXO Anda terlindungi dari upaya untuk merekonstruksi riwayatnya dari titik masuk ke titik keluar dalam proses coinjoin.

Sebagai contoh, jika transaksi Anda berpartisipasi dalam siklus coinjoin pertama dan dua siklus turun tambahan telah selesai, calon anonset koin Anda adalah `13`:

![BTC204](assets/fr/153.webp)

Sebagai contoh, mari kita bayangkan bahwa koin kita di pintu masuk siklus coinjoin mendapatkan keuntungan dari calon anonset `86.871`. Secara praktis, ini berarti koin tersebut tersembunyi di antara koin-koin lain yang tidak dapat dibedakan. Untuk pengamat luar yang mengetahui koin ini di awal siklus coinjoin dan mencoba melacak jalan keluarnya, dia akan dihadapkan dengan `86,871` kemungkinan UTXO, masing-masing dengan probabilitas yang sama dengan koin yang dicari.

![BTC204](assets/it/55/05.webp)

### Anonset Retrospektif

Anonset retrospektif menunjukkan jumlah sumber yang memungkinkan untuk koin tertentu, dengan mengetahui UTXO pada saat keluar dari siklus. Indikator ini mengukur ketahanan privasi koin terhadap analisis masa kini-ke-masa lalu (keluar ke masuk), yaitu seberapa sulit bagi seorang analis untuk melacak asal-usul koin Anda, sebelum siklus koin. Dalam bahasa Inggris, nama indikator ini adalah "backward anonset," atau "metrik retrospektif."

Dengan mengetahui UTXO Anda pada saat keluar dari siklus, anonset retrospektif menentukan jumlah potensi transaksi Tx0 yang dapat menjadi entri Anda dalam siklus coinjoin. Pada diagram di bawah ini, ini sesuai dengan jumlah semua gelembung oranye.

Sebagai contoh, mari kita bayangkan bahwa koin kita pada saat keluar dari siklus coinjoin mendapatkan keuntungan dari anonset retrospektif sebesar `42.185`. Secara praktis, ini berarti ada `42.185` sumber yang memungkinkan untuk UTXO ini. Jika pengamat luar mengidentifikasi koin ini pada akhir siklus dan mencoba melacak asalnya, dia akan dihadapkan pada `42.185` kemungkinan sumber yang mungkin, semuanya dengan probabilitas yang sama untuk menjadi sumber yang dicari.

### Bagaimana cara menghitung anonset secara konkret?

Anda dapat menghitung anonset secara manual menggunakan penjelajah blok untuk set kecil. Namun, untuk anonset yang lebih besar, penggunaan alat khusus menjadi sangat penting. Sepengetahuan saya, satu-satunya perangkat lunak yang mampu melakukan tugas ini adalah _Whirlpool Stats Tool_, sebuah alat Python yang dikembangkan oleh tim Samourai dan OXT. Sayangnya, alat ini saat ini tidak berfungsi setelah penangkapan para pendiri Samourai dan penghentian OXT, yang digunakan untuk mengekstrak data dari blockchain.

Seperti yang telah kita lihat dalam bab ini, anonset hanya dapat dihitung jika terdapat homogenitas dalam struktur coinjoin. Dan tepatnya, pada bab selanjutnya, kita akan mengetahui bagaimana cara menghitung homogenitas ini dalam sebuah transaksi Bitcoin, baik itu coinjoin maupun transaksi yang lebih tradisional.

https://planb.network/tutorials/privacy/analysis/wst-anonsets-0354b793-c301-48af-af75-f87569756375
## Entropi

<chapterId>e4fe289d-618b-49a2-84c9-68c562e708b4</chapterId>

Seperti yang telah kita lihat pada bagian ini tentang coinjoin, homogenitas UTXO pada input dan output memainkan peran penting dalam meningkatkan kerahasiaan transaksi Bitcoin. Parameter ini memungkinkan penyangkalan yang masuk akal terhadap analisis rantai. Beberapa metode dapat mengukur homogenitas ini, tetapi salah satu yang paling efektif, menurut saya, adalah penggunaan indikator yang disediakan oleh alat _Boltzmann_, yang dikembangkan oleh tim OXT dan Dompet Samourai, khususnya entropi transaksi. Inilah yang akan kita pelajari secara rinci dalam bab ini.

Tidak seperti anonset, yang dihitung berdasarkan sekumpulan transaksi, indikator yang akan kami tampilkan di sini fokus secara eksklusif pada satu transaksi, baik itu coinjoin atau transaksi yang lebih tradisional.

### Jumlah interpretasi

Indikator pertama yang dapat diamati dalam transaksi Bitcoin adalah jumlah total interpretasi yang mungkin terjadi di mata pengamat luar yang menganalisis transaksi tersebut. Dengan mempertimbangkan nilai UTXO yang terlibat dalam transaksi, indikator ini menunjukkan jumlah cara di mana input dapat dikaitkan dengan output. Dengan kata lain, indikator ini menentukan jumlah kemungkinan interpretasi yang dapat dihasilkan oleh sebuah transaksi dalam aliran bitcoin dari sudut pandang pengamat luar yang menganalisisnya.

Sebagai contoh, sebuah transaksi pembayaran sederhana dengan 1 input dan 2 output hanya memiliki satu interpretasi, yaitu input #0 mendanai output #0 dan output #1. Tidak ada interpretasi lain yang memungkinkan:

![BTC204](assets/fr/159.webp)

Sebaliknya, coinjoin yang terstruktur menurut model Whirlpool 5x5 memiliki 1.496 kemungkinan kombinasi:

![BTC204](assets/fr/160.webp)

Sebuah coinjoin Whirlpool Surge Cycle 8x8 menghasilkan interpretasi sebesar $9.934.563:

![BTC204](assets/fr/161.webp)

### Entropi

Dari jumlah interpretasi sebuah transaksi Bitcoin, kita dapat menghitung entropinya.

Dalam konteks umum kriptografi dan informasi, entropi adalah sebuah ukuran kuantitatif dari ketidakpastian atau ketidakpastian yang terkait dengan sumber data atau proses acak. Dengan kata lain, entropi adalah sebuah cara untuk mengukur seberapa sulit untuk memprediksi atau menebak sebuah informasi.

Dalam konteks khusus analisis rantai, entropi juga merupakan nama sebuah indikator, yang berasal dari entropi Shannon dan [ditemukan oleh LaurentMT] (https://gist.github.com/LaurentMT/e758767ca4038ac40aaf), yang dapat dihitung pada transaksi Bitcoin.

Ketika sebuah transaksi memiliki banyak kemungkinan interpretasi, sering kali lebih relevan untuk merujuk pada entropinya. Indikator ini memberikan ukuran kurangnya pengetahuan analis mengenai konfigurasi yang tepat dari transaksi. Dengan kata lain, semakin tinggi entropi, semakin sulit bagi para analis untuk mengidentifikasi aliran bitcoin antara input dan output.

Dalam praktiknya, entropi mengungkapkan apakah, dari sudut pandang pengamat luar, sebuah transaksi memiliki beberapa kemungkinan interpretasi, hanya berdasarkan pada jumlah input dan output, tanpa mempertimbangkan pola dan heuristik eksternal atau internal lainnya. Entropi yang tinggi identik dengan kerahasiaan yang lebih tinggi untuk transaksi.

Entropi didefinisikan sebagai logaritma biner dari jumlah kombinasi yang mungkin. Berikut adalah rumus yang digunakan dengan $E$ yang mewakili entropi transaksi dan $C$ jumlah interpretasi yang mungkin:

$$
E = \log_2(C)
$$

Dalam matematika, logaritma biner (logaritma dengan basis 2) berhubungan dengan operasi kebalikan dari menaikkan 2 ke pangkat tertentu. Dengan kata lain, logaritma biner dari $x$ adalah eksponen yang harus dipangkatkan $2 untuk mendapatkan $x$. Dengan demikian, indikator ini dinyatakan dalam bit.

Ambil contoh perhitungan entropi untuk transaksi coinjoin yang terstruktur menurut model Whirlpool 5x5, yang, seperti yang disebutkan di bagian sebelumnya, memiliki sejumlah kemungkinan interpretasi terhadap $1.496:

$$
\begin{align*}
C &= 1.496 \\
E &= \log_2(1.496) \\
E &= 10.5469 \text{ bit}
\end{align*}
$$

Dengan demikian, transaksi coinjoin ini menunjukkan entropi sebesar $10.5469$ bit, yang dianggap sangat memuaskan. Semakin tinggi nilai ini, semakin banyak interpretasi yang berbeda yang dapat diterima oleh transaksi, sehingga meningkatkan tingkat privasinya.

Untuk transaksi coinjoin 8x8 yang memiliki interpretasi $9.934.563, entropinya adalah:

$$
\begin{align*}
C &= 9.934.563 \\
E &= \log_2(9.934.563) \\
E &= 23,244 \text{ bit}
\end{align*}
$$

Mari kita ambil contoh lain dengan transaksi pembayaran standar, dengan 1 input dan 2 output: [1b1b0c3f0883a99f1161c64da19471841ed12a1f78e77fab128c69a5f578ccce](https://mempool.space/tx/1b1b0c3f0883a99f1161c64da19471841ed12a1f78e77fab128c69a5f578ccce)

![BTC204](assets/fr/162.webp)

Dalam kasus transaksi ini, satu-satunya interpretasi yang mungkin adalah: `(In.0) > (Out.0 ; Out.1)`. Akibatnya, entropinya ditetapkan ke $0$:

$$
\begin{align*}
C &= 1 \\
E &= \log_2(1) \\
E &= 0 \text{ bit}
\end{align*}
$$

### Efisiensi

Dari entropi transaksi, kita juga dapat menghitung efisiensi privasinya. Indikator ini mengevaluasi efisiensi transaksi dengan membandingkannya dengan transaksi optimal yang dapat dilakukan dalam konfigurasi yang identik.

Hal ini membawa kita untuk mendiskusikan konsep entropi maksimum, yang berhubungan dengan entropi tertinggi yang secara teoritis dapat dicapai oleh struktur transaksi tertentu. Efisiensi transaksi kemudian dihitung dengan membandingkan entropi maksimum ini dengan entropi aktual dari transaksi yang dianalisis.

Rumus yang digunakan adalah sebagai berikut dengan:


- e_R$: entropi aktual dari transaksi yang dinyatakan dalam bit;
- e_M $: entropi maksimum yang mungkin untuk struktur transaksi yang juga dinyatakan dalam bit;
- $Ef$: efisiensi transaksi dalam satuan bit:

$$
Ef = E_R - E_M
$$

Sebagai contoh, untuk struktur coinjoin tipe Whirlpool 5x5, entropi maksimumnya adalah $10,5469$:

$$
\begin{align*}
E_R &= 10,5469 \\
E_M &= 10,5469 \\
Ef &= E_R - E_M \\
Ef &= 10,5469 - 10,5469 \\
Ef &= 0 \text{ bit}
\end{align*}
$$

Indikator ini juga dinyatakan dalam bentuk persentase. Rumus yang digunakan adalah sebagai berikut dengan:


- c_R$: jumlah interpretasi nyata yang mungkin terjadi;
- c_M$: jumlah maksimum interpretasi yang mungkin dengan struktur yang sama;
- $Ef$: efisiensi yang dinyatakan dalam bentuk persentase:

$$
\begin{align*}
E_f &= \frac{C_R}{C_M} \\
E_f &= \frac{1.496}{1.496} \\
E_f &= 100\%
\end{align*}
$$

Efisiensi sebesar $100\%$ dengan demikian menunjukkan bahwa transaksi tersebut memaksimalkan potensi privasinya berdasarkan strukturnya.

### Kepadatan Entropi

Entropi adalah indikator yang baik untuk mengukur privasi suatu transaksi, tetapi sebagian tergantung pada jumlah input dan output dalam transaksi. Untuk membandingkan entropi dari 2 transaksi yang berbeda yang tidak memiliki jumlah input dan output yang sama, densitas entropi dapat dihitung. Indikator ini memberikan perspektif tentang entropi relatif terhadap setiap input atau output dalam transaksi. Kepadatan terbukti berguna dalam mengevaluasi dan membandingkan efisiensi transaksi dengan ukuran yang berbeda.

Untuk menghitungnya, cukup bagi total entropi transaksi dengan jumlah total input dan output yang terlibat dalam transaksi:


- e_D$: kepadatan entropi yang dinyatakan dalam bit;
- e$: entropi transaksi yang dinyatakan dalam bit;
- t$: jumlah total input dan output dalam transaksi:

$$
E_D = \frac{E}{T}
$$

Ambil contoh coinjoin Whirlpool 5x5:

$$
\begin{align*}
T &= 5 + 5 = 10 \\
E &= 10.5469 \\
E_D &= \frac{E}{T} \\
E_D &= \frac{10.5469}{10} \\
E_D &= 1.054 \text{ bit}
\end{align*}
$$

Kami juga menghitung kepadatan entropi dari coinjoin Whirlpool 8x8:

$$
\begin{align*}
T &= 8 + 8 = 16 \\
E &= 23.244 \\
E_D &= \frac{E}{T} \\
E_D &= \frac{23.244}{16} \\
E_D &= 1.453 \text{ bit}
\end{align*}
$$

Dengan menganalisis kepadatan entropi dari kedua jenis coinjoin ini, menjadi jelas bahwa bahkan ketika menormalkan entropi untuk jumlah elemen, coinjoin "Surge Cycle 8x8" menghasilkan lebih banyak ketidakpastian untuk analisis.

### Skor Boltzmann

Informasi lain yang dianalisis dalam sebuah transaksi adalah skor Boltzmann dari setiap elemen relatif terhadap elemen lainnya. Ini adalah tabel probabilitas korespondensi antara input dan output. Tabel ini menunjukkan, melalui skor Boltzmann, probabilitas bersyarat bahwa input tertentu terkait dengan output yang diberikan. Dengan demikian, ini adalah ukuran kuantitatif dari probabilitas bersyarat bahwa hubungan antara input dan output dalam suatu transaksi akan terjadi, yang ditentukan berdasarkan rasio jumlah kejadian yang menguntungkan dari peristiwa ini dengan jumlah total kemungkinan kejadian, dalam satu set interpretasi.

Mengambil contoh coinjoin Whirlpool, tabel probabilitas bersyarat akan menyoroti kemungkinan hubungan antara setiap input dan output, memberikan ukuran kuantitatif ambiguitas asosiasi dalam transaksi:

| % | Keluaran 0 | Keluaran 1 | Keluaran 2 | Keluaran 3 | Keluaran 4

| ------- | -------- | -------- | -------- | -------- | -------- |

Di sini, jelas bahwa setiap input memiliki probabilitas yang sama untuk dikaitkan dengan output apa pun, yang meningkatkan kerahasiaan transaksi.

Menghitung skor Boltzmann melibatkan pembagian jumlah interpretasi di mana peristiwa tertentu terjadi dengan jumlah total interpretasi yang tersedia. Dengan demikian, untuk menentukan skor dengan mengaitkan input #0 dengan output #3 (peristiwa yang ada dalam interpretasi $512), prosesnya adalah sebagai berikut:

$$
\begin{align*}
\text{Interpretazioni (IN.0 > OUT.3)} &= 512 \\
\text{Interpretazioni Totali} &= 1496 \\
\text{Punteggio} &= \frac{512}{1496} \\
\text{Punteggio} &= 34\%
\end{align*}
$$

Jika kita mempertimbangkan kembali contoh siklus coinjoin Surge 8x8 Whirlpool, tabel Boltzmann akan terlihat seperti ini:

| OUT.0 | OUT.1 | OUT.2 | OUT.3 | OUT.4 | OUT.5 | OUT.6 | OUT.7 | OUT.7

| ---- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |

| IN.0 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| IN.1 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| IN.2 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

| IN.3 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

iN.4 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

iN.5 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

iN.6 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

iN.7 | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23% | 23

Namun, dalam kasus transaksi sederhana yang melibatkan satu input dan 2 output, situasinya berbeda:

| % | Keluaran 0 | Keluaran 1 |

| ------- | -------- | -------- |

| Masukan 0 | 100% | 100% |

Di sini, kami mengamati bahwa probabilitas setiap output yang berasal dari input #0 adalah 100%. Probabilitas yang lebih rendah menghasilkan privasi yang lebih besar dengan menipiskan hubungan langsung antara input dan output.

### Tautan Deterministik

Anda juga dapat menghitung jumlah tautan deterministik dalam sebuah transaksi. Indikator ini menunjukkan berapa banyak hubungan antara input dan output dalam transaksi yang dianalisis yang tidak perlu dipertanyakan lagi, dengan probabilitas 100%. Indikator ini kemudian dapat dilengkapi dengan menghitung rasio tautan deterministik. Rasio ini memberikan perspektif tentang bobot dari hubungan deterministik ini dalam semua hubungan dalam transaksi.

Sebagai contoh, transaksi coinjoin Whirlpool menunjukkan tidak ada hubungan deterministik antara input dan output, sehingga menunjukkan indikator 0 hubungan dan rasio 0%. Sebaliknya, dalam transaksi pembayaran sederhana kedua yang kami periksa (dengan satu input dan 2 output), indikator memberi tahu kami bahwa ada 2 hubungan deterministik dan rasionya mencapai 100%. Dengan demikian, indikator nol menandakan privasi yang sangat baik karena tidak adanya hubungan langsung dan tak terbantahkan antara input dan output.

### Bagaimana cara menghitung indikator-indikator ini?

Menghitung indikator-indikator ini secara manual dengan menggunakan persamaan yang telah saya sediakan relatif sederhana. Kesulitan utama terletak pada penentuan jumlah interpretasi yang mungkin dari sebuah transaksi. Untuk transaksi standar, perhitungan ini dapat dilakukan dengan tangan. Namun, untuk coinjoin, tugasnya jauh lebih kompleks.

Sebelumnya, ada alat Python yang disebut _Boltzmann Calculator_, yang dikembangkan oleh tim di OXT dan Samourai, yang memungkinkan penghitungan otomatis semua indikator ini untuk sebuah transaksi Bitcoin:

![BTC204](assets/fr/163.webp)

Anda juga dapat menggunakan situs web KYCP.org untuk melakukan analisis ini:

![BTC204](assets/fr/164.webp)

Sayangnya, setelah para pendiri Samourai ditangkap, alat-alat ini saat ini tidak beroperasi.

Setelah kita membahas coinjoin secara mendetail, kita akan mengeksplorasi teknik privasi lain yang tersedia di Bitcoin di bagian terakhir pelatihan ini. Kita akan mempelajari transaksi payjoin, jenis transaksi pseudo-coinjoin tertentu, protokol alamat statis, dan juga langkah-langkah untuk meningkatkan privasi bukan pada tingkat transaksi, tetapi pada tingkat jaringan node.

https://planb.network/tutorials/privacy/analysis/boltzmann-entropy-738e45af-18a6-4ce6-af1a-1bf58e15f1fe
# Memahami risiko dari teknik privasi tingkat lanjut lainnya

<partId>19989ae6-d608-4acf-b698-2cf1e7e5e6ae</partId>

## Transaksi Payjoin

<chapterId>c1e90b95-f709-4574-837b-2ec26b11286f</chapterId>

Saat ini, coinjoin adalah metode yang paling efektif untuk memasukkan ketidakpastian ke dalam pelacakan koin selama analisis rantai. Seperti yang telah kita lihat pada bab sebelumnya, untuk mencapai pencampuran yang efektif, input dan output harus sehomogen mungkin. Selain itu, sangat penting bahwa coinjoin diintegrasikan ke dalam kelompok sebesar mungkin untuk memaksimalkan anonset. Dengan demikian, agar coinjoin efektif, mereka harus melibatkan sejumlah besar koin yang seragam. Banyaknya persyaratan ini berarti bahwa transaksi coinjoin memiliki struktur yang sangat kaku: jumlah yang telah ditentukan sebelumnya dan semua peserta harus mematuhinya untuk memastikan keseragaman proses. Selain itu, coinjoin membutuhkan sinkronisasi antara semua peserta dan koordinator selama proses transaksi.

Persyaratan ini membuat coinjoin tidak cocok untuk pembayaran langsung. Sebagai contoh, jika Anda memiliki 1 juta satoshi di pool coinjoin, menggunakannya secara langsung sebagai pembayaran akan menjadi rumit. Diperlukan sinkronisasi dengan peserta lain dan koordinator untuk membangun tepat pada saat Anda perlu melakukan pembayaran transaksi kolaboratif, dan jumlah pembelian harus sama persis dengan nilai potongan Anda, yang secara praktis tidak memungkinkan. Oleh karena itu, transaksi coinjoin pada dasarnya adalah transaksi pembersihan kolaboratif, yang berarti bahwa secara umum pemilik input yang sama dengan yang ada di output.

Namun, akan sangat menarik untuk memiliki struktur transaksi yang memungkinkan pembayaran praktis dengan memasukkan keraguan ke dalam analisis rantai. Inilah yang akan kita bahas pada bab ini dan bab selanjutnya.

### Apa yang dimaksud dengan transaksi payjoin?

Payjoin adalah struktur transaksi Bitcoin khusus yang meningkatkan privasi pengguna selama melakukan pembelanjaan dengan berkolaborasi dengan penerima pembayaran.

Pada tahun 2015, LaurentMT pertama kali menyebutkan metode ini dengan nama "transaksi steganografi," menurut sebuah makalah yang dapat diakses [di sini] (https://gist.githubusercontent.com/LaurentMT/e758767ca4038ac40aaf/raw/c8125f6a3c3d0e90246dc96d3b603690ab6f1dcc/gistfile1.txt). Teknik ini kemudian diadopsi oleh Samourai Wallet, yang pada tahun 2018, merupakan klien pertama yang mengimplementasikannya dengan alat Stowaway. Konsep payjoin juga ditemukan di [BIP79] (https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki) dan [BIP78] (https://github.com/bitcoin/bips/blob/master/bip-0078.mediawiki). Beberapa istilah digunakan untuk menunjuk payjoin:


- Payjoin;
- Penumpang gelap;
- P2EP (_Bayar-ke-Titik-Akhir_);
- Transaksi steganografi.

Keunikan payjoin terletak pada kemampuannya untuk menghasilkan transaksi yang sekilas terlihat biasa, tetapi sebenarnya merupakan Coinjoin mini antara dua orang. Untuk itu, struktur transaksi melibatkan penerima pembayaran dalam input bersama dengan pengirim yang sebenarnya. Penerima kemudian memasukkan pembayaran untuk dirinya sendiri di tengah-tengah transaksi yang memungkinkannya untuk dibayar.

Mari kita ambil sebuah contoh untuk lebih memahami proses ini. Alice membeli baguette seharga 4.000 sat menggunakan UTXO 10.000 sat dan memilih untuk melakukan pembayaran. Tukang rotinya, Bob, menambahkan UTXO sebesar 15.000 sat sebagai input, yang dia dapatkan kembali seluruhnya sebagai output, di samping 4.000 sat milik Alice.

Dalam contoh tersebut, Bob si pembuat roti memasukkan 15.000 sats dan menghasilkan 19.000 sats, selisihnya tepat 4.000 sats, yang merupakan harga baguette. Sementara itu, Alice masuk dengan 10.000 sats dan keluar dengan 6.000 sats, yang menunjukkan keseimbangan -4.000 sats, yang merupakan harga baguette. Untuk menyederhanakan contoh, saya sengaja menghilangkan biaya penambangan dalam transaksi ini.

### Apa tujuan dari payjoin?

Transaksi payjoin memenuhi dua tujuan yang memungkinkan pengguna untuk meningkatkan privasi pembayaran mereka.

Pertama, payjoin bertujuan untuk menipu pengamat luar dengan menciptakan pengalihan dalam analisis rantai. Hal ini dimungkinkan melalui _Common Input Ownership Heuristic_ (CIOH). Seperti yang kita lihat di Bagian 3, biasanya ketika sebuah transaksi di blockchain memiliki banyak input, diasumsikan bahwa semua input tersebut adalah milik entitas atau pengguna yang sama.

Dengan demikian, ketika seorang analis memeriksa sebuah transaksi payjoin, dia akan percaya bahwa semua input berasal dari orang yang sama. Namun, persepsi ini tidak benar, karena penerima pembayaran juga memberikan input bersama dengan pembayar yang sebenarnya. Dengan demikian, analisis rantai condong ke arah interpretasi yang ternyata salah.

Mari kita kembali ke contoh transaksi payjoin untuk membayar baguette:

Melihat transaksi ini di blockchain, pengamat luar yang mengikuti heuristik analisis rantai yang biasa akan menafsirkannya seperti ini, "Alice bergabung dengan 2 UTXO dalam input transaksi untuk membayar 19.000 sat kepada Bob."

Interpretasi ini jelas salah; seperti yang telah Anda ketahui, dua UTXO yang dimasukkan tidak dimiliki oleh orang yang sama. Satu dari Alice, pembeli baguette, dan yang lainnya dari Bob, pembuat roti.

Dengan demikian, analisis pengamat eksternal diarahkan pada kesimpulan yang salah, yang menjamin terjaganya kerahasiaan pemangku kepentingan.

### Transaksi steganografi

Tujuan kedua dari payjoin adalah untuk menipu pengamat luar tentang jumlah pembayaran yang sebenarnya dilakukan. Dengan memeriksa struktur transaksi, analis mungkin percaya bahwa pembayaran setara dengan jumlah salah satu output.

Jika kita mengambil contoh pembelian baguette, analis akan berpikir bahwa jumlah pembayaran sesuai dengan UTXO 6.000 sat atau UTXO 19.000 sat. Dalam kasus ini, analis lebih cenderung berpikir bahwa jumlah pembayaran adalah 19.000 sat karena ada 2 UTXO dalam output, setidaknya salah satu di antaranya lebih besar dari 6.000 sat (tidak ada alasan logis untuk menggunakan 2 UTXO untuk membayar 6.000 sat ketika satu UTXO sudah mencukupi untuk pembayaran ini).

Namun pada kenyataannya, analisis ini tidak benar. Jumlah pembayaran tidak sesuai dengan output mana pun. Ini sebenarnya adalah perbedaan antara UTXO penerima output dan UTXO penerima input.

Dalam hal ini, transaksi payjoin masuk ke dalam ranah steganografi. Hal ini memungkinkan jumlah transaksi yang sebenarnya disembunyikan di dalam transaksi palsu yang berfungsi sebagai pengalihan.

Steganografi adalah sebuah teknik untuk menyembunyikan informasi di dalam data atau objek lain sehingga keberadaan informasi yang disembunyikan tidak terlihat. Sebagai contoh, sebuah pesan rahasia dapat disembunyikan di dalam sebuah titik pada teks yang tidak berhubungan, sehingga tidak terdeteksi oleh mata telanjang (ini adalah teknik [micropoint] (https://fr.wikipedia.org/wiki/Micropoint)).

Tidak seperti enkripsi, yang membuat informasi tidak dapat dimengerti tanpa kunci dekripsi, steganografi tidak mengubah informasi. Mereka tetap terlihat. Sebaliknya, tujuannya adalah untuk menyembunyikan keberadaan pesan rahasia, sedangkan kriptografi dengan jelas mengungkapkan keberadaan informasi yang tersembunyi, meskipun tidak dapat diakses tanpa kunci. Inilah mengapa nama awal untuk payjoin adalah "transaksi steganografi."

Sebuah analogi dapat dibuat antara kriptografi dan coinjoin, serta antara steganografi dan payjoin. Pada kenyataannya, coinjoin memiliki atribut yang mirip dengan kriptografi: metodenya dapat dikenali, tetapi informasinya tidak dapat diuraikan. Sebaliknya, payjoin mirip dengan steganografi: informasinya secara teori dapat diakses, tetapi karena metode penyembunyiannya tidak dapat dikenali, maka informasi tersebut menjadi tidak dapat diakses.

### Bagaimana cara menggunakan payjoin?

Perangkat lunak terkenal yang mendukung payjoin termasuk Sparrow Wallet, Wasabi Wallet, Mutiny, BitMask, BlueWallet, dan JoinMarket, serta prosesor pembayaran BTCPay.

Implementasi payjoin yang paling maju hanyalah Stowaway di Samourai Wallet. Akan tetapi, sejak ditutupnya pendiri perangkat lunak ini, alat ini sekarang hanya berfungsi sebagian. Keuntungan dari Stowaway adalah protokol yang lengkap dan sangat mudah digunakan yang mendukung penerimaan dan pengiriman payjoin. Transaksi yang ditandatangani sebagian dapat ditukar secara manual dengan memindai beberapa kode QR atau secara otomatis melalui Tor melalui Soroban. Ini adalah opsi komunikasi yang terakhir yang saat ini tidak digunakan.

Kesulitan dalam menggunakan payjoin terletak pada ketergantungannya pada partisipasi merchant. Sebagai pelanggan, menggunakan payjoin tidak mungkin dilakukan jika merchant tidak mendukungnya. Hal ini menambah kesulitan tambahan saat melakukan pembelian: tidak hanya sulit untuk menemukan merchant yang menerima bitcoin, tetapi jika Anda juga mencari merchant yang mendukung payjoin, maka akan semakin rumit.

Salah satu solusinya adalah dengan menggunakan struktur transaksional yang memperkenalkan ambiguitas ke dalam analisis rantai tanpa memerlukan kerja sama dari penerima. Hal ini akan memungkinkan kita untuk meningkatkan privasi pembayaran tanpa bergantung pada partisipasi aktif dari pedagang. Inilah yang akan kita pelajari pada bab selanjutnya.

https://planb.network/tutorials/privacy/on-chain/payjoin-sparrow-wallet-087a0e49-61cd-41f5-8440-ac7b157bdd62
https://planb.network/tutorials/privacy/on-chain/payjoin-samourai-wallet-48a5c711-ee3d-44db-b812-c55913080eab
## Pembayaran dengan koin mini

<chapterId>300777ee-30ae-43d7-ab00-479dac3522c1</chapterId>

Ketika ingin melakukan transaksi pembayaran sambil menjaga tingkat privasi, payjoin adalah pilihan yang baik. Tetapi seperti yang telah kita lihat, payjoin membutuhkan keterlibatan penerima. Jadi apa yang harus dilakukan jika penerima menolak untuk berpartisipasi dalam payjoin, atau jika Anda lebih memilih untuk tidak melibatkannya? Salah satu alternatifnya adalah dengan menggunakan transaksi Stonewall atau Stonewall x2. Mari kita lihat lebih dekat kedua jenis transaksi ini.

### Transaksi Stonewall

Stonewall adalah sebuah bentuk transaksi Bitcoin khusus yang bertujuan untuk meningkatkan privasi pengguna selama berbelanja dengan meniru transaksi koin semu antara dua orang, tetapi tanpa benar-benar menjadi satu koin. Pada kenyataannya, transaksi ini tidak bersifat kolaboratif. Seorang pengguna dapat membuatnya sendiri, dengan hanya melibatkan UTXO yang dimilikinya sebagai input. Anda kemudian dapat membuat transaksi Stonewall untuk setiap kesempatan, tanpa perlu melakukan sinkronisasi dengan pengguna lain atau penerima.

Pengoperasian transaksi Stonewall adalah sebagai berikut: pada input transaksi, pengirim menggunakan 2 UTXO yang menjadi miliknya. Pada output, transaksi menghasilkan 4 UTXO, 2 di antaranya akan memiliki jumlah yang sama persis. 2 UTXO lainnya akan menjadi sisanya. Di antara 2 output dengan jumlah yang sama, hanya satu yang akan benar-benar masuk ke penerima pembayaran.

Hanya ada 2 peran dalam transaksi Stonewall:


- Pengirim, yang melakukan pembayaran;
- Penerima, yang mungkin tidak menyadari sifat spesifik dari transaksi dan hanya menunggu pembayaran dari pengirim.

Mari kita ambil sebuah contoh untuk memahami struktur transaksi ini. Alice berada di toko roti Bob untuk membeli roti baguette seharga 4.000 sat. Ia ingin membayar dengan bitcoin sambil tetap menjaga tingkat privasi tentang pembayarannya. Oleh karena itu, ia memutuskan untuk membuat transaksi Stonewall untuk pembayarannya.

Dengan menganalisis transaksi ini, kita dapat melihat bahwa Bob si tukang roti sebenarnya menerima 4.000 sat sebagai pembayaran untuk baguette tersebut. Alice menggunakan 2 UTXO sebagai input: satu dari 10.000 sat dan satu dari 15.000 sat. Sebagai output, ia menerima 3 UTXO: satu dari 4.000 sat, satu dari 6.000 sat, dan satu dari 11.000 sat. Alice memiliki saldo bersih -4.000 sat pada transaksi ini, yang persis sama dengan harga baguette.

Dalam contoh ini, saya sengaja mengabaikan biaya penambangan untuk memudahkan pemahaman. Pada kenyataannya, biaya transaksi sepenuhnya ditanggung oleh pengirim.

### Apa saja tujuan dari transaksi Stonewall?

Struktur Stonewall menambahkan banyak entropi pada transaksi dan mengacaukan jejak analisis rantai. Dari luar, transaksi seperti ini dapat diartikan sebagai sebuah koin mini antara dua orang. Namun pada kenyataannya, ini adalah sebuah pembayaran. Dengan demikian, metode ini menghasilkan ketidakpastian dalam analisis rantai, atau bahkan menyebabkan jejak palsu.

Mari kita kembali ke contoh Alice di Bob the Baker. Transaksi pada blockchain akan terlihat seperti ini:

![BTC204](assets/fr/174.webp)

Seorang pengamat luar yang mengandalkan heuristik umum dari analisis rantai dapat secara keliru menyimpulkan bahwa "_dua orang membuat sebuah coinjoin kecil, dengan masing-masing satu UTXO sebagai input dan dua UTXO sebagai output_." Analisis transaksi ini dari luar tidak mengarah pada penerapan Common Ownership Heuristics of Input (CIOH), karena adanya dua output dengan jumlah yang sama menunjukkan pola coinjoin. Dari perspektif eksternal, CIOH tidak berlaku dalam kasus ini.

![BTC204](assets/fr/175.webp)

Interpretasi ini tidak akurat, karena, seperti yang Anda ketahui, satu UTXO dikirim ke Bob the Baker, 2 UTXO yang menjadi input berasal dari Alice, dan dia mengambil 3 output sisanya.

![BTC204](assets/fr/176.webp)

Dan yang sangat menarik dari struktur transaksi Stonewall adalah, dari sudut pandang pengamat luar, struktur ini terlihat persis seperti transaksi Stonewall x2.

### Transaksi Stonewall x2

Stonewall x2 adalah bentuk spesifik lain dari transaksi Bitcoin yang juga bertujuan untuk meningkatkan privasi pengguna selama melakukan pembelanjaan, tetapi kali ini dengan berkolaborasi dengan pihak ketiga yang tidak terlibat dalam pembelanjaan. Metode ini berfungsi sebagai pseudo-coinjoin antara dua partisipan ketika melakukan pembayaran kepada pihak ketiga.

Pengoperasian transaksi Stonewall x2 relatif sederhana: seseorang menggunakan UTXO yang dimilikinya untuk melakukan pembayaran dan meminta bantuan pihak ketiga yang juga menyumbangkan UTXO miliknya. Transaksi ini berakhir dengan empat keluaran: dua di antaranya dengan jumlah yang sama, satu dikirim ke alamat penerima pembayaran, dan satu lagi ke alamat milik kontributor. UTXO ketiga dikirim ke alamat kontributor lain, yang memungkinkan mereka untuk mendapatkan kembali jumlah awal (tindakan netral bagi mereka, dikurangi biaya penambangan), dan UTXO terakhir kembali ke alamat milik kami, yang merupakan sisa pembayaran.

Dengan demikian, tiga peran berbeda didefinisikan dalam transaksi Stonewall x2:


- Pengirim, yang melakukan pembayaran yang sebenarnya;
- Penerima, yang mungkin tidak menyadari sifat spesifik dari transaksi dan hanya menunggu pembayaran dari pengirim;
- Kolaborator, yang menyediakan bitcoin untuk menimbulkan keraguan dalam analisis transaksi, sepenuhnya memulihkan dana mereka di akhir (tindakan netral bagi mereka, setelah dikurangi biaya penambangan).

Mari kita kembali ke contoh kita dengan Alice yang berada di Bob the Baker untuk membeli roti baguette seharga 4.000 sat. Alice ingin membayar dengan bitcoin sambil tetap menjaga tingkat privasi pembayarannya. Jadi, dia menelepon temannya Charles, yang akan membantunya dalam proses ini.

![BTC204](assets/fr/177.webp)

Dengan menganalisis transaksi ini, kita dapat melihat bahwa Bob si pembuat roti sebenarnya menerima 4.000 sat sebagai pembayaran untuk baguette tersebut. Alice menggunakan 10.000 sat sebagai input dan menerima 6.000 sat sebagai output, sehingga menghasilkan saldo bersih -4.000 sat, yang sesuai dengan harga baguette. Sedangkan untuk Charles, ia memberikan 15.000 sat sebagai input dan menerima dua output: satu sebesar 4.000 sat dan yang lainnya sebesar 11.000 sat, menghasilkan saldo 0.

Dalam contoh ini, saya sengaja mengabaikan komisi untuk memudahkan pemahaman. Pada kenyataannya, biaya penambangan umumnya dibagi rata antara penerbit pembayaran dan kontributor.

### Apa saja tujuan dari transaksi Stonewall x2?

Seperti struktur Stonewall, struktur Stonewall x2 menambahkan sejumlah besar entropi ke dalam transaksi dan mengaburkan jejak analisis rantai. Dari sudut pandang eksternal, transaksi seperti ini dapat diartikan sebagai sebuah koin kecil antara dua orang. Namun pada kenyataannya, ini adalah sebuah pembayaran. Oleh karena itu, metode ini menghasilkan ketidakpastian dalam analisis rantai, yang juga mengarah ke jejak palsu.

Mari kita tinjau kembali contoh Alice, Bob the Baker, dan Charles. Transaksi pada blockchain akan terlihat seperti ini:

![BTC204](assets/fr/178.webp)

Seorang pengamat luar yang mengandalkan heuristik umum dari analisis rantai mungkin secara keliru menyimpulkan bahwa "_Alice dan Charles melakukan coinjoin kecil, dengan masing-masing satu UTXO sebagai input dan dua UTXO sebagai output_." Sekali lagi, menganalisis transaksi ini dari luar tidak mengarah pada penerapan Common Ownership Heuristics of Input (CIOH), karena adanya dua output dengan jumlah yang sama menunjukkan pola coinjoin. Dari perspektif eksternal, CIOH tidak berlaku dalam kasus ini.

![BTC204](assets/fr/179.webp)

Interpretasi ini tidak akurat karena, seperti yang Anda ketahui, satu UTXO dikirim ke Bob the Baker, Alice hanya memiliki satu output istirahat, dan Charles memiliki dua.

![BTC204](assets/fr/180.webp)

Dan sekali lagi, apa yang sangat menarik dari struktur transaksi Stonewall x2 adalah bahwa dari sudut pandang pengamat luar, struktur tersebut terlihat persis seperti transaksi Stonewall.

### Apa perbedaan antara Stonewall dan Stonewall x2?

Transaksi StonewallX2 bekerja persis seperti transaksi Stonewall, kecuali yang pertama bersifat kolaboratif, sedangkan yang kedua tidak. Seperti yang telah kita lihat, transaksi StonewallX2 melibatkan partisipasi pihak ketiga (Charles), yang berada di luar pembayaran, dan yang menyediakan bitcoin-nya untuk meningkatkan kerahasiaan transaksi. Dalam transaksi Stonewall klasik, peran kontributor diasumsikan oleh pengirim.

![BTC204](assets/fr/181.webp)

Oleh karena itu, dari sudut pandang eksternal, model transaksinya sama persis.

Fakta bahwa kedua struktur transaksi ini memiliki pola yang sama persis menyiratkan bahwa meskipun pengamat luar dapat mengidentifikasi pola "Stonewall (x2)", dia tidak akan memiliki semua informasi. Dia tidak akan dapat menentukan mana dari dua UTXO dengan jumlah yang sama yang sesuai dengan pembayaran. Ia juga tidak akan dapat menentukan apakah dua UTXO yang dimasukkan berasal dari dua orang yang berbeda (Stonewall x2) atau apakah keduanya berasal dari satu orang yang bergabung dengan keduanya (Stonewall).

Poin terakhir ini disebabkan oleh fakta bahwa transaksi Stonewall x2 mengikuti pola yang sama persis dengan transaksi Stonewall. Dari luar dan tanpa informasi konteks tambahan, tidak mungkin untuk membedakan transaksi Stonewall dengan transaksi Stonewall x2. Akan tetapi, yang pertama bukanlah transaksi kolaboratif, sedangkan yang kedua adalah transaksi kolaboratif. Hal ini menambah keraguan dalam analisis salah satu transaksi tersebut.

### Kapan menggunakan transaksi Stonewall dan Stonewall x2?

Logikanya harus seperti berikut ketika Anda ingin menggunakan alat privasi untuk sebuah transaksi:


- Sebagai prioritas, Anda dapat memilih untuk melakukan payjoin;
- Jika merchant tidak mendukung payjoin, transaksi kolaboratif dapat dilakukan dengan orang lain di luar pembayaran menggunakan struktur Stonewall x2;
- Jika Anda tidak dapat menemukan siapa pun untuk melakukan transaksi Stonewall x2, Anda dapat melakukan transaksi Stonewall sendiri, yang akan meniru perilaku transaksi Stonewall x2.

### Bagaimana cara menggunakan transaksi Stonewall dan Stonewall x2?

Transaksi Stonewall dan Stonewall x2 tersedia di aplikasi Samourai Wallet dan perangkat lunak Sparrow Wallet.

Namun, seperti halnya dengan payjoin, setelah penangkapan para pendiri Samourai, transaksi Stonewall x2 sekarang hanya dapat dilakukan dengan menukarkan PSBT secara manual di antara para pihak yang terlibat. Pertukaran otomatis melalui Soroban sayangnya tidak tersedia saat ini.

Anda juga bisa melakukan jenis transaksi ini secara manual dari perangkat lunak dompet Bitcoin apa pun.

Dalam bab berikutnya, kita akan mempelajari teknik privasi lain yang relatif tidak dikenal tetapi sangat berguna sebagai tambahan dari apa yang telah kita pelajari.

https://planb.network/tutorials/privacy/on-chain/stonewall-033daa45-d42c-40e1-9511-cea89751c3d4
https://planb.network/tutorials/privacy/on-chain/stonewall-x2-05120280-f6f9-4e14-9fb8-c9e603f73e5b
## Rebound

<chapterId>db9a20ac-a149-443d-884b-ea6c03f28499</chapterId>

Penggunaan struktur transaksi Bitcoin yang menambahkan ambiguitas dalam analisis rantai, seperti coinjoin, sangat bermanfaat untuk perlindungan privasi. Akan tetapi, seperti yang telah kita bahas pada bab mengenai payjoin, transaksi coinjoin secara alami dapat diidentifikasi dalam rantai. Ingatlah analogi yang kita buat antara kriptografi dan coinjoin: ketika mengenkripsi sebuah file, pihak ketiga yang menemukan file terenkripsi ini tidak dapat mengakses isinya, akan tetapi dapat dengan jelas mengidentifikasi bahwa telah terjadi modifikasi pada file tersebut untuk menyembunyikan isinya. Hal yang sama juga berlaku untuk coinjoin: ketika seorang analis memeriksa sebuah transaksi coinjoin, walaupun dia tidak dapat membuat hubungan langsung antara input dan output (dan sebaliknya), dia masih dapat mengenali bahwa transaksi yang diamati adalah sebuah coinjoin.

Tergantung pada tujuan penggunaan koin Anda setelah menjalani siklus coinjoin, fakta bahwa koin tersebut telah menjalani proses ini dapat menjadi masalah. Misalnya, jika Anda berencana untuk menjual koin Anda di platform bursa yang teregulasi, tetapi koin tersebut baru saja mengalami coinjoin, alat analisis rantai platform akan mendeteksi fakta ini. Platform kemudian dapat menolak untuk menerima UTXO Anda yang telah mengalami coinjoin, atau bahkan meminta penjelasan dari Anda, dengan risiko akun Anda ditangguhkan atau dana Anda dibekukan. Dalam beberapa kasus, platform juga dapat melaporkan perilaku Anda kepada otoritas negara (misalnya, inilah yang diwajibkan oleh TRACFIN kepada Penyedia Layanan Aset Digital (PSAN) di Prancis).

Yang perlu kita hindari adalah alat yang mampu mengaburkan jejak masa lalu koin Bitcoin untuk mengembalikan beberapa bentuk kesepadanan. Inilah tujuan dari ricochet.

### Apakah yang dimaksud dengan ricochet?

Ricochet adalah sebuah teknik yang melibatkan melakukan beberapa transaksi tiruan kepada diri sendiri (sweeping) untuk mensimulasikan transfer kepemilikan bitcoin. Alat ini berbeda dengan struktur transaksi lain yang telah kita bahas karena tidak memungkinkan anonimitas prospektif, melainkan sebuah bentuk anonimitas retrospektif. Faktanya, ricochet memungkinkan pengaburan kekhususan yang dapat mengganggu kesetaraan koin bitcoin karena masa lalunya.

Untuk mengaburkan jejak yang ditinggalkan oleh peristiwa masa lalu pada koin, seperti siklus coinjoin, misalnya, ricochet melakukan empat transaksi berurutan di mana pengguna mentransfer dana ke dirinya sendiri di alamat yang berbeda.

Setelah rangkaian transaksi ini, alat ricochet akhirnya merutekan bitcoin ke tujuan akhirnya sebagai platform pertukaran.

Tujuannya adalah untuk menciptakan jarak yang mempengaruhi kesepadanan koin, seperti transaksi koin bersama, dan tindakan pembelanjaan terakhir yang mungkin menolak koin ini karena masa lalunya. Dengan demikian, alat analisis rantai dapat menyimpulkan bahwa kemungkinan ada perubahan kepemilikan setelah kejadian tersebut, dan menganggap bahwa koin ini dapat dipertukarkan. Dalam kasus coinjoin, alat analisis rantai dapat berasumsi bahwa bukan orang yang sama yang mengirimkan bitcoin dan mengeksekusi coinjoin, dan dengan demikian tidak ada gunanya melakukan tindakan terhadap pengirim.

### Mengapa ini berhasil?

Dihadapkan dengan metode ricochet ini, orang mungkin membayangkan bahwa perangkat lunak analisis rantai akan memperdalam pemeriksaan mereka lebih dari empat lompatan. Akan tetapi, platform-platform ini menghadapi dilema dalam mengoptimalkan ambang batas deteksi. Mereka perlu menetapkan batasan jumlah hop setelah itu mereka mengakui bahwa perubahan kepemilikan mungkin telah terjadi dan bahwa tautan ke peristiwa sebelumnya (seperti coinjoin) harus diabaikan.

Namun, menentukan ambang batas ini terbukti berisiko: setiap perluasan jumlah lompatan yang diamati secara eksponensial meningkatkan volume positif palsu, yaitu individu yang secara tidak benar ditandai sebagai peserta dalam suatu peristiwa ketika transaksi dilakukan oleh orang lain. Skenario ini menimbulkan risiko yang lebih besar bagi perusahaan-perusahaan ini, karena positif palsu menyebabkan ketidakpuasan, yang dapat mendorong pelanggan yang terkena dampak ke pesaing. Dalam jangka panjang, ambang batas deteksi yang terlalu besar menyebabkan platform kehilangan lebih banyak pelanggan daripada pesaingnya, yang dapat mengancam kelangsungan hidupnya. Oleh karena itu, sulit bagi platform ini untuk meningkatkan jumlah lompatan yang diamati, dan 4 sering kali merupakan angka yang cukup untuk melawan analisis mereka.

Fenomena yang diamati di sini agak mirip dengan teori enam derajat pemisahan.

Teori enam derajat pemisahan menunjukkan bahwa setiap orang di Bumi terhubung dengan orang lain melalui rantai pengetahuan yang tidak lebih dari enam perantara. Cukup melalui serangkaian enam orang, yang masing-masing mengenal satu sama lain secara pribadi, untuk menjangkau individu mana pun di dunia.

Untuk transaksi Bitcoin, kita akan menemukan fenomena yang sama. Dengan melacak kembali sejumlah transaksi Bitcoin, seseorang pasti akan menemukan koin bersama. Metode ricochet mengeksploitasi prinsip ini dengan menggunakan lebih banyak lompatan daripada yang dapat diikuti oleh platform bursa. Jika platform memutuskan untuk mengikuti lebih banyak transaksi, maka dapat dengan mudah menambahkan lompatan tambahan untuk menghindari langkah ini.

### Kapan dan bagaimana cara menggunakan ricochet?

Kasus penggunaan yang paling umum untuk ricochet terjadi ketika Anda perlu menyembunyikan partisipasi sebelumnya dalam coinjoin pada UTXO yang Anda miliki. Idealnya, yang terbaik adalah menghindari mentransfer bitcoin yang telah mengalami coinjoin ke entitas yang diatur. Namun, jika seseorang tidak memiliki pilihan lain, terutama dalam keadaan mendesak untuk melikuidasi bitcoin ke dalam mata uang fiat, ricochet menawarkan solusi yang efektif.

Metode ini efektif tidak hanya untuk koin koin tetapi juga untuk tanda lain yang dapat mengganggu kesetaraan koin.

Ide untuk metode ricochet ini awalnya berasal dari tim Samourai Wallet, yang mengintegrasikannya ke dalam aplikasi mereka untuk mengotomatiskan prosesnya. Ada biaya untuk layanan ini di Samourai, karena sebuah ricochet dikenakan biaya layanan sebesar 100.000 sat, selain biaya penambangan. Oleh karena itu, penggunaannya lebih disarankan untuk transfer dalam jumlah besar.

Aplikasi Samourai menawarkan dua variasi pantulan:


- Advanced ricochet, atau "pengiriman terhuyung-huyung", yang memiliki keuntungan untuk menyebarkan biaya layanan Samourai ke dalam lima transaksi yang berurutan. Opsi ini juga memastikan bahwa setiap transaksi ditransmisikan pada waktu yang berbeda dan dicatat dalam blok yang berbeda, yang memungkinkannya untuk meniru perilaku perubahan kepemilikan semirip mungkin. Meskipun lebih lambat, metode ini lebih disukai oleh mereka yang tidak terburu-buru, karena metode ini memaksimalkan efisiensi ricochet dengan memperkuat ketahanannya terhadap analisis rantai;
- Ricochet klasik, yang dirancang untuk melakukan operasi dengan cepat dengan mentransmisikan semua transaksi dalam waktu singkat. Oleh karena itu, metode ini menawarkan lebih sedikit privasi dan lebih sedikit resistensi terhadap analisis daripada metode lanjutan. Metode ini sebaiknya digunakan hanya untuk pengiriman yang mendesak.

Recochet hanya terdiri dari pengiriman bitcoin ke diri sendiri. Sangat memungkinkan untuk melakukan recochet secara manual pada perangkat lunak dompet apa pun, tanpa menggunakan alat khusus. Cukup transfer koin yang sama ke diri Anda sendiri nanti, menggunakan alamat baru yang kosong setiap kali.

Pada bab berikut, kita akan membahas beberapa teknik untuk transfer properti rahasia. Metode-metode ini berbeda secara radikal dari yang telah kita bahas sejauh ini, baik dari segi cara kerjanya maupun hasilnya.

https://planb.network/tutorials/privacy/on-chain/ricochet-e0bb1afe-becd-44a6-a940-88a463756589
## Transfer Properti Rahasia

<chapterId>a2067036-849c-4d6b-87d2-44235cfae7a1</chapterId>

Di antara teknik privasi pada bitcoin adalah transfer kepemilikan secara rahasia. Metode ini bertujuan untuk memindahkan kepemilikan bitcoin dari satu orang ke orang lain, dan sebaliknya, tanpa transaksi ini secara eksplisit terlihat di blockchain. Mari kita pelajari bersama teknik-teknik yang tersedia serta kelebihan dan kekurangannya.

### CoinSwap

CoinSwap didasarkan pada konsep yang relatif sederhana: ia menggunakan kontrak pintar untuk memfasilitasi transfer kepemilikan bitcoin antara dua pengguna, tanpa memerlukan kepercayaan dan tanpa transfer ini terlihat secara eksplisit di blockchain.

Mari kita bayangkan sebuah contoh sederhana dengan Alice dan Bob. Alice memiliki 1 BTC yang diamankan dengan private key $A$, dan Bob juga memiliki 1 BTC yang diamankan dengan private key $B$. Secara teoritis, mereka dapat menukarkan private key mereka melalui saluran komunikasi eksternal untuk melakukan transfer rahasia.

Akan tetapi, metode yang naif ini memiliki risiko yang tinggi dalam hal kepercayaan. Tidak ada yang menghalangi Alice untuk menyimpan salinan private key $A$ setelah pertukaran dan menggunakannya nanti untuk mencuri bitcoin setelah kunci tersebut berada di tangan Bob.

Terlebih lagi, tidak ada jaminan yang mencegah Alice untuk menerima private key $B$ milik Bob dan tidak pernah mengirimkan private key $A$ miliknya sebagai gantinya. Oleh karena itu, pertukaran ini bergantung pada kepercayaan yang berlebihan antara kedua belah pihak dan terbukti tidak efisien dalam memastikan transfer kepemilikan secara rahasia dengan cara yang aman.

Untuk mengatasi masalah ini dan memungkinkan pertukaran antara pihak-pihak yang tidak saling percaya, kita dapat menggunakan sistem kontrak pintar. Kontrak pintar adalah sebuah program yang berjalan secara otomatis ketika kondisi yang telah ditetapkan terpenuhi, yang, dalam kasus kami, memastikan bahwa pertukaran properti terjadi secara otomatis tanpa memerlukan rasa saling percaya.

Untuk melakukan ini, kita dapat menggunakan HTLC (_Hash Time-Locked Contracts_) atau PTLC (_Point Time-Locked Contracts_). Kedua protokol ini bekerja dengan cara yang sama menggunakan sistem penguncian waktu yang memastikan bahwa pertukaran berhasil diselesaikan atau dibatalkan sepenuhnya, sehingga melindungi integritas dana kedua belah pihak. Perbedaan utama antara HTLC dan PTLC adalah bahwa HTLC menggunakan hash dan preimage untuk mengamankan transaksi, sedangkan PTLC menggunakan Adaptive Signature.

Dalam skenario CoinSwap menggunakan HTLC atau PTLC antara Alice dan Bob, pertukaran berlangsung dengan cara yang aman: baik itu berhasil, dan masing-masing menerima BTC satu sama lain, atau gagal, dan masing-masing menyimpan BTC-nya sendiri. Oleh karena itu, tidak mungkin salah satu pihak menipu atau mencuri BTC pihak lain.

> hTLC juga merupakan mekanisme yang digunakan untuk merutekan pembayaran dengan aman melalui saluran dua arah Lightning Network
> Penggunaan Tanda Tangan Adaptif sangat menarik dalam konteks ini, karena memungkinkan skrip tradisional dilewati (ini adalah mekanisme yang kadang-kadang disebut sebagai "_scriptless scripts_"). Fitur ini membantu mengurangi biaya yang terkait dengan pertukaran. Keuntungan utama lain dari Tanda Tangan Adaptif adalah bahwa mereka tidak membutuhkan penggunaan hash yang sama untuk kedua sisi transaksi, sehingga menghindari pengungkapan hubungan langsung di antara keduanya dalam jenis bursa tertentu.
### Tanda Tangan Adaptif

Tanda Tangan Adaptif adalah metode kriptografi yang mengintegrasikan tanda tangan yang valid dengan tanda tangan tambahan, yang disebut "tanda tangan adaptif", untuk mengungkapkan data rahasia. Mekanisme ini dirancang sedemikian rupa sehingga dengan mengetahui 2 dari 3 elemen berikut: tanda tangan yang sah, tanda tangan adaptif dan rahasia, memungkinkan elemen ketiga yang hilang untuk disimpulkan. Sebuah sifat yang menarik dari metode ini adalah jika kita mengetahui tanda tangan adaptif dari mitra kita dan titik spesifik pada kurva elips yang terkait dengan rahasia yang digunakan untuk menghitung tanda tangan adaptif ini, kita dapat memperoleh tanda tangan adaptif kita sendiri yang akan kompatibel dengan rahasia yang sama, tanpa harus memiliki akses langsung ke rahasia itu sendiri.

Dalam pertukaran koin, penggunaan Tanda Tangan Adaptif memungkinkan pengungkapan dua buah informasi sensitif secara bersamaan di antara para partisipan, sehingga menghindari kebutuhan akan rasa saling percaya. Mari kita ambil contoh untuk mengilustrasikan proses ini dengan Alice dan Bob, yang ingin menukarkan kepemilikan masing-masing 1 BTC, tetapi tidak saling percaya. Mereka menggunakan Tanda Tangan Adaptif untuk menghilangkan kebutuhan akan kepercayaan dalam pertukaran ini. Berikut ini adalah bagaimana prosesnya:


- Alice memulai pertukaran dengan membuat sebuah transaksi $m_A$ yang mengirimkan 1 BTC ke Bob. Dia membuat tanda tangan $s_A$, yang memvalidasi transaksi ini, dengan menggunakan kunci pribadinya $p_A$ ($P_A = p_A \cdot G$), sebuah nonce $n_A$ ($N_A = n_A \cdot G$), dan sebuah rahasia $t$ ($T = t \cdot G$):

$$s_A = n_A + t + H(N_A + T \paralel P_A \paralel m_A) \cdot p_A$$


- Alice menghitung tanda tangan adaptif $s_A'$ dengan mengurangkan tanda tangan rahasia $t$ dari tanda tangan sebenarnya $s_A$:

$$s_A' = s_A - t$$


- Alice mengirimkan tanda tangan adaptifnya kepada Bob $s'_A$, transaksi yang belum ditandatangani $m_A$, titik yang berhubungan dengan rahasia ($T$), dan titik yang berhubungan dengan nonce ($N_A$). Elemen-elemen ini membentuk apa yang disebut dengan "_adapter_" Penting untuk diperhatikan bahwa hanya dengan informasi ini, Bob tidak dapat mengambil BTC milik Alice.
- Akan tetapi, Bob memiliki kemampuan untuk memverifikasi bahwa Alice tidak mencoba untuk mencuri darinya. Untuk melakukan hal ini, ia memeriksa apakah tanda tangan adaptif Alice $s_A'$ benar-benar cocok dengan transaksi yang diajukan $m_A$. Jika persamaan berikut ini benar, maka ia dapat memastikan bahwa tanda tangan adaptif Alice adalah valid:

$$s_A' \cdot G = N_A + H(N_A + T \paralel P_A \paralel m_A) \cdot P_A$$


- Verifikasi ini memberikan jaminan yang cukup bagi Bob untuk melanjutkan pertukaran dengan cara yang percaya diri. Dia kemudian membuat transaksi sendiri $m_B$, yang ditujukan untuk mengirim 1 BTC kepada Alice, dan menghasilkan tanda tangan adaptifnya $s_B'$, yang juga akan ditautkan dengan rahasia yang sama, yaitu $t$. Pada titik ini, hanya Alice yang mengetahui nilai $t$; Bob hanya mengetahui titik $T$ yang dikirimkan Alice kepadanya:

$$s_B' = n_B + H(N_B + T \paralel P_B \paralel m_B) \cdot p_B$$


- Bob mengirimkan kepada Alice tanda tangan adaptifnya $s_B'$, transaksi yang tidak ditandatangani $m_B$, serta titik yang berhubungan dengan rahasia ($T$) dan titik yang berhubungan dengan nonce ($N_B$). Alice, yang mengetahui rahasia $t$, sekarang dapat menggabungkan tanda tangan adaptif Bob $s_B'$ dengan rahasia ini untuk menghasilkan tanda tangan yang valid $s_B$ untuk transaksi $m_B$ yang akan mentransfer BTC Bob kepadanya:

$$s_B = s_B' + t$$

$$(s_B' + t) \cdot G = N_B + T + H(N_B + T \paralel P_B \paralel m_B) \cdot P_B$$


- Alice mengirimkan transaksi yang ditandatangani ini $m_B$ pada blockchain Bitcoin untuk mengambil BTC yang dijanjikan oleh Bob. Ketika Bob melihat transaksi ini di blockchain, ia dapat mengekstrak tanda tangan $s_B = s_B' + t$. Dengan informasi ini, Bob kemudian dapat mengisolasi rahasia $t$ yang ia butuhkan:

$$t = (s_B' + t) - s_B' = s_B - s_B'$$


- Dan pada kenyataannya, $t$ rahasia ini adalah satu-satunya elemen yang hilang bagi Bob untuk menghasilkan tanda tangan yang valid $s_A$ dari tanda tangan adaptor Alice $s_A'$. Tanda tangan ini memungkinkan transaksi $m_A$ yang mengirimkan BTC dari Alice ke Bob untuk divalidasi. Bob kemudian menghitung $s_A$ dan kemudian mengirimkan transaksi $m_A$ pada blockchain:

$$s_A = s_A' + t$$

$$(s_A' + t) \cdot G = N_A + T + H(N_A + T \paralel P_A \paralel m_A) \cdot P_A$$

Mari kita rangkum bagaimana cara kerja Adaptor Tanda Tangan dalam pertukaran koin. Pada awalnya, Alice mengirimkan sebuah transaksi yang belum ditandatangani kepada Bob bersama dengan adaptor, yang memungkinkan Bob untuk memverifikasi bahwa rahasia yang diungkapkan nanti akan memberinya akses ke bitcoin. Sebagai gantinya, Bob mengirimkan Alice transaksi dan adaptor yang belum ditandatangani. Alice kemudian dapat menyelesaikan transaksi Bob dan mendapatkan kembali bitcoin dengan mengirimkan sebuah transaksi yang valid menggunakan rahasia tersebut. Ketika transaksi ini dipublikasikan di blockchain, Bob memiliki kemampuan untuk mengekstrak rahasia tersebut dan dengan demikian membuka kunci transaksi Alice. Akibatnya, jika Alice memulai transfer bitcoin Bob, dia dapat, pada gilirannya, mengakses bitcoin Alice tanpa memerlukan rasa saling percaya.

Penting untuk dicatat bahwa pertukaran koin pertama kali diusulkan oleh [Gregory Maxwell pada bulan Oktober 2013 di BitcoinTalk](https://bitcointalk.org/index.php?topic=321228.0).

### Bursa Atom

Mirip dengan pertukaran koin dan menggunakan jenis kontrak pintar yang sama, pertukaran atom juga memungkinkan untuk dilakukan. Pertukaran atom memungkinkan pertukaran langsung mata uang kripto yang berbeda, seperti BTC dan XMR, antara dua pengguna tanpa memerlukan kepercayaan atau intervensi perantara. Pertukaran ini disebut pertukaran "atomik" karena hanya ada dua kemungkinan hasil yang mungkin terjadi: pertukaran berhasil dan kedua belah pihak merasa puas, atau gagal dan masing-masing tetap memiliki mata uang kripto asli mereka, sehingga menghilangkan kebutuhan akan kepercayaan pada pihak lain.

![BTC204](assets/fr/197.webp)

Bursa atom dan bursa koin memiliki metode operasi yang sama dan menawarkan keuntungan dan kerugian yang sama dalam hal privasi. Faktanya, dari sudut pandang Bitcoin, bursa atom sebanding dengan bursa koin yang dilakukan dalam dua langkah. Pertama, kita menukarkan BTC kita dengan mata uang kripto lain, dan kemudian mata uang kripto ini dapat ditukarkan dengan BTC lainnya. Terakhir, kita mengambil BTC milik pengguna lain. Inilah sebabnya, dalam analisis masalah privasi, saya mengelompokkan kedua protokol ini di bawah kategori pertukaran properti rahasia.

![BTC204](assets/fr/198.webp)

Namun, tidak seperti pertukaran koin, pertukaran atom dapat memiliki ketidakseimbangan dalam hal likuiditas yang tersedia, terutama dalam pertukaran BTC/XMR. Secara umum, lebih mudah untuk menukarkan bitcoin dengan altcoin karena ada permintaan yang besar untuk bitcoin, yang membuat premi untuk arah konversi ini rendah. Namun, memperdagangkan altcoin untuk mendapatkan BTC bisa menjadi lebih rumit karena permintaan yang lebih rendah, sering kali menghasilkan premi yang sangat tinggi.

Terakhir, ketika pertukaran atom melibatkan bitcoin onchain dan bitcoin di jaringan Lightning, kami menyebutnya sebagai "_pertukaran submersible_."

### Apakah Ini Benar-Benar Berguna?

Pemindahan kepemilikan secara rahasia, seperti pertukaran koin dan pertukaran atom, memiliki keuntungan dalam mengelabui heuristik analisis rantai. Metode-metode ini dapat memberikan kesan bahwa transaksi melibatkan pengguna yang sama, bahkan jika kepemilikan yang sebenarnya telah berpindah tangan. Akan tetapi, kelemahan utama dari metode-metode ini adalah bahwa metode-metode ini sangat beresiko tanpa menggunakan teknik tambahan untuk mengacaukan riwayat koin.

Secara efektif, ketika Alice melakukan pertukaran koin atau atomic swap dengan Bob, ia menukar kepemilikan bitcoin-nya dengan bitcoin Bob. Dalam kasus pertukaran atom, pertukaran tersebut menyertakan altcoin, tetapi prinsipnya tetap sama. Dengan demikian, Alice berakhir dengan koin $B$ dan Bob dengan koin $A$. Hal ini menambah keraguan dalam analisis rantai, tetapi sejarah koin tetap dapat dilacak. Jika seorang analis memeriksa koin $A$, dia dapat melacak aktivitas Alice sebelumnya, dan sebaliknya untuk koin $B$.

Dari sudut pandang Alice, risikonya adalah sejarah koin $B$ dapat dianggap mencurigakan oleh entitas tertentu. Jika, misalnya, Bob mendapatkan koin $B$ melalui tindakan kriminal seperti peretasan, koin ini akan tetap terkait dengan aktivitas ilegal yang dilakukannya. Alice kemudian dapat menemukan dirinya memiliki koin yang tidak dapat ia transfer ke platform perdagangan yang teregulasi tanpa mengambil risiko dananya dibekukan, atau bahkan dituduh melakukan kejahatan Bob, meskipun ia tidak ada hubungannya dengan kejahatan tersebut.

Dan tentu saja, metode privasi seperti pertukaran koin atau pertukaran atom disukai oleh para penjahat yang dananya dipantau oleh pihak berwenang. Protokol ini memberikan mereka kesempatan untuk membuang bitcoin yang dipantau dengan imbalan bitcoin yang dapat dipertukarkan secara sempurna. Hal ini juga memungkinkan mereka untuk membuat pengalihan dengan mengarahkan pihak berwenang ke pengguna lain. Dengan demikian, terdapat kegunaan ganda bagi orang-orang ini.

Dengan coinjoin, meskipun koin Anda tercampur dengan bitcoin yang dipantau, riwayat koin tersebut akan rusak, yang memberikan sebuah bentuk penyangkalan yang masuk akal yang tidak ada pada protokol transfer properti rahasia seperti pertukaran koin atau pertukaran atom.

Jika Alice ingin menghindari risiko, dia harus menggunakan metode untuk mengganggu riwayat koin $B$, seperti menjalankannya melalui coinjoin, misalnya. Hal ini menimbulkan pertanyaan mengenai kegunaan menggabungkan transfer kepemilikan secara rahasia dan coinjoin. Coinjoin, dengan menginterupsi sejarah koin, sudah memberikan tingkat privasi yang cukup untuk Alice. Dengan demikian, pandangan saya adalah jika Alice ingin melindungi privasinya, akan lebih bijaksana untuk langsung menggunakan coinjoin daripada terlibat dalam pertukaran koin yang diikuti dengan coinjoin.

Agar metode transfer kepemilikan secara rahasia dapat benar-benar efektif dan menghindari risiko menghubungkan riwayat pengguna $A dengan pengguna $B, maka secara paradoksal penggunaannya harus diketahui secara luas. Jika pertukaran koin digunakan secara masif dan pihak berwenang mengetahui praktik umum ini, maka bentuk penyangkalan yang masuk akal dapat dibuat. Akan tetapi, selama penggunaan transfer ini masih marjinal, saya yakin metode ini akan tetap terlalu beresiko untuk para pengguna.

Sejauh ini, kita telah mempelajari metode privasi pada tingkat transaksi itu sendiri. Pada bab berikutnya, kita akan mengeksplorasi masalah pada tingkat jaringan dan difusi transaksi.

## Privasi di Jaringan P2P

<chapterId>04a2467b-db84-4076-a9ff-919be5135106</chapterId>

Pada Bagian 4, kita telah membahas pentingnya menggunakan full node untuk melindungi privasi transaksi Anda. Akan tetapi, penting untuk memahami bahwa node Anda sendiri dapat menjadi sasaran serangan yang berusaha mengekstrak informasi mengenai aktivitas Anda. Oleh karena itu, pada bab ini, kita akan melihat langkah-langkah perlindungan privasi yang berbeda, bukan pada tingkat transaksi itu sendiri atau aliran bitcoin, tetapi pada tingkat jaringan.

### Dandelion

Salah satu cara untuk menghindari berbagai serangan deanonimisasi adalah dengan menggunakan Dandelion yang diusulkan. Protokol transmisi ini diformalkan dalam BIP156, tetapi belum pernah diimplementasikan pada Bitcoin. Ide dari Dandelion adalah untuk meningkatkan privasi perutean transaksi dalam jaringan Bitcoin untuk menggagalkan berbagai bentuk serangan. Tujuan utamanya adalah untuk menyembunyikan node sumber yang pada awalnya mentransmisikan sebuah transaksi dalam jaringan. Pengungkapan node ini dapat menghubungkan transaksi Bitcoin ke alamat IP tertentu (jika node tersebut beroperasi di jaringan yang tidak terenkripsi), sehingga memberikan titik masuk untuk analisis rantai.

Hubungan antara aktivitas di Bitcoin dan alamat IP menimbulkan risiko yang signifikan terhadap privasi pengguna. Faktanya, banyak entitas yang dapat dengan mudah menghubungkan alamat IP dengan identitas pribadi. Hal ini termasuk pemerintah dan penyedia layanan Internet. Selain itu, informasi ini dapat diakses oleh publik, contohnya, jika alamat IP dan data pribadi Anda terekspos karena kebocoran data selama peretasan database situs web.

Dalam operasi standar Bitcoin, transaksi yang dibuat oleh pengguna pada dompet perangkat lunak mereka ditransmisikan ke simpul pribadi mereka. Node ini akan segera mengirimkan transaksi baru tersebut ke semua peer yang terhubung dengannya.

Peers ini kemudian memverifikasi transaksi untuk memastikan bahwa transaksi tersebut memenuhi aturan konsensus dan aturan standardisasi lokal. Setelah divalidasi, setiap peer pada gilirannya meneruskan transaksi ke rekan-rekannya, dan seterusnya.

Distribusi transaksi yang menunggu integrasi dalam sebuah blok terjadi dengan cara yang cukup seimbang dan dapat diprediksi secara statistik. Kerentanan ini dapat dieksploitasi oleh mata-mata yang berkolusi, yang berkolaborasi untuk memonitor dan menganalisa jaringan untuk mengidentifikasi node pertama yang mengirimkan sebuah transaksi. Jika pengamat dapat menemukan node sumber, mereka dapat mengasumsikan bahwa transaksi tersebut berasal dari operator node tersebut. Jenis pengamatan ini dapat menghubungkan transaksi, yang biasanya anonim, ke alamat IP tertentu.

Tujuan dari BIP156 adalah untuk mengatasi masalah ini. Untuk melakukannya, ia memperkenalkan tahap tambahan dalam transmisi transaksi baru untuk menjaga anonimitas sebelum diseminasi publik berskala besar. Dandelion pertama kali menggunakan fase "stem" di mana transaksi dikirim melalui jalur node secara acak.

Transaksi kemudian ditransmisikan ke seluruh jaringan dalam tahap "fluff" (blowhole).

Batang dan dandelion adalah referensi untuk perilaku penyebaran transaksi melalui jaringan, yang menyerupai bentuk dandelion.

Dengan demikian, node mata-mata berpotensi melacak transaksi kembali ke node yang memulai fase blowing (transmisi besar-besaran), tetapi node ini bukanlah node yang pertama kali mentransmisikan transaksi, karena node ini menerimanya dari node terakhir dalam batang. Jika node mata-mata tidak dapat melacak batang, mereka juga tidak dapat mengidentifikasi node sumber.

Bahkan dengan adanya spy node selama fase batang, keraguan selalu ada karena begitu mereka menemukan node yang jujur dalam grafik difusi, mata-mata tidak dapat menentukan apakah node ini adalah sumber asli atau hanya perantara.

Metode perutean ini membuat lebih sulit untuk melacak kembali ke node sumber, membuatnya rumit untuk melacak transaksi melalui jaringan ke asalnya. Dengan demikian, Dandelion meningkatkan privasi dengan membatasi kemampuan lawan untuk mendeanonimisasi jaringan. Metode ini bahkan lebih efektif ketika transaksi, selama fase "batang", melewati sebuah node yang mengenkripsi komunikasi jaringannya, seperti pada Tor atau P2P Transport V2.

BIP156 belum diintegrasikan ke dalam Bitcoin Core dan saat ini diklasifikasikan dengan status "ditolak" Kekhawatiran utama mengenai protokol ini terletak pada fakta bahwa, selama fase stem, transaksi harus diteruskan oleh node perantara sebelum diverifikasi. Seperti yang telah kita lihat, pada model Bitcoin normal, setiap node memverifikasi transaksi terlebih dahulu sebelum meneruskannya ke rekan-rekannya. Jika sebuah transaksi tidak memenuhi konsensus node atau aturan standarisasi lokal, maka transaksi tersebut akan diabaikan dan tidak diteruskan. Proses ini penting dalam menggagalkan serangan DoS, karena hanya transaksi yang valid yang dikirimkan ke seluruh jaringan. Transaksi yang tidak valid, yang berpotensi dibuat secara massal untuk membebani jaringan, akan dihentikan di node pertama yang ditemui dan tidak menyebar. Resiko utama dari Dandelion adalah protokol baru ini dapat memperkenalkan vektor baru untuk serangan DoS dengan mengizinkan transaksi yang tidak valid untuk dikirim melalui sebagian jaringan.

### Transportasi P2P V2

P2P Transport V2 adalah protokol jaringan lain yang dihadirkan dalam BIP324. Ini adalah versi baru dari protokol transport P2P Bitcoin yang menggabungkan kriptografi oportunistik untuk meningkatkan kerahasiaan dan keamanan komunikasi antar node.

Peningkatan ini bertujuan untuk memecahkan beberapa masalah dengan versi dasar protokol P2P. Salah satunya, membuat data yang dipertukarkan tidak dapat dibedakan dari jenis data lain yang beredar di Internet bagi pengamat pasif. Tujuan utamanya adalah untuk mencegah pemerintah, penyedia layanan Internet, atau penyedia VPN untuk memonitor pengguna Bitcoin secara besar-besaran. Hal ini juga mempersulit tugas entitas-entitas tersebut untuk menentukan apakah seorang pengguna Internet juga merupakan pengguna Bitcoin, yaitu apakah mereka mengoperasikan sebuah node penuh.

P2P V2 juga membantu mengurangi risiko penyensoran dan serangan dengan mendeteksi pola-pola tertentu dalam paket data. Hal ini memperumit dan membuatnya lebih mahal untuk mengeksekusi berbagai jenis serangan Sybil di tingkat jaringan. Serangan Sybil terjadi ketika seorang aktor membuat beberapa identitas palsu untuk mendapatkan keuntungan yang tidak semestinya. Dalam konteks jaringan Bitcoin, hal ini sering kali terlihat ketika seorang aktor mengendalikan sejumlah besar node dan secara agresif menggunakannya untuk memperbanyak koneksi. Serangan Sybil dapat bersifat pasif, yang bertujuan untuk mengumpulkan informasi dan membahayakan kerahasiaan pengguna, atau bersifat aktif, dalam bentuk serangan Eclipse. Serangan yang terakhir ini mengisolasi sebuah node tertentu dari seluruh jaringan, yang memungkinkannya untuk menyensor pengguna atau mengubah data yang diterimanya. Terakhir, P2P V2 membuat serangan _Man-In-The-Middle_ (MITM) menjadi lebih mahal dan lebih mudah dideteksi.

Enkripsi yang diimplementasikan oleh P2P V2 tidak menyertakan autentikasi agar tidak menambah kerumitan yang tidak perlu dan tidak mengganggu sifat koneksi jaringan yang tanpa izin. Namun, protokol transport P2P yang baru ini memberikan keamanan yang lebih baik terhadap serangan pasif dan membuat serangan aktif menjadi jauh lebih mahal dan dapat dideteksi. Pengenalan aliran data acak semu dalam pesan jaringan memperumit tugas penyerang yang ingin menyensor atau memanipulasi komunikasi.

Transportasi P2P V2 disertakan sebagai opsi (dinonaktifkan secara default) dalam versi 26.0 Bitcoin Core, yang digunakan pada bulan Desember 2023. Kemudian diaktifkan secara default pada versi 27.0 pada bulan April 2024. Opsi ini dapat diubah dengan opsi `v2transport=` dalam file konfigurasi.

### Tor

Solusi yang relatif sederhana untuk menghindari risiko hilangnya kerahasiaan untuk node tingkat jaringan adalah menjalankannya sepenuhnya di bawah Tor. Tor adalah jaringan server relai (node) yang menganonimkan asal koneksi TCP melalui Internet. Tor bekerja dengan mengenkapsulasi data dalam beberapa lapisan enkripsi. Setiap simpul relai menghilangkan satu lapisan untuk mengungkapkan alamat simpul berikutnya, sampai tujuan akhir tercapai. Jaringan Tor memastikan anonimitas dengan mencegah simpul perantara mengetahui asal dan tujuan data, sehingga sangat sulit bagi pengamat untuk melacak aktivitas pengguna.

Oleh karena itu, Tor tidak hanya mengenkripsi data yang dikomunikasikan, tetapi juga memungkinkan asal dan tujuan komunikasi disamarkan. Dengan menggunakan Tor untuk komunikasi simpul pribadi seseorang, kami meningkatkan privasi transaksi kami: Penyedia Layanan Internet (ISP) tidak dapat mendekripsi komunikasi, dan simpul-simpul lain dalam jaringan Bitcoin tidak dapat mengidentifikasi alamat IP simpul sumber. Selain itu, Tor juga menyembunyikan penggunaan Bitcoin dari ISP seseorang.

Risiko utama yang terkait dengan metode ini adalah bahwa Tor merupakan protokol yang tidak bergantung pada Bitcoin. Jika Anda memiliki sebuah simpul Bitcoin di bawah Tor dan Tor berhenti bekerja, maka simpul Bitcoin Anda tidak akan lagi dapat berkomunikasi.

Selain itu, penting untuk dicatat bahwa komunikasi pada Tor lebih lambat. Latensi ini sangat merepotkan selama peluncuran awal sebuah node, karena Initial Block Download (IBD) membutuhkan banyak komunikasi. Akibatnya, sinkronisasi awal dengan jaringan Bitcoin dapat memakan waktu yang lebih lama dengan menggunakan Tor. Anda juga dapat melakukan IBD di jaringan terbuka dan kemudian mengaktifkan Tor di kemudian hari. Walaupun metode ini mengungkapkan keberadaan node Bitcoin Anda kepada ISP Anda, metode ini melindungi informasi transaksi pribadi Anda setelah Anda beralih ke Tor.

Setelah menjelajahi berbagai metode privasi di tingkat jaringan, saya juga ingin memperkenalkan dua solusi elegan di bab berikutnya untuk menghindari penggunaan ulang alamat: BIP47 dan Pembayaran Senyap.

## BIP47 dan Kode Pembayaran yang Dapat Digunakan Kembali

<chapterId>ad88e076-a04b-4aec-b3b2-7b4760175504</chapterId>

Seperti yang telah kita lihat pada Bagian 3, penggunaan ulang alamat merupakan sebuah hambatan serius untuk privasi pengguna pada protokol Bitcoin. Untuk mengurangi risiko ini, sangat disarankan untuk membuat alamat penerima baru untuk setiap pembayaran baru yang diterima di dompet. Walaupun saat ini pembuatan alamat baru telah disederhanakan dengan penggunaan perangkat lunak modern dan dompet hirarkis deterministik, praktik ini mungkin terlihat berlawanan dengan intuisi.

Dalam sistem perbankan tradisional, misalnya, kita terbiasa berbagi IBAN, yang selalu sama. Begitu kita memberi tahu seseorang, mereka dapat mengirimi kita banyak pembayaran tanpa harus berinteraksi dengan kita lagi. Neo-bank juga menawarkan kemungkinan yang lebih modern seperti penggunaan alamat email unik di PayPal atau RevTags di Revolut. Bahkan di luar domain keuangan, pengidentifikasi harian kita seperti alamat surat, nomor telepon, dan alamat email adalah unik dan permanen. Kita tidak perlu memperbaruinya dengan setiap interaksi baru.

Namun, cara kerja Bitcoin berbeda: sangat penting untuk membuat alamat penerima baru untuk setiap transaksi yang masuk. Pertukaran antara kemudahan penggunaan dan privasi ini sudah ada sejak awal mula buku putih Bitcoin. Sejak publikasi versi pertama dari makalahnya pada akhir tahun 2008, Satoshi Nakamoto telah memperingatkan kita akan risiko ini:

**"_Sebagai firewall tambahan, pasangan kunci baru dapat digunakan untuk setiap transaksi agar tidak terhubung dengan pemilik yang sama._"**

Ada banyak metode untuk menerima banyak pembayaran dengan satu pengenal tanpa menyebabkan penggunaan ulang alamat. Setiap metode ini memiliki kelebihan dan kekurangannya masing-masing. Di antara metode-metode ini adalah BIP47, sebuah proposal yang dikembangkan oleh Justus Ranvier dan diterbitkan pada tahun 2015. Proposal ini bertujuan untuk membuat kode pembayaran yang dapat digunakan kembali yang memungkinkan beberapa transaksi ke orang yang sama sambil menghindari penggunaan ulang alamat. Pada intinya, BIP47 berusaha untuk menawarkan sebuah sistem pembayaran yang intuitif sebagai sebuah pengenal yang unik dengan tetap menjaga privasi transaksi.

![BTC204](assets/fr/212.webp)

BIP47 tidak secara langsung meningkatkan privasi pengguna, karena pembayaran BIP47 menawarkan tingkat privasi yang sama dengan transaksi Bitcoin klasik yang menggunakan alamat baru. Namun, hal ini membuat penggunaan Bitcoin menjadi lebih nyaman dan intuitif, sebuah kemudahan yang biasanya harus mengorbankan privasi. Berkat BIP47, kemudahan penggunaan ini mencapai tingkat privasi yang sama dengan transaksi klasik. Inilah sebabnya mengapa BIP47 adalah alat yang berharga untuk menjaga privasi.

Pada awalnya, BIP47 merupakan sebuah proposal yang diformulasikan untuk diintegrasikan ke dalam Bitcoin Core, tetapi tidak pernah diadopsi. Akan tetapi, beberapa perangkat lunak memilih untuk mengimplementasikannya secara mandiri di tingkat aplikasi. Oleh karena itu, tim Dompet Samourai mengembangkan implementasi BIP47 mereka sendiri yang disebut "PayNym."

### Prinsip Umum BIP47 dan PayNym

Tujuan dari BIP47 adalah untuk memungkinkan penerimaan banyak pembayaran tanpa menyebabkan penggunaan ulang alamat. Hal ini didasarkan pada penggunaan kode pembayaran yang dapat digunakan kembali, yang memungkinkan pengirim yang berbeda untuk mengirim beberapa pembayaran ke satu kode milik pengguna lain. Dengan demikian, penerima tidak perlu memberikan alamat baru untuk setiap transaksi, yang sangat memudahkan pertukaran mereka sambil menjaga privasi mereka.

![BTC204](assets/it/66/4.webp)

Seorang pengguna dapat dengan bebas membagikan kode pembayarannya, baik di jejaring sosial atau di situs webnya sendiri, tanpa risiko kehilangan privasi, tidak seperti yang akan terjadi pada alamat penerima klasik atau kunci publik.

Untuk melakukan transaksi, kedua belah pihak harus memiliki dompet Bitcoin dengan implementasi BIP47, seperti PayNym di Samourai Wallet atau Sparrow Wallet. Penggunaan bersama kode pembayaran mereka menciptakan saluran rahasia di antara mereka. Untuk membuat saluran ini secara efisien, pengirim harus melakukan transaksi tertentu pada blockchain Bitcoin, yang dikenal sebagai "transaksi notifikasi" (saya akan menjelaskan lebih lanjut mengenai hal ini nanti).

Kombinasi dari kode pembayaran kedua pengguna menghasilkan rahasia bersama, yang pada gilirannya memungkinkan terciptanya sejumlah besar alamat penerima Bitcoin yang unik (tepatnya 2^32, atau sekitar 4 miliar). Dengan demikian, pembayaran yang dilakukan melalui BIP47 tidak benar-benar ditujukan kepada kode pembayaran itu sendiri, tetapi lebih kepada alamat penerima klasik yang berasal dari kode pembayaran para pengguna yang terlibat.

Kode pembayaran kemudian berfungsi sebagai pengenal virtual yang berasal dari seed wallet. Dalam struktur derivasi hirarkis portofolio, kode pembayaran ditempatkan pada level 3, yaitu pada level akun.

![BTC204](assets/it/66/5.webp)

Target derivasi untuk BIP47 diidentifikasi dengan indeks `47'` (`x8000002F`), yang mengacu pada BIP47. Contoh jalur derivasi untuk kode pembayaran yang dapat digunakan kembali adalah sebagai berikut:

```plaintext
m/47'/0'/0'/
```

Untuk memberi Anda gambaran seperti apa kode pembayaran itu, berikut ini milik saya:

```plaintext
M8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5
```

Kode ini juga dapat dikodekan ke dalam kode QR untuk memudahkan komunikasi, seperti halnya alamat penerima klasik.

Sedangkan untuk PayNym Bots, robot-robot yang terkadang terlihat di Twitter adalah representasi visual dari kode pembayaran, yang dibuat oleh Samourai Wallet. Mereka dihasilkan melalui fungsi hashing, yang memberi mereka keunikan. Mereka muncul sebagai serangkaian karakter kecil yang dimulai dengan `+`:

```plaintext
+throbbingpond8B1
+twilightresonance487
+billowingfire340
```

Avatar ini juga dapat direpresentasikan sebagai gambar:

![BTC204](assets/fr/215.webp)

Meskipun robot ini tidak memiliki fungsi teknis khusus dalam kerangka kerja BIP47, namun robot ini berperan dalam memfasilitasi interaksi antara pengguna dengan menawarkan identitas visual yang mudah dikenali.

---
*Pada bagian selanjutnya dari bab ini yang membahas tentang BIP47, kita akan membahas pengoperasiannya secara mendetail, dengan fokus pada metode kriptografi yang digunakan. Untuk memahami penjelasan yang agak teknis ini, pertama-tama kita harus memahami struktur dari HD Wallet, proses penurunan kunci, dan prinsip-prinsip dasar kriptografi berbasis kurva eliptik. Jika Anda ingin mempelajari lebih lanjut tentang konsep-konsep ini, kursus gratis lainnya tersedia di Plan ₿ Network:*

https://planb.network/courses/cyp201
*Saya sangat menyarankan Anda untuk mengikutinya, karena dengan memahami cara kerja teknis BIP47 akan membantu Anda lebih mudah memahami proposal serupa lainnya yang akan kita bahas di bab-bab selanjutnya*

---
### Kode Pembayaran yang dapat digunakan kembali

Seperti yang telah disebutkan sebelumnya, kode pembayaran yang dapat digunakan kembali terletak di level 3 dompet HD, membuatnya sebanding dengan `xpub`, baik dalam posisinya di dalam struktur dompet maupun perannya.

Kode pembayaran 80-byte dibagi sebagai berikut:


- Byte `0`: Versi **. Untuk versi pertama BIP47, byte ini diatur ke `0x01`;
- Byte `1`: Bidang bit**. Ruang ini dicadangkan untuk memasukkan indikasi tambahan selama penggunaan tertentu. Untuk penggunaan standar dengan PayNym, byte ini didefinisikan sebagai `x00`;
- Byte `2`: Paritas dari `y`**. Byte ini adalah `0x02` atau `0x03`, yang menunjukkan apakah ordinat kunci publik genap atau ganjil, karena kunci publik terkompresi digunakan;
- Dari byte `3` hingga byte `34`: Nilai dari `x`**. Byte ini mewakili absis dari kunci publik. Gabungan dari `x` dan paritas dari `y` membentuk kunci publik terkompresi yang lengkap;
- Dari byte `35` hingga byte `66`: Kode rantai**. Ruang ini berisi kode rantai yang terkait dengan kunci publik;
- Dari byte `67` hingga byte `79`: Mengisi**. Ruang ini dimaksudkan untuk kemungkinan pengembangan di masa mendatang. Untuk versi saat ini, angka nol hanya ditempatkan di sini untuk mencapai ukuran 80 byte yang diperlukan untuk output `OP_RETURN`.

Berikut adalah representasi heksadesimal dari kode pembayaran yang dapat digunakan kembali yang telah disajikan di bagian sebelumnya:

```plaintext
0x010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000
```

![BTC204](assets/it/66/7.webp)

Pertama-tama, Anda perlu menambahkan byte awalan `P` di awal untuk menunjukkan dengan jelas bahwa itu adalah kode pembayaran. Byte ini diwakili oleh `x47`:

```plaintext
0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000
```

Terakhir, untuk memastikan integritas kode pembayaran, perhitungan checksum dilakukan dengan menggunakan `HASH256`, yang terdiri dari hash ganda dengan fungsi `SHA256`. Empat byte pertama yang dihasilkan dari hash ini kemudian digabungkan di akhir kode pembayaran:

```plaintext
0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000567080c4
```

Setelah langkah-langkah ini selesai, kode pembayaran sudah siap. Satu-satunya langkah yang tersisa adalah mengonversinya ke base 58 untuk mendapatkan versi finalnya:

```plaintext
PM8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5
```

Selama proses pembuatan kode pembayaran, kami menggunakan kunci publik terkompresi dan kode rantai. Keduanya diturunkan secara deterministik dan hirarkis dari seed wallet. Jalur penurunan yang digunakan untuk mencapai hal ini adalah:

```plaintext
m/47'/0'/0'/
```

Untuk menghasilkan kunci publik terkompresi dan kode rantai terkait untuk kode pembayaran yang dapat digunakan kembali, kita mulai dengan menghitung kunci privat utama dari seed wallet. Kemudian kita lanjutkan dengan menurunkan pasangan anak kunci dengan menggunakan indeks `47 + 2^31` (turunan yang diperkuat). Langkah ini diikuti dengan dua turunan pasangan kunci anak yang lebih banyak lagi, masing-masing menggunakan indeks `2^31` (turunan yang diperkuat).

### Pertukaran Kunci Diffie-Hellman Kurva Elips (ECDH)

Protokol kriptografi yang menjadi inti dari BIP47 disebut dengan singkatan ECDH, yaitu _Eliptic-Curve Diffie-Hellman_. Metode ini merupakan varian dari pertukaran kunci Diffie-Hellman yang asli.

Diperkenalkan pada tahun 1976, Diffie-Hellman adalah protokol perjanjian kunci yang memungkinkan dua pihak, masing-masing dilengkapi dengan pasangan kunci (publik dan privat), untuk menyetujui rahasia bersama, bahkan ketika berkomunikasi secara eksklusif melalui saluran publik yang tidak aman.

![BTC204](assets/it/66/10.webp)

Rahasia bersama ini (di sini, kunci biru), kemudian dapat digunakan untuk operasi lainnya. Biasanya, rahasia bersama ini dapat digunakan untuk mengenkripsi dan mendekripsi komunikasi melalui jaringan yang tidak aman:

![BTC204](assets/fr/220.webp)

Untuk mencapai pertukaran ini, Diffie-Hellman menggunakan aritmatika modular untuk menghitung rahasia bersama. Berikut ini adalah penjelasan sederhana tentang cara kerjanya:


- Alice dan Bob menyetujui warna yang sama, di sini adalah kuning, yang merupakan data publik (penyerang mengetahui warna ini);
- Alice memilih warna rahasia, di sini merah, dan mencampurkan keduanya untuk mendapatkan warna jingga;
- Bob juga memilih warna rahasia, di sini biru, dan mencampurkannya dengan warna kuning untuk mendapatkan warna hijau;
- Kemudian mereka menukar warna yang diperoleh, oranye dan hijau. Pertukaran ini dapat terjadi pada jaringan yang tidak aman dan teramati;
- Dengan mencampurkan warna hijau Bob dengan warna rahasianya, Alice menghasilkan warna cokelat;
- Bob, melakukan hal yang sama dengan warna oranye Alice dan warna biru rahasianya, juga menjadi cokelat.

![BTC204](assets/it/66/12.webp)

Dalam penyederhanaan ini, warna coklat mewakili rahasia yang dimiliki bersama antara Alice dan Bob. Penting untuk dipahami bahwa, pada kenyataannya, tidak mungkin bagi penyerang untuk memisahkan warna oranye dan hijau untuk menemukan warna rahasia Alice atau Bob.

Sekarang, mari kita periksa bagaimana protokol ini benar-benar bekerja, bukan dengan analogi warna, tetapi menggunakan bilangan riil dan aritmatika modular!

Sebelum membahas mekanisme Diffie-Hellman, izinkan saya mengingatkan Anda secara singkat tentang dua konsep matematika penting yang akan kita perlukan:


- Bilangan prima adalah bilangan asli yang hanya memiliki dua pembagi: $ 1$ dan dirinya sendiri. Sebagai contoh, $7$ adalah bilangan prima karena hanya dapat dibagi oleh $1$ dan $7$. Di sisi lain, $8$ bukanlah bilangan prima karena dapat dibagi oleh $1$, $2$, $4$ dan $8$. Oleh karena itu, bilangan ini memiliki empat pembagi bilangan bulat positif, bukan dua;
- **mod** (dilambangkan dengan $mod$ atau $\%$) adalah operasi matematika yang, di antara dua bilangan bulat, mengembalikan sisa pembagian Euclidean dari bilangan bulat yang pertama dengan bilangan bulat yang kedua. Sebagai contoh, $16 \bmod 5 = 1$.

**Pertukaran kunci Diffie-Hellman antara Alice dan Bob berlangsung sebagai berikut:**


- Alice dan Bob setuju dengan dua bilangan yang sama: $p$ dan $g$. $p$ adalah sebuah bilangan prima, dan semakin besar bilangan ini, maka semakin aman Diffie-Hellman. $g$ adalah sebuah akar primitif dari $p$. Kedua bilangan ini dapat dikomunikasikan secara terbuka melalui jaringan yang tidak aman. Mereka mewakili ekuivalen dengan **warna kuning** dalam penyederhanaan di atas. Oleh karena itu, penting bagi Alice dan Bob untuk menggunakan nilai yang sama persis untuk $p$ dan $g$.

Setelah parameter ini ditentukan, Alice dan Bob masing-masing memilih nomor rahasia secara acak. Alice menyebut nomor rahasia acak sebagai $a (setara dengan **warna merah**) dan Bob menyebutnya sebagai $b (setara dengan **warna biru**). Nomor-nomor ini harus tetap dijaga kerahasiaannya.

Alih-alih menukar angka $a$ dan $b$ secara langsung, masing-masing pihak menghitung $A$ dan $B$ sebagai berikut:

$A$ sama dengan $g$ yang dipangkatkan dengan pangkat $a$ modulo $p$:

$$
A = g^a \bmod p
$$

$B$ sama dengan $g$ yang dipangkatkan dengan pangkat $b$ modulo $p$:

$$
B = g^b \bmod p
$$

Nilai $A (setara dengan **warna oranye**) dan $B (setara dengan **warna hijau**) dipertukarkan antara kedua belah pihak. Pertukaran ini dapat dilakukan secara terbuka melalui jaringan yang tidak aman;

Alice, setelah menerima $B$, menghitung nilai $z$ sebagai berikut:

$z$ sama dengan $B$ yang dipangkatkan dengan pangkat $a$ modulo $p$:

$$
z = B^a \bmod p
$$

Ingat:

$$
B = g^b \bmod p
$$

Dengan demikian, kita mendapatkan:

$$
z = B^a \bmod p
$$

$$
z = (g^b)^a \bmod p
$$

Menerapkan aturan eksponen:

$$
(x^n)^m = x^{nm}
$$

Dengan demikian, kami memperoleh:

$$
z = g^{ba} \bmod p
$$


- Di sisi lain, Bob, setelah menerima $A$, juga menghitung nilai $z$ dengan cara berikut:

$z$ sama dengan $A$ yang dipangkatkan dengan pangkat $b$ modulo $p$:

$$
z = A^b \bmod p
$$

Dengan demikian, kita mendapatkan:

$$
z = (g^a)^b \bmod p
$$

$$
z = g^{ab} \bmod p
$$

$$
z = g^{ba} \bmod p
$$

Karena sifat distributif dari operator modulo, Alice dan Bob mendapatkan nilai $z$ yang sama persis. Angka ini mewakili rahasia bersama mereka, setara dengan **warna coklat** dalam penyederhanaan sebelumnya dengan pot cat. Mereka sekarang dapat menggunakan rahasia bersama ini untuk mengenkripsi komunikasi mereka secara simetris melalui jaringan yang tidak aman.

Seorang penyerang, bahkan jika ia memiliki $p$, $g$, $A$ dan $B$ (nilai publik), tidak akan dapat menghitung $a$, $b$ atau $z$ (nilai privat). Untuk melakukan hal tersebut, diperlukan pembalikan eksponensial, sebuah tugas yang mustahil dilakukan tanpa mencoba semua kemungkinan satu per satu, karena hal ini sama dengan menghitung logaritma diskrit, yaitu kebalikan dari eksponensial pada sebuah grup siklik berhingga.

Oleh karena itu, selama nilai $a$, $b$ dan $p$ cukup besar, protokol Diffie-Hellman aman. Biasanya, dengan parameter 2048-bit (angka dengan 600 digit dalam desimal), menguji semua kemungkinan untuk $a$ dan $b$ tidak praktis. Sampai saat ini, dengan angka tersebut, algoritma ini dianggap aman.

Di sinilah letak kelemahan utama protokol Diffie-Hellman. Agar aman, algoritme ini harus menggunakan angka yang besar. Itulah sebabnya, saat ini, orang lebih memilih algoritma ECDH (_Eliptic Curve Diffie-Hellman_), sebuah varian Diffie-Hellman yang didasarkan pada kurva aljabar, lebih tepatnya kurva elips. Pendekatan ini memungkinkan untuk bekerja dengan jumlah yang jauh lebih kecil dengan tetap mempertahankan keamanan yang setara, sehingga mengurangi sumber daya yang diperlukan untuk komputasi dan penyimpanan.

Prinsip umum dari algoritma ini tetap sama. Namun, alih-alih menggunakan angka acak $a$ dan angka $A$ yang dihitung dari $a$ dengan eksponensial modular, kami menggunakan pasangan kunci yang dibuat pada kurva elips. Alih-alih mengandalkan distributivitas dari operator modulo, kita menggunakan hukum grup pada kurva eliptik, dan lebih khusus lagi, asosiatifitas dari hukum ini.

Untuk menjelaskan secara singkat prinsip kriptografi kurva eliptik, sebuah kunci privat diwakili oleh sebuah angka acak antara $1$ dan $n-1$, di mana $n$ merepresentasikan urutan kurva. Kunci publik, di sisi lain, adalah sebuah titik tertentu pada kurva ini, yang didapatkan dari kunci privat dengan operasi penambahan dan penggandaan titik-titik yang dimulai dari titik pembangkitan, sesuai dengan persamaan:

$$
K = k \cdot G
$$

Dalam rumus ini, $K$ menunjukkan kunci publik, $k$ kunci privat, dan $G$ titik pembangkit.

Salah satu fitur penting dari kunci ini adalah kemudahan dalam menghitung $K$ dari $k$ dan $G$, sementara hampir tidak mungkin untuk menemukan $k$ dari $K$ dan $G$. Asimetri ini menciptakan fungsi satu arah. Dengan kata lain, mudah untuk menghitung kunci publik jika seseorang mengetahui kunci privat, tetapi menemukan kunci privat dari kunci publik adalah mustahil. Keamanan ini masih bergantung pada kesulitan komputasi dari logaritma diskrit.

Kita akan menggunakan properti ini untuk mengadaptasi algoritma Diffie-Hellman. *prinsip kerja ECDH adalah sebagai berikut:*** 1


- Alice dan Bob sepakat bersama mengenai kurva elips yang aman secara kriptografi dan parameternya. Informasi ini bersifat publik;
- Alice menghasilkan sebuah angka acak $ka$ yang akan menjadi kunci pribadinya. Kunci pribadi ini harus tetap dirahasiakan. Dia menentukan kunci publiknya $Ka$ dengan penambahan dan penggandaan titik-titik pada kurva elips yang dipilih:

$$
K_a = k_a \cdot G
$$


- Bob juga menghasilkan sebuah angka acak $kb$ yang akan menjadi kunci pribadinya. Dia menghitung kunci publik $kb$ yang terkait:

$$
K_b = k_b \cdot G
$$


- Alice dan Bob saling bertukar kunci publik $Ka$ dan $Kb$ pada jaringan publik yang tidak aman.
- Alice menghitung sebuah titik $(x,y)$ pada kurva dengan menggunakan kunci privatnya $ka$ ke kunci publik Bob $Kb$:

$$
(x,y) = k_a \cdot K_b
$$


- Bob menghitung sebuah titik $(x,y)$ pada kurva dengan menggunakan kunci privatnya $kb$ ke kunci publik Alice $Ka$:

$$
(x,y) = k_b \cdot K_a
$$


- Alice dan Bob mendapatkan titik yang sama pada kurva elips. Rahasia yang dibagikan adalah koordinat $x$ dari titik ini.

Faktanya, mereka mendapatkan rahasia bersama yang sama karena:

(x,y) = k_a \cdot K_b = k_a \cdot (k_b \cdot G) = (k_a \cdot k_b) \cdot G = (k_b \cdot k_a) \cdot G = k_b \cdot (k_a \cdot G) = k_b \cdot K_a

$$
Un attaccante che osserva la rete pubblica non protetta può ottenere solo le chiavi pubbliche di ciascuna parte e i parametri della curva ellittica scelta. Come precedentemente spiegato, queste informazioni da sole non sono sufficienti per determinare le chiavi private. Pertanto, l'attaccante non può trovare il segreto condiviso tra Alice e Bob.
ECDH è quindi un algoritmo che consente lo scambio di chiavi. È spesso utilizzato in combinazione con altri metodi crittografici per stabilire un protocollo completo. Ad esempio, ECDH è integrato nel nucleo di TLS (_Transport Layer Security_), un protocollo di crittografia e autenticazione utilizzato per il livello di trasporto di Internet. TLS utilizza ECDHE per lo scambio di chiavi, una variante di ECDH dove le chiavi sono effimere, per garantire la confidenzialità persistente. Inoltre, TLS utilizza algoritmi di autenticazione come ECDSA, algoritmi di crittografia come AES e funzioni hash come SHA256.
TLS è notevolmente responsabile della `s` in `https` così come del lucchetto visibile nella barra degli indirizzi del tuo browser, simboli delle comunicazioni criptate. Seguendo questo corso, stai quindi utilizzando ECDH, ed è molto probabile che lo usi quotidianamente senza nemmeno saperlo.
### La Transazione di Notifica
Come abbiamo visto nella sezione precedente, ECDH è una variante dello scambio Diffie-Hellman che utilizza coppie di chiavi stabilite su una curva ellittica. Convenientemente, possediamo già molte coppie di chiavi aderenti a questo standard nei nostri portafogli Bitcoin! L'idea di BIP47 è di utilizzare le coppie di chiavi dei portafogli Bitcoin gerarchici deterministici di entrambe le parti per stabilire segreti condivisi ed effimeri tra di loro. Nel contesto di BIP47, viene utilizzato ECDHE (_Elliptic Curve Diffie-Hellman Ephemeral_).
ECDHE viene utilizzato per la prima volta in BIP47 per trasmettere il codice di pagamento dal mittente al destinatario. Questo è il famoso **notification transaction**. Questo passaggio è essenziale perché affinché BIP47 funzioni efficacemente, entrambe le parti coinvolte (il mittente e il destinatario) devono conoscere il codice di pagamento dell'altro. Questa conoscenza consente la derivazione di chiavi pubbliche effimere e, di conseguenza, indirizzi di ricezione vuoti associati.
Prima di questo scambio, il mittente è logicamente già a conoscenza del codice di pagamento del destinatario poiché lo ha recuperato off-chain, ad esempio, dal loro sito web, una fattura o i loro social media. Tuttavia, il destinatario potrebbe non conoscere necessariamente il codice di pagamento del mittente. Eppure, questo codice deve essere trasmesso a loro; altrimenti, non saranno in grado di derivare le chiavi effimere necessarie per identificare gli indirizzi dove sono conservati i loro bitcoin, né accedere ai loro fondi. Sebbene questa trasmissione del codice del mittente possa tecnicamente essere effettuata off-chain attraverso altri mezzi di comunicazione, ciò pone un problema se il portafoglio deve essere recuperato solo dal seme.
Infatti, a differenza degli indirizzi convenzionali, gli indirizzi BIP47 non sono derivati direttamente dal seed del destinatario—utilizzare un `xpub` sarebbe più semplice in questo caso—ma risultano da un calcolo che combina i codici di pagamento di entrambi: quello del mittente e quello del destinatario. Pertanto, se il destinatario perde il proprio portafoglio e tenta di ripristinarlo dal proprio seed, recupererà il proprio codice di pagamento, che è derivato direttamente dal loro seed. Tuttavia, per trovare gli indirizzi effimeri, sarà essenziale per loro avere anche i codici di pagamento di tutti coloro che hanno inviato loro bitcoin tramite BIP47. Da qui l'importanza della transazione di notifica, che consente di salvare queste informazioni sulla blockchain di Bitcoin, pur essendo in grado di trovarle molto facilmente senza dover cercare tra il miliardo di transazioni eseguite dal suo lancio nel 2009.
![BTC204](assets/it/66/15.webp)
Pertanto, sarebbe possibile implementare BIP47 senza ricorrere alla transazione di notifica, a condizione che ogni utente conservi un backup dei codici di pagamento dei propri pari. Tuttavia, questo metodo si rivela complesso da gestire finché non viene sviluppata una soluzione semplice, robusta ed efficiente per creare, conservare e aggiornare questi backup. Nello stato attuale delle cose, la transazione di notifica diventa quasi indispensabile.
Nei capitoli seguenti, studieremo altri protocolli con obiettivi simili a quelli di BIP47, ma che non richiedono una transazione di notifica. Queste alternative, tuttavia, introducono i propri compromessi.
Oltre al suo ruolo nel backup dei codici di pagamento, la transazione di notifica serve anche una funzione di notifica per il destinatario, come suggerisce il suo nome. Segnala al client del destinatario che è stato stabilito un nuovo canale di pagamento e suggerisce quindi di monitorare gli indirizzi effimeri risultanti.
### Il Modello di Privacy di BIP47
Prima di dettagliare il funzionamento tecnico della transazione di notifica, è importante discutere il modello di privacy associato a BIP47, che giustifica alcune misure prese durante la creazione di questa transazione iniziale.
Il codice di pagamento, di per sé, non rappresenta un rischio diretto per la privacy. A differenza del modello Bitcoin tradizionale, che mira a rompere il collegamento tra l'identità di un utente e le sue transazioni (che sono pubbliche) preservando l'anonimato di chiavi e indirizzi, il codice di pagamento può essere apertamente associato a un'identità senza rappresentare una minaccia.
Infatti, il codice di pagamento non è utilizzato per derivare direttamente gli indirizzi che ricevono pagamenti BIP47. Questi indirizzi sono invece generati attraverso l'applicazione di ECDH tra le chiavi derivate dai codici di pagamento delle due parti coinvolte.
Così, un codice di pagamento di per sé non porta direttamente a una perdita di privacy, poiché solo l'indirizzo di notifica è derivato da esso. Sebbene questo indirizzo possa rivelare alcune informazioni, normalmente non consente di scoprire le parti con cui si stanno conducendo transazioni, a meno che non si effettui un'analisi approfondita della catena. Infatti, se il mittente utilizza UTXO che possono essere collegati alla loro identità per eseguire la transazione di notifica, allora diventa possibile dedurre che la loro identità è probabilmente collegata ai pagamenti BIP47 al tuo codice di pagamento. Questo non rivelerà le transazioni sottostanti, ma indicherà la loro probabile esistenza.
Pertanto, è essenziale mantenere questa stretta separazione tra i codici di pagamento degli utenti. Verso questo obiettivo, il passo iniziale di comunicazione del codice è un momento critico per la privacy del pagamento, ma obbligatorio per il corretto funzionamento del protocollo. Se uno dei codici di pagamento può essere ottenuto pubblicamente (come su un sito web), il secondo codice, quello del mittente, non deve essere collegato al primo in nessun caso.
Prendiamo un esempio concreto: voglio fare una donazione a un movimento politico tramite BIP47:
- L'organizzazione ha reso pubblico il suo codice di pagamento sul suo sito web o tramite i suoi social network;
- Questo codice è quindi collegato al movimento politico;
- Recupero questo codice di pagamento;
- Prima di procedere con un invio, devo assicurarmi che conoscano il mio codice di pagamento, che è anche collegato alla mia identità poiché lo uso per ricevere transazioni sui miei social network.
Come trasmettere il mio codice senza rischi? L'uso di mezzi di comunicazione convenzionali potrebbe portare a una fuga di informazioni e, di conseguenza, associarmi a questo movimento politico. La transazione di notifica offre una soluzione grazie a uno strato di crittografia che impedisce precisamente questa associazione tra due codici. Sebbene questo non sia l'unico metodo per trasmettere segretamente il codice di pagamento del mittente, si dimostra molto efficace.
Nel diagramma sottostante, le linee arancioni indicano i punti in cui il flusso di informazioni deve essere interrotto, e le frecce nere mostrano le connessioni che potrebbero potenzialmente essere osservate da terze parti:
![BTC204](assets/it/66/16.webp)
In realtà, all'interno del modello tradizionale di privacy di Bitcoin, è spesso complesso dissociare completamente il flusso di informazioni tra la coppia di chiavi e l'utente, specialmente durante le transazioni a distanza. Ad esempio, nel contesto di una campagna di donazione, il destinatario deve inevitabilmente divulgare un indirizzo o una chiave pubblica tramite il loro sito web o social network. L'uso corretto di BIP47, in particolare con la transazione di notifica, permette di aggirare questo problema grazie a ECDHE e allo strato di crittografia che studieremo ulteriormente.
Ovviamente, il modello classico di privacy di Bitcoin si applica ancora alle chiavi pubbliche effimere, che sono derivate dalla combinazione dei due codici di pagamento. I due modelli sono in realtà complementari. Quello che voglio evidenziare qui è che, contrariamente all'uso abituale di una chiave pubblica per ricevere bitcoin, il codice di pagamento può essere collegato a una specifica identità, perché l'informazione "_Alice effettua una transazione con Bob_" viene interrotta in un'altra fase. Il codice di pagamento viene utilizzato per generare indirizzi di pagamento, ma basandosi unicamente sull'osservazione della blockchain, è impossibile collegare una transazione di pagamento BIP47 ai codici di pagamento utilizzati per eseguirla, a meno che gli UTXO coinvolti non fossero già collegati a un'identità precedentemente e gli utenti non abbiano associato i loro codici di pagamento alle rispettive identità.
Per riassumere, il modello di privacy offerto dai pagamenti BIP47 potrebbe essere considerato superiore a quello della base di Bitcoin, anche se non è magico in alcun modo.
### Costruzione della Transazione di Notifica
Ora, vediamo come funziona questa transazione di notifica. Immaginiamo che Alice voglia inviare fondi a Bob con BIP47. Nel mio esempio, Alice agisce come mittente e Bob come destinatario. Quest'ultimo ha pubblicato il suo codice di pagamento sul suo sito web. Pertanto, Alice è già a conoscenza del codice di pagamento di Bob.
**1- Alice calcola un segreto condiviso con ECDH:**
- Seleziona una coppia di chiavi dal suo portafoglio HD situato su un ramo diverso dal suo codice di pagamento. Nota, questa coppia non dovrebbe essere facilmente associata all'indirizzo di notifica di Alice, né all'identità di Alice (vedi sezione precedente);
- Alice seleziona la chiave privata da questa coppia. La chiamiamo $a$ (minuscolo);
$$

a

$$
```text
- Alice recupera la chiave pubblica associata all'indirizzo di notifica di Bob. Questa chiave è la prima figlia derivata dal codice di pagamento di Bob (indice $/0$). Chiamiamo questa chiave pubblica $B$ (maiuscolo). La chiave privata associata a questa chiave pubblica è chiamata $b$ (minuscolo). $B$ è determinata dall'addizione e dal raddoppio dei punti sulla curva ellittica da $G$ (il punto generatore) con $b$ (la chiave privata):
$$ B = b \cdot G $$
- Alice calcola un punto segreto $S$ (maiuscolo) sulla curva ellittica tramite l'addizione e il raddoppio dei punti applicando la sua chiave privata $a$ dalla chiave pubblica di Bob $B$.
$$ S = a \cdot B $$
- Alice calcola il fattore di oscuramento $f$ che le permetterà di criptare il suo codice di pagamento. Per fare ciò, determinerà un numero pseudo-casuale con la funzione HMAC-SHA512. Nel secondo input di questa funzione, utilizza un valore che solo Bob potrà recuperare: $x$ che è l'ascissa del punto segreto precedentemente calcolato. Il primo input è $o$ che è l'UTXO consumato in input di questa transazione (outpoint).
$$ f = \text{HMAC-SHA512}(o, x) $$
**2- Alice converte il suo codice di pagamento personale in base 2 (binario).**
**3- Utilizza questo fattore di oscuramento come chiave per eseguire la crittografia simmetrica sul payload del suo codice di pagamento.** L'algoritmo di crittografia utilizzato è semplicemente un `XOR`. L'operazione eseguita è paragonabile alla cifratura di Vernam, anche denominata "One-Time Pad".
- Alice prima divide il suo fattore di oscuramento in due: i primi 32 byte sono denominati $f1$ e gli ultimi 32 byte sono denominati $f2$. Quindi, abbiamo:
$$ f = f1 || f2 $$
- Alice calcola l'$x'$ criptato dell'ascissa della chiave pubblica $x$ del suo codice di pagamento, e il $c'$ criptato del suo codice catena $c$ separatamente. $f1$ e $f2$ agiscono rispettivamente come chiavi di crittografia. L'operazione utilizzata è il `XOR` (o esclusivo).
$$ x' = x \oplus f1 $$
$$ c' = c \oplus f2 $$
- Alice sostituisce i valori reali dell'ascissa della chiave pubblica $x$ e del codice catena $c$ nel suo codice di pagamento con i valori criptati $x'$ e $c'$.
**4-** Alice ora ha il suo codice di pagamento con un payload criptato. Costruirà e trasmetterà una transazione che coinvolge la sua chiave pubblica $A$ come input, un output all'indirizzo di notifica di Bob, e un output `OP_RETURN` contenente il suo codice di pagamento con il payload criptato. **Questa transazione è la transazione di notifica**.
Un `OP_RETURN` è un opcode che segna un output di una transazione Bitcoin come non valido. Oggi, è utilizzato per trasmettere o ancorare informazioni sulla blockchain di Bitcoin. Fino a 80 byte di dati possono essere memorizzati, che sono scritti sulla catena e quindi visibili a tutti gli altri utenti.
Come abbiamo visto nelle sezioni precedenti, ECDH è utilizzato per generare un segreto condiviso tra due utenti che comunicano su una rete non sicura, potenzialmente osservata da attaccanti. In BIP47, ECDH è utilizzato per la comunicazione sulla rete Bitcoin, che per sua natura è una rete di comunicazione trasparente osservata da molti attaccanti. Il segreto condiviso calcolato tramite lo scambio di chiavi ECDH è poi utilizzato per criptare le informazioni segrete da trasmettere: il codice di pagamento del mittente (di Alice).
Ricapitoliamo i passaggi che abbiamo appena esaminato insieme per eseguire una transazione di notifica:
- Alice recupera il codice di pagamento e l'indirizzo di notifica di Bob;
- Alice seleziona un UTXO che possiede nel suo portafoglio HD con la corrispondente coppia di chiavi;
- Calcola un punto segreto sulla curva ellittica utilizzando ECDH;
- Utilizza questo punto segreto per calcolare un HMAC, che è il fattore di oscuramento;
- Utilizza questo fattore di oscuramento per criptare il payload del suo codice di pagamento personale.
- Lei utilizza un output di transazione `OP_RETURN` per comunicare il codice di pagamento mascherato a Bob.
![BTC204](assets/it/66/17.webp)
### Transazione di Notifica: Studio Concreto
Per comprendere meglio il suo funzionamento, in particolare l'uso di `OP_RETURN`, esaminiamo insieme una vera transazione di notifica. Ho eseguito tale transazione sulla testnet, che potete trovare [cliccando qui](https://mempool.space/fr/testnet/tx/0e2e4695a3c49272ef631426a9fd2dae6ec3a469e3a39a3db51aa476cd09de2e).
![BTC204](assets/fr/227.webp)
Osservando questa transazione, possiamo vedere che ha un singolo input e 4 output:
- Il primo output è l'`OP_RETURN` che contiene il mio codice di pagamento mascherato;
- Il secondo output di 546 sats punta all'indirizzo di notifica del mio destinatario;
- Il terzo output di 15.000 sats rappresenta le commissioni di servizio, poiché ho utilizzato Samourai Wallet per costruire questa transazione;
- Il quarto output di 2 milioni di sats rappresenta il resto, ovvero la differenza rimanente dal mio input che ritorna a un altro indirizzo che mi appartiene.
Il più interessante da studiare è ovviamente l'output 0 che utilizza l'`OP_RETURN`. Vediamo più da vicino cosa contiene. Ecco lo `scriptPubKey` in esadecimale:
6a4c50010002b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d800000000000000000000000000
```

```text
In questo script, possiamo sezionare diverse parti. Prima di tutto, gli opcode:
6a4c
```

```text
Tra gli opcode, possiamo riconoscere `0x6a` che designa l'`OP_RETURN` e `0x4c` che designa l'`OP_PUSHDATA1`.
Il byte seguente questo ultimo opcode indica la dimensione del payload che segue. Indica `0x50`, ovvero 80 byte:
6a4c50
```

```text
Poi, abbiamo i metadati del mio codice di pagamento in chiaro:
010002
```

```text
La coordinata x criptata della chiave pubblica del mio codice di pagamento:
b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164
```

```text
Il codice catena criptato del mio codice di pagamento:
927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d8
```

```text
E infine, il padding per raggiungere 80 byte, la dimensione standard di un `OP_RETURN`:
00000000000000000000000000
```

```
Per capire meglio, ecco il mio codice di pagamento in chiaro in base 58:
````text
PM8TJQCyt6ovbozreUCBrfKqmSVmTzJ5vjqse58LnBzKFFZTwny3KfCDdwTqAEYVasn11tTMPc2FJsFygFd3YzsHvwNXLEQNADgxeGnMK8Ugmin62TZU
Quando si confronta il mio codice di pagamento in chiaro con l'`OP_RETURN`, è evidente che l'HRP (`0x47`) e il checksum (`0x8604e4db`) non vengono trasmessi. Questo è previsto, poiché queste informazioni sono destinate agli esseri umani.
Successivamente, possiamo identificare la versione (`0x01`), il campo di bit (`0x00`) e la parità della chiave pubblica (`0x02`). E, alla fine del codice di pagamento, i byte vuoti (`0x00000000000000000000000000`) sono utilizzati per riempire il codice fino a un totale di 80 byte. Tutti questi metadati vengono trasmessi in chiaro (non criptati).
Infine, si può osservare che la coordinata x della chiave pubblica (`0x77507c9c17a89cfca2d3af554745d6c2db0e7f6b2721a3941a504933103cc42a`) e il codice catena (`0xdd94881210d6e752a9abc8a9fa0070e85184993c4f643f1121dd807dd556d1dc`) sono stati criptati. Questo costituisce il payload del codice di pagamento.
### Cos'è XOR?
Nelle sezioni precedenti, abbiamo visto che il codice di pagamento è stato trasmesso criptato utilizzando l'operazione XOR. Prendiamoci un momento per capire come funziona questo operatore, poiché è ampiamente utilizzato nella crittografia.
XOR è un operatore logico bit a bit basato sull'algebra booleana. Con due operandi bit, restituisce `1` se i bit dello stesso rango sono diversi, e restituisce `0` se i bit dello stesso rango sono uguali. Ecco la tabella di verità di XOR basata sui valori degli operandi `D` e `E`:
| D   | E   | D XOR E |
| --- | --- | ------- |
| 0   | 0   | 0       |
| 0   | 1   | 1       |
| 1   | 0   | 1       |
| 1   | 1   | 0       |
Per esempio:
$$

$$
0110 \oplus 1110 = 1000
Oppure:
$$

$$
010011 \oplus 110110 = 100101
Con ECDH, l'uso di XOR come strato di crittografia è particolarmente adatto. Innanzitutto, a causa di questo operatore, la crittografia è simmetrica. Questo consente al destinatario di decifrare il codice di pagamento con la stessa chiave utilizzata per la crittografia. La chiave di crittografia e decrittografia viene calcolata dal segreto condiviso grazie a ECDH. Questa simmetria è resa possibile dalle proprietà commutativa e associativa dell'operatore XOR:
- Altre proprietà:
$$

$$
D \oplus D = 0
D ⊕ 0 = D
- Commutatività:
$$

$$
D \oplus E = E \oplus D
- Associatività:
$$

$$
D \oplus (E \oplus Z) = (D \oplus E) \oplus Z = D \oplus E \oplus Z
Se:
$$

$$
D \oplus E = L
Allora:
$$

$$
D \oplus L = D \oplus (D \oplus E) = D \oplus D \oplus E = 0 \oplus E = E \\
\therefore D \oplus L = E
Successivamente, questo metodo di cifratura assomiglia molto al cifrario di Vernam (One-Time Pad), l'unico algoritmo di cifratura conosciuto fino ad oggi che possiede sicurezza incondizionata (o assoluta). Affinché il cifrario di Vernam abbia questa caratteristica, la chiave di cifratura deve essere perfettamente casuale, deve essere della stessa dimensione del messaggio e deve essere utilizzata una sola volta. Nel metodo di cifratura utilizzato qui per BIP47, la chiave è effettivamente della stessa dimensione del messaggio, il fattore di offuscamento è esattamente della stessa dimensione della concatenazione della coordinata x della chiave pubblica con il codice catena del codice di pagamento. Questa chiave di cifratura è effettivamente utilizzata una sola volta. Tuttavia, questa chiave non è il risultato di una casualità perfetta poiché è un HMAC. È piuttosto pseudo-casuale. Pertanto, non si tratta di un cifrario di Vernam, ma il metodo è simile.
### Ricezione della Transazione di Notifica
Ora che Alice ha inviato la transazione di notifica a Bob, vediamo come lui la interpreta. Come promemoria, Bob deve essere in grado di accedere al codice di pagamento di Alice. Senza queste informazioni, come vedremo nella sezione seguente, non sarà in grado di derivare le coppie di chiavi create da Alice e, quindi, non sarà in grado di accedere ai suoi bitcoin ricevuti tramite BIP47. Per ora, il payload del codice di pagamento di Alice è criptato. Vediamo come Bob lo decifra.
**1-** Bob monitora le transazioni che creano output con il suo indirizzo di notifica.
**2-** Quando una transazione ha un output sul suo indirizzo di notifica, Bob la analizza per vedere se contiene un output OP_RETURN che segue lo standard BIP47.
**3-** Se il primo byte del payload OP_RETURN è `0x01`, Bob inizia la sua ricerca di un possibile segreto condiviso con ECDH:
- Bob seleziona la chiave pubblica nell'input della transazione. Ovvero, la chiave pubblica di Alice denominata $A$ con:
$$ A = a \cdot G $$
- Bob seleziona la chiave privata $b$ associata al suo indirizzo di notifica personale:
$$ b $$
- Bob calcola il punto segreto $S$ (segreto condiviso ECDH) sulla curva ellittica sommando e raddoppiando i punti, applicando la sua chiave privata $b$ alla chiave pubblica di Alice $A$:
$$ S = b \cdot A $$
- Bob determina il fattore di offuscamento $f$ che gli permetterà di decifrare il payload del codice di pagamento di Alice. Nello stesso modo in cui Alice aveva precedentemente calcolato, Bob troverà $f$ applicando HMAC-SHA512 su $x$ la coordinata x del punto segreto $S$, e su $o$ l'UTXO consumato come input in questa transazione di notifica:
$$ f = \text{HMAC-SHA512}(o, x) $$
**4-** Bob interpreta i dati nell'OP_RETURN della transazione di notifica come un codice di pagamento. Egli semplicemente decifra il payload di questo potenziale codice di pagamento usando il fattore di offuscamento $f$:
- Bob divide il fattore di offuscamento $f$ in 2 parti: i primi 32 byte di $f$ saranno $f1$ e gli ultimi 32 byte saranno $f2$;
- Bob decifra la coordinata x cifrata $x'$ della chiave pubblica dal codice di pagamento di Alice:
$$ x = x' \oplus f1 $$
- Bob decifra il valore del codice catena cifrato $c'$ dal codice di pagamento di Alice:
$$ c = c' \oplus f2 $$
**5-** Bob verifica se il valore della chiave pubblica dal codice di pagamento di Alice è effettivamente parte del gruppo secp256k1. Se è così, lo interpreta come un codice di pagamento valido. Altrimenti, ignora questa transazione.
Ora che Bob è a conoscenza del codice di pagamento di Alice, lei può inviargli fino a `2^32` pagamenti, senza mai dover effettuare un'altra transazione di notifica di questo tipo.
Perché funziona? Come fa Bob a determinare lo stesso fattore di offuscamento di Alice, e quindi a decifrare il suo codice di pagamento? Esaminiamo più da vicino il ruolo di ECDH in quello che abbiamo appena descritto.
Prima di tutto, stiamo trattando con la crittografia simmetrica. Questo significa che la chiave di cifratura e la chiave di decifratura sono lo stesso valore. Questa chiave nella transazione di notifica è il fattore di offuscamento:
$$ f = f1 || f2 $$
Pertanto, Alice e Bob devono ottenere lo stesso valore per $f$, senza trasmetterlo direttamente poiché un attaccante potrebbe rubarlo e decifrare le informazioni segrete. Questo fattore di offuscamento si ottiene applicando HMAC-SHA512 su 2 valori:
- la coordinata x di un punto segreto;
- e l'UTXO consumato come input nella transazione.
Bob, quindi, ha bisogno di queste due informazioni per decifrare il payload del codice di pagamento di Alice. Per l'UTXO come input, Bob può semplicemente recuperarlo osservando la transazione di notifica. Per il punto segreto, Bob dovrà usare ECDH. Come visto nella sezione precedente su Diffie-Hellman, semplicemente scambiando le rispettive chiavi pubbliche e applicando segretamente le proprie chiavi private alla chiave pubblica dell'altro, Alice e Bob possono trovare un punto specifico e segreto sulla curva ellittica. La transazione di notifica si basa su questo meccanismo:
- Coppia di chiavi di Bob:
$$ B = b \cdot G $$
- Coppia di chiavi di Alice:
$$ A = a \cdot G $$
- Per un segreto $S (x, y)$:
$$ S = a \cdot B = a \cdot (b \cdot G) = (b \cdot a) \cdot G = b \cdot A $$
Ora che Bob conosce il codice di pagamento di Alice, sarà in grado di rilevare i suoi pagamenti BIP47, e può derivare le chiavi private che bloccano i bitcoin ricevuti.
Ricapitoliamo i passaggi che abbiamo appena esaminato per ricevere e interpretare una transazione di notifica:
- Bob monitora gli output delle transazioni al suo indirizzo di notifica;
- Quando ne rileva uno, recupera le informazioni contenute nell'OP_RETURN;
- Bob seleziona la chiave pubblica in input e calcola un punto segreto usando ECDH;
- Usa questo punto segreto per calcolare un HMAC che è il fattore di offuscamento;
- Usa questo fattore di offuscamento per decifrare il payload del codice di pagamento di Alice contenuto nell'OP_RETURN.
### La Transazione di Pagamento BIP47
Studiamo ora insieme il processo di pagamento con BIP47. Per ricordarvi lo stato attuale delle cose:
- Alice conosce il codice di pagamento di Bob, che ha semplicemente recuperato dal suo sito web;
- Bob conosce il codice di pagamento di Alice grazie alla transazione di notifica;
- Alice effettuerà un primo pagamento a Bob. Potrà effettuarne molti altri allo stesso modo.
Prima di spiegare questo processo, penso sia importante ricordare gli indici su cui stiamo attualmente lavorando. Il percorso di derivazione di un codice di pagamento è descritto come segue: `m/47'/0'/0'`. La profondità successiva distribuisce gli indici in questo modo:
- La prima coppia di chiavi figlio normali (non rinforzate) è quella utilizzata per generare l'indirizzo di notifica di cui abbiamo parlato nella parte precedente: `m/47'/0'/0'/0`;
- Le coppie di chiavi figlio normali sono utilizzate all'interno di ECDH per generare indirizzi di ricezione dei pagamenti BIP47 come vedremo in questa sezione: da `m/47'/0'/0'/0` a `m/47'/0'/0'/2 147 483 647`;
- Le coppie di chiavi figlio rinforzate sono codici di pagamento effimeri: da `m/47'/0'/0'/0'` a `m/47'/0'/0'/2 147 483 647'`.
Ogni volta che Alice desidera inviare un pagamento a Bob, deriva un nuovo indirizzo vergine unico, grazie ancora al protocollo ECDH:
- Alice seleziona la prima chiave privata derivata dal suo codice di pagamento personale riutilizzabile:
$$ a $$
- Alice seleziona la prima chiave pubblica inutilizzata derivata dal codice di pagamento di Bob. Questa chiave pubblica, la chiameremo $B$. È associata alla chiave privata $b$ che solo Bob conosce:
$$ B = b \cdot G $$
- Alice calcola un punto segreto $S$ sulla curva ellittica tramite addizione e raddoppio di punti applicando la sua chiave privata $a$ alla chiave pubblica $B$ di Bob:
$$ S = a \cdot B $$
- Da questo punto segreto, Alice calcolerà il segreto condiviso $s$ (minuscolo). Per fare ciò, seleziona la coordinata x del punto segreto $S$ denominata $Sx$, e passa questo valore attraverso la funzione hash SHA256:
$$ S = (Sx, Sy) $$
$$ s = \text{SHA256}(Sx) $$
- Alice utilizza questo segreto condiviso $s$ per calcolare un indirizzo Bitcoin di ricezione dei pagamenti. Inizialmente, verifica che $s$ sia contenuto nell'ordine della curva secp256k1. In caso contrario, incrementa l'indice della chiave pubblica di Bob per derivare un altro segreto condiviso;
- In secondo luogo, calcola una chiave pubblica $K0$ aggiungendo sulla curva ellittica i punti $B$ e $s·G$. In altre parole, Alice aggiunge la chiave pubblica derivata dal codice di pagamento di Bob $B$ con un altro punto calcolato sulla curva ellittica tramite addizione e raddoppio con il segreto condiviso $s$ dal punto generatore della curva secp256k1 $G$. Questo nuovo punto rappresenta una chiave pubblica, e lo chiamiamo $K0$:
$$ K0 = B + s \cdot G $$
- Con questa chiave pubblica $K0$, Alice può derivare un indirizzo vergine standard di ricezione (per esempio, SegWit V0 in bech32).
Una volta che Alice ha ottenuto l'indirizzo di ricezione di Bob $K0$, può eseguire una transazione Bitcoin in modo standard. Per fare ciò, seleziona un UTXO di sua proprietà, assicurato da una coppia di chiavi di un ramo diverso del suo portafoglio HD, e lo spende per soddisfare un output all'indirizzo di Bob $K0$. È importante notare che questo pagamento, una volta derivato l'indirizzo, segue un processo convenzionale e non dipende più dalle chiavi associate a BIP47.
Ricapitoliamo i passaggi che abbiamo appena eseguito insieme per inviare un pagamento BIP47:
- Alice seleziona la prima chiave privata derivata dal suo codice di pagamento personale;
- Calcola un punto segreto sulla curva ellittica utilizzando ECDH dalla prima chiave pubblica derivata non utilizzata dal codice di pagamento di Bob;
- Utilizza questo punto segreto per calcolare un segreto condiviso con SHA256;
- Utilizza questo segreto condiviso per calcolare un nuovo punto segreto sulla curva ellittica;
- Aggiunge questo nuovo punto segreto alla chiave pubblica di Bob;
- Ottiene una nuova chiave pubblica effimera per la quale solo Bob ha la chiave privata associata;
- Alice può effettuare una transazione standard a Bob con l'indirizzo di ricezione effimero derivato.
![BTC204](assets/it/66/21.webp)
Se Alice desidera effettuare un secondo pagamento, seguirà gli stessi passaggi di prima, eccetto che questa volta selezionerà la seconda chiave pubblica derivata dal codice di pagamento di Bob. Specificamente, utilizzerà la prossima chiave non utilizzata. Otterrà così un nuovo indirizzo di ricezione appartenente a Bob, designato $K1$:
![BTC204](assets/it/66/22.webp)
Può continuare in questo modo e derivare fino a `2^32` indirizzi non utilizzati appartenenti a Bob.
Da un punto di vista esterno, osservando la blockchain, è teoricamente impossibile differenziare un pagamento BIP47 da un pagamento standard. Ecco un esempio di transazione di pagamento BIP47 sul Testnet:
```

94b2e59510f2e1fa78411634c98a77bbb638e28fb2da00c9f359cd5fc8f87254
````
Questo sembra una transazione standard con un input consumato, un output di pagamento e un resto:
![BTC204](assets/fr/232.webp)
### Ricevere il Pagamento BIP47 e Derivare la Chiave Privata
Alice ha appena effettuato il suo primo pagamento a un nuovo indirizzo BIP47 appartenente a Bob. Ora vediamo come Bob riceve questo pagamento. Vedremo anche perché Alice non ha accesso alla chiave privata dell'indirizzo che ha appena generato da sola, e come Bob recupera questa chiave per spendere i bitcoin che ha appena ricevuto.
Non appena Bob riceve la transazione di notifica da Alice, deriva la chiave pubblica BIP47 $K0$ anche prima che lei abbia inviato qualsiasi pagamento. Poi monitora qualsiasi pagamento all'indirizzo associato. Infatti, deriva immediatamente diversi indirizzi che monitorerà ($K0$, $K1$, $K2$, $K3$...). Ecco come deriva questa chiave pubblica $K0$:
- Bob seleziona la prima chiave privata derivata dal suo codice di pagamento. Questa chiave privata è denominata $b$. È associata alla chiave pubblica $B$ con cui Alice aveva fatto i suoi calcoli nel passaggio precedente:
$$ b $$
- Bob seleziona la prima chiave pubblica di Alice derivata dal suo codice di pagamento. Questa chiave è denominata $A$. È associata alla chiave privata $a$ con cui Alice aveva fatto i suoi calcoli, e di cui solo Alice è a conoscenza. Bob può eseguire questo processo poiché è a conoscenza del codice di pagamento di Alice che le è stato trasmesso con la transazione di notifica:
$$ A = a \cdot G $$
- Bob calcola il punto segreto $S$, mediante addizione e raddoppio di punti sulla curva ellittica, applicando la sua chiave privata $b$ alla chiave pubblica di Alice $A$. Qui troviamo l'uso di ECDH che garantisce che questo punto $S$ sarà lo stesso sia per Bob che per Alice:
$$ S = b \cdot A $$
- Proprio come ha fatto Alice, Bob isola la coordinata x di questo punto $S$. Abbiamo chiamato questo valore $Sx$. Egli passa questo valore attraverso la funzione SHA256 per trovare il segreto condiviso $s$ (minuscolo):
$$ s = \text{SHA256}(Sx) $$
- Proprio come Alice, Bob calcola il punto $s·G$ sulla curva ellittica. Poi, aggiunge questo punto segreto alla sua chiave pubblica $B$. Ottiene così un nuovo punto sulla curva ellittica che interpreta come una chiave pubblica $K0$:
$$ K0 = B + s \cdot G $$
Una volta che Bob ha questa chiave pubblica $K0$, può derivare la chiave privata associata per essere in grado di spendere i suoi bitcoin. È l'unico che può generare questa chiave privata:
- Bob aggiunge la sua chiave privata figlio $b$ derivata dal suo codice di pagamento personale. È l'unico che può ottenere il valore di $b$. Poi, aggiunge $b$ con il segreto condiviso $s$ per ottenere $k0$, la chiave privata di $K0$:
$$ k0 = b + s $$
Grazie alla legge di gruppo della curva ellittica, Bob ottiene esattamente la chiave privata corrispondente alla chiave pubblica usata da Alice. Abbiamo quindi:
$$ K0 = k0 \cdot G $$
Riassumerò i passaggi che abbiamo appena esaminato insieme per ricevere un pagamento BIP47 e calcolare la chiave privata corrispondente:
- Bob seleziona la prima chiave privata figlio derivata dal suo codice di pagamento personale;
- Calcola un punto segreto sulla curva ellittica usando ECDH dalla prima chiave pubblica figlio derivata dal codice catena di Alice;
- Usa questo punto segreto per calcolare un segreto condiviso con SHA256;
- Usa questo segreto condiviso per calcolare un nuovo punto segreto sulla curva ellittica;
- Aggiunge questo nuovo punto segreto alla sua chiave pubblica personale;
- Ottiene una nuova chiave pubblica effimera, alla quale Alice invierà il suo primo pagamento;
- Bob calcola la chiave privata associata a questa chiave pubblica effimera aggiungendo la sua chiave privata figlio derivata dal suo codice di pagamento e il segreto condiviso.
![BTC204](assets/it/66/24.webp)
Poiché Alice non può ottenere $b$ (la chiave privata di Bob), lei non è in grado di determinare $k0$ (la chiave privata associata all'indirizzo di ricezione BIP47 di Bob). Schematicamente, possiamo rappresentare il calcolo del segreto condiviso $S$ così:
![BTC204](assets/it/66/19.webp)
Una volta trovato il segreto condiviso con ECDH, Alice e Bob calcolano la chiave pubblica di pagamento BIP47 $K0$, e Bob calcola anche la chiave privata associata $k0$:
![BTC204](assets/it/66/25.webp)
### Rimborsare il Pagamento BIP47
Poiché Bob è a conoscenza del codice di pagamento riutilizzabile di Alice, ha già tutte le informazioni necessarie per inviarle un rimborso. Non avrà bisogno di contattare nuovamente Alice per chiedere informazioni. Dovrà semplicemente notificarla con una transazione di notifica, specialmente affinché lei possa recuperare i suoi indirizzi BIP47 con il suo seed, e poi potrà anche inviarle fino a `2^32` pagamenti.
La funzionalità di rimborso è specifica per BIP47 ed è uno dei suoi vantaggi rispetto ad altri metodi che studieremo nei prossimi capitoli, come i Pagamenti Silenziosi.
Bob può quindi rimborsare Alice nello stesso modo in cui lei gli ha inviato i pagamenti. I ruoli si invertono:
![BTC204](assets/it/66/26.webp)
_Un grande ringraziamento a [Fanis Michalakis](https://x.com/FanisMichalakis) per la sua revisione e preziosi consigli esperti sull'articolo che ha ispirato la scrittura di questo capitolo!_
https://planb.network/tutorials/privacy/on-chain/paynym-bip47-a492a70b-50eb-4f95-a766-bae2c5535093
## Pagamenti Silenziosi
<chapterId>2871d594-414e-4598-a830-91c9eb84dfb8</chapterId>
Il BIP47 è stato criticato per la sua inefficienza sulla blockchain. Come spiegato nel capitolo precedente, richiede una transazione di notifica per ogni nuovo destinatario. Questo vincolo diventa trascurabile se si prevede di stabilire un canale di pagamento duraturo con questo destinatario. Infatti, una singola transazione di notifica apre la strada a un numero quasi infinito di pagamenti BIP47 successivi.
Tuttavia, in determinate situazioni, la transazione di notifica può rappresentare un ostacolo per l'utente. Prendiamo l'esempio di una donazione una tantum a un destinatario: con un indirizzo Bitcoin classico, una singola transazione è sufficiente per effettuare la donazione. Ma con il BIP47, sono necessarie due transazioni: una per la notifica e un'altra per il pagamento effettivo. Quando la domanda di spazio nel blocco è bassa e le commissioni di transazione sono minime, questo passaggio aggiuntivo generalmente non rappresenta un problema. Tuttavia, durante i periodi di congestione, le commissioni di transazione possono diventare esorbitanti per un singolo pagamento, potenzialmente raddoppiando il costo per l'utente rispetto a una transazione Bitcoin standard, il che può essere inaccettabile per l'utente.
Per situazioni in cui l'utente prevede di effettuare solo pochi pagamenti a un identificatore statico, sono state sviluppate altre soluzioni. Tra queste ci sono i Pagamenti Silenziosi, descritti nel [BIP352](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki). Questo protocollo consente l'uso di un identificatore statico per ricevere pagamenti senza generare riutilizzo dell'indirizzo e senza richiedere l'uso di transazioni di notifica. Esaminiamo come funziona questo protocollo.
---
_Per comprendere appieno questo capitolo, è essenziale essere familiari con il funzionamento di ECDH (Elliptic Curve Diffie-Hellman) e la derivazione delle chiavi crittografiche in un portafoglio HD. Questi concetti sono stati dettagliati nel capitolo precedente sul BIP47. Non li ripeterò qui. Se non sei ancora familiare con queste nozioni, ti consiglio di consultare il capitolo precedente prima di continuare con questo. Non riprenderò nemmeno i rischi associati al riutilizzo degli indirizzi di ricezione, né l'importanza di avere un identificatore unico per ricevere pagamenti._
---
### Perché non spostare la notifica?
Come discusso nel capitolo sul BIP47, la transazione di notifica svolge principalmente due funzioni:
- Notifica il destinatario;
- Trasmette il codice di pagamento del mittente.
Si potrebbe ingenuamente pensare che questo processo di notifica potrebbe essere effettuato off-chain. In teoria, ciò è completamente fattibile: sarebbe sufficiente per il destinatario indicare un mezzo di comunicazione per ricevere i codici di pagamento BIP47 dai mittenti. Tuttavia, questo approccio presenta due problemi principali:
- Primo, ciò sposterebbe il processo di trasmissione del codice su un altro protocollo di comunicazione. Le questioni relative ai costi e alla privacy dello scambio rimarrebbero, ma sarebbero semplicemente trasferite a questo nuovo protocollo. In termini di privacy, ciò potrebbe anche creare un collegamento tra l'identità di un utente e l'attività sulla blockchain, cosa che cerchiamo di evitare eseguendo la notifica direttamente sulla blockchain. Inoltre, effettuare la notifica fuori dalla blockchain introdurrebbe rischi di censura (come il blocco dei fondi) che non esistono su Bitcoin;
Successivamente, ciò porrebbe un problema di recupero. Con BIP47, il destinatario deve assolutamente conoscere i codici di pagamento dei mittenti per accedere ai fondi. Questo è vero al momento della ricezione, ma anche in caso di recupero dei fondi tramite il seed in caso di perdita del portafoglio. Con le notifiche onchain, questo rischio viene evitato, poiché l'utente può trovare e decifrare le transazioni di notifica semplicemente conoscendo il proprio seed. Tuttavia, se la notifica viene eseguita fuori dalla blockchain, l'utente dovrebbe mantenere un backup dinamico di tutti i codici di pagamento ricevuti, il che è impraticabile per l'utente medio.
Tutti questi vincoli rendono l'uso della notifica onchain indispensabile nel contesto di BIP47. Eppure, i Pagamenti Silenziosi cercano specificamente di evitare questo passaggio di notifica onchain a causa del suo costo. Pertanto, la soluzione adottata non è spostare la notifica, ma eliminarla completamente. Per raggiungere questo obiettivo, deve essere accettato un compromesso: quello della scansione. A differenza di BIP47, dove l'utente sa esattamente dove trovare i propri fondi grazie alle transazioni di notifica, nel contesto dei Pagamenti Silenziosi, l'utente deve esaminare tutte le transazioni Bitcoin esistenti per rilevare eventuali pagamenti che potrebbero essere destinati a loro. Per ridurre questo onere operativo, la ricerca di Pagamenti Silenziosi è limitata solo alle transazioni che probabilmente contengono tali pagamenti, ovvero quelle che includono almeno un output Taproot P2TR. La scansione si concentra esclusivamente anche sulle transazioni dalla data di creazione del portafoglio (non c'è bisogno di scandire transazioni risalenti al 2009 se il portafoglio è stato creato nel 2024).
Pertanto, potete vedere perché BIP47 e Pagamenti Silenziosi, sebbene mirino a un obiettivo simile, comportano compromessi diversi e **quindi si rivolgono effettivamente a casi d'uso distinti**. Per i pagamenti una tantum, come le donazioni occasionali, i Pagamenti Silenziosi sono più appropriati a causa del loro costo inferiore. Al contrario, per le transazioni regolari allo stesso destinatario, come nel caso delle piattaforme di scambio o dei pool di mining, BIP47 potrebbe essere preferito.
Esploriamo insieme il funzionamento tecnico dei Pagamenti Silenziosi per capirne meglio le implicazioni. Per fare ciò, suggerisco di adottare lo stesso approccio del documento esplicativo di BIP352. Scomporremo gradualmente i calcoli da eseguire, elemento per elemento, giustificando ogni nuova aggiunta.
### Alcuni concetti da comprendere
Prima di iniziare, è importante chiarire che i Pagamenti Silenziosi si basano esclusivamente sull'uso di tipi di script P2TR (_Pay to Taproot_). A differenza di BIP47, non è necessario derivare gli indirizzi di ricezione dalle chiavi pubbliche figlie tramite hashing. Infatti, nello standard P2TR, la chiave pubblica modificata viene utilizzata direttamente e apertamente nell'indirizzo. Così, un indirizzo di ricezione Taproot è essenzialmente una chiave pubblica accompagnata da alcuni metadati. Questa chiave pubblica modificata è l'aggregazione di altre due chiavi pubbliche: una che consente la spesa diretta e tradizionale tramite una semplice firma, e l'altra che rappresenta la radice di Merkle del MAST, che autorizza la spesa soggetta alla soddisfazione di una delle condizioni potenzialmente iscritte nell'albero di Merkle.
![BTC204](assets/it/67/01.webp)
La decisione di limitare i Pagamenti Silenziosi esclusivamente a Taproot è motivata da due ragioni principali:
- Primo, facilita significativamente l'implementazione e gli aggiornamenti futuri nel software del portafoglio, poiché è necessario aderire a un solo standard;
- In secondo luogo, questo approccio aiuta a migliorare l'insieme di anonimato degli utenti incoraggiandoli a non disperdersi tra diversi tipi di script, che generano impronte di portafoglio distinte nell'analisi della catena (per maggiori informazioni su questo concetto, vi invito a consultare il capitolo 4 della parte 2).
### Derivazione naive di una chiave pubblica di Pagamenti Silenziosi
Iniziamo con un semplice esempio che ti aiuterà a comprendere il funzionamento di base dei Pagamenti Silenziosi (SP, Silent Payments). Prendiamo Alice e Bob, due utenti Bitcoin. Alice vuole inviare bitcoin a Bob su un nuovo indirizzo di ricezione. Tre obiettivi devono essere raggiunti in questo processo:
- Alice deve essere in grado di generare un nuovo indirizzo;
- Bob deve essere in grado di identificare un pagamento inviato a questo specifico indirizzo;
- Bob deve essere in grado di ottenere la chiave privata associata a questo indirizzo per poter spendere i suoi fondi.
Alice ha un UTXO nel suo portafoglio Bitcoin protetto con la seguente coppia di chiavi:
- $a$: la chiave privata;
- $A$: la chiave pubblica ($A = a \cdot G$)
Bob ha un indirizzo SP che ha pubblicato su internet con:
- $b$: la chiave privata;
- $B$: la chiave pubblica ($B = b \cdot G$)
Recuperando l'indirizzo di Bob, Alice è in grado di calcolare un nuovo indirizzo vuoto che appartiene a Bob usando ECDH. Chiamiamo questo indirizzo $P$:
$$ P = B + \text{hash}(a \cdot B) \cdot G $$
In questa equazione, Alice ha semplicemente calcolato il prodotto scalare della sua chiave privata $a$ e della chiave pubblica di Bob $B$. Ha passato questo risultato attraverso una funzione hash conosciuta da tutti. Il valore di output è poi moltiplicato scalarmente per il punto generatore $G$ della curva ellittica `secp256k1`. Infine, Alice aggiunge il punto ottenuto alla chiave pubblica di Bob $B$. Una volta che Alice ha questo indirizzo $P$, lo usa come output in una transazione, il che significa che invia bitcoin ad esso.
> _Nel contesto dei Pagamenti Silenziosi, la funzione "hash" corrisponde a una funzione hash SHA256 etichettata specificamente con `BIP0352/SharedSecret`, assicurando che gli hash generati siano unici per questo protocollo e non possano essere riutilizzati in altri contesti, fornendo anche una protezione aggiuntiva contro il riutilizzo di nonce nelle firme. Questo standard corrisponde a quello [specificato nel BIP340 per le firme Schnorr](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) su `secp256k1`._
Grazie alle proprietà della curva ellittica su cui si basa ECDH, sappiamo che:
$$ a \cdot B = b \cdot A $$
Bob sarà quindi in grado di calcolare l'indirizzo di ricezione su cui Alice ha inviato i bitcoin. Per fare ciò, monitora tutte le transazioni Bitcoin che soddisfano i criteri dei Pagamenti Silenziosi e applica il seguente calcolo a ciascuna di esse per vedere se il pagamento è indirizzato a lui (_scanning_):
$$ P' = B + \text{hash}(b \cdot A) \cdot G $$
Quando esamina la transazione di Alice, si rende conto che $P'$ è uguale a $P$. Sa quindi che questo pagamento è indirizzato a lui:
$$ P' = B + \text{hash}(b \cdot A) \cdot G = B + \text{hash}(a \cdot B) \cdot G = P $$
Da qui, Bob sarà in grado di calcolare la chiave privata $p$ che consente di spendere l'indirizzo $P$:
$$ p = (b + \text{hash}(b \cdot A)) \bmod n $$
Come puoi vedere, per calcolare questa chiave privata $p$, è necessario avere la chiave privata $b$. Solo Bob ha questa chiave privata $b$. Sarà quindi effettivamente l'unico in grado di spendere i bitcoin inviati al suo indirizzo di Pagamenti Silenziosi.
![BTC204](assets/fr/236.webp)
_Didascalia:_
- $B$: La chiave pubblica / indirizzo statico pubblicato da Bob
- $b$: La chiave privata di Bob
- $A$: La chiave pubblica dell'UTXO di Alice usata come input per la transazione
- $a$: La chiave privata di Alice
- $G$: Il punto generatore della curva ellittica `secp256k1`
- $\text{SHA256}$: La funzione di hashing SHA256 etichettata con `BIP0352/SharedSecret`
- $s$: Il segreto comune ECDH
- $P$: La chiave pubblica / indirizzo unico per il pagamento a Bob
Ecco un approccio inizialmente piuttosto ingenuo nell'uso dell'indirizzo statico di Bob, denotato $B$, per derivare un indirizzo unico $P$ per inviare bitcoin. Tuttavia, questo metodo è troppo semplicistico e presenta diversi difetti che necessitano di correzione. Il primo problema è che, in questo schema, Alice non può creare molteplici output per Bob all'interno della stessa transazione.
### Come creare molteplici output?
Nell'esempio della sezione precedente, Alice crea un singolo output che andrà a Bob al suo indirizzo unico $P$. Con lo stesso input selezionato, è impossibile per Alice creare due indirizzi vergini distinti per Bob, poiché il metodo utilizzato porterebbe sempre allo stesso risultato per $P$, quindi allo stesso indirizzo. Tuttavia, ci possono essere molte situazioni in cui Alice desidera dividere il suo pagamento a Bob in diverse piccole somme, creando così molteplici UTXO. È quindi necessario trovare un metodo che permetta di farlo.
Per raggiungere questo obiettivo, modificheremo leggermente il calcolo che Alice esegue per derivare $P$, in modo che possa generare due indirizzi distinti per Bob, ovvero $P_0$ e $P_1$.
Per modificare il calcolo e ottenere 2 indirizzi diversi, è sufficiente aggiungere un intero che modifica il risultato. Così, Alice aggiungerà $0$ nel suo calcolo per ottenere l'indirizzo $P_0$ e $1$ per ottenere l'indirizzo $P_1$. Chiamiamo questo intero $i$:
$$ P_i = B + \text{hash}(a \cdot B \text{ ‖ } i) \cdot G $$
Il processo di calcolo rimane invariato rispetto al metodo precedente, eccetto che questa volta Alice concatenerà $a \cdot B$ con $i$ prima di procedere al hash. È quindi sufficiente cambiare $i$ per avere un nuovo indirizzo appartenente a Bob. Ad esempio:
$$ P_0 = B + \text{hash}(a \cdot B \text{ ‖ } 0) \cdot G $$
$$ P_1 = B + \text{hash}(a \cdot B \text{ ‖ } 1) \cdot G $$
Quando Bob esamina la blockchain per i Pagamenti Silenziosi destinati a lui, inizia utilizzando $i = 0$ per l'indirizzo $P_0$. Se non trova nessun pagamento su $P_0$, conclude che questa transazione non contiene nessun Pagamento Silenzioso per lui e smette di analizzarla. Tuttavia, se $P_0$ è valido e contiene un pagamento per lui, procede con $P_1$ nella stessa transazione per verificare se Alice ha effettuato un secondo pagamento. Se $P_1$ risulta essere invalido, interrompe la sua ricerca per questa transazione; altrimenti, continua a testare valori successivi di $i$.
$$ P_1 = B + \text{hash}(b \cdot A \text{ ‖ } 1) \cdot G $$
Poiché Bob si ferma immediatamente a $i = 0$ se $P_0$ non produce risultati, l'uso di questo intero aggiunge quasi nessun onere operativo aggiuntivo a Bob per la fase di scansione delle transazioni.
Bob può quindi calcolare le chiavi private nello stesso modo:
$$

p_0 = (b + \text{hash}(b \cdot A \text{ ‖ } 0)) \bmod n

$$
p_1 = (b + \text{hash}(b \cdot A \text{ ‖ } 1)) \bmod n
$$

didascalia:_


- $B$: La chiave pubblica / indirizzo statico pubblicato da Bob
- $b$: Ruang pribadi di Bob
- $A$: Jumlah publik UTXO dari Alice yang digunakan sebagai input untuk transaksi
- $a$: Ruang pribadi di Alice
- $G$: Penghasil kurva elips `secp256k1`
- $\text{SHA256}$: Fungsi hash SHA256 dienkripsi dengan `BIP0352/SharedSecret`
- $s_0$: Bagian pertama dari ECDH
- $s_1$: Rumah terpisah kedua ECDH
- $P_0$: Publikasi utama / pengumuman tunggal untuk pagamento ke Bob
- $P_1$: Publik yang kedua / pengumuman tunggal untuk pagamento untuk Bob

Dengan metode ini, kami berharap dapat menerapkan protokol yang sama, tetapi tidak ada cara lain yang lebih baik, khususnya pencegahan terhadap risiko infeksi.

### Bagaimana cara menghilangkan kebiasaan merokok?

Seperti yang telah kita lihat di contoh sebelumnya, Alice menggunakan kopor yang melindungi UTXO miliknya, yang digunakan untuk menghitung jumlah yang dibagi ECDH dengan Bob. Segreto ini memungkinkan Anda untuk menurunkan nilai awal tunggal $P_0$. Namun, coppia chiavi ($a$, $A$) yang digunakan oleh Alice dapat digunakan untuk mengetahui apakah UTXO telah menjalankan fungsi ini dengan berbagai macam nilai. Dalam kasus di mana Alice mendapatkan beberapa parameter untuk menentukan nilai statis $B$ dari Bob menggunakan protokol UTXO yang ditetapkan di atas koin $A$, ini akan menjadi pengulangan nilai statis untuk Bob.

> penggunaan informasi ini merupakan praktik yang sangat negatif bagi privasi pengguna. Untuk mengetahuinya, kami menyarankan Anda untuk membaca bagian utama dari formulir ini._
Jadi, jika harga tunggal $P_0$ berasal dari $A$ dan $B$, jika Alice mendapatkan harga kedua untuk setiap pagamento kedua dari $B$, dengan harga tetap $A$, maka harga $P_0$ akan tetap sama. Untuk menghindari risiko ini dan mencegah penggunaan rutin dari indirek internal Pagamenti Silenziosi, kami akan memodifikasi sebagian besar kalkulator kami.

Apa yang akan kita lihat adalah bahwa setiap UTXO yang dikonsumsi oleh Alice sebagai masukan dari sebuah pagamento tentang satu tujuan tunggal dari Bob, juga jika UTXO yang dilindungi oleh kopiah yang sama. Ini cukup untuk meningkatkan nilai tukar semua UTXO dalam perhitungan nilai tukar tunggal $ P_0 $. Proses ini secara sederhana menggunakan hash dari UTXO sebagai masukan:

$$ \text{inputHash} = \text{hash}(\text{outpoint} \text{ ‖ } A) $$

Dan dengan masukan ini, Alice akan memasukkannya ke dalam kalkulatornya sendiri $P_0$:

Selama pemindaian, Bob juga dapat melakukan $\text{inputHash}$, sehingga semua yang harus dilakukan adalah mengamati proses transaksinya untuk menentukan $\text{outpoint}$:

$$ P_0 = B + \text{hash}(\text{inputHash} \cdot b \cdot A \text{ ‖ } 0) \cdot G $$

Saat menemukan kode $P_0$, Anda dapat menghitung koresponden pribadi $p_0$:

$$
p_0 = (b + \text{hash}(\text{inputHash} \cdot b \cdot A \text{ ‖ } 0)) \bmod n
$$

```text
_Legenda:_
- $B$: La chiave pubblica / indirizzo statico pubblicato da Bob
- $b$: La chiave privata di Bob
- $A$: La chiave pubblica dell'UTXO di Alice usata come input per la transazione
- $a$: La chiave privata di Alice
- $H$: L'hash dell'UTXO usato come input
- $G$: Il punto generatore della curva ellittica `secp256k1`
- $\text{SHA256}$: La funzione di hash SHA256 etichettata con `BIP0352/SharedSecret`
- $s_0$: Il primo segreto condiviso ECDH
- $P_0$: La prima chiave pubblica / indirizzo unico per il pagamento a Bob
Al momento, i nostri calcoli presuppongono che Alice utilizzi un singolo input per la sua transazione. Tuttavia, dovrebbe essere in grado di utilizzare più input. Di conseguenza, da parte di Bob, per ogni transazione contenente più input, teoricamente avrebbe bisogno di calcolare l'ECDH per ogni input per determinare se un pagamento è destinato a lui. Questo metodo non è soddisfacente, quindi abbiamo bisogno di trovare una soluzione per ridurre il carico di lavoro!
### Modificare le chiavi pubbliche negli input
Per risolvere questo problema, invece di utilizzare la coppia di chiavi che protegge un input specifico da parte di Alice, useremo la somma di tutte le coppie di chiavi utilizzate negli input della transazione. Questa somma sarà quindi considerata come una nuova coppia di chiavi. Questa tecnica è nota come "tweak".
Per esempio, immagina che la transazione di Alice abbia 3 input, ognuno protetto con una coppia di chiavi diversa:
- $a_0$ protegge l'input #0;
- $a_1$ protegge l'input #1;
- $a_2$ protegge l'input #2.
Seguendo il metodo descritto sopra, Alice dovrebbe scegliere una singola coppia di chiavi tra $a_0$, $a_1$ e $a_2$ per calcolare il segreto ECDH e generare l'indirizzo di pagamento unico $P$ dall'indirizzo statico $B$ di Bob. Tuttavia, questo approccio richiede a Bob di testare ogni possibilità sequenzialmente, partendo da $a_0$, poi $a_1$, e così via, fino all'identificazione di una coppia che genera un indirizzo valido $P$. Questo processo richiede che Bob esegua il calcolo ECDH su tutti gli input di tutte le transazioni, aumentando significativamente il carico di lavoro operativo di scansione.
Per evitare ciò, chiederemo ad Alice di eseguire il suo calcolo di $P$ utilizzando la somma di tutte le chiavi in input. Prendendo il nostro esempio, la chiave privata modificata $a$ sarebbe calcolata come segue:
$$ a = a_0 + a_1 + a_2 $$
Allo stesso modo, Alice e Bob saranno in grado di calcolare la chiave pubblica modificata:
$$ A = A_0 + A_1 + A_2 $$
Grazie a questo metodo, a Bob basta calcolare la somma delle chiavi pubbliche della transazione, poi calcolare il segreto ECDH da $A$ soltanto, il che riduce notevolmente il numero di calcoli da fare per la fase di scansione. Tuttavia, ricorda dalla sezione precedente. Avevamo incluso nel nostro calcolo l'hash $\text{inputHash}$ che viene usato come nonce per prevenire il riutilizzo degli indirizzi:
$$ \text{inputHash} = \text{hash}(\text{outpoint} \text{ ‖ } A) $$
Ma se ci sono più input in una transazione, è necessario determinare quale $\text{outpoint}$ viene scelto in questo calcolo. Secondo il BIP352, il criterio di selezione per $\text{outpoint}$ da usare è scegliere il più piccolo lessicograficamente, il che significa selezionare l'UTXO che appare per primo in ordine alfabetico. Questo metodo standardizza l'UTXO da scegliere in ogni transazione. Ad esempio, se questo $\text{outpoint}$ più piccolo lessicograficamente è $\text{outpoint}_L$, il calcolo di $\text{inputHash}$ sarà:
$$ \text{inputHash} = \text{hash}(\text{outpoint}\_L \text{ ‖ } A) $$
I calcoli rimangono quindi identici a quelli presentati nella sezione precedente, eccetto che la chiave privata $a$ e la sua corrispondente chiave pubblica $A$ non rappresentano più una coppia che protegge un singolo input, ma ora rappresentano la modifica di tutte le coppie di chiavi negli input.
### Separare le Chiavi di Spesa e di Scansione
Finora, abbiamo discusso dell'indirizzo statico di Pagamento Silenzioso $B$ come di una chiave pubblica unica. Ricorda, è questa chiave pubblica $B$ che viene usata da Alice per creare il segreto condiviso ECDH, che a sua volta viene usato per calcolare l'indirizzo di pagamento unico $P$. Bob usa questa chiave pubblica $B$ e la corrispondente chiave privata $b$ per la fase di scansione. Ma userà anche la chiave privata $b$ per calcolare la chiave privata $p$ che consente di spendere dall'indirizzo $P$.
Lo svantaggio di questo metodo è che la chiave privata $b$, che viene usata per calcolare tutte le chiavi private per gli indirizzi che ricevono Pagamenti Silenziosi, viene anche usata da Bob per scansionare le transazioni. Questo passaggio richiede che la chiave $b$ sia disponibile su un software di portafoglio connesso a Internet, il che la espone a un rischio maggiore di furto rispetto al mantenerla su un portafoglio freddo. Idealmente, sarebbe vantaggioso poter approfittare dei Pagamenti Silenziosi mantenendo la chiave privata $b$, che controlla l'accesso a tutte le altre chiavi private, al sicuro su un portafoglio hardware. Fortunatamente, il protocollo è stato adattato per permettere esattamente questo.
Per raggiungere questo obiettivo, il BIP352 specifica che il ricevente usa 2 diverse coppie di chiavi:
- $B_{\text{spend}}$: per calcolare le chiavi private degli indirizzi di pagamento unici;
- $B_{\text{scan}}$: per trovare indirizzi di pagamento unici.
In questo modo, Bob può mantenere la chiave privata $b_{\text{spend}}$ su un portafoglio hardware e usare la chiave privata $b_{\text{scan}}$ su software online per trovare i suoi Pagamenti Silenziosi, senza rivelare $b_{\text{spend}}$. Tuttavia, le chiavi pubbliche $B_{\text{scan}}$ e $B_{\text{spend}}$ sono entrambe pubblicamente rivelate, poiché si trovano nell'indirizzo statico di Bob $B$:
Per calcolare un indirizzo di pagamento unico $P_0$ appartenente a Bob, Alice eseguirà il seguente calcolo:
$$ P*0 = B*{\text{spend}} + \text{hash}(\text{inputHash} \cdot a \cdot B\_{\text{scan}} \text{ ‖ } 0) \cdot G $$
Per trovare i pagamenti indirizzati a lui, Bob eseguirà il seguente calcolo:
$$ P*0 = B*{\text{spend}} + \text{hash}(\text{inputHash} \cdot b\_{\text{scan}} \cdot A \text{ ‖ } 0) \cdot G $$
Come puoi vedere, fino a questo momento, Bob non ha avuto bisogno di usare $b_{\text{spend}}$ che si trova sul suo portafoglio hardware. Quando desidera spendere $P_0$, può quindi eseguire il seguente calcolo per trovare la chiave privata $p_0$:
$$ p*0 = (b*{\text{spend}} + \text{hash}(\text{inputHash} \cdot b\_{\text{scan}} \cdot A \text{ ‖ } 0)) \bmod n $$
_Didascalia:_
- $B_{\text{scan}}$: Chiave pubblica di scansione di Bob (indirizzo statico)
- $b_{\text{scan}}$: Chiave privata di scansione di Bob
- $B_{\text{spend}}$: Chiave pubblica di spesa di Bob (indirizzo statico)
- $b_{\text{spend}}$: Chiave privata di spesa di Bob
- $A$: La somma delle chiavi pubbliche in input (tweak)
- $a$: La chiave privata corrispondente alla chiave pubblica modificata
- $H$: L'hash dell'UTXO più piccolo (lessicograficamente) usato in input
- $G$: Il punto generatore della curva ellittica `secp256k1`
- $\text{SHA256}$: La funzione di hashing SHA256 etichettata con `BIP0352/SharedSecret`
- $s_0$: Il primo segreto condiviso ECDH
- $P_0$: La prima chiave pubblica / indirizzo di pagamento unico per Bob
### Utilizzando indirizzi SP con un'etichetta
Bob ha quindi un indirizzo statico $B$ per i Pagamenti Silenziosi come segue:
$$ B = B*{\text{scan}} \text{ ‖ } B*{\text{spend}} $$
Il problema con questo metodo è che non permette di segregare i diversi pagamenti inviati a questo indirizzo. Ad esempio, se Bob ha 2 clienti diversi per la sua attività e vuole differenziare chiaramente i pagamenti da ciascuno, avrebbe bisogno di 2 indirizzi statici diversi. Una soluzione ingenua, con l'approccio attuale, sarebbe che Bob crei due portafogli separati, ognuno con il proprio indirizzo statico, o addirittura stabilisca due indirizzi statici diversi all'interno dello stesso portafoglio. Tuttavia, questa soluzione richiede la scansione dell'intera blockchain due volte (una per ciascun indirizzo) per rilevare rispettivamente i pagamenti destinati a ciascun indirizzo. Questa doppia scansione aumenta in modo irragionevole l'onere operativo per Bob.
Per risolvere questo problema, BIP352 utilizza un sistema di etichettatura che consente di avere diversi indirizzi statici senza aumentare in modo irragionevole il carico di lavoro per trovare Pagamenti Silenziosi sulla blockchain. Per fare ciò, viene aggiunto un intero $m$ alla chiave pubblica di spesa $B_{\text{spend}}$. Questo intero può assumere il valore di $1$ per il primo indirizzo statico, poi $2$ per il secondo, e così via. Le chiavi di spesa $B_{\text{spend}}$ saranno d'ora in poi chiamate $B_m$ e saranno costruite in questo modo:
$$ B*m = B*{\text{spend}} + \text{hash}(b\_{\text{scan}} \text{ ‖ } m) \cdot G $$
Per esempio, per la prima chiave di spesa con l'etichetta $1$:
$$ B*1 = B*{\text{spend}} + \text{hash}(b\_{\text{scan}} \text{ ‖ } 1) \cdot G $$
L'indirizzo statico pubblicato da Bob consisterà ora di $B_{\text{scan}}$ e $B_m$. Per esempio, il primo indirizzo statico con l'etichetta $1$ sarà:
$$ B = B\_{\text{scan}} \text{ ‖ } B_1 $$
> _Iniziamo solo dall'etichetta 1 perché l'etichetta 0 è riservata per il resto._
Alice, da parte sua, deriverà l'indirizzo di pagamento unico $P$ nello stesso modo di prima, ma utilizzando il nuovo $B_1$ invece di $B_{\text{spend}}$.
$$ P*0 = B_1 + \text{hash}(\text{inputHash} \cdot a \cdot B*{\text{scan}} \text{ ‖ } 0) \cdot G $$
In realtà, Alice potrebbe non sapere nemmeno che Bob ha un indirizzo etichettato, poiché lei semplicemente utilizza la seconda parte dell'indirizzo statico che lui le ha fornito, che in questo caso, è il valore $B_1$ piuttosto che $B_{\text{spend}}$.
Per scansionare i pagamenti, Bob utilizzerà sempre il valore del suo indirizzo statico iniziale con $B_{\text{spend}}$ in questo modo:
$$ P*0 = B*{\text{spend}} + \text{hash}(\text{inputHash} \cdot b\_{\text{scan}} \cdot A \text{ ‖ } 0) \cdot G $$
Poi, semplicemente sottrae il valore che trova per $P_0$ da ogni output uno per uno. Poi controlla se uno dei risultati di queste sottrazioni corrisponde al valore di una delle etichette che usa nel suo portafoglio. Se corrisponde, per esempio, per l'output #4 con l'etichetta $1$, ciò significa che questo output è un Pagamento Silenzioso associato al suo indirizzo statico etichettato $B_1$:
$$ Out*4 - P_0 = \text{hash}(b*{\text{scan}} \text{ ‖ } 1) \cdot G $$
Questo funziona perché:
$$ B*1 = B*{\text{spend}} + \text{hash}(b*{\text{scan}} \text{ ‖ } 1) \cdot G $$
Grazie a questo metodo, Bob può utilizzare una moltitudine di indirizzi statici ($B_1$, $B_2$, $B_3$...), tutti derivati dal suo indirizzo statico base ($B = B*{\text{scan}} \text{ ‖ } B*{\text{spend}}$), al fine di separare correttamente gli usi.
Tuttavia, questa separazione degli indirizzi statici è valida solo da una prospettiva di gestione personale del portafoglio e non consente la separazione delle identità. Poiché tutti hanno lo stesso $B*{\text{scan}}$, è molto facile associare tutti gli indirizzi statici insieme e dedurre che appartengono a una singola entità.
_Didascalia:_
- $B_{\text{scan}}$: chiave pubblica di scansione di Bob (indirizzo statico)
- $b_{\text{scan}}$: chiave privata di scansione di Bob
- $B_{\text{spend}}$: chiave pubblica di spesa di Bob (indirizzo iniziale)
- $B_m$: chiave pubblica di spesa etichettata di Bob (indirizzo statico)
- $b_m$: chiave privata di spesa etichettata di Bob
- $A$: La somma delle chiavi pubbliche in input (tweak)
- $a$: La chiave privata corrispondente alla chiave pubblica modificata
- $H$: L'hash del più piccolo UTXO (lessicograficamente) utilizzato come input
- $G$: Il punto generatore della curva ellittica `secp256k1`
- $\text{SHA256}$: La funzione di hashing SHA256 etichettata con `BIP0352/SharedSecret`
- $s_0$: Il primo segreto condiviso ECDH
- $P_0$: La prima chiave pubblica / indirizzo unico per il pagamento a Bob
- $p_0$: La chiave privata del primo indirizzo di pagamento unico a Bob
- $X$: L'hash della chiave privata di scansione con l'etichetta
### Come Costruire un Indirizzo per Pagamenti Silenziosi?
Per costruire un indirizzo dedicato ai Pagamenti Silenziosi, è necessario prima derivare 2 coppie di chiavi nel proprio portafoglio Bitcoin HD:
- La coppia $b_{\text{scan}}$, $B_{\text{scan}}$ per cercare i pagamenti indirizzati a noi;
- La coppia $b_{\text{spend}}$, $B_{\text{spend}}$ per spendere i bitcoin che abbiamo ricevuto.
Queste coppie sono derivate seguendo questi percorsi (_Bitcoin Mainnet_):
scan: m / 352' / 0' / 0' / 1' / 0
spend: m / 352' / 0' / 0' / 0' / 0
```

```text
Una volta disponibili queste 2 coppie di chiavi, si concatenano semplicemente (una di seguito all'altra) per creare il payload dell'indirizzo statico:
$$ B = B*{\text{scan}} \text{ ‖ } B*{\text{spend}} $$
Se si desidera utilizzare etichette, $B_{\text{spend}}$ viene sostituito con $B_m$:
$$ B = B\_{\text{scan}} \text{ ‖ } B_m $$
Con l'etichetta $m$:
$$ B*m = B*{\text{spend}} + \text{hash}(b\_{\text{scan}} \text{ ‖ } m) \cdot G $$
Una volta disponibile questo payload, si aggiunge la HRP (_Human-Readable Part_) `sp` e la versione `q` (= versione 0). Viene anche aggiunto un checksum, e l'indirizzo è formattato in bech32m.
Ad esempio, ecco il mio indirizzo statico per i Pagamenti Silenziosi:
sp1qqvhjvsq2vz8zwrw372vuzle7472zup2ql3pz64yn5cpkw5ngv2n6jq4nl8cgm6zmu48yk3eq33ryc7aam6jrvrg0d0uuyzecfhx2wgsumcurv77e
```