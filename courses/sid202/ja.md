---
name: エレメントとリキッドネットワークの構築
goal: Elementsオープンソース・ブロックチェーン・プラットフォームとその主要機能の使用と開発を学ぶ
objectives: 

  - ElementsブロックチェーンプラットフォームとLiquidサイドチェーンの基礎概念を理解する。
  - スタンドアロンおよびサイドチェーン構成のためのElementsノードのセットアップと実行を学びます。
  - フェデレーテッド・ブロック署名とフェデレーテッド2ウェイ・ペグの実践的な経験を積む。
  - 実際のユースケースに対応した、安全で効率的なブロックチェーン環境を構築・管理する。

---
# リキッドとエレメントの上に構築する

LiquidとElementsの高度な機能と性能を発見し、開発プロジェクトを強化するためにこれらのツールを効果的に活用する方法を学びます。このトレーニングでは、完全な理論と実践の基礎を提供し、機密取引、発行資産、統合ブロック署名などの機能をマスターすることができます。

ElementsフレームワークをベースとするLiquidは、金融および技術ソリューションのプライバシー、スケーラビリティ、および機能性を向上させるように設計されています。このコースでは、アセット発行と管理、Federated 2-Way Peg、そしてelementsdやelements-cliのようなツールの使い方を実際に体験することで、ニーズに合わせた革新的なソリューションを作成できるようになります。

このコースは、あらゆる経験レベルの開発者を対象としています。初心者や中級者にはわかりやすい説明と実践的な例を、上級者にはLiquidとElementsの技術的な詳細やあまり知られていない機能を深く掘り下げることができます。

あなたのスキルを高め、LiquidとElementsの可能性を最大限に引き出し、Liquidイノベーションの未来のためにインパクトのあるツールを作成するためにご参加ください。

+++
# はじめに

<partId>8f34de87-6e9a-4e3b-a326-50fc7c1803b3</partId>

## コース紹介

<chapterId>a721398e-7040-4edd-be53-b485ea759fa9</chapterId>

![Video](https://youtu.be/gkQfnwYLyI0?si=H6cIPhgZaSAwHaHI)

Elementsアカデミーの目的は、Liquidが構築されているオープンソースプラットフォームであるElementsの主要コンセプトを紹介し、説明することです。コース終了時には、機密取引や発行資産などのElementsの主な機能や、Elements Coreの運用に関わるプロセスを十分に理解している必要があります。

各セクションには、説明文付きのレッスンと、クイズで終わるビデオがある。問題の数は、その前のトピックの大きさに関連しています。セクション10ではコースの内容を要約し、最後により大きなクイズで終わります。

ご質問、追加情報のリクエスト、クイズの解答に関するお問い合わせは、講師のジェームズ・ドーフマンまでお願いします。

## エレメントの概要

<chapterId>7a7f2712-5300-4a6d-b1ed-05eab731bc35</chapterId>

![Video](https://youtu.be/ns-JLGdkNig?si=fmWye_boRSvVF1Bt)

Elementsはオープンソースのサイドチェーン対応ブロックチェーンプラットフォームであり、秘密取引や発行資産など、コミュニティのメンバーによって開発された強力な機能へのアクセスを提供する。

エレメンツとは、分散型ブロックチェーン台帳に格納された資産の移転と創造を支配する取引履歴とルールについて、合意形成を可能にするプロトコルを中核とするものである。

Elementsの背景情報については、Elementsプロジェクトのウェブサイト(https://elementsproject.org/)、Liquidの公式ブログ(https://blog.liquid.net/)、開発者ポータル(https://liquid.net/devs)をご覧ください。

### エレメント

2015年に発表されたElementsは、社内の開発・研究コストを削減し、最新のブロックチェーン技術を活用することで、多くの新しいユースケースの実装を可能にします。Elementsベースのブロックチェーンは、スタンドアロンのブロックチェーンとして運用することも、他のブロックチェーンにペッグしてサイドチェーンとして運用することもできる。Elementsをサイドチェーンとして運用することで、異なるブロックチェーン間で資産を検証可能に移転することができる。

ビットコインのコードベースに基づいて構築され、拡張されているため、ビットコインAPIに精通した開発者は、迅速かつコスト効率よく実用的なブロックチェーンを作成し、概念実証プロジェクトをテストすることができます。ビットコインのコードベース上に構築されているため、Elementsはビットコインプロトコルそのものを変更するためのテストベッドとしても機能する。

エレメンツの主な特徴を次に挙げる。

#### 機密取引

デフォルトでは、Elementsのすべてのアドレスは、Confidential Transactionsを使用してブラインドされています。ブラインドとは、送金されるアセットの金額と種類が、参加者とその参加者がブラインドキーを公開することを選択した参加者以外には、暗号的に隠されるプロセスのことです。

#### 発行済資産

エレメンツ上の発行アセットでは、複数のタイプのアセットを発行し、ネットワーク参加者間で移転することができます。また、発行されたアセットには秘密取引（Confidential Transactions）の利点があり、関連する再発行トークンを持っている人であれば誰でも再発行または破棄することができます。

#### 2ウェイ・ペグ

Elementsは汎用のブロックチェーンプラットフォームであり、既存のブロックチェーン（Bitcoinなど）に「ペッグ」することで、一方のチェーンから他方のチェーンへの資産の双方向転送を可能にする。Elementsをサイドチェーンとして実装することで、メインチェーンが持つ固有の性質を回避しつつ、メインチェーン上で確保された資産によって提供されるセキュリティを十分に保持することができる。

#### サイン入りブロック

エレメンツは、ブロック・サイナーと呼ばれる署名者の強力な連盟を使用しており、彼らは信頼性の高いタイムリーな方法で署名し、ブロックを作成します。これにより、ランダムなポアソン分布によりブロックの時間変動が大きいPoWマイニングプロセスのトランザクション待ち時間がなくなります。Federated Block Signingプロセスは、サードパーティの信頼やアルゴリズムベースのマイニングを導入することなく、信頼性の高いブロック生成を実現します。

Elementsは、Bitcoin Coreのコードベース上にこれらの機能をすべて追加し、メインチェーンプロトコルの能力を拡張し、サイドチェーンとして、またはスタンドアロンのブロックチェーンソリューションとして展開された場合に、新しいビジネスユースケースを可能にする。

# エレメント

<partId>ac68d611-be84-432f-a3a8-620d310e131c</partId>

## エレメンツの仕組み

<chapterId>05d88877-58b0-455b-9ae6-a72d19070525</chapterId>

![Video](https://youtu.be/v0lzmfH81AY?si=V-xDWfmDLKyBcdPs)

エレメンツは、ブロックチェーン利用者が日々直面する問題、すなわち取引の遅延、プライバシーの欠如、換金性のリスクに対する技術的な解決策を提供する。

エレメンツは、Federated Block SigningとConfidential Transactionsを使用することで、これらの問題を克服している。

ビットコインネットワークとは異なり、エレメンツ内のブロック署名プロセスは、動的会員制多者署名（DMMS）やプルーフ・オブ・ワーク（PoW）に依存していない。その代わりに、Elementsはブロック署名者と呼ばれる署名者の強力な連盟を使用し、彼らは信頼できるタイムリーな方法で署名し、ブロックを作成することができます。これにより、ランダムなポアソン分布のためブロックの時間変動が大きいPoWマイニングプロセスのトランザクション遅延がなくなります。Federated Block Signingプロセスは、サードパーティの信頼を導入することなく、信頼性の高いブロック生成を実現します。

エレメントは、ビットコインなどの他のブロックチェーンのサイドチェーンとして、あるいは他のネットワークに依存しない独立したブロックチェーンとして実行することができる。

サイドチェーンとして使用される場合、ストロングフェデレーションには、メインチェーンとエレメンツサイドチェーン間の安全かつ制御された資産移転を可能にするメンバーも含まれる。管理されたアセット移転はFederated 2-Way Pegと呼ばれ、アセット移転の役割を果たすメンバーはWatchmenと呼ばれます。

エレメンツ・ネットワークの運営に関わるプロセスと、ネットワーク参加者の役割は、エレメンツの仕組みを理解する上で重要である。

サイドチェーンとして実装されるにせよ、スタンドアロンのブロックチェーンとして実装されるにせよ、エレメンツはブロックを生成するためにブロック署名者の強力な連合を利用する。

### 強力な連盟

エレメンツは、ブロックストリームが最初に提案したストロング・フェデレーションと呼ばれるコンセンサス・モデルを採用している。ストロング・フェデレーションはプルーフ・オブ・ワーク（PoW）を必要とせず、その代わりにファンクショナリーと呼ばれる相互に不信感を持つ参加者グループの集団的行動に依存する。

ストロングフェデレーションにおいてファンクショナリーが果たすことのできる役割は以下の通りである：ブロック・サイグナーとウォッチマンです。ブロック・サイグナーはエレメントをサイドチェーンまたはスタンドアロン・ブロックチェーン・モードで運用する場合に必要であり、ウォッチマンはサイドチェーンの設定でのみ必要である。

ストロングフェデレーションのメンバーが実行できるアクションは、セキュリティを強化し、攻撃者が引き起こす損害を制限するために、2つの異なる役割に分かれている。

これらの参加者の役割を組み合わせることで、エレメンツは迅速なブロック生成（より迅速で最終的な取引確認）と、確実で譲渡可能な資産（別のブロックチェーンに直接リンク可能なペッグ資産）の両方を提供することができる。

ストロング・フェデレーションズのホワイトペーパーはこちらからお読みいただけます： https://blockstream.com/strong-federations.pdf

### ブロック署名者

ビットコインのようなブロックチェーンは、ブロック署名者の動的なグループの一部を形成する誰もが、費やされた作業の証明を示すことによってチェーンを拡張する。このセットの動的な性質は、このようなシステムに固有の待ち時間の問題をもたらす。

固定署名者セットを使用することで、Federatedモデルは動的セットを既知のセット、マルチ署名スキームに置き換える。ブロックチェーンを拡張するために必要な参加者の数を減らすことで、システムのスピードとスケーラビリティが向上し、同時にすべての当事者による検証によって取引履歴の完全性が保証される。

フェデレーテッド・ブロック署名はいくつかのフェーズで構成される：


- ステップ1 - ブロック署名者は、他の参加ブロック署名者すべてにラウンドロビン方式で候補ブロックを提案する。
- ステップ2 - 各ブロック署名者は、指定された候補ブロックに署名することを事前にコミットすることで、その意思を示す。
- ステップ3 - 与えられた事前コミットメントの閾値を満たした場合、各ブロック署名者はブロックに署名する。
- ステップ4 - 署名のしきい値（ステップ3とは異なる場合がある）を満たした場合、ブロックは受理され、ネットワークに送信される。強者連合は最新の取引ブロックについてコンセンサスに達した。
- ステップ5 - 次のブロックは、ラウンドロビンの次のブロック・サイ ナーによって提案され、プロセスが繰り返される。

ストロングフェデレーションのブロック生成は確率的ではなく、固定された署名者セットに基づいているため、マルチブロックの再編成を受けることはない。これにより、トランザクションの確認に関連する待ち時間を大幅に短縮することができる。また、利益のために採掘するインセンティブ（すなわちブロック報酬）を取り除き、すべての参加者が同じ目標を共有するネットワークに生産的に参加するインセンティブに置き換えます。これは、単一障害点（single point of failure）や、より高い信頼性の要件を導入することなく実現されます。

### サイドチェーンとしてのエレメンツ - ウォッチメンとフェデレイテッド2ウェイ・ペグ

サイドチェーンとして運営される場合、強力な連盟の一部のメンバーは、ウォッチマンという新たな役割を担うことになる。ウォッチメンはエレメンツサイドチェーンへの資産の出し入れを担当し、`Peg-In`と`Peg-Out`と呼ばれる処理を行う。

サイドチェーンが信頼できる方法で運用されるためには、資産の供給が管理され検証可能であることを参加者が確認できるようにする必要があります。Elementsサイドチェーンは、2Way Federated Pegを使用して、Elementsブロックチェーン内外でのアセットの双方向転送を可能にします。これにより、証明可能な発行とチェーン間送金の要件を満たすことができる。

Federated 2-way Peg機能により、アセットは他のブロックチェーンと相互運用可能で、他のブロックチェーンのネイティブアセットを代表することができます。自分のブロックチェーンを他のブロックチェーンにペッグすることで、メインチェーンの機能を拡張し、その固有の制限を克服することができます。

ハイレベルでは、誰かがメインチェーンのアセットをマルチシグネチャーのウォッチメン・ウォレットが管理するアドレスに送ると、サイドチェーンへの送金が発生する。これによってメインチェーンのアセットが効果的に凍結される。その後、ウォッチメンはトランザクションを検証し、サイドチェーン内で関連アセットと同額をリリースする。放出されたアセットは、元のメインチェーンアセットへの請求権を証明できるサイドチェーンウォレットに送られる。このプロセスにより、アセットが効果的に親チェーンからサイドチェーンに移動する。

アセットをメインチェーンに送金するために、ユーザーはサイドチェーン上で特別なペグアウト取引を行う。このトランザクションはウォッチマンによってチェックされ、ウォッチマンはメインチェーン上で自分が管理するマルチ署名ウォレットからトランザクション支出に署名する。メインチェーンの取引が有効になる前に、フェデレーション内の閾値数の参加者が署名する必要がある。ウォッチメンがアセットをメインチェーンに送り返す際、サイドチェーン上の対応する金額も破棄し、ブロックチェーン間でアセットを効果的に移転する。

## エレメントのセットアップと実行

<chapterId>cc806e5a-81ab-457b-9531-9f863120a019</chapterId>

![Video](https://youtu.be/Frr_OjTEPAM?si=iq5XonJyQk8S5OAu)

エレメンツはビットコインのコードベースに基づいているため、機能するネットワークを構成するコンポーネントは非常によく似ている。

Elementsノードのソフトウェア自体は`elementsd`と呼ばれ、ユーザーのマシン上でデーモンとして動作する。デーモン（Windowsではサービス）とは、ログオンしているユーザーの直接的な制御を必要とせずにバックグラウンドサービスとして動作するプログラムのことである。

注：この文書では、常にelementsdをデーモンバージョンと呼ぶが、サーバーオプションが有効になっていれば、すべてelements-qtで実行できる。

Elementsデーモンはネットワーク上の他のノードに接続し、取引とブロックデータを交換し、ネットワークのブロックチェーンのローカルコピーを検証し、拡張することができる。

Elementsソフトウェアには、`elements-cli`というクライアントプログラムも含まれており、コマンドラインからelementsdにリモートプロシージャコール(RPC)コマンドを送ることができる。これは例えば、ウォレットの残高を照会したり、トランザクションやブロックデータを閲覧したり、トランザクションをブロードキャストしたりするのに使うことができる。このセットアップは、ビットコインの同等物である bitcoind と bitcoin-cli を使ったことがある人なら誰でも知っているはずだ。

Elementsノードは、起動時にパラメータを渡すか、設定ファイルを介して設定することができるため、同じマシン上で複数のインスタンスを実行させることが可能です。各Elementsノードはブロックチェーンデータの独自のコピーを持ち、未確認の有効なトランザクションの独自のプールを管理し、異なるポートでRPCリクエストをリッスンする。

### エレメンツ・コード・リポジトリとコミュニティ

Elementsはオープンソースのプロジェクトであり、そのソースコードはElements GitHubリポジトリ（https://github.com/ElementsProject/elements）にある。このリポジトリには、elementsdとelements-cliプログラムのソースと、それをサポートするインストールとビルドツール、一連のテスト、いくつかの解説文書が含まれている。

コードリポジトリを補完するために、Elementsとは何か、どのように動作するか、包括的なチュートリアルセクションの説明を含むコミュニティに焦点を当てたリソースである、https://elementsproject.org ウェブサイトもあります。このチュートリアルでは、コマンドラインの例に従ってElementsについて学ぶことに重点を置き、Elementsの上に簡単なデスクトップアプリケーションやウェブアプリケーションを構築する方法を紹介している。また、Elementsコミュニティで人気のあるディスカッションフォーラムも掲載されており、GitHubでホストされているため、サイトのコンテンツにコミュニティからのコントリビューションを行うことも可能です。

お使いのマシンでElementsを実行するには、まずソースコードをクローン（ダウンロード）し、そのコードが持つ依存関係をインストールし、最後にデーモンとクライアントの実行ファイルをビルドする必要があります。これで、Elementsソフトウェアの設定と実行の準備が整いました。

## ノードとネットワークの設定

<chapterId>df1ec0aa-84ea-4149-af7a-b4523d67e1d9</chapterId>

起動時にコンフィギュレーション設定をElementsノードに渡すことで、そのノードの実行方法、データの検証方法、他のノードへの接続方法、ブロックチェーンデータの初期化方法を変更することができる。

設定は`elements.conf`ファイルからロードされるか、コマンドラインからパラメータとして渡される。

これらのパラメータを使って変更できるものもある：


- スタンドアロン型ブロックチェーンの実装で使用されるデフォルトアセット名。
- 最初に作成されたアセットの番号。
- ネットワーク上で取引手数料を支払う際に使用するアセット。
- ブロックチェーンのデータファイルの保存場所。
- Bitcoin ノードへの接続に使用される RPC 認証情報。
- ブロックに署名できる有効な公開鍵。
- サイドチェーンにアセットを出し入れするために必要なスクリプト。
- サイドチェーンとしてビットコインノードに接続するかどうか。

これらの多くはネットワークのコンセンサス・ルールの一部を形成するので、起動時にすべてのノードに適用されることが重要である。チェーンが初期化された後で変更できるものもあるが、チェーンの初期化に使われた後で修正する必要があるものもある。

パラメータの使い方については、各セクションに関連するときに、コースの後半で説明する。

### コマンドラインを使った基本操作

このコースでは、`elements-cli` プログラムを使用して 1 つ以上の Elements ノードに RPC 呼び出しを行う例を示します。これはターミナルセッションから行われ、コマンドを簡潔にするために `alias` が使用されます。以下のようなコマンドを見るときは、この規約に従ってください：

```bash
e1-dae
e1-cli getnewaddress
```

e1-dae`と`e1-cli`は実際にはターミナルの`alias`機能を利用したタイポグラフィ的なショートカットです。e1-dae`と`e1-cli`はコマンド実行時に実際に置き換えられ、実行されるコマンドは以下のようになる：

```
$HOME/elements/src/elementsd -datadir=$HOME/elementsdir1
$HOME/elements/src/elements-cli -datadir=$HOME/elementsdir1 getnewaddress
```

上に示したのは、Elementsデーモンの起動と、`$HOME/elements/src`ディレクトリにあるelements-cliプログラムの呼び出し、そして`datadir`パラメータの値である。datadir`パラメータは、デーモンとクライアントのインスタンスに、それぞれの設定ファイルの場所と、デーモンの場合はブロックチェーンのコピーの保存場所を教えることができる。設定ファイルを共有することで、クライアントはデーモンにRPCコールを行うことができる。

上記のコマンドを別の `datadir` 値を指定して再度実行することで、複数の Elements インスタンスを起動し、それぞれにブロックチェーンとコンフィグ設定を個別にコピーすることができる。この規約により、e1とは異なるdatadirディレクトリを参照するために、コースでは`e2-dae`と`e2-cli`というエイリアスを使用する。従って、2つ目の `e2` インスタンスに対する上記の例は次のようになる：

```
$HOME/elements/src/elementsd -datadir=$HOME/elementsdir2
$HOME/elements/src/elements-cli -datadir=$HOME/elementsdir2 getnewaddress
```

これにより、ノード間の資産取引、資産の発行、同一ネットワーク上の異なるノード間の秘密取引における目隠し使用のチェックなど、あらゆる操作を実行できるようになる。

# エレメントの使用 実際の使用例

<partId>3f31a30a-957a-4813-b5fe-5dccbb5366f3</partId>

## 機密取引

<chapterId>263b1c5b-59ed-49e7-b811-95c354f41eae</chapterId>

![Video](https://youtu.be/-by2xBtXQeE?si=7bLo_geGn3qh7MXN)

このセクションでは、ElementsのConfidential Transactions機能の使い方を学びます。

Elementsのすべてのアドレスは、デフォルトでは、Confidential Transactionsを使用してブラインドされています。これは、トランザクションの参加者（およびその参加者がブラインドキーを公開することを選択した参加者）だけが、転送された資産の量と種類を確認できるようにするものです。

### 秘密住所と秘密取引

デフォルトでは、エレメンツで`getnewaddress`コマンドを使って新しいアドレスを作成する場合、それは機密アドレスとして作成されます。

機密トランザクションを実証するために、e2 に自己資金を送金させ、e1 からのトランザクショ ンを表示させてみる。これにより、Elementsにおけるトランザクションの機密性を実証する。

エレメンツ・ノードが生成する新しいアドレスは、デフォルトではすべて機密扱いとなる。e2に新しいアドレスを生成させることで、これを実証することができる。

```
e2-cli getnewaddress
```

アドレスがe1で始まることに注意。これは機密アドレスであることを示す。getaddressinfoコマンドを使ってアドレスを詳しく調べると、アドレスの詳細がわかる。

```
e2-cli getaddressinfo <address>
```

機密アドレスであることを示すconfidential_keyプロパティがあることがわかる。

confidential_keyは、機密アドレス自体に追加される公開ブラインド鍵である。これが秘密アドレスが長い理由である。

また、関連する非機密アドレスもあります。Elements内で通常の非機密扱いのトランザクションを使用したい場合は、lq1接頭辞を持つアドレスではなく、このアドレスにアセットを送信する必要があります。

e2が生成したアドレスに資金を送金する。e1は取引当事者ではないので、取引の詳細を見ることはできない。

```
e2-cli sendtoaddress <address>
```

取引IDをメモする。取引を確認する。

```
e2-cli -generate 101
```

e2が自分自身に資金を送金した取引をe2自身の視点から見てみよう。

```
e2-cli gettransaction <txid>
```

トランザクションの詳細を上にスクロールすると、e2が送受信金額と取引されたアセットを表示できることがわかる。また、amountblinder プロパティと assetblinder プロパティも表示されます。これは、トランザクションに関与していない他のノードから詳細を見えないようにするために使用されます。

e1から同じトランザクションの詳細を確認するには、まず生のトランザクション詳細を取得する必要がある。

```
e1-cli getrawtransaction <txid>
```

これは生のトランザクションの詳細を返す。voutセクションを見ると、3つのインスタンスがあることがわかる。最初の2つのインスタンスは受取額と釣銭額で、3つ目は取引手数料である。これら3つの金額のうち、値を確認できるのは手数料だけで、手数料自体はエレメンツ内で常にブラインドされていないからである。

### ブラインド・キー

最初の2つのVOUTセクションが示すのは、実際の取引額と資産の種類を証明するコミットメントデータと金額の "ブラインドレンジ "である。

仮にe2の秘密鍵をe1のウォレットにインポートしたとしても、e2が使っている目隠し鍵のことを知らないため、e1は取引された金額や資産の種類を見ることはできない。e2のウォレットで使われている秘密鍵をe1のウォレットにインポートすることで、このことを証明しよう。まず、e2から鍵をエクスポートする必要があります。

```
e2-cli dumpprivkey <address>
```

それをe1にインポートする。

```
e1-cli importprivkey <privkey>
```

これで、e1がまだ値を見ることができないことを証明できる。

```
e1-cli gettransaction <txid>
```

確かに、実際には1であるにもかかわらず、TX量として0が表示されている。

実際の目隠しされていない値を見るには、目隠しキーが必要だ。そのために、まずe2からブラインドキーをエクスポートする。

```
e2-cli dumpblindingkey <address>
```

それをe1にインポートする。

```
e1-cli importblindingkey <address> <blinding key>
```

さて、e1からトランザクションの詳細を取得する。

```
e1-cli gettransaction <txid>
```

これは、ブラインド・キーがインポートされたことで、トランザクション内の実際の値1を見ることができることを示している。

本節では、Blinding Keyを使用することで、取引における資産の金額と種類が隠蔽されること、 そして正しいBlinding Keyをインポートすることで、その値を明らかにできることを見てきた。実際の使用では、例えば、ある当事者が保有する資産の金額や種類を確認する必要がある場合に、監査人に目隠しキーを渡すことができる。ElementsのConfidential Transactions機能では、「範囲証明」を行うこともできる。範囲証明は、実際の金額そのものを公開する必要なく、ある資産の金額が所定の範囲内で保有されていることを証明することができます。

また、コンフィデンシャル取引はオプションであるが、新しいアドレスが生成されるとデフォルトで有効になることも確認した。

今回のレッスンはここまで。クイズで頑張って、また次のレッスンでお会いしましょう！

## 発行済資産

<chapterId>c33c7020-5975-457a-99db-4f8b90d1fa1c</chapterId>

![Video](https://youtu.be/XnY4WZUNSs4?si=dG8I5OoSh_0EBdvL)

このセクションでは、ElementsのIssued Assets機能の使い方を学びます。

発行されたアセットにより、複数のタイプのアセットを発行し、エレメンツ・ネットワーク参加者間で移転することが可能になります。ネットワーク上のどのノードも自身のアセットを発行することができます。発行は、バウチャー、クーポン、通貨、預金、債券、株式など、あらゆるアセットの交換可能な所有権を表すことができます。発行アセットにより、自己発行アセットを含むトラストレス取引所、オプション、その他の高度なスマートコントラクトを構築するための扉が開かれます。

発行されたアセットもまた、機密取引の恩恵を受け、関連トークンを保有する誰もが再発行することができます。

まず最初に、e1とe2と呼ぶ2つのエレメンツ・ノードにアクセスする必要がある。これらのノードはブロックチェーンがリセットされ、デフォルトのアセットが分割されている。

2つのノードは同じローカルネットワーク上にあり、互いに接続されているため、トランザクションメンプール内の同じトランザクションと同一のブロックチェーンを共有している。両者は同じマシン上で稼働しているが、実際のブロックチェーン・ファイルは共有していないことは注目に値する。各ノードはそれぞれブロックチェーンのローカルコピーを管理し、コンセンサスを得て互いに同じプロトコルルールを遵守しているため、同じ取引履歴を含んでいる。

まず、各ノードがネットワーク上に存在する資産の発行状況を確認することから始めよう。

これはlistissuancesコマンドを使って行う。

```
e1-cli listissuances
e2-cli listissuances
```

ご覧のように、どちらのノードも同じ発行履歴を示しています。チェーン初期化時に作成された2100万ビットコインの初期発行です。上記のコマンドを実行した結果、アセットの 16 進 ID と、アセットに割り当てられたラベル（'bitcoin'）が確認できます。

注目すべきは、チェーンが初期化されるとき、デフォルトのアセットには常にラベルが与えられるということです。自分のアセットを発行するときには、自分でラベルを設定することができます。その前に、自分のアセットを発行する必要があります。

e1に新しいアセットを発行させます。これは issueasset コマンドを使って行います。

```
e1-cli issueasset 100 1 false
```

issueasset`は3つのパラメータを受け付ける。

発行する新しいアセットの量、ここでは100とした。作成するトークンの量（トークンはアセットの量を再発行するために使用されます）。最後のパラメータは、アセット発行をブラインドまたはアンブラインドのどちらで作成するかをエレメンツに指示します。e2からの発行金額をすぐに確認したいので、ここではブラインドなしを使用します。

コマンドを実行すると、発行に関するデータが返されます。これには、後で使用するためにコピーを取ることができるトランザクションID、アセットの一意の16進数値、およびアセットのトークンの一意の16進数値が含まれます。

発行トランザクションを確認するためのブロックを生成する。

```
e1-cli -generate 1
```

もう一度 e1 に対して `listissuances` コマンドを実行する。

```
e1-cli listissuances
```

これは、e1が現在2つの発行を認識していることを示しています。ビットコインの最初の発行と、新しく発行されたアセットです。新しいアセットの16進数値と、ビットコイン発行のように関連するアセットラベルがないことに注意してください。

e2の既知の発行リストをもう一度確認してください。

```
e2-cli listissuances
```

このことから、e2はe1が行った資産発行を認識していないことがわかる。e2が見ることができるのは、すでに見ることができたビットコインの最初の発行だけである。

これは、e2が、e1から新しいアセットが発行されたときの送り先のアドレスを知らず、見ていないからである。

e2が発行そのものを見ることができなくても、e1はe2に資産の一部を送ることができることは注目に値する。その場合、e2は元の発行に気づいていなくても、新しいアセットがe2のウォレットで利用可能な残高として表示される。

e2が実際の発行（したがって発行額）を確認できるようにするためには、e2にウォッチド・アドレスとして住所を追加する必要がある。

そのためには、アセットが送られたアドレスを見つける必要があります。そのために、先にコピーしたトランザクション ID を使い、e1 にそのトランザクションの詳細を取得させ、e2 のウォレットウォッチリストに追加する正しいアドレスを調べます。

```
e1-cli gettransaction <the-issuance-transaction-id>
```

取引データの16進数を超えて上にスクロールすると、新しい資産を100個受け取ったアドレスが表示されます。

e2にインポートできるように、住所をコピーしてください。

では、そのアドレスをe2にインポートしてみよう。それにはimportaddressコマンドを使う。

```
e2-cli importaddress <the-issued-to-address>
```

e2の発行リストを確認してみよう。

```
e2-cli listissuances
```

新しく発行されたアセットがリストに含まれていることがわかります。e2 ノードでは、発行されたアセットの金額と、関連付けられたトークンの金額も確認できます。Elements 内でアセット ID と名前のマッピングを使用できるようにするには、まず Elements を停止します。

```
e1-cli stop
```

その後、アセットの16進数を指定されたラベルにマッピングする追加パラメータを指定して再起動します。これにより、ノードがアセットに関するデータを人間が読みやすい形式で表示できるようになります。必要であれば、これをelements.confの最後に追加すれば、デーモンを起動するたびに引数を追加する必要はありません。例えば

```
assetdir=5186d0bc8ed15e6ef85571bd2d8070573adf0e06fd4507082694526975ce4f35:My new asset (MNA)
```

しかし、ここでは引数法を使う。

```
e1-dae -assetdir=<assetid-here>:<name-of-the-new-asset>
```

再び発行リストをノードに問い合わせる。

```
e1-cli listissuances
```

これは、アセットの16進数値とラベルのマッピングが機能していることを示しています。e2ノードの発行リストをもう一度確認します。

```
e2-cli listissuances
```

ラベルはそれを設定したノードだけが利用できるため、e2ノードがこのラベルにアクセスできないことがわかります。実際、e1 で設定したラベルとは異なるラベルを e2 の同じアセットヘクスに割り当てることができます。まずe2ノードを停止します。

```
e2-cli stop
```

新しいアセットの16進数に別のラベルを割り当てて再スタート。

```
e2-dae -assetdir=<assetid-here>:<another-name-for-the-new-asset>
```

e2からの発行物を掲載。

```
e2-cli listissuances
```

アセットのラベルは各ノードにローカルで、アセットの16進数のみがネットワーク上の他のノードによって認識される。

ラベルとアセットヘクスのマッピングは、取引やウォレット残高のクエリなどのアクションを実行するときに便利です。例えば、ラベルを使用せずにe1からe2へ新しいアセット(10ドル)を送金したいとします。

まず、アセットの送信先アドレスを取得する必要がある。

```
e2-cli getnewaddress
```

それからsenttoaddressコマンドを使う。

```
e1-cli sendtoaddress <address> 10 "" "" false false 1 UNSET false <asset-id-here>
```

ブロックを生成して取引を確認する。

```
generate 1
```

e2で資産を受け取ったことを確認。

```
e2-cli getwalletinfo
```

資産を確かに受け取ったことがわかる。

e2は受信したアセットの16進数をマップし、独自のラベルを使って表示することに注意してください。同じことをより簡単に行うには、送信時にe1のアセットラベルを使用することです。

```
e1-cli sendtoaddress <address> 10 "" "" false false 1 UNSET false <name-of-the-new-asset>
```

その裏では、Elementsがローカルラベルを16進数にマッピングし、発行されたアセットの使用を簡素化します。

このセクションでは、アセットの発行とラベル付けについて見てきました。次のセクションでは、発行したアセットの再発行と破棄について説明します。

## 資産の再発行

<chapterId>78751b21-1dc8-4877-a406-e71bc80a95b0</chapterId>

![Video](https://youtu.be/5em79YHtYk0?si=rhponm6Hw9AB6RJp)

このセクションでは、すでに発行された資産をさらに発行する方法と、発行された資産を一定量破棄する方法を学びます。

資産の再発行（増発）や資産の破棄の必要性は、資産が一定の供給量を持たないものを表す場合に生じやすいものである。これは、例えば、金庫に保管されている金を表す資産に当てはまります。金の単位が金庫から出入りすると、金庫の供給を表す資産はそれに応じて増減する必要があります。

アセットを再発行するには、そのアセットが最初に発行されたときに一緒に作成された関連トークンを所有する必要があります。

アセットを再発行するノードがアセット再発行トークンと呼ばれるものを所持している限り、最初にどのノードがアセットを発行したかは関係ありません。ここでは、再発行トークンを最初に作成する方法、再発行トークンを使ってアセットを再発行する方法、再発行トークンを他のノードに転送して、他のノードにもアセットを再発行する権限を与える方法について説明します。

e1とe2と呼ぶ2つのエレメンツ・ノードにアクセスする必要がある。これらのノードはブロックチェーンがリセットされ、デフォルトのアセットが分割されています。

e1に新しいアセットを100枚発行させ、同じアセットに対して1枚の再発行トークンを作成します。例を簡単にするため、発行は非ブラインドで行います。それでは、アセットとそれに関連する再発行トークンを発行してみましょう。

```
e1-cli issueasset 100 1 false
```

アセットと（再発行）トークンのIDに注意してください。

後に e2 からさらに資産を再発行することになるため、資産が発行されたトランザクション ID をメモしておき、その ID を使用して資産が送信されたアドレスをインポートする必要があります。

取引を確認する。

```
e1-cli -generate 1
```

それでは、gettransactionコマンドを使ってトランザクションの詳細を確認してみよう：

```
e1-cli gettransaction <txid>
```

トランザクションデータの16進数を超えて上にスクロールすると、このトランザクションでe1が再発行トークン1つと関連アセット100を受け取ったことがわかる。

e2にインポートできるように、住所をコピーしておいてください。

そして今、e2のウォレットにアドレスをインポートしている。

```
e2-cli importaddress <address>
```

e1とe2の両方が資産発行を認識していることがわかる。

```
e1-cli listissuances
e2-cli listissuances
```

現在、e1はアセットと再発行トークン1個を保有しているが、e2は保有していない。

```
e1-cli getwalletinfo
```

また、e1は取引手数料を賄うために少額を支払ったため、以前よりもデフォルト資産が少なくなっていることに注意。この金額は、作成されたブロックが100ブロック以上深く成熟したときにe1が回収することになっている。

```
e2-cli getwalletinfo
```

e1は再発行トークンを保持しているので、それをさらに再発行することができる。これはreissueassetコマンドを使って行う。e1がさらに100のアセットを再発行してみましょう。

```
e1-cli reissueasset <asset-id> 100
```

再発行はうまくいった。

```
e1-cli getwalletinfo
```

e1が予想通り200の資産を保有していることがわかる。

e2は再発行トークンを保有していないため、アセットを再発行しようとするとエラーが発生します。

```
e2-cli reissueasset <asset-id> 100
```

エラーメッセージに注意してください。

再発行の詳細は、listissuancesコマンドを使ってe1から見ることができる。

```
e1-cli listissuances
```

is_reissuance`フラグに注意。

e2に再発行トークンを送ると、e2自身がそのアセットを再発行できるようになる。まず、トークンを送るためのアドレスが必要だ。再発行トークンは、e2がアセットを再発行できるようにするために、1つの再発行トークンをe2に送る必要はありません。どのような額面でも十分です。e2が再発行トークンを受け取るためのアドレスを生成する。

```
e2-cli getnewaddress
```

次に、e1からe2へRITの一部を送信する。

```
e1-cli sendtoaddress <address-of-e2> 0.1 "" "" false false 1 UNSET false <reissuance-token-id>
```

取引を確認する。

```
e1-cli -generate 1
```

e2が送られた0.1を保持していることがわかる。

```
e2-cli getwalletinfo
```

これは、e2がウォレットに保有するRITに関連する資産を、より多く再発行できるようになったことを意味する。e2に500枚の資産を再発行してもらう。

```
e2-cli reissueasset <asset-id> 500
```

再発行の結果を確認する。

```
e2-cli getwalletinfo
```

e2は現在、再発行された金額をウォレット残高に保持しており、RIT自体はアセット再発行のプロセスで消費されていないことがわかります。

資産の破棄は、少なくとも破棄される量を保有していれば誰でもできることであり、再発行トークンに支配されるものではない。

```
e2-cli destroyamount <asset-id>
e2-cli getwalletinfo
```

このセクションでは、アセットを発行する方法と、アセット発行の際に任意で作成される再発行トークンの利用方法について見てきました。また、再発行トークンの譲渡は他のアセットと同様に簡単であり、再発行トークンを保有することで、関連するアセットをさらに発行する権利が付与されます。したがって、ネットワーク内で再発行トークンにアクセスできる人を管理することは非常に重要です。また、再発行トークンを保有することで、そのアセットを破棄することはできません。

# エレメント連盟

<partId>173a2440-0203-4dcc-8e2b-f8fa2cc8d3ca</partId>

## ブロックサイン

<chapterId>c47b217e-db14-4843-a66f-3e5f3a00a808</chapterId>

![Video](https://youtu.be/kxWX91fCnus?si=KItm_Am3_RrBcLBN)

Elementsは連合署名モデルをサポートしており、有効なブロックを生成するために、提案されたブロックに署名しなければならない強力な連合メンバーの数を指定することができます。

以前は、また例を簡単にするために、`generate`コマンドを使ってブロックを作成していた。これは、作成されたブロックを有効なものとしてネットワークが受け入れるために、マルチシグネチャの要件を満たす必要はなかった。

2-of-2マルチシグブロックの作成を要求するようにノードを設定します。これはsignblockscriptパラメータを使って設定します。signblockscriptパラメータは設定ファイルに追加するか、起動時にノードに渡します。このパラメーターを使用してチェーンを初期化するには、まず、チェーンを構成するスクリプトをビルドする必要があります。

既存のノードをいくつか使ってこれを行い、出力されたデータを保存してからチェーンを消去し、signblockscriptパラメータを使って再開できるようにする。このスクリプトはネットワークのコンセンサスルールの一部を形成するため、チェーンの初期化時に設定する必要がある。すでに存在するチェーンに後から追加することはできない。

e1とe2と呼ぶ2つのエレメンツ・ノードにアクセスする必要がある。これらのノードはブロックチェーンがリセットされ、デフォルトのアセットが分割されています。

elements.confファイルでcon_max_block_sig_sizeパラメータが大きな値に設定されていることを確認してください。そうでないと、このセクションの後半でブロック署名が失敗します。このチュートリアルでは、con_max_block_sig_size=2000に設定しています。

ブロックチェーンをリセットし、e1とe2に関連するウォレットを消去するので、ブロック署名スクリプトの生成に使用したアドレス、公開鍵、秘密鍵のコピーを取っておき、後で使用できるようにしておく必要がある。

まず、各ブロック署名ノードが新しいアドレスを生成する必要がある。

```
e1-cli getnewaddress
e2-cli getnewaddress
```

次に、アドレスから公開鍵を抽出し、後で使うために記録しておく必要がある。

```
e1-cli getaddressinfo <e1-address>
e2-cli getaddressinfo <e2-address>
```

ブロックチェーンとウォレットのデータを再初期化した後、ノードがブロックに署名できるようにするためだ。

```
e1-cli dumpprivkey <e1-address>
e2-cli dumpprivkey <e2-address>
```

次に、2対2のマルチシグネチャ要件を持つredeemスクリプトを生成する 必要がある。そのためには、createmultisigコマンドを使用し、最初のパラメー タに2を指定し、2つの公開鍵を提供する。これらの鍵は、後でブロックを作成する際に所有権を証明する必要がある。

e1またはe2のどちらのノードがマルチシグを生成してもよい。

```
e1-cli createmultisig 2 '["<e1-pubkey>", "<e2-pubkey>"]'
```

これでredeemscriptができあがった。

さて、既存のブロックチェーンとウォレットのデータを消去して、チェーンのコンセンサスルールの一部として新しいsignblockscriptで再スタートできるようにする必要がある。新しいチェーンでブロックに署名するために使われる秘密鍵のようなデータのコピーを取る必要があるのはこのためだ。先に進む前に、これを行う必要がある。

既存のウォレットとチェーンデータが削除されたので、ノードを起動し、signblockscriptパラメータを使って新しいチェーンを初期化することができます。この例ではその高度な機能は必要ないので、-evbparams=dynafed:0:: を渡してdynafedの有効化を無効にしましょう。

```
e1-dae -signblockscript=<redeem-script> -evbparams=dynafed:0:::
e2-dae -signblockscript=<redeem-script> -evbparams=dynafed:0:::
```

ここで、ノードが署名して提案されたブロックを完成させることができるように、先に保存した秘密鍵をインポートする必要がある。

```
e1-cli importprivkey <e1-priv-key>
e2-cli importprivkey <e2-priv-key>
```

generateコマンドの使用は、現在私たちのノードによって強制されている必要なブロック署名ルールを満たさないため、エラーになるはずです。

```
e1-cli -generate 1
```

新しいブロックを提案するために、いずれかのノードはgetnewblockhexコマンドを呼び出すことができる。これはネットワーク上のどのノードにも受け入れられる前に署名が必要な新しいブロックの16進数を返す。

```
e1-cli getnewblockhex
```

このコマンドは提案ブロックを作成するだけで、ブロックを生成するわけではないことを覚えておいてほしい。

これを確認するために、現在ブロックチェーンにブロックがないことを確認できる。

```
e1-cli getblockcount
```

ブロックヘクスに署名せずに送信しようとすると、そのブロックヘクスは署名されない。

```
e1-cli submitblock <block-hex>
```

ブロック証明は無効です」というメッセージが表示される。これは、必要な2者のうち2者がまだ署名していないためです。

では、e1に提案されたブロックにサインしてもらおう。

```
e1-cli signblock <block-hex>
```

e2にヘクスに署名させる。

```
e2-cli signblock <block-hex>
```

e2が、e1が提案ブロックに署名してできた出力に署名していないことに注意してください。両者は提案されたブロックの16進数に、互いの結果とは無関係に署名する。

ここで、e1とe2のブロック署名を結合する必要がある。どちらのノードでも可能で、必要なのはもう一方のノードの署名付きブロック16進数だけである。

```
e1-cli combineblocksigs <block-hex> '["<signed-hex-from-e1>", "<signed-hex-from-e2>"]'
```

combineblocksigsコマンドは、署名されたブロックの16進数と、ブロックの16進数を送信する準備ができたことを示すcompleteというステータスを出力することがわかる。

これで、どちらのノードも完成したブロック・ヘクスを送信できるようになった。e1にやってもらおう。

```
e1-cli submitblock <combined-signed-hex>
```

投稿が有効なものであることを確認する。

```
e1-cli getblockcount
e2-cli getblockcount
```

e1とe2の両方がこのブロックを有効なものとして受け入れ、ブロックチェーンのローカルコピーの先端に追加したことがわかる。

プロセスを要約するとこのセクションでは


- ブロックを提案した。
- 各ノードに署名してもらった。
- 署名を組み合わせた。
- 署名が有効であり、チェーンのredeemscriptの閾値を満たしていることを確認。
- ブロックを提出した。

ネットワーク上の各ノードはそのブロックを検証し、ブロックチェーンのローカルコピーに追加する。

### ブロック・セッティング

一見複雑なプロセスに見えるが、エレメンツでのブロック署名の順序は常に同じであり、初期設定は一度しか行う必要がない：

1.初期セットアップ（1回）

2.Federated Block Signersの公開鍵を使用して、`signblockscript`と呼ばれるマルチ署名アドレスが作成される。

3.このスクリプトから引き出されたスクリプトは、新しいブロックチェーンを開始するために使われる。

4.ブロック生産（継続中）

5.提案されたブロックが生成され、署名のために交換される。

しきい値の数の署名者が提案されたブロックに署名すると、そのブロックは結合され、ネットワークに提出される。そのブロックがチェーンの `signblockscript` の基準を満たしていれば、ノードはそれを有効なブロックとして受け入れる。

## サイドチェーンとしてのエレメント

<chapterId>432d7a65-255f-44a3-8b38-78508202cb37</chapterId>

![Video](https://youtu.be/egYzj4N8CB8?si=v7_-IXsjHPE-ARDe)

Elementsはオープンソースの汎用ブロックチェーンプラットフォームで、ビットコインなどの既存のブロックチェーンに「ペッグ」することもできる。他のブロックチェーンにペッグされた場合、Elementsは「サイドチェーン」として動作すると言われている。サイドチェーンは、あるチェーンから別のチェーンへの資産の双方向転送を可能にする。Elementsをサイドチェーンとして実装することで、メインチェーンに内在する制限のいくつかを回避しつつ、メインチェーン上で確保された資産によって提供されるセキュリティを十分に保持することができる。

サイドチェーンはメインチェーンとその取引履歴を認識しているが、メインチェーンはサイドチェーンを認識しておらず、その運用には何も必要ない。このため、サイドチェーンはメインチェーンのプロトコル改善提案に伴う制限や遅延なしにイノベーションを起こすことができる。メインプロトコルを直接変更しようとするのではなく、メインプロトコルを拡張することで、メインチェーン自体が安全で特化された状態を維持し、サイドチェーンの円滑な運用を支えることができる。

Bitcoinの機能を拡張し、その基礎となるセキュリティを活用することで、Elementsベースのサイドチェーンは、メインチェーンのユーザーが以前は利用できなかった新しい機能を提供することができる。実運用されているElementsベースのサイドチェーンの例としては、Liquid Networkがある。

Elementsブロックチェーンをサイドチェーンとして初期化するには、federated pegスクリプトパラメータを使用する必要があります。このパラメータはノードの設定ファイルで設定するか、起動時に渡すことができます。

フェデレーション・ペグ・スクリプトは、強力なフェデレーションのどのメンバーがペグイン・ペグアウト機能を実行できるかを定義する。これらのファンクショナリーは`ウォッチマン`と呼ばれ、メインチェーンとサイドチェーンで有効なペッグインとペッグアウトのトランザクションを監視し、有効であればアクションを起こす。ペッグアウト」とは、ペッグされた資産をサイドチェーンからメインチェーンに移動させることを意味し、「ペッグイン」とは、ペッグされた資産をメインチェーンからサイドチェーンに移動させることを意味する。サイドチェーンに移動する」というのは、メインチェーンのマルチシグネチャアドレスに資金がロックされ、それに対応する量の資産がエレメンツのサイドチェーンに作られるということです。サイドチェーンから移動する」とは、Elementsサイドチェーン上で資産が破棄され、メインチェーン上でロックされた資金から対応する金額が解放されることを意味します。ペグイン・ペグアウト機能を実行する許可を得るには、ファンクショナリーが連携ペグスクリプトで使用する公開鍵の所有権を証明する必要がある。これには、対応する秘密鍵を使用する。

連携ペグスクリプトを作成するには、まず各ノードに公開鍵を生成させる必要があります。また、既存のチェーンデータを消去し、フェデレーテッド・ペグ・スクリプトを使用して新しいチェーンを初期化する必要があるため、後で使用するために関連する秘密鍵を保存しておく必要があります。これは、フェデレーテッド・ペグ・スクリプトがサイドチェーンのコンセンサス・ルールの一部を形成しているためで、後日、ペッグされていない既存のブロックチェーンに適用することはできない。

そこで、各ノードでアドレスを生成し、後で使うために関連データを保存し、後でサイドチェーンを初期化するために使うフェデレート・ペグ・スクリプトを生成しよう。

まず、ネットワークのウォッチマンとなる各ノードが新しいアドレスを生成する必要がある。

```
e1-cli getnewaddress
e2-cli getnewaddress
```

次に、そのアドレスを検証して公開鍵を取得する。

```
e1-cli getaddressinfo <e1-address>
e2-cli getaddressinfo <e2-address>
```

そして、各アドレスに関連付けられた秘密鍵を取り出す。

```
e1-cli dumpprivkey <e1-address>
e2-cli dumpprivkey <e2-address>
```

秘密鍵と公開鍵を後で使用するために保管する。

さて、連合ペグスクリプトを使って新しいチェーンを初期化するので、既存のブロックチェーンとウォレットのデータを消去する必要がある。これは今すぐできる。Bitcoinデーモンを起動するのを忘れないでください。

これで、先ほど保存した公開鍵を使用して作成した連合ペグスクリプトで、 新しいチェーンを初期化できるようになった。入力する数字と公開鍵を囲む数字が、使用する鍵の数と、サイドチェーンにペグインしたりペグアウトしたりするために証明しなければならない鍵の所有権を定義し、区切ります。

```
e1-dae -fedpegscript=5221<e1-pubkey>21<e2-pubkey>52ae
e2-dae -fedpegscript=5221<e1-pubkey>21<e2-pubkey>52ae
```

ここで、以前に保存した秘密鍵をインポートし、ノードがチェーン間で署名して資産の移転を完了し、フェデレーション・ペグ・スクリプトの要件を満たすことができるようにする。

```
e1-cli importprivkey <priv-key-1>
e2-cli importprivkey <priv-key-1>
```

ここで、両チェーンのブロックを成熟させる必要がある。ブロックの成熟はペッグプロセスの要件であり、メインチェーン上のブロック再編成がサイドチェーン内のペッグされた資産供給のインフレにつながることを防ぐためである。

このセクションでは、連合ペグに焦点を絞るため、前回のセクションで見たブロック署名モデルを使用せずにブロックを生成し、新しいブロックを作成するために「generate」コマンドを使用することに戻る。

```
b-cli generate 101
e1-cli generate 1
```

今すぐエレメントのブロックを生成する必要はない。しかし、とにかく1つ生成してみよう。潜在的な矛盾を避けるための良い習慣だ。

これでペグインチェーンの準備は整った。ペグインアドレスを生成するためには、getpeginaddressコマンドを使って特別な種類のアドレスを生成する必要がある。getpeginaddressでペグインアドレスを生成してからclaimpeginでクレームするまでの期間はできるだけ短くする必要がある。

```
e1-cli getpeginaddress
```

このコマンドを実行すると、新しいメインチェーンアドレスと、ペグインファンドを請求するために必要な新しいスクリプトが作成されることがわかります。メインチェーンアドレスは、Elementsネットワーク内でウォッチマンの役割を果たすファンクショナリーが使用する`pay to script hash`アドレスである。

getnewaddressと同様に、getpeginaddressは呼び出したノードのウォレットに新しいシークレットを追加します。したがって、ウォレットファイルのバックアップをノード管理プロセスに組み込むことが重要です。

メインチェーンからサイドチェーンにビットコインを送ります。メインチェーンのリグレッションテスト用ウォレットには、すでにいくらかの資金があります。

```
b-cli getwalletinfo
```

ウォレットには50ビットコインが保管されていることがわかる。メインチェーンからサイドチェーンに1ビットコインを送ります。先ほどノードが生成したメインチェーンのアドレスに送金する必要があります。

```
b-cli sendtoaddress <e1-pegin-address>
```

後で資金調達の証明のために必要なので、この取引のIDを保管しておく必要がある。

メインチェーンウォレットの残高が、送金した金額と、取引手数料をカバーするための追加的な少額分だけ減っていることがわかります。

```
b-cli getwalletinfo
```

もう一度取引を成熟させる必要がある。

```
b-cli generate 101
```

エレメンツ・ノードにペッグイン資金を要求させるためには、ペッグイン取引が行われたことを示す「証明」を得る必要がある。暗号的証明は資金取引IDを使ってメルケル経路を計算し、その取引が確認済みブロックに存在することを証明する。

```
b-cli gettxoutproof '["<tx-id>"]'
```

生の取引データも必要だ。

```
b-cli getrawtransaction <tx-id>
```

ペグイントランザクションの証明と生データがあれば、エレメン トノードは生トランザクションとトランザクション証明を使ってペグイントランザクションを主張できる。

```
e1-cli claimpegin <raw> <proof>
```

claimpeginにはオプションの第3引数があることに注意。この3番目の引数は、請求された資金を送るサイドチェーンアドレスを指定するのに使うことができます。この例では、請求された資金の送り先のアドレスを所有する同じノードからコマンドを呼び出しているので、これは必要ありませんでした。

e1の残高をチェックする。

```
e1-cli getwalletinfo
```

クレームを確認するためのブロックを生成する。

```
e1-cli generate 1
```

e1の残高をチェックする。

```
e1-cli getwalletinfo
```

ペグインが成功したことがわかる。

ペッグアウトの場合も、プロセスは似ている。アドレスが生成され、そこに資金が送られ、取引が有効であれば資金が放出される。ペグアウトのプロセス全体については、メインチェーンでの作業が含まれるため、このコースの範囲外なので割愛する。エレメンツ・イベントのステップとしては、メインチェーン上でアドレスが生成される。

```
b-cli getnewaddress
```

資金はsendtomainchainコマンドを使ってエレメンツ・ノードからメインチェーンのアドレスに送られる。

```
e1-cli sendtomainchain <new-address> 1
```

トランザクションを確認するためのブロックを生成する。

```
e1-cli generate 1
```

ノードのウォレットの残高を確認する。

```
e1-cli getwalletinfo
```

そして、残高が減っていることを確認する。

このセクションでは、その方法について見てきた：


- 連合ペグスクリプトを生成する。
- スクリプトをネットワークコンセンサスパラメータルールとして使用する新しいチェーンを初期化する。
- メインチェーンからサイドチェーンに資金を送る。
- エレメンツのサイドチェーン内で資金を請求する。
- メインチェーンへの資金送金がどのように開始されるかを理解する。

### FederatedPegScript

Elementsをサイドチェーンとして動作させるためには、そのブロックチェーン内のgenesisブロックが`fedpegscript`を配置した状態で作成されている必要があります。これはノードの起動時に `fedpegscript` パラメータを渡すことで実行される。このスクリプトはElementsブロックチェーンのコンセンサスルールの一部を形成し、ペグイン・ペグアウトのリクエストを検証して処理することを可能にする。

fedpegscript`は、ペグのアクションを実行する権限を持つ者が管理する 公開鍵で構成される。以下は2-of-2の多署名fedpegscriptのフォーマット例である：

```
fedpegscript=5221<public key 1>21<public key 2>52ae
```

注: 公開鍵の外側の文字は、公開鍵と`n of m`の要件を示す区切り文字である。例えば、1-of-1のfedpegscriptのテンプレートは'5121<公開鍵1>51ae'となる。

### ペグイン

ペッグインがElementsサイドチェーンに受け入れられる前に、メインチェーン上で十分な確認が取れている必要があります。これは、メインチェーンの再編成によって引き起こされる可能性のある、Elementsサイドチェーン上でのペッグアセット供給のインフレを避けるために必要です。

ビットコインブロックチェーンの先端の短時間の再編成は、プルーフ・オブ・ワーク（PoW）コンセンサスメカニズムの通常の運用の一部として予想される。そのため、Elementsはビットコインブロックチェーン内で十分な深さがある場合にのみ、ペグインを有効であると認めます。これは、Elementsが同じペグインを複数回受け入れることを防ぐ役割を果たします。

### ペグアウト

このコマンドはメインチェーンのアドレス（ペッグアウト先）と、ペッグアウトされる資産の金額`withdrawn`を入力として受け取ります。これによりサイドチェーン上でペッグアウト取引が行われます。ウォッチマンとして働くファンクショナリーは、サイドチェーン上でペッグアウト取引が確認されたことを検知すると、コースの前のセクションで学んだように、メインチェーン上の資産をペッグアウト先に実際にリリースする処理を行います。

## 独立したブロックチェーンとしての要素

<chapterId>50dff39b-2702-47d7-9c15-0b54b845e99f</chapterId>

![Video](https://youtu.be/u-3rV7DGtD0?si=G1__H0Uelf4sTUDM)

これまで、Elementsをサイドチェーンとして運用する方法を見てきた。しかし、独自のデフォルトネイティブアセットを持つスタンドアローンのブロックチェーンソリューションとして運用することも可能です。この設定では、Elementsブロックチェーンは機密取引や発行資産など、サイドチェーン実装のすべての機能を保持したままですが、デフォルト資産量を流通から追加または削除するためのペグイン・ペグアウトは必要ありません。

このセクションでは

newasset`という名前のデフォルトアセットで新しいElementsブロックチェーンを初期化する。

1,000,000の`newasset`を指定し、そのために2つの再発行トークンを作成する。

誰でも使える `newasset` コインをすべて要求する。

誰でも使える再発行トークンをすべて「newasset」に請求する。

アセットとその再発行トークンを別のノードのウォレットに送る。

両ノードからさらに「newasset」を再発行する。

Elementsネットワークを初期化してスタンドアロンのブロックチェーンとして動作させるためには、各ノードをいくつかの基本パラメータで起動する必要があります。これらのパラメータは、他のブロックチェーンからのペグインを検証しようとしないこと、ネットワークのデフォルトアセット名、デフォルトアセットと関連する再発行トークンの作成量をノードに指示するために使用されます。

接続された2つのElementsノードで、これらのパラメータを使用して新しいチェーンを開始します。デフォルトアセットに `newasset` という名前を付け、100万個のアセットと2つの `newasset` 再発行トークンを発行します。

```
e1-dae -validatepegin=0 -defaultpeggedassetname=newasset -initialfreecoins=100000000000000 -initialreissuancetokens=200000000
e2-dae -validatepegin=0 -defaultpeggedassetname=newasset -initialfreecoins=100000000000000 -initialreissuancetokens=200000000
```

ここで使用されている金額は、ネットワークが受け入れることができる最小の額面であるため、2億の再発行トークンは実際には2つのトークン全体に相当することに注意してください。初回無料コインの額面も同様である。

ノードの現在のウォレット残高を確認する。

```
e1-cli getwalletinfo
e2-cli getwalletinfo
```

初期化が正しく行われたことがわかる。

資産の初期発行は「誰でも使える」として作成されるため、e1にそれらをすべて請求させ、e2のアクセス権を削除する。

```
e1-cli getnewaddress
e1-cli sendtoaddress <e1-address> 1000000 "" "" true
```

送信するアセットとして「newasset」を指定する必要はないことに注意してください。newassetはすでにデフォルトのアセットであるため、ネットワーク料金の支払いに使用されるデフォルトのアセットでもあります。

Elements内では、複数のアセットタイプを同じアドレスに送信することができます。したがって、デフォルトアセットを受信するために生成したアドレスを再利用し、再発行トークンの送信先アドレスとして使用することができます。

```
e1-cli sendtoaddress <e1-address> 1 "" "" false false 1 UNSET false <reissuance-token-id>
```

取引を確認する。

```
e1-cli generate 101
```

e1がアセットと再発行トークンの唯一の保有者であることを確認します。

```
e1-cli getwalletinfo
e2-cli getwalletinfo
```

それが事実であることは明らかだ。

ここで、「newasset」の一部を、現在残高ゼロのe2に送る。

```
e2-cli getnewaddress
e1-cli sendtoaddress <e2-address> 500 "" "" false
```

ネットワークのデフォルトアセットとして `newasset` が作成されているので、送信するアセットのタイプを指定する必要はないことに注意してください。

newasset`の再発行トークンもe2に送ろう。

```
e1-cli sendtoaddress <e2-address> 1 "" "" false false 1 UNSET false <reissuance-token-id>
```

取引を確認する。

```
e1-cli generate 101
```

ウォレットが適宜更新されていることを確認できる。

```
e1-cli getwalletinfo
e2-cli getwalletinfo
```

ここで、e1 のデフォルトアセットの一部を再発行します。この機能は、initialreissuancetokens 起動パラメータによって有効になることに注意してください。このパラメータを省略したりゼロに設定したりすると、後日再発行できないデフォルトアセットになります。

```
e1-cli reissueasset newasset 100
```

エレメントチェーンは常にデフォルトのアセットにラベルを付けるので、16進数のid値を提供する代わりに、`newasset`のラベルを使用することができました。

デフォルト・アセットの再発行がうまくいったことを確認：

```
e1-cli generate 101
e1-cli getwalletinfo
```

ここで、e2が再発行トークン `newasset` の一部を保有しているため、デフォルトアセットも再発行できることを証明する。

```
e2-cli reissueasset newasset 100
```

e2によるデフォルト資産の再発行がうまくいったことを確認。

```
e2-cli generate 101
e2-cli getwalletinfo
```

このセクションでは、Elementsをスタンドアロンのブロックチェーンとしてセットアップし、基本的な機能が期待通りに動作することを確認した。

スタートアップのパラメーターを使った：

newasset'という名前のデフォルトアセットで新しいElementsブロックチェーンを初期化する。

チェーンの初期化時に作成するデフォルト資産の量を指定します。

デフォルトアセット用の再発行トークンをいくつか作成し、両方のノードからデフォルトアセットをさらに再発行する。

私たちのスタンドアローンのブロックチェーンElementsネットワークでは、他のすべてのトランザクション操作は、コースの主なセクションでカバーされている例と同じように動作しますが、デフォルトと手数料資産として`ビットコイン`の代わりに 'newasset'を使用します。

### ノードの起動とチェーンの初期化パラメータ

Elementsノードにスタンドアロンのブロックチェーンとして動作するように指示するには、いくつかのパラメータを一緒に使用する必要があります。では、それぞれのパラメータについて見ていこう。

#### validatepegin=0`。

スタンドアロン・ブロックチェーンでは、ペグイン・トランザクションやペグアウト・トランザクションを検証する必要がないため、これらのチェックを無効にする必要があります。この設定では、Elementsネットワークが独立して動作するため、ビットコインクライアントソフトウェアを実行したり、ビットコインブロックチェーンのコピーを保存したりする必要はありません。

#### defaultpeggedassetname`。

ブロックチェーン初期化時に作成されるデフォルトアセット名を指定できます。

#### 初期フリーコイン

作成するデフォルト資産の数（ビットコインのサトシ単位に相当）。

#### 最初の再発行トークン`。

デフォルトアセットが作成する再発行トークンの数（ビットコインのSatoshi単位に相当）。これがなければ、デフォルトアセットをさらに作成することは不可能です。デフォルトアセットを増やしたくない場合は、ゼロに設定するか省略できます。

これらのパラメーターを使用すると、ノードを開始するコモンは次のようになる：

```
e1-dae -validatepegin=0 -defaultpeggedassetname=newasset -initialfreecoins=100000000000000 -initialreissuancetokens=200000000
```

### 基本操作

defaultpeggedassetname`パラメータはデフォルトアセットにラベルを適用します。この設定をしないと、デフォルトのアセットは自動的に `bitcoin` という名前になります。これまでのセクションでは、自分自身で発行したアセットを別のノードに送信する場合、どのアセットを送信するのかをエレメンツに伝えるために、アセットヘックスかローカルで適用されたアセットラベルのどちらかを指定する必要がありました。defaultpeggedassetname`はすべてのノードに適用されるため、送信時に名前を指定する必要はありません。以前はデフォルトで `bitcoin` を送信していたすべての関数は、デフォルトアセットにラベルを付けて送信するようになりました。

そのため、新しいデフォルトのアセットを10個、あるアドレスに送るのは簡単だ：

```
e1-cli sendtoaddress <destination address> 10 "" "" true
```

また、`initialreissuancetokens`の値を0より大きくノードに与えた場合、サイドチェーンとしてElementsを実行した場合には不可能な、より多くのデフォルトアセットを再発行することができます。

これを行うには、デフォルトのアセットに関連付けられたトークンの量を保持するノードが、フォームでコマンドを発行するだけでよい：

```
e1-cli reissueasset <default asset name> <amount>
```

上記のパラメータを使用することで、ビットコインや他のブロックチェーンから切り離された、独自のデフォルトアセットを持つ独立したブロックチェーンとしてElementsを運用することができます。

## 結論

<chapterId>7e2c916d-8114-424c-97f5-cbff9d73b8e3</chapterId>

![Video](https://youtu.be/CTMdamTZBBM?si=16LBcXvN4pBfC7lr)

このコースでは、Elementsがオープンソースのネットワーク・プロトコルであり、他のブロックチェーンのサイドチェーンとして、あるいは独立したブロックチェーン・ソリューションとして実装できることを学んだ。

Elementsのソースコードとウェブサイト(https://github.com/ElementsProject/elements)はGitHubでホストされており、Build On L2(https://community.liquid.net/c/developers/)やLiquid Developers Telegram(https://t.me/liquid_devel)のようなコミュニティディスカッションフォーラムがあり、ElementsとLiquid上でのアプリケーションのデプロイと開発について学ぶことができます。Confidential Transactions や Issued Assets のような主要な機能は、Strong Federation のメンバーがどのように連携したブロック署名と 2-Way Peg メカニズムを可能にするかと共にカバーされました。

次のステップは、これまでのすべてのセクションをカバーする累積クイズに挑戦することだ！

# 結論

<partId>d5dbd616-e291-42bc-aae3-6c44599dbd06</partId>

## レビュー＆評価

<chapterId>beae23bd-2fd1-49fe-8f38-ed169acde51d</chapterId>

<isCourseReview>真</isCourseReview>。

## 結論

<chapterId>15f62056-c69c-467e-9565-af48d439a1f5</chapterId>

コース修了おめでとう！

皆様が学習の旅の節目を無事に迎えられたことに、私たちは感激しています。皆さんの献身的な取り組みにより、プロとしての成長に役立つ貴重な知識とスキルが身につきました。