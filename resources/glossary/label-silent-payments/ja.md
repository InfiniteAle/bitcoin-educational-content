---
期間ラベル

---
サイレントペイメントプロトコルでは、ラベルは、他の多くの静的アドレスを作成するために、最初の静的アドレスを修正するために使用される整数である。このラベルを使用することで、サイレントペイメン トを経由して送信される支払いを、使用ごとに異なる静的アドレスを使用する ことで、これらの支払いを検出する(スキャンする)運用負荷を過度に増加 させることなく、分離することができる。Bobは、2つの公開鍵で構成される静的アドレス$B$を使用する。$B_{text{scan}}$はスキャン用、$B_{text{spend}}$は支出用である。b_{text{scan}}$のハッシュと、生成点$G$でスカラー倍した整数$m$を、支出公開鍵$B_{text{spend}}$に追加して、一種の新しい支出公開鍵$B_m$を生成する：

B_m = B_{text{spend}}。+  \text{hash}(b_{text{scan}}  \text{ ‖ } m)  \cdot G $$

例えば、最初の鍵$B_1$はこのようにして得られる：

B_1 = B_{text{spend}}。+ B_{text{hash}(b_{text{scan}} ￤ 1) ￤ G $$ B_{text{spend

Bobが公開する静的アドレスは、$B_{text{scan}}$と$B_m$で構成される。例えば、ラベル$1$を持つ最初の静的アドレスは次のようになる：

B = B_{text{scan}}\テキストB_1 $$

ラベル$0$は変更用に予約されているので、ラベル$1$から始めるだけである。Bobが提供したラベル付き静的アドレスにビットコインを送りたいAliceは、 $B_{text{spend}}$の代わりに新しい$B_1$を使って一意な支払いアドレス$P_0$を導出する：



実際には、アリスはボブがラベル付きアドレスを持っていることすら知らない かもしれない。アリスは、ボブが提供した静的アドレスの2番目の部分(この 場合は$B_{text{spend}}$ではなく値$B_1$)を使うだけだからである。支払いをスキャンするために、ボブは常にこのように$B_{text{spend}}$を含む初期静的アドレ スの値を使用する：

P_0 = B_{text{spend}}とする。

次に、各出力から$P_0$の値を一つずつ引いていく。そして、これらの引き算の結果の1つが、財布で使っているラベルの1つの値と一致するかどうかをチェックする。たとえば、$1$というラベルの出力#4と一致した場合、この出力は、$B_1$というラベルの静的アドレスに関連付けられたサイレント・ペイメントであることを意味する：

Out_4 - P_0 = \text{hash}(b_{text{scan}} \text{ ‖ } 1)

なぜなら、これはうまくいくからだ：

B_1 = B_{text{spend}}。+ B_{text{hash}(b_{text{scan}} ￤ 1) ￤ G $$ B_{text{spend

この方法のおかげで、Bobは、自分の基本静的アドレス（$B = B_{text{scan}}  \text{ ‖ } B_{text{spend}}$）から派生した多数の静的アドレス（$B_1$、$B_2$、$B_3$...）を、適切に使い分けることができる。

しかし、この静的アドレスの分離は、個人のウォレット管理の観点からのみ有効で、アイデンティティの分離はできない。これらの静的アドレスはすべて同じ$B_{text{scan}}$を持っているので、すべての静的アドレスを一緒に関連付け、それらが単一のエンティティに属していると推測することは非常に簡単である。