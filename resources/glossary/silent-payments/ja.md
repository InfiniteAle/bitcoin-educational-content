---
期間サイレント・ペイメント

---
静的ビットコインアドレスを使用して、アドレスの再利用、相互作用、および異なる支払いと静的アドレスとの間の目に見えるオンチェーンリンクなしで支払いを受け取る方法。この手法により、取引のたびに新しい未使用の受信アドレスを生成する必要がなくなるため、受信者が支払者に新しいアドレスを提供しなければならないビットコインにおける通常のやり取りを回避できる。

サイレント・ペイメントでは、支払者は、受信者の公開鍵（spend 公開鍵と scan 公開鍵）と自身の秘密鍵の合計を入力として使用し、支払いごとに新しいアドレスを生成する。受信者だけが、自分の秘密鍵を使って、この支払いアドレスに対応する秘密鍵を計算できる。暗号鍵交換アルゴリズムである ECDH (*Elliptic-Curve Diffie-Hellman*) が共有秘密の確立に使用され、この共有秘密は受信アドレスと秘密鍵の導出に使用される（受信者側のみ）。受信者は、自分宛てのサイレント・ペイメントを特定するために、ブロックチェーンをスキャンし、プロトコルの基準に一致する各取引を調べなければならない。支払いチャネルを確立するために通知トランザクションを使用するBIP47とは異なり、サイレントペイメントはこのステップを省き、トランザクションを節約する。しかし、その妥協点として、受信者はすべての潜在的な取引をスキャンし、ECDHを適用して、それが自分宛のものであるかどうかを判断しなければならない。

例えば、Bobの静的アドレス$B$は、彼のスキャン公開鍵と彼のspend公開鍵の連結を表す：

B = B_{text{scan}}\B_{text{ ‖ }B_{text{spend}}$$

これらのキーは単純に以下のパスから派生したものである：

```text
scan : m / 352' / 0' / 0' / 1' / 0
spend : m / 352' / 0' / 0' / 0' / 0
```

この静的アドレスはボブによって公開される。AliceはBobにSilent Paymentをするためにこのアドレスを取得する。アリスはボブの支払いアドレス$P_0$をこのように計算する：

P_0 = B_{text{spend}}とする。+ \text{hash}( \text{inputHash} a  \cdot B_{text

どこでだ：

$$ \text{inputHash} = \text{hash}(∕text{outpoint}_L∕text{‖ } A) $$ ∕text{outpoint}_L∕text{‖ } A

と：


- B_{text{scan}}$：ボブのスキャン公開鍵（静的アドレス）；
- B_{text{spend}}$：ボブのspend公開鍵（静的アドレス）；
- $A$:入力(tweak)の公開鍵の合計；
- $a$:つまり、Aliceのトランザクションで入力として使われたUTXOの `scriptPubKey`で使われたすべての鍵ペアの合計である；
- text{outpoint}_L$：アリスのトランザクションで入力として使われた(辞書的に)最小のUTXO；
- text{‖}$である：連結（オペランドを端から端まで連結する操作）；
- $G$:楕円曲線 `secp256k1` の生成点；
- text{hash}$：BIP0352/SharedSecret` でタグ付けされた SHA256 ハッシュ関数；
- $P_0$:Bobに支払うための最初の公開鍵/一意なアドレス；
- $0$:複数の一意の支払いアドレスを生成するために使用される整数。

ボブはこのようにしてブロックチェーンをスキャンし、自分のサイレント・ペイメントを見つける：

P_0 = B_{text{spend}}とする。

と：


- b_{text{scan}}$：ボブの秘密スキャン鍵。

もし$P_0$が自分宛のサイレント・ペイメントを含むアドレスであることが分かれば、彼は$p_0$を計算する。$p_0$は、アリスから$P_0$に送られた資金を使うことを可能にする秘密鍵である：

p_0 = (b_{text{spend}})+ \text{hash}( \text{inputHash} b_{text{scan}} ￤A ￤0)) ￤mod n $$ $

と：


- b_{text{spend}}$：ボブの秘密鍵；
- n$: 楕円曲線 `secp256k1` の次数。

この基本バージョンに加え、ラベルを使用して、同じ基本静的アドレスから複数の異なる静的アドレスを生成することも可能で、スキャン時に必要な作業を不当に増やすことなく、複数の用途を分けることを目的としている。